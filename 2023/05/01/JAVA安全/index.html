<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java简单学习 | Khaz</title><meta name="author" content="Khaz"><meta name="copyright" content="Khaz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA基本了解(71条消息) Java–Java版本和JDK版本_java版本和jdk版本区别_MinggeQingchun的博客-CSDN博客  JDK8u311 → JAVA8 java名词Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。    jar包实际上就是一个">
<meta property="og:type" content="article">
<meta property="og:title" content="java简单学习">
<meta property="og:url" content="http://fgtbnc.github.io/2023/05/01/JAVA%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="Khaz">
<meta property="og:description" content="JAVA基本了解(71条消息) Java–Java版本和JDK版本_java版本和jdk版本区别_MinggeQingchun的博客-CSDN博客  JDK8u311 → JAVA8 java名词Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。    jar包实际上就是一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fgtbnc.github.io/images/wallhaven-wyg7g6.jpg">
<meta property="article:published_time" content="2023-05-01T07:00:25.000Z">
<meta property="article:modified_time" content="2023-09-02T05:13:06.787Z">
<meta property="article:author" content="Khaz">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fgtbnc.github.io/images/wallhaven-wyg7g6.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://fgtbnc.github.io/2023/05/01/JAVA%E5%AE%89%E5%85%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java简单学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-02 13:13:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom/beauty.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/Khazing/typora-img/main/16870577801892f4a9c5aac2e9e5422a6ccd26db10dd88c73.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fgtbnc.github.io/images/wallhaven-wyg7g6.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Khaz</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java简单学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-01T07:00:25.000Z" title="发表于 2023-05-01 15:00:25">2023-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-02T05:13:06.787Z" title="更新于 2023-09-02 13:13:06">2023-09-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java简单学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JAVA基本了解"><a href="#JAVA基本了解" class="headerlink" title="JAVA基本了解"></a>JAVA基本了解</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/MinggeQingchun/article/details/120578602">(71条消息) Java–Java版本和JDK版本_java版本和jdk版本区别_MinggeQingchun的博客-CSDN博客</a></p>
<p><img src="/../images/image-20230501122332032.png" alt="image-20230501122332032"></p>
<p>JDK8u311 → JAVA8</p>
<h3 id="java名词"><a href="#java名词" class="headerlink" title="java名词"></a>java名词</h3><p>Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。</p>
<p><img src="/../images/image-20230425225221871.png" alt="image-20230425225221871"></p>
<p><img src="/../images/image-20230425225139403.png" alt="image-20230425225139403"></p>
<p><img src="/../images/image-20230425225121609.png" alt="image-20230425225121609"></p>
<p>jar包实际上就是一个zip格式的压缩文件</p>
<h3 id="运行java程序"><a href="#运行java程序" class="headerlink" title="运行java程序"></a>运行java程序</h3><p><img src="/../images/image-20230425225313657.png" alt="image-20230425225313657"></p>
<p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p>
<p>注意：</p>
<p>我们通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本</p>
<p>而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。</p>
<p><strong>高版本的JDK可编译输出低版本兼容的class文件</strong>，但需注意，低版本的JDK可能不存在高版本JDK添加的类和方法，导致运行时报错。</p>
<p>运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="/../images/image-20230425225605486.png" alt="image-20230425225605486"></p>
<p><img src="/../images/image-20230425225757719.png" alt="image-20230425225757719"></p>
<p>定义private字段和pubilc方法来操作private字段</p>
<blockquote>
<p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p>
</blockquote>
<p>定义private方法</p>
<blockquote>
<p><code>private</code>方法，外部代码无法调用，但是，内部方法可以调用它。</p>
<p>方法可以封装一个类的对外接口，调用方不需要知道也不关心字段是否存在</p>
</blockquote>
<h4 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h4><blockquote>
<p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p>
</blockquote>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><img src="/../images/image-20230425233400613.png" alt="image-20230425233400613"></p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><blockquote>
<p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p>
<p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>无法实例化的抽象类有什么用？</p>
<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
</blockquote>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的继承</p>
<p><img src="/../images/image-20230425233728359.png" alt="image-20230425233728359"></p>
<h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><blockquote>
<p>修饰符static</p>
<p>静态方法和静态字段属于<code>class</code>而不属于实例</p>
</blockquote>
<p><img src="/../images/image-20230425234023210.png" alt="image-20230425234023210"></p>
<p>使用类名来访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.setNumber(<span class="number">99</span>);</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure>



<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><blockquote>
<p>一个包就是一个命名空间</p>
<p>真正的完整类名是<code>包名.类名</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xxx; <span class="comment">// 申明包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> packge_name.class_name; <span class="comment">// 导入其他包中的类</span></span><br></pre></td></tr></table></figure>

<h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><p><img src="/../images/java.lang.png" alt="img"></p>
<h5 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h5><blockquote>
<p>Java中的String是不可变的，因为String类的存储是通过final修饰的char[]数组来存放结果的，不可更改。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        System.out.println(s.hashCode());</span><br><span class="line">        System.out.println(s.toUpperCase().hashCode());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20230428115645212.png" alt="image-20230428115645212"></p>
<h5 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h5><p>内存数据与外存数据，使用字节流或字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// getInputStream()获得结果</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;whoami&quot;</span>).getInputStream();</span><br><span class="line">        <span class="comment">// 用来缓存命令执行结果数据</span></span><br><span class="line">        <span class="type">byte</span>[] cache = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// read方法将数据读取到cache字节数组中，如果返回-1说明到了结尾，数据读取完毕</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(cache))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 数据读取完毕后，write方法将cache数组中从0到readlen的数据写入输出流中</span></span><br><span class="line">            byteArrayOutputStream.write(cache, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteArrayOutputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1887019">IDEA中的debug断点调试技巧，学会真的香！ - 腾讯云开发者社区-腾讯云</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">(72条消息) IntelliJ IDEA创建Servlet最新方法 Idea版本2020.2.2以及IntelliJ IDEA创建Servlet 404问题（超详细）_idea创建servlet项目_Granger_g的博客-CSDN博客</a></p>
<h2 id="ysoserial-调试"><a href="#ysoserial-调试" class="headerlink" title="ysoserial 调试"></a>ysoserial 调试</h2><p>下载源码，等待maven导入依赖，再配置如下即可（java版本为java8）</p>
<p><img src="/../images/image-20230502220543589.png" alt="image-20230502220543589"></p>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p><img src="/../images/image-20230426102535777.png" alt="image-20230426102535777"></p>
<h3 id="模块化管理"><a href="#模块化管理" class="headerlink" title="模块化管理"></a>模块化管理</h3><p>把一个项目分成多个模块</p>
<p><img src="/../images/image-20230426102935510.png" alt="image-20230426102935510"></p>
<p>Maven的中央仓库，存储各种模块，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p>
<h2 id="更换中央仓库源"><a href="#更换中央仓库源" class="headerlink" title="更换中央仓库源"></a>更换中央仓库源</h2><p>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/maven/maven-plugins.html">https://www.runoob.com/maven/maven-plugins.html</a></p>
<h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/maven/maven-pom.html">https://www.runoob.com/maven/maven-pom.html</a></p>
<p>包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p>
<p>引入外部依赖</p>
<blockquote>
<p>要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。</p>
</blockquote>
<h3 id="注册依赖"><a href="#注册依赖" class="headerlink" title="注册依赖"></a>注册依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里添加你的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 库名称，也可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="comment">&lt;!--库名称，也可以自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!--作用域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span> <span class="comment">&lt;!--项目根目录下的lib文件夹下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/../images/image-20230426105518262.png" alt="image-20230426105518262"></p>
<h2 id="Maven打包程序"><a href="#Maven打包程序" class="headerlink" title="Maven打包程序"></a>Maven打包程序</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2089955">Maven打包三种方法和常用命令大全-腾讯云开发者社区-腾讯云</a></p>
<p><img src="/../images/image-20230826121756632.png" alt="image-20230826121756632"></p>
<h2 id="与Gradle的区别"><a href="#与Gradle的区别" class="headerlink" title="与Gradle的区别"></a>与Gradle的区别</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/maven/maven-plugins.html">https://www.runoob.com/maven/maven-plugins.html</a></p>
<h1 id="JAVA-WEB"><a href="#JAVA-WEB" class="headerlink" title="JAVA WEB"></a>JAVA WEB</h1><p>Servlet Tomcat JSP</p>
<p>传统XML配置</p>
<p>SSM&#x2F;SSHSpringBoot</p>
<p>SpringCloud (了解即可)</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型就是编写模板代码来适应任意类型；</p>
<p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>反射是Java的特征之一，是一种间接操作目标对象的机制，核心是<strong>JVM在运行状态的时候才动态加载类</strong>，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。</p>
</blockquote>
<p>类加载流程如下</p>
<img src="../images/EsePjI7n9CtyqbA.png" alt="img" style="zoom:150%;" />

<p>JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存后会为其创建一个<code>Class</code>类型的实例，并在该实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>
<h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Class：类对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Constructor：类的构造器对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Field：类的属性对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method：类的方法对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Modifier：类的修饰符对象;</span><br></pre></td></tr></table></figure>



<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>Class</code>类型实际上是一个名叫<code>Class</code>的<code>class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出Class类的构造器是私有的，所以只有JVM能够创建Class对象。</p>
<p>如果我们想使用就需要以下几种方法获得：</p>
<h4 id="获得Class类"><a href="#获得Class类" class="headerlink" title="获得Class类"></a>获得Class类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用Class类的静态方法forName获取某个类的Class类实例：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">注：类名默认为类完整路径，如java.lang.Runtime</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用某个类实例的getClass()方法：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">User</span>()).getClass();    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//访问某个类实例的class属性，这个属性就存储着这个类对应的Class类的实例</span></span><br><span class="line"><span class="comment">//这个⽅法其实不属于反射</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">User</span>()).class;</span><br></pre></td></tr></table></figure>

<h4 id="获得构造函数"><a href="#获得构造函数" class="headerlink" title="获得构造函数"></a>获得构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstructors() ：只返回<span class="keyword">public</span>构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors() ：返回所有构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;&gt; getConstructor(类&lt;?&gt;... parameterTypes) : 匹配和参数配型相符的<span class="keyword">public</span>构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) ： 匹配和参数配型相符的构造函数</span><br></pre></td></tr></table></figure>



<h4 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a>实例化类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clz.newInstance();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上是调用了该类的无参构造函数</p>
<p>所以前提条件：</p>
<p>该类有无参构造函数，并且是公有的</p>
</blockquote>
<h4 id="获得成员方法"><a href="#获得成员方法" class="headerlink" title="获得成员方法"></a>获得成员方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method=Class.getMethod(String name, 类&lt;?&gt;... parameterTypes) <span class="comment">//返回该类所声明的public方法</span></span><br><span class="line"></span><br><span class="line">Method method=Class.getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) <span class="comment">//返回该类所声明的所有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数为方法名，第二个参数为这个方法的参数类型</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">Method method=Class.getMethods() <span class="comment">//获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法</span></span><br><span class="line"></span><br><span class="line">Method method=Class.getDeclaredMethods() <span class="comment">// 获取该类中的所有方法</span></span><br></pre></td></tr></table></figure>



<h4 id="使用成员方法"><a href="#使用成员方法" class="headerlink" title="使用成员方法"></a>使用成员方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(类实例, [该方法的参数类型]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果调用这个方法是普通方法，第一个参数就是类对象；</strong></p>
<p><strong>如果调用这个方法是静态方法，第一个参数就是类；</strong></p>
</blockquote>
<h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields() ：获取所有 <span class="keyword">public</span> 修饰的成员变量</span><br><span class="line"></span><br><span class="line">Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符</span><br><span class="line"></span><br><span class="line">Field <span class="title function_">getField</span><span class="params">(String name)</span> 获取指定名称的 <span class="keyword">public</span> 修饰的成员变量</span><br><span class="line"></span><br><span class="line">Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span> 获取指定的成员变量</span><br></pre></td></tr></table></figure>



<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>常用的RCE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>Runtime</code>这个类的构造函数是私有的，所以我们正常只能通过公有的方法<code>Runtime.getRuntime() </code>来获取到 Runtime 对象</p>
</blockquote>
<p>通过反射实现上述代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先需要获得Runtime类的Class实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//获得Runtime类的getRuntime方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getruntime</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用该方法获得Runtime对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getruntime.invoke(clz);</span><br><span class="line"><span class="comment">//获得Runtime类的exec方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line"><span class="comment">//调用exec方法执行命令</span></span><br><span class="line">exec.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>整合成一句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)), <span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="强制访问私有，保护"><a href="#强制访问私有，保护" class="headerlink" title="强制访问私有，保护"></a>强制访问私有，保护</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上述命令执行代码可以转为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class c1= Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> c1.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 获得访问私有方法和属性的权限</span></span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        c1.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修改final字段"><a href="#修改final字段" class="headerlink" title="修改final字段"></a>修改<code>final</code>字段</h3><p><img src="/../images/image-20230503115304804.png" alt="image-20230503115304804"></p>
<ul>
<li><p>只有final修饰，并且为间接赋值，可以修改</p>
</li>
<li><p>如果是final+static修饰，并且为间接赋值，需要先去掉final修饰符才能修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得modifiers</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameModifyField</span> <span class="operator">=</span> nameField.getClass().getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line"><span class="comment">// 修改权限</span></span><br><span class="line">nameModifyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 去除final修饰符</span></span><br><span class="line">nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"><span class="comment">// 修改Field值</span></span><br><span class="line">nameField.set(m,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Drunkbaby Too Silly&quot;</span>));</span><br><span class="line"><span class="comment">// 重新添加上final修饰符</span></span><br><span class="line">nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p><img src="/../images/image-20230505171840712.png" alt="image-20230505171840712"></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9002">JAVA安全基础（一）–类加载器（ClassLoader） - 先知社区</a></p>
<h1 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h1><p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1611/#toc_api">JNDI注入分析 - 跳跳糖</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zpchcbd/p/14880727.html">Java JNDI注入（一） - zpchcbd - 博客园</a></p>
<h2 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h2><p><code>JNDI(Java Naming and Directory Interface)</code>是<code>Java</code>提供的<code>Java</code>命名和目录接口。</p>
<blockquote>
<p>Naming Service 命名服务：命名服务将名称和对象进行关联，提供通过名称找到对象的操作</p>
<p>Directory Service目录服务：目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。</p>
</blockquote>
<p>通过调用<code>JNDI</code>的<code>API</code>可以定位资源和其他程序对象。</p>
<blockquote>
<p>通过名称查找(<code>lookup</code>)对象 		</p>
<p>通过对象的属性搜索(<code>search</code>)对象</p>
</blockquote>
<p><code>JNDI</code>是<code>Java EE</code>的重要部分，<code>JNDI</code>可访问的现有的目录及服务有:<code>JDBC</code>、<code>LDAP</code>、<code>RMI</code>、<code>DNS</code>、<code>NIS</code>、<code>CORBA</code>。</p>
<h2 id="什么是RMI"><a href="#什么是RMI" class="headerlink" title="什么是RMI"></a>什么是RMI</h2><p><code>RMI</code>全称是<code>Remote Method Invocation</code>（远程⽅法调⽤），目的是为了让两个隔离的java虚拟机，如虚拟机A能够调用到虚拟机B中的对象，而且这些虚拟机可以不存在于同一台主机上。</p>
<h2 id="什么是LDAP"><a href="#什么是LDAP" class="headerlink" title="什么是LDAP"></a>什么是LDAP</h2><p> <code>LDAP</code>，全称为 <code>Lightweight Directory Access Protocol</code>，即轻量级目录访问协议，主要用于资源查询。</p>
<h2 id="漏洞形成原因"><a href="#漏洞形成原因" class="headerlink" title="漏洞形成原因"></a>漏洞形成原因</h2><blockquote>
<p>JNDI支持从指定的远程服务器上下载class文件，加载到本地JVM中，并通过适当的方式创建对象。</p>
<p>如果目标应用进行了JNDI查询（<code>lookup</code>），并且其查询的地址或名称可控的话，就会形成JNDI注入漏洞</p>
</blockquote>
<h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><img src="../images/无标题-2023-05-01-1454-1682925503892.png" alt="无标题-2023-05-01-1454" style="zoom:80%;" />

<ol>
<li><p>攻击者构造恶意协议，传入服务端（目标应用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rmi:<span class="comment">//ip:port/name</span></span><br><span class="line">ldap:<span class="comment">//ip:port/name</span></span><br><span class="line">dns:<span class="comment">//外带.域名</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端连接到攻击者指定的服务，查询得到一个恶意的<code>JNDI Reference</code></p>
</li>
<li><p>服务端解析该恶意<code>JNDI Reference</code></p>
</li>
<li><p>根据解析结果到指定服务器上下载<code>Factory</code>的字节码</p>
</li>
<li><p>加载字节码，攻击者的恶意代码被执行</p>
</li>
</ol>
<h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><h4 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h4><p>服务端</p>
<p><img src="/../images/image-20230501151253546.png" alt="image-20230501151253546"></p>
<p>RMI服务</p>
<p><img src="/../images/image-20230501151418991.png" alt="image-20230501151418991"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(className,classFactor,classFactoryLocation)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>className</code>：远程加载时所使用的类名<br><code>classFactor</code>：加载的 class 中需要实例化类的名称<br><code>classFactoryLocation</code>：提供classes数据的地址可以是 file&#x2F;ftp&#x2F;http 等协议</p>
</blockquote>
<p>存放恶意字节码的WEB服务器</p>
<p>恶意字节码对应的java文件<img src="/../images/image-20230501151607225.png" alt="image-20230501151607225"></p>
<p>先启动RMI服务和web服务器</p>
<p><img src="/../images/image-20230501152041695.png" alt="image-20230501152041695"></p>
<p><img src="/../images/image-20230501152052702.png" alt="image-20230501152052702"></p>
<p>再启动Server</p>
<p><img src="/../images/image-20230501152145871.png" alt="image-20230501152145871"></p>
<p><img src="/../images/image-20230501152116749.png" alt="image-20230501152116749"></p>
<h4 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h4><p><img src="/../images/image-20230502172305622.png" alt="image-20230502172305622"></p>
<p><code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code>，所以会进入 <code>if</code> 语句，抛出异常。</p>
<h5 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h5><p>原理</p>
<p>绕过抛出异常后进入<code>javax.naming.spi.NamingManager</code> </p>
<p><img src="/../images/image-20230502172806278.png" alt="image-20230502172806278"></p>
<p><img src="/../images/image-20230502173802695.png" alt="image-20230502173802695"></p>
<p>实现</p>
<p><code>Tomcat Server</code>中的<code>BeanFactory</code>类，通过该类的<code>getObjectInstance</code>方法反射调用了<code>javax.el.ELProcessor</code>的<code>eval</code>方法，最终实现了EL表达式执行达到RCE的效果。</p>
<h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><h4 id="低版本-1"><a href="#低版本-1" class="headerlink" title="低版本"></a>低版本</h4><p>同RMI，远程加载即可</p>
<h4 id="高版本-1"><a href="#高版本-1" class="headerlink" title="高版本"></a>高版本</h4><p>当从<code>LDAP Server</code>传来的对象是序列化对象时，会调用<code>readobject</code>方法，存在反序列化漏洞。</p>
<h3 id="版本影响"><a href="#版本影响" class="headerlink" title="版本影响"></a>版本影响</h3><p><code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code></p>
<img src="../images/1586953-20210613173957090-164407195.png" alt="img" style="zoom:150%;" />





<h2 id="Log4J2"><a href="#Log4J2" class="headerlink" title="Log4J2"></a>Log4J2</h2><p>Log4j是java用来处理日志的第三方组件，提供了<code>Lookups</code>的机制：</p>
<blockquote>
<p>会对日志中用 <code>$&#123;prefix:key&#125;</code>包裹起来的变量进行解析</p>
</blockquote>
<p><img src="/../images/image-20230426124656392.png" alt="image-20230426124656392"></p>
<p>当记录的信息为<code>$&#123;jndi:xxx&#125;</code>时,log4j2就会发起<code>JNDI Lookup</code>查询,从而触发JNDI注入漏洞。</p>
<p>payload</p>
<p><code>abc</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a$&#123;:-b&#125;c</span><br><span class="line">$&#123;lower:b&#125;</span><br><span class="line">a$&#123;::-b&#125;c</span><br><span class="line">a$&#123;E:-a&#125;c</span><br><span class="line">a$&#123;:-$&#123;:-b&#125;&#125;c</span><br><span class="line">a$&#123;xxxanycodexxxx:-b&#125;c</span><br><span class="line">    </span><br><span class="line">unicode编码绕过</span><br><span class="line">插入空白字符绕过</span><br></pre></td></tr></table></figure>







<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>​	在java中，如果要对一个对象进行序列化或者反序列化，那么这个对象的类必须要实现<code>java.io.Serializable</code>接口。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>序列化<code>writeObject</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));  </span><br><span class="line"></span><br><span class="line">oos.writeObject(obj);</span><br></pre></td></tr></table></figure>

<p>反序列化<code>readObject</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));  </span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br></pre></td></tr></table></figure>



<h3 id="创建一个对象时各代码块的执行顺序"><a href="#创建一个对象时各代码块的执行顺序" class="headerlink" title="创建一个对象时各代码块的执行顺序"></a>创建一个对象时各代码块的执行顺序</h3><p><img src="/../images/image-20230503114055054.png" alt="image-20230503114055054"></p>
<p><code>static &#123;&#125;</code>  →  <code>&#123;&#125;</code>  →  构造函数</p>
<h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>反序列时, 如果字节流中的serialVersionUID与目标服务器对应类中的serialVersionUID不同时就会出现异常，造成反序列化失败。</p>
<p><img src="/../images/1615523079000-30cnxtq.png-w331s" alt="图片"></p>
<p>SUID不同是jar包版本不同所造成，不同版本jar包可能存在不同的计算方式导致算出的SUID不同，这种情况下只需要基于目标一样的jar包版本去生成payload即可解决异常，进而提升反序列化漏洞利用成功率。</p>
<h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>分析的时候发现需要注释掉<code>ysoserial</code>重写的<img src="/../images/image-20230502230402644.png" alt="image-20230502230402644"></p>
<blockquote>
<p>ysoserial为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询，所以重写了⼀ 个 SilentURLStreamHandler 类。</p>
</blockquote>
<h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>如何寻找可能具有反序列化漏洞的类？</p>
<p>要有<code>readObject</code>方法，所以直奔<code>HashMap</code>的<code>readObject</code>方法</p>
<p><img src="/../images/image-20230502233642388.png" alt="image-20230502233642388"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>ysoserial</code>中打下断点</p>
<p><img src="/../images/image-20230502233910801.png" alt="image-20230502233910801"></p>
<p>跟进<code>put</code></p>
<p><img src="/../images/image-20230502233952861.png" alt="image-20230502233952861"></p>
<p>跟进<code>hash</code></p>
<p><img src="/../images/image-20230502234020014.png" alt="image-20230502234020014"></p>
<p>跟进<code>hashCode</code></p>
<p><img src="/../images/image-20230502234105324.png" alt="image-20230502234105324"></p>
<p>跟进<code>handler.hashCode</code></p>
<p><img src="/../images/image-20230502234135313.png" alt="image-20230502234135313"></p>
<p>跟进<code>getHostAddress</code></p>
<p><img src="/../images/image-20230502235424673.png" alt="image-20230502235424673"></p>
<p>这里多了一步，可能是版本问题吧？</p>
<p><img src="/../images/image-20230502234312446.png" alt="image-20230502234312446"></p>
<p>这⾥ InetAddress.getByName(host) 的作用是根据主机名，获取其IP地址，在网络上其实就是⼀次 DNS查询。</p>
<p><code>Gadget Chain</code></p>
<p><img src="/../images/image-20230502234635733.png" alt="image-20230502234635733"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">HashMap.hash()</span><br><span class="line">URL.hashCode()：Field hashCode=-<span class="number">1</span></span><br><span class="line">URLStreamHandler-&gt;hashCode()</span><br><span class="line">URLStreamHandler-&gt;getHostAddress()</span><br><span class="line">URL-&gt;getHostAddress()    </span><br><span class="line">InetAddress-&gt;getByName()</span><br></pre></td></tr></table></figure>

<p>需要实例化三个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap</span><br><span class="line">URLStreamHandler</span><br></pre></td></tr></table></figure>

<p>无参构造，直接<code>new</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20230503000931008.png" alt="image-20230503000931008"></p>
<p>payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNSTestDemo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://123.1020fd40.ipv6.1433.eu.org&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射修改私有属性hashCode为-1</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> u.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(u, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        hm.put(u, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../images/image-20230503001328190.png" alt="image-20230503001328190"></p>
<h3 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h3><p>CC&#x2F;CB&#x2F;7u21&#x2F;8u20</p>
<p>分析尝试阅读并魔改ysoserial</p>
<p>JEP 290是什么</p>
<p>JEP290是Java底层为了缓解反序列化攻击提出的一种解决方案，主要做了以下几件事</p>
<ol>
<li>提供一个限制反序列化类的机制，白名单或者黑名单。</li>
<li>限制反序列化的深度和复杂度。</li>
<li>为RMI远程调用对象提供了一个验证类的机制。</li>
<li>定义一个可配置的过滤机制，比如可以通过配置properties文件的形式来定义过滤器。</li>
</ol>
<h1 id="JAVA-Agent"><a href="#JAVA-Agent" class="headerlink" title="JAVA Agent"></a>JAVA Agent</h1><h1 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h1><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/279160#h3-1">内存马探究-安全客 - 安全资讯平台</a></p>
<p><a target="_blank" rel="noopener" href="https://trrqsec.github.io/2022/04/10/Java%E5%AE%89%E5%85%A8-Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/">Java安全-Tomcat内存马学习-信息安全博客</a></p>
<p><a target="_blank" rel="noopener" href="http://wjlshare.com/archives/1529">Tomcat 内存马学习(一)：Filter型 – 天下大木头</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/343105.html">Tomcat Filter 型内存马流程理解与手写 EXP - FreeBuf网络安全行业门户</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/whgk/p/6399262.html">Java Web(一) Servlet详解！！ - 有梦想的老王 - 博客园</a></p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><img src="/../images/201909251250360.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>客户端发起一个http请求，比如get类型。</p>
<p>Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；</p>
<p>Servlet容器接收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象。<br>Servlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。<br>Servlet容器调用service()方法。<br>service()方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法，这里调用doGet方法。<br>doXXX方法中是我们自己写的业务逻辑。</p>
<p>业务逻辑处理完成之后，返回给Servlet容器，Servlet容器会将响应的信息封装为HttpServletResponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器，然后容器将结果返回给客户端。</p>
<p>容器关闭时候，会调用destory方法</p>
</blockquote>
<p>Tomcat的配置</p>
<p><img src="/../images/v2-c3adc47d4c42dae472308ca19eb84374_720w.webp" alt="img"></p>
<ul>
<li>Server 元素表示整个 Catalina servlet 容器。</li>
<li>Service元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。</li>
<li>Executor表示可以在Tomcat中的组件之间共享的线程池。</li>
<li>Connector代表连接组件。Tomcat 支持三种协议：HTTP&#x2F;1.1、HTTP&#x2F;2.0、AJP。</li>
<li>Context元素表示一个Web应用程序，它在特定的虚拟主机中运行。每个Web应用程序都基于Web应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如Servlet规范述。</li>
<li>Engine元素表示与特定的Catalina服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。</li>
<li>Host元素表示一个虚拟主机，它是一个服务器的网络名称（如“<a target="_blank" rel="noopener" href="http://www.mycompany.com”)与运行tomcat的特定服务器的关联./">www.mycompany.com”）与运行Tomcat的特定服务器的关联。</a></li>
</ul>
<p><img src="/../images/1622447564_60b495cc4ddf6ab5c7b98.png!small" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Engine，实现类为 org.apache.catalina.core.StandardEngine</span><br><span class="line">Host，实现类为 org.apache.catalina.core.StandardHost</span><br><span class="line">Context，实现类为 org.apache.catalina.core.StandardContext</span><br><span class="line">Wrapper，实现类为 org.apache.catalina.core.StandardWrapper</span><br></pre></td></tr></table></figure>

<p>Tomcat启动加载的顺序：Listener -&gt; Filter -&gt; Servlet</p>
<h2 id="传统web应用型"><a href="#传统web应用型" class="headerlink" title="传统web应用型"></a>传统web应用型</h2><h3 id="listener类型"><a href="#listener类型" class="headerlink" title="listener类型"></a>listener类型</h3><p>最终实例化出来的监听器被存储在 <code>applicationEventListenersList</code> 属性中</p>
<p>所以内存马构造中需要获取到 StandardContext 类，然后获取其applicationEventListenersList 属性，最后注入我们构造的恶意监听器到 applicationEventListenersList 属性里</p>
<h3 id="filter类型"><a href="#filter类型" class="headerlink" title="filter类型"></a>filter类型</h3><p><a target="_blank" rel="noopener" href="http://wjlshare.com/archives/1529">Tomcat 内存马学习(一)：Filter型 – 天下大木头</a></p>
<p><strong>动态注册恶意 Filter，并且将其放到 <code>filterChain </code>的最前面</strong></p>
<h4 id="filter过滤器工作原理"><a href="#filter过滤器工作原理" class="headerlink" title="filter过滤器工作原理"></a>filter过滤器工作原理</h4><p><img src="/../images/image-20210331212905616.png" alt="image-20210331212905616"></p>
<ol>
<li>根据请求的 URL 从 <code>FilterMaps</code> 中遍历<code>FilterMap</code>找出与之 URL 对应的 Filter 名称</li>
<li>根据 Filter 名称去 <code>FilterConfigs</code> 中寻找对应名称的 <code>FilterConfig</code></li>
<li>找到对应的 <code>FilterConfig</code> 之后添加到<code> FilterChain</code>中，并且返回 <code>FilterChain</code></li>
<li><code>filterChain </code>中调用 <code>internalDoFilter</code> 遍历获取 chain 中的 <code>FilterConfig </code>，然后从<code> FilterConfig</code> 中获取 Filter，然后调用 Filter 的 doFilter 方法</li>
</ol>
<blockquote>
<p>关键点在于<code>FilterMap</code>和<code>FilterConfig</code>，如果我们可以控制这两个变量，我们就可以任意注册filter。</p>
<p>他们存储在<code>StandardContext</code>的属性<code>FilterMaps</code>和<code>FilterConfigs</code>中，而<code>StandardContext</code>是可以获得的，<code>filterconfig</code>中需要添加的<code>filterdef</code>也是我们可控的，综上filter动态添加过程是我们可操控的。</p>
</blockquote>
<p><img src="/../images/image-20230424230657970.png" alt="image-20230424230657970"></p>
<ul>
<li><p><code>filterConfigs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filterDefs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filterMaps</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern</span><br></pre></td></tr></table></figure></li>
</ul>
<p>思路：</p>
<ol>
<li>创建一个恶意 Filter</li>
<li>利用 FilterDef 对 Filter 进行一个封装</li>
<li>将 FilterDef 添加到 FilterDefs 和 FilterConfig</li>
<li>创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发）</li>
</ol>
<img src="../images/image-20230424231859397.png" alt="image-20230424231859397" style="zoom: 150%;" />





<h3 id="servlet类型"><a href="#servlet类型" class="headerlink" title="servlet类型"></a>servlet类型</h3><p>工作流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装载：启动服务器时加载Servlet的实例</span><br><span class="line"></span><br><span class="line">初始化：web服务器启动时或web服务器接收到请求时，或者两者之间的某个时刻启动。初始化工作有init()方法负责执行完成</span><br><span class="line"></span><br><span class="line">调用：即每次调用Servlet的service()，从第一次到以后的多次访问，都是只是调用doGet()或doPost()方法（doGet、doPost内部实现，具体参照HttpServlet类service()的重写）</span><br><span class="line"></span><br><span class="line">销毁：停止服务器时调用destroy()方法，销毁实例</span><br></pre></td></tr></table></figure>

<p>Servlet需要重写doGet和doPost</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过 context.createWapper() 创建 Wapper 对象；</span><br><span class="line"></span><br><span class="line">2. 设置 Servlet 的 LoadOnStartUp 的值；（优先级）</span><br><span class="line"></span><br><span class="line">3. 设置 Servlet 的 Name；</span><br><span class="line"></span><br><span class="line">4. 设置 Servlet 对应的 Class；</span><br><span class="line"></span><br><span class="line">5. 将 Servlet 添加到 context 的 children 中；</span><br><span class="line"></span><br><span class="line">6. 将 url 路径和 servlet 类做映射。</span><br></pre></td></tr></table></figure>







<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>阿里巴巴的Java诊断工具–阿尔萨斯</p>
<p>注意启动用的java版本要和启动tomcat的java版本一致，用户一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">servelt</span></span><br><span class="line">mbean | grep &quot;name=/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filter</span></span><br><span class="line">sc *.Filter # 模糊搜索，列出所有调用了 Filter 的类</span><br><span class="line">sc -d org.apache.coyote.module.SimpleSerializers # classloader</span><br><span class="line"></span><br><span class="line">classloader # 查看类加载器加载了哪些类</span><br><span class="line"></span><br><span class="line">jad --source-only org.apache.jsp.evil_jsp # 反编译类</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终极排查 heapdump</span></span><br><span class="line">heapdump</span><br><span class="line">strings /var/cache/tomcat/temp/heapdump2022-10-19-12-464292342944555007800.hprof | grep &quot;POST /&quot;</span><br></pre></td></tr></table></figure>



<p><img src="/../images/image-20230503204528006.png" alt="image-20230503204528006"></p>
<p><img src="/../images/image-20230426163320217.png" alt="image-20230426163320217"></p>
<p>动态注册，对比<code>web.xml</code>中的配置</p>
<h1 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22076345/article/details/82392236">(69条消息) Intellij idea 报错：Error : java 不支持发行版本5_idea错误不支持发行版本5_灵颖桥人的博客-CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Fgtbnc.github.io">Khaz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://fgtbnc.github.io/2023/05/01/JAVA%E5%AE%89%E5%85%A8/">http://fgtbnc.github.io/2023/05/01/JAVA%E5%AE%89%E5%85%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Fgtbnc.github.io" target="_blank">Khaz</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://fgtbnc.github.io/images/wallhaven-wyg7g6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"><img class="prev-cover" src="https://fgtbnc.github.io/images/wallhaven-xlz933.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python命名空间</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/01/phpinfo/"><img class="next-cover" src="https://fgtbnc.github.io/images/wallhaven-wyg7g6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">phpinfo</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/Khazing/typora-img/main/16870577801892f4a9c5aac2e9e5422a6ccd26db10dd88c73.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Khaz</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">脚本小子的学习笔记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">JAVA基本了解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%90%8D%E8%AF%8D"><span class="toc-number">1.0.1.</span> <span class="toc-text">java名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.2.</span> <span class="toc-text">运行java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.3.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-Bean"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">Java Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.3.6.</span> <span class="toc-text">静态字段和静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.0.3.7.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">1.0.3.8.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.3.8.1.</span> <span class="toc-text">String对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IO"><span class="toc-number">1.0.3.8.2.</span> <span class="toc-text">IO</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IDEA"><span class="toc-number">2.</span> <span class="toc-text">IDEA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ysoserial-%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.</span> <span class="toc-text">ysoserial 调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Maven"><span class="toc-number">3.</span> <span class="toc-text">Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">模块化管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%8D%A2%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E6%BA%90"><span class="toc-number">3.3.</span> <span class="toc-text">更换中央仓库源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pom-xml"><span class="toc-number">3.5.</span> <span class="toc-text">pom.xml</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BE%9D%E8%B5%96"><span class="toc-number">3.5.1.</span> <span class="toc-text">注册依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maven%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.7.</span> <span class="toc-text">Maven打包程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8EGradle%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.</span> <span class="toc-text">与Gradle的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA-WEB"><span class="toc-number">4.</span> <span class="toc-text">JAVA WEB</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">6.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.0.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">6.0.2.</span> <span class="toc-text">相关类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">6.0.3.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97Class%E7%B1%BB"><span class="toc-number">6.0.3.1.</span> <span class="toc-text">获得Class类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.3.2.</span> <span class="toc-text">获得构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB"><span class="toc-number">6.0.3.3.</span> <span class="toc-text">实例化类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.0.3.4.</span> <span class="toc-text">获得成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.0.3.5.</span> <span class="toc-text">使用成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">6.0.3.6.</span> <span class="toc-text">获取成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.0.3.7.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%EF%BC%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">6.0.3.8.</span> <span class="toc-text">强制访问私有，保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9final%E5%AD%97%E6%AE%B5"><span class="toc-number">6.0.4.</span> <span class="toc-text">修改final字段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JNDI"><span class="toc-number">9.</span> <span class="toc-text">JNDI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJNDI"><span class="toc-number">9.1.</span> <span class="toc-text">什么是JNDI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRMI"><span class="toc-number">9.2.</span> <span class="toc-text">什么是RMI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFLDAP"><span class="toc-number">9.3.</span> <span class="toc-text">什么是LDAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%BD%A2%E6%88%90%E5%8E%9F%E5%9B%A0"><span class="toc-number">9.4.</span> <span class="toc-text">漏洞形成原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JNDI%E6%B3%A8%E5%85%A5"><span class="toc-number">9.5.</span> <span class="toc-text">JNDI注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">9.5.1.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI"><span class="toc-number">9.5.2.</span> <span class="toc-text">RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E7%89%88%E6%9C%AC"><span class="toc-number">9.5.2.1.</span> <span class="toc-text">低版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%89%88%E6%9C%AC"><span class="toc-number">9.5.2.2.</span> <span class="toc-text">高版本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95%E8%BF%87"><span class="toc-number">9.5.2.2.1.</span> <span class="toc-text">绕过</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LDAP"><span class="toc-number">9.5.3.</span> <span class="toc-text">LDAP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E7%89%88%E6%9C%AC-1"><span class="toc-number">9.5.3.1.</span> <span class="toc-text">低版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%89%88%E6%9C%AC-1"><span class="toc-number">9.5.3.2.</span> <span class="toc-text">高版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%BD%B1%E5%93%8D"><span class="toc-number">9.5.4.</span> <span class="toc-text">版本影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log4J2"><span class="toc-number">9.6.</span> <span class="toc-text">Log4J2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">10.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%90%84%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">10.1.2.</span> <span class="toc-text">创建一个对象时各代码块的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialVersionUID"><span class="toc-number">10.1.3.</span> <span class="toc-text">serialVersionUID</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">10.2.</span> <span class="toc-text">利用链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#URLDNS"><span class="toc-number">10.2.1.</span> <span class="toc-text">URLDNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">分析过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CC1"><span class="toc-number">10.2.2.</span> <span class="toc-text">CC1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA-Agent"><span class="toc-number">11.</span> <span class="toc-text">JAVA Agent</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A9%AC"><span class="toc-number">12.</span> <span class="toc-text">内存马</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">12.1.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Fweb%E5%BA%94%E7%94%A8%E5%9E%8B"><span class="toc-number">12.2.</span> <span class="toc-text">传统web应用型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#listener%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.1.</span> <span class="toc-text">listener类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.2.</span> <span class="toc-text">filter类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filter%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.2.1.</span> <span class="toc-text">filter过滤器工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#servlet%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.3.</span> <span class="toc-text">servlet类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E6%9F%A5"><span class="toc-number">12.3.</span> <span class="toc-text">排查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3"><span class="toc-number">13.</span> <span class="toc-text">报错解决</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/03/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/" title="实习小结"><img src="https://fgtbnc.github.io/images/wallhaven-yxe8kk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实习小结"/></a><div class="content"><a class="title" href="/2023/08/03/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/" title="实习小结">实习小结</a><time datetime="2023-08-03T02:26:00.000Z" title="发表于 2023-08-03 10:26:00">2023-08-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/25/openfire/" title="Openfire身份认证绕过+插件Getshell漏洞复现"><img src="https://fgtbnc.github.io/images/wallhaven-yxe8kk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Openfire身份认证绕过+插件Getshell漏洞复现"/></a><div class="content"><a class="title" href="/2023/06/25/openfire/" title="Openfire身份认证绕过+插件Getshell漏洞复现">Openfire身份认证绕过+插件Getshell漏洞复现</a><time datetime="2023-06-25T15:00:25.000Z" title="发表于 2023-06-25 23:00:25">2023-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/24/Apache%20Druid/" title="Apache Druid RCE漏洞复现(QVD-2023-9629)"><img src="https://fgtbnc.github.io/images/wallhaven-wyg7g6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Apache Druid RCE漏洞复现(QVD-2023-9629)"/></a><div class="content"><a class="title" href="/2023/06/24/Apache%20Druid/" title="Apache Druid RCE漏洞复现(QVD-2023-9629)">Apache Druid RCE漏洞复现(QVD-2023-9629)</a><time datetime="2023-06-24T08:00:25.000Z" title="发表于 2023-06-24 16:00:25">2023-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="Spring框架漏洞"><img src="https://fgtbnc.github.io/images/wallhaven-xl8gq3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring框架漏洞"/></a><div class="content"><a class="title" href="/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="Spring框架漏洞">Spring框架漏洞</a><time datetime="2023-06-22T02:40:25.000Z" title="发表于 2023-06-22 10:40:25">2023-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="若依漏洞"><img src="https://fgtbnc.github.io/images/wallhaven-xlz933.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="若依漏洞"/></a><div class="content"><a class="title" href="/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="若依漏洞">若依漏洞</a><time datetime="2023-06-21T13:11:25.000Z" title="发表于 2023-06-21 21:11:25">2023-06-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Khaz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/chocolate.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>